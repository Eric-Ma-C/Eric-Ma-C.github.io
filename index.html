<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Eric&#39;s Blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Eric&#39;s Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="EricMa">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Eric's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Eric's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Better Code, Better Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/18/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/18/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Linux内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-19 02:02:51 / 修改时间：10:05:32" itemprop="dateCreated datePublished" datetime="2020-08-19T02:02:51+08:00">2020-08-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天来带大家研究一下<code>Linux</code>内存管理。对于精通 <code>CURD</code> 的业务同学，内存管理好像离我们很远，但这个知识点虽然冷门（估计很多人学完根本就没机会用上）但绝对是基础中的基础，这就像武侠中的内功修炼，学完之后看不到立竿见影的效果，但对你日后的开发工作是大有裨益的，因为你站的更高了。</p>
<p>前提约定：本文讨论技术内容前提，操作系统环境都是 <code>x86</code>架构的 32 位 <code>Linux</code>系统。</p>
<h2 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h2><p>即使是现代操作系统中，内存依然是计算机中很宝贵的资源，看看你电脑几个T固态硬盘，再看看内存大小就知道了。为了充分利用和管理系统内存资源，Linux采用虚拟内存管理技术，利用虚拟内存技术让每个进程都有<code>4GB</code> 互不干涉的虚拟地址空间。</p>
<p>进程初始化分配和操作的都是基于这个「虚拟地址」，只有当进程需要实际访问内存资源的时候才会建立虚拟地址和物理地址的映射，调入物理内存页。</p>
<p>打个不是很恰当的比方。这个原理其实和现在的某某网盘一样，假如你的网盘空间是<code>1TB</code>，真以为就一口气给了你这么大空间吗？那还是太年轻，都是在你往里面放东西的时候才给你分配空间，你放多少就分多少实际空间给你，但你和你朋友看起来就像大家都拥有<code>1TB</code>空间一样。</p>
<h3 id="虚拟地址的好处"><a href="#虚拟地址的好处" class="headerlink" title="虚拟地址的好处"></a>虚拟地址的好处</h3><ul>
<li>避免用户直接访问物理内存地址，防止一些破坏性操作，保护操作系统</li>
<li>每个进程都被分配了4GB的虚拟内存，用户程序可使用比实际物理内存更大的地址空间</li>
</ul>
<p><code>4GB</code> 的进程虚拟地址空间被分成两部分：「用户空间」和「内核空间」</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a6aaf6064?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="用户空间内核空间"></p>
<h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>上面章节我们已经知道不管是用户空间还是内核空间，使用的地址都是虚拟地址，当需进程要实际访问内存的时候，会由内核的「请求分页机制」产生「缺页异常」调入物理内存页。</p>
<p>把虚拟地址转换成内存的物理地址，这中间涉及利用<code>MMU</code> 内存管理单元（Memory Management Unit ) 对虚拟地址分段和分页（段页式）地址转换，关于分段和分页的具体流程，这里不再赘述，可以参考任何一本计算机组成原理教材描述。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a6abc1636?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="段页式内存管理地址转换"></p>
<p><code>Linux</code> 内核会将物理内存分为3个管理区，分别是：</p>
<h3 id="ZONE-DMA"><a href="#ZONE-DMA" class="headerlink" title="ZONE_DMA"></a>ZONE_DMA</h3><p><code>DMA</code>内存区域。包含0MB~16MB之间的内存页框，可以由老式基于<code>ISA</code>的设备通过<code>DMA</code>使用，直接映射到内核的地址空间。</p>
<h3 id="ZONE-NORMAL"><a href="#ZONE-NORMAL" class="headerlink" title="ZONE_NORMAL"></a>ZONE_NORMAL</h3><p>普通内存区域。包含16MB~896MB之间的内存页框，常规页框，直接映射到内核的地址空间。</p>
<h3 id="ZONE-HIGHMEM"><a href="#ZONE-HIGHMEM" class="headerlink" title="ZONE_HIGHMEM"></a>ZONE_HIGHMEM</h3><p>高端内存区域。包含896MB以上的内存页框，不进行直接映射，可以通过永久映射和临时映射进行这部分内存页框的访问。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a6d1a5191?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="物理内存区划分"></p>
<h2 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h2><p>用户进程能访问的是「用户空间」，每个进程都有自己独立的用户空间，虚拟地址范围从从 <code>0x00000000</code> 至 <code>0xBFFFFFFF</code> 总容量3G 。</p>
<p>用户进程通常只能访问用户空间的虚拟地址，只有在执行内陷操作或系统调用时才能访问内核空间。</p>
<h3 id="进程与内存"><a href="#进程与内存" class="headerlink" title="进程与内存"></a>进程与内存</h3><p>进程（执行的程序）占用的用户空间按照「 访问属性一致的地址空间存放在一起 」的原则，划分成 <code>5</code>个不同的内存区域。 访问属性指的是“可读、可写、可执行等 。</p>
<ul>
<li><p>代码段</p>
<p>代码段是用来存放可执行文件的操作指令，可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，它是不可写的。</p>
</li>
<li><p>数据段</p>
<p>数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量和全局变量。</p>
</li>
<li><p>BSS段</p>
<p><code>BSS</code>段包含了程序中未初始化的全局变量，在内存中 <code>bss</code> 段全部置零。</p>
</li>
<li><p>堆 <code>heap</code></p>
<p>堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p>
</li>
<li><p>栈 <code>stack</code></p>
<p>栈是用户存放程序临时创建的局部变量，也就是函数中定义的变量（但不包括 <code>static</code> 声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p>
</li>
</ul>
<p>上述几种内存区域中数据段、<code>BSS</code> 段、堆通常是被连续存储在内存中，在位置上是连续的，而代码段和栈往往会被独立存放。堆和栈两个区域在 <code>i386</code> 体系结构中栈向下扩展、堆向上扩展，相对而生。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a71e78b4c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="程序内存区域分段"></p>
<p>你也可以再linux下用<code>size</code> 命令查看编译后程序的各个内存区域大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lemon ~]# size &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;sshd</span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line">1924532	  12412	 426896	2363840	 2411c0	&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;sshd</span><br></pre></td></tr></table></figure>

<h2 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h2><p>在 <code>x86 32</code> 位系统里，Linux 内核地址空间是指虚拟地址从 <code>0xC0000000</code> 开始到 <code>0xFFFFFFFF</code> 为止的高端内存地址空间，总计 <code>1G</code> 的容量， 包括了内核镜像、物理页面表、驱动程序等运行在内核空间 。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a958cdbeb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="内核空间细分区域."></p>
<h4 id="直接映射区"><a href="#直接映射区" class="headerlink" title="直接映射区"></a>直接映射区</h4><p>直接映射区 <code>Direct Memory Region</code>：从内核空间起始地址开始，最大<code>896M</code>的内核空间地址区间，为直接内存映射区。</p>
<p>直接映射区的896MB的「线性地址」直接与「物理地址」的前<code>896MB</code>进行映射，也就是说线性地址和分配的物理地址都是连续的。内核地址空间的线性地址<code>0xC0000001</code>所对应的物理地址为<code>0x00000001</code>，它们之间相差一个偏移量<code>PAGE_OFFSET = 0xC0000000</code></p>
<p>该区域的线性地址和物理地址存在线性转换关系「线性地址 = <code>PAGE_OFFSET</code> + 物理地址」也可以用 <code>virt_to_phys()</code>函数将内核虚拟空间中的线性地址转化为物理地址。</p>
<h4 id="高端内存线性地址空间"><a href="#高端内存线性地址空间" class="headerlink" title="高端内存线性地址空间"></a>高端内存线性地址空间</h4><p>内核空间线性地址从 896M 到 1G 的区间，容量 128MB 的地址区间是高端内存线性地址空间，为什么叫高端内存线性地址空间？下面给你解释一下：</p>
<p>前面已经说过，内核空间的总大小 1GB，从内核空间起始地址开始的 896MB 的线性地址可以直接映射到物理地址大小为 896MB 的地址区间。退一万步，即使内核空间的1GB线性地址都映射到物理地址，那也最多只能寻址 1GB 大小的物理内存地址范围。</p>
<p>请问你现在你家的内存条多大？快醒醒都 0202 年了，一般 PC 的内存都大于 1GB 了吧！</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a95ad1545?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>所以，内核空间拿出了最后的 128M 地址区间，划分成下面三个高端内存映射区，以达到对整个物理地址范围的寻址。而在 64 位的系统上就不存在这样的问题了，因为可用的线性地址空间远大于可安装的内存。</p>
<h5 id="动态内存映射区"><a href="#动态内存映射区" class="headerlink" title="动态内存映射区"></a>动态内存映射区</h5><p><code>vmalloc Region</code> 该区域由内核函数<code>vmalloc</code>来分配，特点是：线性空间连续，但是对应的物理地址空间不一定连续。 <code>vmalloc</code> 分配的线性地址所对应的物理页可能处于低端内存，也可能处于高端内存。</p>
<h5 id="永久内存映射区"><a href="#永久内存映射区" class="headerlink" title="永久内存映射区"></a>永久内存映射区</h5><p><code>Persistent Kernel Mapping Region</code> 该区域可访问高端内存。访问方法是使用 <code>alloc_page (_GFP_HIGHMEM)</code> 分配高端内存页或者使用<code>kmap</code>函数将分配到的高端内存映射到该区域。</p>
<h5 id="固定映射区"><a href="#固定映射区" class="headerlink" title="固定映射区"></a>固定映射区</h5><p><code>Fixing kernel Mapping Region</code> 该区域和 4G 的顶端只有 4k 的隔离带，其每个地址项都服务于特定的用途，如 <code>ACPI_BASE</code> 等。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a94f6a870?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p>
<h2 id="回顾一下"><a href="#回顾一下" class="headerlink" title="回顾一下"></a>回顾一下</h2><p>上面讲的有点多，先别着急进入下一节，在这之前我们再来回顾一下上面所讲的内容。如果认真看完上面的章节，我这里再画了一张图，现在你的脑海中应该有这样一个内存管理的全局图。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a9b3cf2c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="内核空间用户空间全图"></p>
<h2 id="内存数据结构"><a href="#内存数据结构" class="headerlink" title="内存数据结构"></a>内存数据结构</h2><p>要让内核管理系统中的虚拟内存，必然要从中抽象出内存管理数据结构，内存管理操作如「分配、释放等」都基于这些数据结构操作，这里列举两个管理虚拟内存区域的数据结构。</p>
<h3 id="用户空间内存数据结构"><a href="#用户空间内存数据结构" class="headerlink" title="用户空间内存数据结构"></a>用户空间内存数据结构</h3><p>在前面「进程与内存」章节我们提到，Linux进程可以划分为 5 个不同的内存区域，分别是：代码段、数据段、<code>BSS</code>、堆、栈，内核管理这些区域的方式是，将这些内存区域抽象成<code>vm_area_struct</code>的内存管理对象。</p>
<p><code>vm_area_struct</code>是描述进程地址空间的基本管理单元，一个进程往往需要多个<code>vm_area_struct</code>来描述它的用户空间虚拟地址，需要使用「链表」和「红黑树」来组织各个<code>vm_area_struct</code>。</p>
<p>链表用于需要遍历全部节点的时候用，而红黑树适用于在地址空间中定位特定内存区域。内核为了内存区域上的各种不同操作都能获得高性能，所以同时使用了这两种数据结构。</p>
<p>用户空间进程的地址管理模型：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7aae19dce8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="wm_arem_struct"></p>
<h3 id="内核空间动态分配内存数据结构"><a href="#内核空间动态分配内存数据结构" class="headerlink" title="内核空间动态分配内存数据结构"></a>内核空间动态分配内存数据结构</h3><p>在内核空间章节我们提到过「动态内存映射区」，该区域由内核函数<code>vmalloc</code>来分配，特点是：线性空间连续，但是对应的物理地址空间不一定连续。 <code>vmalloc</code> 分配的线性地址所对应的物理页可能处于低端内存，也可能处于高端内存。</p>
<p><code>vmalloc</code> 分配的地址则限于<code>vmalloc_start</code>与<code>vmalloc_end</code>之间。每一块<code>vmalloc</code>分配的内核虚拟内存都对应一个<code>vm_struct</code>结构体，不同的内核空间虚拟地址之间有<code>4k</code>大小的防越界空闲区间隔区。与用户空间的虚拟地址特性一样，这些虚拟地址与物理内存没有简单的映射关系，必须通过内核页表才可转换为物理地址或物理页，它们有可能尚未被映射，当发生缺页时才真正分配物理页面。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7aae171d87?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="动态内存映射"></p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p><code>Linux</code>内存管理是一个非常复杂的系统，本文所述只是冰山一角，从宏观角度给你展现内存管理的全貌，但一般来说，这些知识在你和面试官聊天的时候还是够用的，当然我也希望大家能够通过读书了解更深层次的原理。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/6844904132378116104" target="_blank" rel="noopener">面试问了解Linux内存管理吗？10张图给你安排的明明白白！</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/17/MySQL%E4%B8%ADnull%E5%80%BC%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/17/MySQL%E4%B8%ADnull%E5%80%BC%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">MySQL中null值建立索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-17 12:14:36 / 修改时间：20:17:51" itemprop="dateCreated datePublished" datetime="2020-08-17T12:14:36+08:00">2020-08-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>不知道从什么时候开始，网上流传着这么一个说法：</p>
<blockquote>
<p>MySQL的WHERE子句中包含 IS NULL、IS NOT NULL、!= 这些条件时便不能使用索引查询，只能使用全表扫描。</p>
</blockquote>
<p>这种说法愈演愈烈，甚至被很多同学奉为真理。咱啥话也不说，举个例子。假如我们有个表<code>s1</code>，结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s1 (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key3 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">KEY</span> idx_key1 (key1),</span><br><span class="line">    <span class="keyword">KEY</span> idx_key2 (key2),</span><br><span class="line">    <span class="keyword">KEY</span> idx_key3 (key3),</span><br><span class="line">    <span class="keyword">KEY</span> idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) <span class="keyword">Engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>这个表里有10000条记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(*) FROM s1;</span><br><span class="line">+----------+</span><br><span class="line">| COUNT(*) |</span><br><span class="line">+----------+</span><br><span class="line">|    10000 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>下边我们直接贴几个图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f089efb9cf6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqmch3p1f881eqmvb29gk1tom6e.png-40.7kB"></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f089f21818c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqmbf5616fb1g0b1trv13elsst61.png-40.7kB"></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f089f885438?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqmarklhku131o18rs15281min5k.png-40.2kB"></p>
<p>上边几个查询语句的<code>WHERE</code>子句中用了<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>!=</code>这些条件，但是从它们的执行计划中可以看出来，这些语句都采用了相应的二级索引执行查询，而不是使用所谓的全表扫描，谣言不攻自破。当然，戳破这些谣言并不是本文的目的，本文来更细致的分析一下这些查询到底是怎么执行的。</p>
<h2 id="NULL值是怎么在记录中存储的"><a href="#NULL值是怎么在记录中存储的" class="headerlink" title="NULL值是怎么在记录中存储的"></a>NULL值是怎么在记录中存储的</h2><p>在MySQL中，每一条记录都有它固定的格式，我们以<code>InnoDB</code>存储引擎的<code>Compact</code>行格式为例，来看一下<code>NULL</code>值是怎样存储的。在<code>Compact</code>行格式下，一条记录是由下边这几个部分构成的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f089fc7cd5e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqmp377ebqgqf15e1tuv1qri6r.png-72.8kB"></p>
<p>为了故事的顺利发展，我们新建一个称之为<code>record_format_demo</code>的表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> record_format_demo (</span><br><span class="line">     c1 <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">     c2 <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">     c3 <span class="built_in">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">     c4 <span class="built_in">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line"> ) <span class="keyword">CHARSET</span>=<span class="keyword">ascii</span> ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>

<p>因为我们的重点是<code>NULL</code>值是如何存储在记录中的，所以重点唠叨一下行格式的<code>NULL值列表</code>部分，其他的部分可以到小册中查看。存储<code>NULL</code>值的过程如下：</p>
<ol>
<li><p>首先统计表中允许存储<code>NULL</code>的列有哪些。</p>
<p>我们前边说过，主键列、被<code>NOT NULL</code>修饰的列都是不可以存储<code>NULL</code>值的，所以在统计的时候不会把这些列算进去。比方说表<code>record_format_demo</code>的3个列<code>c1</code>、<code>c3</code>、<code>c4</code>都是允许存储<code>NULL</code>值的，而<code>c2</code>列是被<code>NOT NULL</code>修饰，不允许存储<code>NULL</code>值。</p>
</li>
<li><p>如果表中没有允许存储<code>NULL</code>的列，则<code>NULL值列表</code>也不存在了，否则将每个允许存储<code>NULL</code>的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：</p>
<ul>
<li>二进制位的值为<code>1</code>时，代表该列的值为<code>NULL</code>。</li>
<li>二进制位的值为<code>0</code>时，代表该列的值不为<code>NULL</code>。</li>
</ul>
<p>因为表<code>record_format_demo</code>有3个值允许为<code>NULL</code>的列，所以这3个列和二进制位的对应关系就是这样：</p>
</li>
</ol>
<p>   <img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f089f7318fb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqn3dt810cpog1l4710q637q78.png-19.3kB"></p>
<p>   再一次强调，二进制位按照列的顺序逆序排列，所以第一个列<code>c1</code>和最后一个二进制位对应。</p>
<ol start="3">
<li><p>设计<code>InnoDB</code>的大叔规定<code>NULL值列表</code>必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。</p>
<p>表<code>record_format_demo</code>只有3个值允许为<code>NULL</code>的列，对应3个二进制位，不足一个字节，所以在字节的高位补0，效果就是这样：</p>
</li>
</ol>
<p>   <img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f08a0464a01?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqn48071s0i104314m31isi1ks97l.png-37.7kB"></p>
<p>   以此类推，如果一个表中有9个允许为<code>NULL</code>，那这个记录的<code>NULL值列表</code>部分就需要2个字节来表示了。</p>
<p>假设我们现在向<code>record_format_demo</code>表中插入一条记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO record_format_demo(c1, c2, c3, c4)</span><br><span class="line">    VALUES(&#39;eeee&#39;, &#39;fff&#39;, NULL, NULL);</span><br></pre></td></tr></table></figure>

<p>这条记录的<code>c1</code>、<code>c3</code>、<code>c4</code>这3个列中<code>c3</code>和<code>c4</code>的值都为<code>NULL</code>，所以这3个列对应的二进制位的情况就是：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f08cbf7699e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqng28g7df1l68r4737p3a882.png-38.6kB"></p>
<p>所以这记录的<code>NULL值列表</code>用十六进制表示就是：<code>0x06</code>。</p>
<h2 id="键值为NULL的记录是怎么在B-树中存放的"><a href="#键值为NULL的记录是怎么在B-树中存放的" class="headerlink" title="键值为NULL的记录是怎么在B+树中存放的"></a>键值为NULL的记录是怎么在B+树中存放的</h2><p>对于InnoDB存储引擎来说，记录都是存储在页面中的（一个页面默认是16KB大小），这些页面可以作为<code>B+</code>树的节点而组成一个索引，类似这种样子（只是用下边的图举个B+树的例子而已，跟我们上边列举的表没关系）：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f08ccc49370?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqnp86e76v16h31l7qk21v458f.png-296kB"></p>
<p>聚簇索引和二级索引都对应着像上图一样的<code>B+</code>树（也就是说有多少个索引就有多少棵对应的<code>B+</code>树），不过：</p>
<ul>
<li>对于聚簇索引索引来说，页面中的记录是按照主键值进行排序的；而对于二级索引来说，页面中的记录是按照给定的索引列的值进行排序的。</li>
<li>对于聚簇索引来说，B+树每一层节点（页面）都是按照页中记录的主键值大小进行排序的；而对于二级索引来说，B+树每一层节点（页面）都是按照页中记录的给定的索引列的值进行排序的。</li>
<li>对于聚簇索引来说，B+树叶子节点对应的页面中存储的是完整的用户记录（就是一条记录中包含我们定义的所有列值，还包含一些InnoDB自己添加的一些隐藏列）；而对于二级索引来说，B+树叶子节点对应的页面中存储的只是<code>索引列的值 + 主键值</code>。</li>
</ul>
<p>按规定，一条记录的主键值不允许存储<code>NULL</code>值，所以下边语句中的WHERE子句结果肯定为<code>FALSE</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE primary_key IS NULL;</span><br></pre></td></tr></table></figure>

<p>像这样的语句优化器自己就能判定出WHERE子句必定为NULL，所以压根儿不会去执行它，不信我们看（Extra信息提示WHERE子句压根儿不成立）：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f08ce14ddc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqofhth2941mtorq72f1nqf8s.png-35.5kB"></p>
<p>对于二级索引来说，索引列的值可能为<code>NULL</code>。那对于索引列值为<code>NULL</code>的二级索引记录来说，它们被放在<code>B+</code>树的哪里呢？答案是：放在B+树的最左边。比方说我们有如下查询语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 IS NULL;</span><br></pre></td></tr></table></figure>

<p>那它的查询示意图就如下所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f08d1c53f83?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqqjqnahm6176uta91j7j1q8ram.png-52.9kB"></p>
<p>从图中可以看出，对于<code>s1</code>表的二级索引<code>idx_key1</code>来说，值为<code>NULL</code>的二级索引记录都被放在了<code>B+</code>树的最左边，这是因为设计<code>InnoDB</code>的大叔有这样的规定：</p>
<blockquote>
<p>We define the SQL null to be the smallest possible value of a field.</p>
</blockquote>
<p>也就是说他们把SQL中的<code>NULL</code>值认为是列中最小的值。</p>
<p>在通过二级索引<code>idx_key1</code>对应的<code>B+</code>树快速定位到叶子节点中符合条件的最左边的那条记录后，也就是本例中<code>id</code>值为<code>521</code>的那条记录之后，就可以顺着每条记录都有的<code>next_record</code>属性沿着由记录组成的单向链表去获取记录了，直到某条记录的<code>key1</code>列不为NULL。</p>
<blockquote>
<p>小贴士： 通过B+树快速定位到叶子节点的记录的过程是靠一个所谓的页目录（Page Directory）做到的，不过这不是本文的重点，大家可以到小册中翻看，都有详细解释。</p>
</blockquote>
<h2 id="使不使用索引的依据到底是什么？"><a href="#使不使用索引的依据到底是什么？" class="headerlink" title="使不使用索引的依据到底是什么？"></a>使不使用索引的依据到底是什么？</h2><p>那既然<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>!=</code>这些条件都可能使用到索引，那到底什么时候索引，什么时候采用全表扫描呢？</p>
<p>答案很简单：成本。当然，关于如何定量的计算使用某个索引执行查询的成本比较复杂，我们在小册中花了很大的篇幅来唠叨了。不过因为篇幅有限，我们在这里只准备定性的分析一下。对于使用二级索引进行查询来说，成本组成主要有两个方面：</p>
<ul>
<li>读取二级索引记录的成本</li>
<li>将二级索引记录执行回表操作，也就是到聚簇索引中找到完整的用户记录的操作所付出的成本。</li>
</ul>
<p>很显然，要扫描的二级索引记录条数越多，那么需要执行的回表操作的次数也就越多，达到了某个比例时，使用二级索引执行查询的成本也就超过了全表扫描的成本（举一个极端的例子，比方说要扫描的全部的二级索引记录，那就要对每条记录执行一遍回表操作，自然不如直接扫描聚簇索引来的快）。</p>
<p>所以MySQL优化器在真正执行查询之前，对于每个可能使用到的索引来说，都会预先计算一下需要扫描的二级索引记录的数量，比方说对于下边这个查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 IS NULL;</span><br></pre></td></tr></table></figure>

<p>优化器会分析出此查询只需要查找<code>key1</code>值为<code>NULL</code>的记录，然后访问一下二级索引<code>idx_key1</code>，看一下值为<code>NULL</code>的记录有多少（如果符合条件的二级索引记录数量较少，那么统计结果是精确的，如果太多的话，会采用一定的手段计算一个模糊的值，当然算法也比较麻烦，我们就不展开说了，小册里有说），这种在查询真正执行前优化器就率先访问索引来计算需要扫描的索引记录数量的方式称之为<code>index dive</code>。当然，对于某些查询，比方说WHERE子句中有IN条件，并且IN条件中包含许多参数的话，比方说这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ... , &#39;zzzzzzz&#39;);</span><br></pre></td></tr></table></figure>

<p>这样的话需要统计的<code>key1</code>值所在的区间就太多了，这样就不能采用<code>index dive</code>的方式去真正的访问二级索引<code>idx_key1</code>，而是需要采用之前在背地里产生的一些统计数据去估算匹配的二级索引记录有多少条（很显然根据统计数据去估算记录条数比<code>index dive</code>的方式精确性差了很多）。</p>
<p>反正不论采用<code>index dive</code>还是依据统计数据估算，最终要得到一个需要扫描的二级索引记录条数，如果这个条数占整个记录条数的比例特别大，那么就趋向于使用全表扫描执行查询，否则趋向于使用这个索引执行查询。</p>
<p>理解了这个也就好理解为什么在WHERE子句中出现<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>!=</code>这些条件仍然可以使用索引，本质上都是优化器去计算一下对应的二级索引数量占所有记录数量的比值而已。</p>
<h2 id="不信谣，不传谣"><a href="#不信谣，不传谣" class="headerlink" title="不信谣，不传谣"></a>不信谣，不传谣</h2><p>大家可以看到，MySQL中决定使不使用某个索引执行查询的依据很简单：就是成本够不够小。而不是是否在WHERE子句中用了<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>!=</code>这些条件。大家以后也多多辟谣吧，没那么复杂，只是一个成本而已。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/6844903921450745863" target="_blank" rel="noopener">MySQL中IS NULL、IS NOT NULL、!=不能用索引？胡扯！</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/17/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%AE%A1%E7%AE%97Java%E5%AF%B9%E8%B1%A1%E6%89%80%E5%8D%A0%E5%86%85%E5%AD%98%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/17/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%AE%A1%E7%AE%97Java%E5%AF%B9%E8%B1%A1%E6%89%80%E5%8D%A0%E5%86%85%E5%AD%98%EF%BC%9F/" class="post-title-link" itemprop="url">如何正确计算Java对象所占内存？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-17 11:56:07 / 修改时间：19:57:11" itemprop="dateCreated datePublished" datetime="2020-08-17T11:56:07+08:00">2020-08-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java应用上线前，常常需要估算所需的内存，从而设置正确的内存选项参数。正确计算Java对象所占内存从而估算应用的整体所占内存，就显得很有必要。那么，如何计算Java对象所占的内存呢？</p>
<h3 id="1-Java对象的内存布局"><a href="#1-Java对象的内存布局" class="headerlink" title="1.Java对象的内存布局"></a>1.Java对象的内存布局</h3><p>计算Java对象所占内存，首先需要了解Java对象的内存布局。一个Java对象在内存中可以分为三部分：<strong>对象头、实例数据和对齐填充</strong>。关于对象头的详细介绍可查看<a href="https://www.jianshu.com/p/3d38cba67f8b" target="_blank" rel="noopener">这篇文章</a>；实例数据即Java的成员字段，包括基本类型和对象引用；对齐填充并不必须存在，只用作占位对齐字节。一个对象的内存布局示意如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">|---------------------------|</span>-----------------<span class="params">|---------|</span></span><br><span class="line"><span class="params">|       Object Header       |</span>  Instance Data  <span class="params">| Padding |</span></span><br><span class="line"><span class="params">|-----------|</span>---------------<span class="params">|-----------------|</span>---------<span class="params">|</span></span><br><span class="line"><span class="params">|</span> Mark Word <span class="params">| Klass Pointer |</span> field1<span class="params">|filed2|</span>  <span class="params">| Padding |</span></span><br><span class="line"><span class="params">|-----------|</span>---------------<span class="params">|-----------------|</span>---------<span class="params">|</span></span><br></pre></td></tr></table></figure>

<p>需要注意以下几点：</p>
<ol>
<li>对象默认以8字节对齐，即对象所占空间必须是8的整数倍。默认对齐字节数可以使用选项<em>-XX:ObjectAlignmentInBytes=num</em>设置，最小值为8，最大值为256。</li>
<li>为了避免空间浪费，实例数据会进行重排序，排序的优先级为： long = double  &gt; int = float &gt; char = short &gt; byte &gt; boolean &gt; object reference。</li>
<li>继承体系里不同类的字段<strong>不会混合</strong>在一起，父类成员字段分配之后才会分配子类，每个类里的字段遵循第2条规则。</li>
<li>继承体系里不同类间需要8字节对齐。</li>
<li>在继承体系中，父类层次中有至少4字节的空闲而子类含有4字节及其以下的字段，将按优先级：int = float &gt; char = short &gt; byte &gt; boolean &gt; object reference填充这4字节。<strong>对象头部如果有剩余也会使用该规则填充</strong>。</li>
</ol>
<h3 id="2-内存布局实例研究"><a href="#2-内存布局实例研究" class="headerlink" title="2.内存布局实例研究"></a>2.内存布局实例研究</h3><p>为了方便的研究对象所占的内存，建议使用官方提供的<a href="https://link.jianshu.com?t=http%3A%2F%2Fopenjdk.java.net%2Fprojects%2Fcode-tools%2Fjol%2F" target="_blank" rel="noopener">jol工具</a>，如果使用<code>Maven</code>，只需加入如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后便可以愉快的查看内存布局了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(ClassLayout.parseClass(Object<span class="class">.<span class="keyword">class</span>).<span class="title">toPrintable</span>())</span>;</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(<span class="keyword">new</span> Integer(<span class="number">1</span>)).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码第一行的输出如下（JDK8 64 bit）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object <span class="keyword">object</span> internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>    <span class="number">12</span>        (<span class="keyword">object</span> header)                           N/A</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next <span class="keyword">object</span> alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes <span class="keyword">internal</span> + <span class="number">4</span> bytes <span class="keyword">external</span> = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>

<p>由于目前的计算机基本为64位架构，所以忽略32位JVM，只对64位进行讨论。由于JDK8以后默认开启<code>-XX:CompressedOops</code>选项，所以上述为开启指针压缩的结果。</p>
<h4 id="2-1-int-VS-Integer"><a href="#2-1-int-VS-Integer" class="headerlink" title="2.1 int VS Integer"></a>2.1 int VS Integer</h4><p>Java中，一个int占4个字节，那么<code>Integer</code>对象占多少字节呢？Integer对象中只有一个<code>value</code>字段用于存储实际的整数。不开启指针压缩时，其布局为：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">|-------------------------------------------|</span>----------------<span class="params">|-----------------|</span></span><br><span class="line"><span class="params">|                Object Header              |</span>  Instance Data <span class="params">|      Padding    |</span></span><br><span class="line"><span class="params">|-------------------|</span>-----------------------<span class="params">|----------------|</span>-----------------<span class="params">|</span></span><br><span class="line"><span class="params">|</span> Mark Word(<span class="number">8</span> byte) <span class="params">| Klass Pointer(8 byte) |</span>  value(<span class="number">4</span> byte) <span class="params">| Padding(4 byte) |</span></span><br><span class="line"><span class="params">|-------------------|</span>-----------------------<span class="params">|----------------|</span>-----------------<span class="params">|</span></span><br></pre></td></tr></table></figure>

<p>开启指针压缩时，内存布局为：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">|-------------------------------------------|</span>----------------<span class="params">|</span></span><br><span class="line"><span class="params">|</span>                Object Header              <span class="params">|  Instance Data |</span></span><br><span class="line"><span class="params">|-------------------|</span>-----------------------<span class="params">|----------------|</span></span><br><span class="line"><span class="params">| Mark Word(8 byte) |</span> Klass Pointer(<span class="number">4</span> byte) <span class="params">|  value(4 byte) |</span></span><br><span class="line"><span class="params">|-------------------|</span>-----------------------<span class="params">|----------------|</span></span><br></pre></td></tr></table></figure>

<p>可知如果不开启指针压缩，一个<code>Integer</code>对象需要占用24字节，就算开启指针压缩也需要占用16字节，是<code>int</code>的四倍多。<code>Integer</code>的内存占用超出想象，由此在Java中产生了许多优化方案。考虑Java集合，其中的对象泛型不支持基本数据类型，而只能使用<code>Integer</code>，<code>Long</code>等包装器类，这样将会耗费过多的内存。为了节约内存，一些开源工具支持基本类型的容器，比如：<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fleventov%2FKoloboke" target="_blank" rel="noopener">Koloboke</a>。</p>
<h4 id="2-2-字段重排序"><a href="#2-2-字段重排序" class="headerlink" title="2.2 字段重排序"></a>2.2 字段重排序</h4><p>为了更高效的使用内存，实例数据字段将会重排序。排序的优先级为： long = double  &gt; int = float &gt; char = short &gt; byte &gt; boolean &gt; object reference。如下所示的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FieldTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> a;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">boolean</span> d;</span><br><span class="line">    <span class="keyword">long</span> e;</span><br><span class="line">    Object f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将会重排序为（开启<code>CompressedOops</code>选项）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OFFSET  SIZE               TYPE DESCRIPTION            </span><br><span class="line">    <span class="number">16</span>     <span class="number">8</span>               <span class="keyword">long</span> FieldTest.e            </span><br><span class="line">    <span class="number">24</span>     <span class="number">4</span>                <span class="keyword">int</span> FieldTest.c            </span><br><span class="line">    <span class="number">28</span>     <span class="number">1</span>               <span class="keyword">byte</span> FieldTest.a            </span><br><span class="line">    <span class="number">29</span>     <span class="number">1</span>            <span class="keyword">boolean</span> FieldTest.d            </span><br><span class="line">    <span class="number">30</span>     <span class="number">2</span>              (alignment/padding gap)</span><br><span class="line">    <span class="number">32</span>     <span class="number">8</span>   java.lang.Object FieldTest.f</span><br></pre></td></tr></table></figure>

<h4 id="2-3-继承体系的布局"><a href="#2-3-继承体系的布局" class="headerlink" title="2.3 继承体系的布局"></a>2.3 继承体系的布局</h4><p>继承体系中，类间不混排，而是独立分隔开，但每个类中的字段遵循前述的优先级。如下的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">long</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重排序的结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OFFSET  SIZE   TYPE DESCRIPTION    </span><br><span class="line">    <span class="number">16</span>     <span class="number">8</span>   <span class="keyword">long</span> Father.c       </span><br><span class="line">    <span class="number">24</span>     <span class="number">4</span>    <span class="keyword">int</span> Father.a       </span><br><span class="line">    <span class="number">28</span>     <span class="number">4</span>    <span class="keyword">int</span> Father.b       </span><br><span class="line">    <span class="number">32</span>     <span class="number">8</span>   <span class="keyword">long</span> Child.d</span><br></pre></td></tr></table></figure>

<p>不开启指针压缩时，如果继承体系中的类字段没有占满8字节，将补齐字节对齐8字节。如下的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">byte</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> d;</span><br><span class="line">    <span class="keyword">byte</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重排序的结果为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OFFSET  SIZE   TYPE DESCRIPTION            </span><br><span class="line">    <span class="number">16</span>     <span class="number">8</span>   <span class="keyword">long</span> Father.a               </span><br><span class="line">    <span class="number">24</span>     <span class="number">1</span>   <span class="keyword">byte</span> Father.b               </span><br><span class="line">    <span class="number">25</span>     <span class="number">1</span>   <span class="keyword">byte</span> Father.c               </span><br><span class="line">    <span class="number">26</span>     <span class="number">6</span>        (alignment/padding gap)</span><br><span class="line">    <span class="number">32</span>     <span class="number">8</span>   <span class="keyword">long</span> Child.d                </span><br><span class="line">    <span class="number">40</span>     <span class="number">1</span>   <span class="keyword">byte</span> Child.e                </span><br><span class="line">    <span class="number">41</span>     <span class="number">7</span>        (alignment/padding gap)</span><br></pre></td></tr></table></figure>

<p>开启指针压缩时，情况稍有不同：如果父类层次中有至少4字节的空闲，则子类中如果含有4字节及其以下的字段，将按优先级：int = float &gt; char = short &gt; byte &gt; boolean &gt; object reference填充。开启指针压缩时，由于对象头只有12字节，剩余的4字节也将按这样的规则填充。如下的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">long</span> a;</span><br><span class="line">    <span class="keyword">byte</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> e;</span><br><span class="line">    <span class="keyword">long</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重排序的结果为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                             </span><br><span class="line">    <span class="number">12</span>     <span class="number">1</span>   <span class="keyword">byte</span> Father.b                                </span><br><span class="line">    <span class="number">13</span>     <span class="number">1</span>   <span class="keyword">byte</span> Father.c                                </span><br><span class="line">    <span class="number">14</span>     <span class="number">2</span>        (alignment/padding gap)                 </span><br><span class="line">    <span class="number">16</span>     <span class="number">8</span>   <span class="keyword">long</span> Father.a                                </span><br><span class="line">    <span class="number">24</span>     <span class="number">8</span>   <span class="keyword">long</span> Child.d                                 </span><br><span class="line">    <span class="number">32</span>     <span class="number">1</span>   <span class="keyword">byte</span> Child.e                                 </span><br><span class="line">    <span class="number">33</span>     <span class="number">7</span>        (alignment)</span><br></pre></td></tr></table></figure>

<h4 id="2-4-非静态内部类"><a href="#2-4-非静态内部类" class="headerlink" title="2.4 非静态内部类"></a>2.4 非静态内部类</h4><p>非静态内部类隐含一个指向外部类对象的引用，如下的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    Inner i;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>Inner</code>的字段排序结果为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OFFSET  SIZE    TYPE DESCRIPTION      </span><br><span class="line">    <span class="number">0</span>    <span class="number">12</span>         (<span class="keyword">object</span> header)        </span><br><span class="line">    <span class="number">12</span>     <span class="number">4</span>     <span class="keyword">int</span> Inner.b                                  </span><br><span class="line">    <span class="number">16</span>     <span class="number">4</span>   Outer Inner.<span class="keyword">this</span>$<span class="number">0</span>                             </span><br><span class="line">    <span class="number">20</span>     <span class="number">4</span>         (loss due to the next <span class="keyword">object</span> alignment)</span><br></pre></td></tr></table></figure>

<p>可见其中的隐含引用，这也就是能使用<code>Inner.this</code>引用外部对象的原因。</p>
<h3 id="3-估算应用所占内存"><a href="#3-估算应用所占内存" class="headerlink" title="3.估算应用所占内存"></a>3.估算应用所占内存</h3><p>明白了这些，那么估算应用所占内存便成为可能。一个应用使用如下的数据结构存储数据：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, <span class="built_in">String</span>&gt; cache = <span class="keyword">new</span> HashMap&lt;Integer, <span class="built_in">String</span>&gt;();</span><br></pre></td></tr></table></figure>

<p>该应用有约100万数据，其中每个<code>String</code>的长度约为50，该应用大约占用多少内存呢？假设该应用运行在64位JVM上，开启<code>CompressedOops</code>选项。</p>
<p>由前述分析知：一个<code>Integer</code>占用16字节。那么长度为50的字符串占用多少字节呢？<code>String</code>的数据结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中含有一个int值和字符数组，而数组的对象头中含有一个4字节的长度字段，故对象头部为16字节。该<code>String</code>对象的内存布局示意如下：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3288959-61048da22e79d2c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/444/format/webp" alt="img"></p>
<p>字符串内存布局示意</p>
<p> 可知，长度为50的字符串占用24+120=144字节的空间。<br> 估计HashMap大小的关键是估算<code>Entry</code>的大小，它的数据结构如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;    <span class="comment">// 引用</span></span><br><span class="line">    V value;    <span class="comment">// 引用</span></span><br><span class="line">    Entry&lt;K,V&gt; next; <span class="comment">// 引用</span></span><br><span class="line">    <span class="built_in">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知一个<code>Entry</code>所占内存为：12B对象头+16B实例数据+4B对齐填充，共占用32字节。由于含有100万条数据，故将创建100万个<code>Entry</code>。由此可估算所占内存为：100万<code>Integer</code>、100万<code>String</code>和100万<code>Entry</code>，忽略HashMap的其他小额占用，最终占用内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(16 + 144 + 32) * 1 000 000 ≈ 192 MB</span><br></pre></td></tr></table></figure>

<p>使用visual vm工具进行监控的实际数据如下：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3288959-cae5db9293f51779.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/916/format/webp" alt="img"></p>
<p>应用所占内存示意</p>
<p>附相关资料：</p>
<p><a href="https://link.jianshu.com?t=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000004574249" target="_blank" rel="noopener">Java对象结构及大小计算</a><br> <a href="https://link.jianshu.com?t=https%3A%2F%2Fawaiswaheed.wordpress.com%2Fcategory%2Fjava-learning%2Fjava-core%2Fjava-object-memory-structure%2F" target="_blank" rel="noopener">Java Object Memory Structure</a><br> <a href="https://link.jianshu.com?t=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Ftopic%2F41307" target="_blank" rel="noopener">Java数据对齐讨论</a><br> <a href="https://link.jianshu.com?t=http%3A%2F%2Fopenjdk.java.net%2Fprojects%2Fcode-tools%2Fjol%2F" target="_blank" rel="noopener">jdk jol工具</a></p>
<hr>
<p>本文整理自</p>
<p><a href="https://www.jianshu.com/p/ad505f9163b2" target="_blank" rel="noopener">如何正确计算Java对象所占内存？</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/17/Java%E5%8E%8B%E7%BC%A9%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/17/Java%E5%8E%8B%E7%BC%A9%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">Java压缩指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-17 11:54:29 / 修改时间：19:55:52" itemprop="dateCreated datePublished" datetime="2020-08-17T11:54:29+08:00">2020-08-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>Java虚拟机中每个Java对象都有一个对象头，对象头由标记字段和类型指针构成。其中标记字段用以存储Java虚拟机有关对象的运行数据，如哈希码、GC信息及锁信息，而指针类型指向该对象的类。</p>
<h2 id="压缩指针"><a href="#压缩指针" class="headerlink" title="压缩指针"></a>压缩指针</h2><p>在64位的虚拟机中，对象头的标记字段占64位，而类型指针又占64位。也就是说一个对象额外占用的字节就是16个字节。以Integer对象为例，它仅有一个int类型的私有字段，占4个字节。因此，每个Integer的额外开销至少400%，这也就是Java为什么要引入基本数据类型的原因之一。为了减少内存开销，64位Java虚拟机引入了压缩指针概念（对应虚拟机选项 -XX:+UseCompressedOops，默认开启），将堆中原本64位的Java对象指针压缩成32位的。<br> 这样一来，对象头的类型指针也会被压缩成32位，使得对象头大小从16字节降低为12字节。压缩指针不仅可以作用对象头的类型指针，还可以作用引用类型的字段，引用类型的数组。</p>
<h2 id="压缩指针原理"><a href="#压缩指针原理" class="headerlink" title="压缩指针原理"></a>压缩指针原理</h2><p>默认情况下，Java虚拟机中对象的起始地址需要对齐至8的倍数（这个概念我们称之为内存对齐（对应虚拟机选项 -XX:ObjectAlignmentInBytes，默认值为 8）。如果一个对象用不到8N字节，那么空白的那部分空间就白白浪费掉了。这些浪费掉的空间我们称之为对象之间的填充。默认情况下，Java虚拟机中32位的指针可以寻址到2的35次方，也就是32GB的内存空间（超过32位会关闭压缩指针）。在对压缩指针解引用时，我们需要将其左移3位，再加上一个固定的偏移量，便可以寻址到32GB地址空间伪64位指针了。</p>
<p>此外，我们可以配置刚刚提到的内存对齐选项（-XX:ObjectAlignmentInBytes）来进一步提升内存寻址范围。但是，这也可能增加对象填充，导致压缩指针没有打到节省空间效果。</p>
<h2 id="关闭压缩指针"><a href="#关闭压缩指针" class="headerlink" title="关闭压缩指针"></a>关闭压缩指针</h2><p>就算关闭了压缩指针，Java虚拟机也会进行内存对齐。内存对齐不仅在于对象和对象之间，也存在于对象的各个字段之间。比如说，Java虚拟机中的long字段、double字段，以及非压缩指针状态下的引用字段为8的倍数。</p>
<h2 id="内存对齐原因"><a href="#内存对齐原因" class="headerlink" title="内存对齐原因"></a>内存对齐原因</h2><p>内存对齐的一个原因是让字段出现在同一CPU的缓存中。如果字段不对齐，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取的读取可能需要跨两个缓存行，而改字段的存储也可能同时污染两个缓存行。这种情况对程序的执行效率是不利的。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://www.jianshu.com/p/017467692a92" target="_blank" rel="noopener">压缩指针</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/10/kafka%E4%B8%ADpartition%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/kafka%E4%B8%ADpartition%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/" class="post-title-link" itemprop="url">kafka中partition和消费者对应关系</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-10 12:07:35 / 修改时间：20:09:26" itemprop="dateCreated datePublished" datetime="2020-08-10T12:07:35+08:00">2020-08-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>1个partition只能被同组的一个consumer消费，同组的consumer则起到均衡效果</strong></p>
<h2 id="消费者多于partition"><a href="#消费者多于partition" class="headerlink" title="消费者多于partition"></a>消费者多于partition</h2><p>topic： test 只有一个partition<br> 创建一个topic——test，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>在g2组中启动两个consumer，</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> bin/kafka-<span class="built_in">console</span>-consumer.sh --bootstrap-server localhost:<span class="number">9092</span> --topic test --<span class="keyword">from</span>-beginning --consumer.config config/consumer_g2.properties</span><br><span class="line"><span class="number">2.</span> bin/kafka-<span class="built_in">console</span>-consumer.sh --bootstrap-server localhost:<span class="number">9092</span> --topic test --<span class="keyword">from</span>-beginning --consumer.config config/consumer_g2.properties</span><br></pre></td></tr></table></figure>

<p>消费者数量为2大于partition数量1，此时partition和消费者进程对应关系如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-consumer-groups.sh --bootstrap-server localhost:<span class="number">9092</span> --describe --<span class="keyword">group</span> g2</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TOPIC PARTITION CURRENT-OFFSET LOG-END-OFFSET LAG CONSUMER-ID HOST CLIENT-ID</span><br><span class="line"><span class="built_in">test</span> 0 9 9 0 consumer-1-4a2a4aa8-32f4-4904-9c16-1c0bdf7128a2 /127.0.0.1 consumer-1</span><br><span class="line">- - - - - consumer-1-fd7b120f-fd21-4e07-8c23-87b71c1ee8a5 /127.0.0.1 consumer-1</span><br></pre></td></tr></table></figure>

<p>消费者consumer-1-fd7b120f-fd21-4e07-8c23-87b71c1ee8a5无对应的partition。<br> 用图表示为</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2414051-4c77d6b4a8d3ae9a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/339/format/webp" alt="img"></p>
<p>生产者消费者对应关系1.jpg</p>
<p> 如上图，向test发送消息：1，2， 3，4，5，6，7，8，9<br> 只有C1能接收到消息，C2则不能接收到消息，<strong>即同一个partition内的消息只能被同一个组中的一个consumer消费。当消费者数量多于partition的数量时，多余的消费者空闲。</strong><br><strong>也就是说如果只有一个partition你在同一组启动多少个consumer都没用，partition的数量决定了此topic在同一组中被可被均衡的程度，例如partition=4，则可在同一组中被最多4个consumer均衡消费。</strong></p>
<h2 id="消费者少于和等于partition"><a href="#消费者少于和等于partition" class="headerlink" title="消费者少于和等于partition"></a>消费者少于和等于partition</h2><p>topic：test2包含3个partition</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 3 --topic test2</span><br></pre></td></tr></table></figure>

<p>开始时，在g3组中启动2个consumer,</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>bin/kafka-<span class="built_in">console</span>-consumer.sh --bootstrap-server localhost:<span class="number">9092</span> --topic test2 --<span class="keyword">from</span>-beginning --consumer.config config/consumer_g3.properties</span><br><span class="line"><span class="number">2.</span>bin/kafka-<span class="built_in">console</span>-consumer.sh --bootstrap-server localhost:<span class="number">9092</span> --topic test2 --<span class="keyword">from</span>-beginning --consumer.config config/consumer_g3.properties</span><br></pre></td></tr></table></figure>

<p>则对应关系如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TOPIC PARTITION CURRENT-OFFSET LOG-END-OFFSET LAG CONSUMER-ID HOST <span class="built_in">CLIENT</span>-ID</span><br><span class="line">test2 <span class="number">0</span> <span class="number">8</span> <span class="number">8</span> <span class="number">0</span> consumer<span class="number">-1</span><span class="number">-8</span>b872ef7-a2f0<span class="number">-4</span>bd3-b2a8<span class="number">-7</span>b26e4d8ab2c /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br><span class="line">test2 <span class="number">1</span> <span class="number">7</span> <span class="number">7</span> <span class="number">0</span> consumer<span class="number">-1</span><span class="number">-8</span>b872ef7-a2f0<span class="number">-4</span>bd3-b2a8<span class="number">-7</span>b26e4d8ab2c /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br><span class="line">test2 <span class="number">2</span> <span class="number">8</span> <span class="number">8</span> <span class="number">0</span> consumer<span class="number">-1</span>-f362847d<span class="number">-1094</span><span class="number">-4895</span>-ad8b<span class="number">-1e1</span>f1c88936c /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>其中，consumer-1-8b872ef7-a2f0-4bd3-b2a8-7b26e4d8ab2c对应了2个partition<br> 用图表示为：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2414051-dd61642376e23f15.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/343/format/webp" alt="img"></p>
<p>生产者消费者对应关系2.jpg</p>
<p> 消费者数量2小于partition的数量3，此时，向test2发送消息1，2，3，4，5，6，7，8，9<br> C1接收到1，3，4，6，7，9<br> C2接收到2，5，8<br><strong>此时P1、P2对对应C1，即多个partition对应一个消费者，C1接收到消息量是C2的两倍</strong><br> 然后，在g3组中再启动一个消费者，使得消费者数量为3等于topic2中partition的数量</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span>bin/kafka-<span class="built_in">console</span>-consumer.sh --bootstrap-server localhost:<span class="number">9092</span> --topic test2 --<span class="keyword">from</span>-beginning --consumer.config config/consumer_g3.properties</span><br></pre></td></tr></table></figure>

<p>对应关系如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TOPIC PARTITION CURRENT-OFFSET LOG-END-OFFSET LAG CONSUMER-ID HOST <span class="built_in">CLIENT</span>-ID</span><br><span class="line">test2 <span class="number">0</span> <span class="number">8</span> <span class="number">8</span> <span class="number">0</span> consumer<span class="number">-1</span><span class="number">-8</span>b872ef7-a2f0<span class="number">-4</span>bd3-b2a8<span class="number">-7</span>b26e4d8ab2c /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br><span class="line">test2 <span class="number">1</span> <span class="number">7</span> <span class="number">7</span> <span class="number">0</span> consumer<span class="number">-1</span>-ab472ed5-de11<span class="number">-4e56</span><span class="number">-863</span>a<span class="number">-67</span>bf3a3cc36a /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br><span class="line">test2 <span class="number">2</span> <span class="number">8</span> <span class="number">8</span> <span class="number">0</span> consumer<span class="number">-1</span>-f362847d<span class="number">-1094</span><span class="number">-4895</span>-ad8b<span class="number">-1e1</span>f1c88936c /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>此时，partition和消费者是一对一关系，向test2发送消息1，2，3，4，5，6，7，8，9<br> C1接收到了：2，5，8<br> C2接收到了：3，6，9<br> C3接收到了：1，4，7<br> C1，C2，C3均分了test2的所有消息，即<strong>消息在同一个组之间的消费者之间均分了!</strong></p>
<h2 id="多个消费者组"><a href="#多个消费者组" class="headerlink" title="多个消费者组"></a>多个消费者组</h2><p>启动g4组，仅包含一个消费者C1，消费topic2的消息，此时消费端有两个消费者组</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-<span class="built_in">console</span>-consumer.sh --bootstrap-server localhost:<span class="number">9092</span> --topic test2 --<span class="keyword">from</span>-beginning --consumer.config config/consumer_g4.properties --<span class="keyword">delete</span>-consumer-offsets</span><br></pre></td></tr></table></figure>

<p>g4组的C1的对应了test2的所有partition:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-consumer-groups.sh --bootstrap-server localhost:<span class="number">9092</span> --describe --<span class="keyword">group</span> g4</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TOPIC PARTITION CURRENT-OFFSET LOG-END-OFFSET LAG CONSUMER-ID HOST <span class="built_in">CLIENT</span>-ID</span><br><span class="line">test2 <span class="number">0</span> <span class="number">36</span> <span class="number">36</span> <span class="number">0</span> consumer<span class="number">-1</span>-befc9234<span class="number">-260</span>d<span class="number">-4</span>ad3-b283-b67a2bf446ca /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br><span class="line">test2 <span class="number">1</span> <span class="number">35</span> <span class="number">35</span> <span class="number">0</span> consumer<span class="number">-1</span>-befc9234<span class="number">-260</span>d<span class="number">-4</span>ad3-b283-b67a2bf446ca /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br><span class="line">test2 <span class="number">2</span> <span class="number">36</span> <span class="number">36</span> <span class="number">0</span> consumer<span class="number">-1</span>-befc9234<span class="number">-260</span>d<span class="number">-4</span>ad3-b283-b67a2bf446ca /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>用图表示为</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2414051-834521901c8940b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/336/format/webp" alt="img"></p>
<p>生产者消费者对应关系3.jpg</p>
<p> 如上图，向test2发送消息1，2，3，4，5，6，7，8，9<br> 那么g3组各个消费者及g4组的消费者接收到的消息是怎样地呢？欢迎思考！！<br> 答案：<br> 消息被g3组的消费者均分，g4组的消费者在接收到了所有的消息。<br> g3组：<br> C1接收到了：2，5，8<br> C2接收到了：3，6，9<br> C3接收到了：1，4，7<br> g4组：<br> C1接收到了：1，2，3，4，5，6，7，8，9<br><strong>启动多个组，则会使同一个消息被消费多次</strong></p>
<hr>
<p>本文整理自</p>
<p><a href="https://www.jianshu.com/p/6233d5341dfe" target="_blank" rel="noopener">kafka中partition和消费者对应关系</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/10/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Spring事务传播行为详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-10 11:12:34 / 修改时间：19:14:04" itemprop="dateCreated datePublished" datetime="2020-08-10T11:12:34+08:00">2020-08-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。这是Spring为我们提供的强大的工具箱，使用事务传播行可以为我们的开发工作提供许多便利。但是人们对他的误解也颇多，你一定也听过“service方法事务最好不要嵌套”的传言。要想正确的使用工具首先需要了解工具。本文对七种事务传播行为做详细介绍，内容主要代码示例的方式呈现。</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="1-什么是事务传播行为？"><a href="#1-什么是事务传播行为？" class="headerlink" title="1. 什么是事务传播行为？"></a>1. 什么是事务传播行为？</h2><p>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。</p>
<p>用伪代码说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void methodA()&#123;</span><br><span class="line">   methodB();</span><br><span class="line">   &#x2F;&#x2F;doSomething</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transaction(Propagation&#x3D;XXX)</span><br><span class="line">public void methodB()&#123;</span><br><span class="line">   &#x2F;&#x2F;doSomething</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中<code>methodA()</code>方法嵌套调用了<code>methodB()</code>方法，<code>methodB()</code>的事务传播行为由<code>@Transaction(Propagation=XXX)</code>设置决定。这里需要注意的是<code>methodA()</code>并没有开启事务，某一个事务传播行为修饰的方法并不是必须要在开启事务的外围方法中调用。</p>
<h2 id="2-Spring中七种事务传播行为"><a href="#2-Spring中七种事务传播行为" class="headerlink" title="2. Spring中七种事务传播行为"></a>2. Spring中七种事务传播行为</h2><table>
<thead>
<tr>
<th>事务传播行为类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>使用当前的事务，如果当前没有事务，就抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>新建事务，如果当前存在事务，把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>以非事务方式执行，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody></table>
<p>定义非常简单，也很好理解，下面我们就进入代码测试部分，验证我们的理解是否正确。</p>
<h1 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h1><p>文中代码以传统三层结构中两层呈现，即Service和Dao层，由Spring负责依赖注入和注解式事务管理，DAO层由Mybatis实现，你也可以使用任何喜欢的方式，例如，Hibernate,JPA,JDBCTemplate等。数据库使用的是MySQL数据库，你也可以使用任何支持事务的数据库，并不会影响验证结果。</p>
<p>首先我们在数据库中创建两张表：</p>
<p><strong>user1</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;user1&#96; (</span><br><span class="line">  &#96;id&#96; INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; VARCHAR(45) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">  PRIMARY KEY(&#96;id&#96;)</span><br><span class="line">)</span><br><span class="line">ENGINE &#x3D; InnoDB;</span><br></pre></td></tr></table></figure>

<p><strong>user2</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;user2&#96; (</span><br><span class="line">  &#96;id&#96; INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; VARCHAR(45) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">  PRIMARY KEY(&#96;id&#96;)</span><br><span class="line">)</span><br><span class="line">ENGINE &#x3D; InnoDB;</span><br></pre></td></tr></table></figure>

<p>然后编写相应的Bean和DAO层代码：</p>
<p><strong>User1</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class User1 &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">   &#x2F;&#x2F;get和set方法省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User2</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class User2 &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">   &#x2F;&#x2F;get和set方法省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User1Mapper</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface User1Mapper &#123;</span><br><span class="line">    int insert(User1 record);</span><br><span class="line">    User1 selectByPrimaryKey(Integer id);</span><br><span class="line">    &#x2F;&#x2F;其他方法省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User2Mapper</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface User2Mapper &#123;</span><br><span class="line">    int insert(User2 record);</span><br><span class="line">    User2 selectByPrimaryKey(Integer id);</span><br><span class="line">    &#x2F;&#x2F;其他方法省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后也是具体验证的代码由service层实现，下面我们分情况列举。</p>
<h2 id="1-PROPAGATION-REQUIRED"><a href="#1-PROPAGATION-REQUIRED" class="headerlink" title="1.PROPAGATION_REQUIRED"></a>1.PROPAGATION_REQUIRED</h2><p>我们为User1Service和User2Service相应方法加上<code>Propagation.REQUIRED</code>属性。</p>
<p><strong>User1Service方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User1ServiceImpl implements User1Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">    public void addRequired(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User2Service方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User2ServiceImpl implements User2Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">    public void addRequired(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">    public void addRequiredException(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-场景一"><a href="#1-1-场景一" class="headerlink" title="1.1 场景一"></a>1.1 场景一</h3><p>此场景外围方法没有开启事务。</p>
<p><strong>验证方法1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_exception_required_required()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequired(user2);</span><br><span class="line">    </span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_required_required_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiredException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别执行验证方法，结果：</p>
<table>
<thead>
<tr>
<th>验证方法序号</th>
<th>数据库结果</th>
<th>结果分析</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>“张三”、“李四”均插入。</td>
<td>外围方法未开启事务，插入“张三”、“李四”方法在自己的事务中独立运行，外围方法异常不影响内部插入“张三”、“李四”方法独立的事务。</td>
</tr>
<tr>
<td>2</td>
<td>“张三”插入，“李四”未插入。</td>
<td>外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,所以插入“李四”方法抛出异常只会回滚插入“李四”方法，插入“张三”方法不受影响。</td>
</tr>
</tbody></table>
<p><strong>结论：通过这两个方法我们证明了在外围方法未开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong></p>
<h3 id="1-2-场景二"><a href="#1-2-场景二" class="headerlink" title="1.2 场景二"></a>1.2 场景二</h3><p>外围方法开启事务，这个是使用率比较高的场景。</p>
<p><strong>验证方法1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> @Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line"> public void transaction_exception_required_required()&#123;</span><br><span class="line">     User1 user1&#x3D;new User1();</span><br><span class="line">     user1.setName(&quot;张三&quot;);</span><br><span class="line">     user1Service.addRequired(user1);</span><br><span class="line">     </span><br><span class="line">     User2 user2&#x3D;new User2();</span><br><span class="line">     user2.setName(&quot;李四&quot;);</span><br><span class="line">     user2Service.addRequired(user2);</span><br><span class="line">     </span><br><span class="line">     throw new RuntimeException();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void transaction_required_required_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiredException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_required_required_exception_try()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        user2Service.addRequiredException(user2);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        System.out.println(&quot;方法回滚&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别执行验证方法，结果：</p>
<table>
<thead>
<tr>
<th>验证方法序号</th>
<th>数据库结果</th>
<th>结果分析</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>“张三”、“李四”均未插入。</td>
<td>外围方法开启事务，内部方法加入外围方法事务，外围方法回滚，内部方法也要回滚。</td>
</tr>
<tr>
<td>2</td>
<td>“张三”、“李四”均未插入。</td>
<td>外围方法开启事务，内部方法加入外围方法事务，内部方法抛出异常回滚，外围方法感知异常致使整体事务回滚。</td>
</tr>
<tr>
<td>3</td>
<td>“张三”、“李四”均未插入。</td>
<td>外围方法开启事务，内部方法加入外围方法事务，内部方法抛出异常回滚，即使方法被catch不被外围方法感知，整个事务依然回滚。</td>
</tr>
</tbody></table>
<p><strong>结论：以上试验结果我们证明在外围方法开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会加入到外围方法的事务中，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</strong></p>
<h2 id="2-PROPAGATION-REQUIRES-NEW"><a href="#2-PROPAGATION-REQUIRES-NEW" class="headerlink" title="2.PROPAGATION_REQUIRES_NEW"></a>2.PROPAGATION_REQUIRES_NEW</h2><p>我们为User1Service和User2Service相应方法加上<code>Propagation.REQUIRES_NEW</code>属性。<br><strong>User1Service方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User1ServiceImpl implements User1Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</span><br><span class="line">    public void addRequiresNew(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">    public void addRequired(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User2Service方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User2ServiceImpl implements User2Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</span><br><span class="line">    public void addRequiresNew(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</span><br><span class="line">    public void addRequiresNewException(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-场景一"><a href="#2-1-场景一" class="headerlink" title="2.1 场景一"></a>2.1 场景一</h3><p>外围方法没有开启事务。</p>
<p><strong>验证方法1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_exception_requiresNew_requiresNew()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequiresNew(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_requiresNew_requiresNew_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequiresNew(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNewException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别执行验证方法，结果：</p>
<table>
<thead>
<tr>
<th>验证方法序号</th>
<th>数据库结果</th>
<th>结果分析</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>“张三”插入，“李四”插入。</td>
<td>外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,外围方法抛出异常回滚不会影响内部方法。</td>
</tr>
<tr>
<td>2</td>
<td>“张三”插入，“李四”未插入</td>
<td>外围方法没有开启事务，插入“张三”方法和插入“李四”方法分别开启自己的事务，插入“李四”方法抛出异常回滚，其他事务不受影响。</td>
</tr>
</tbody></table>
<p><strong>结论：通过这两个方法我们证明了在外围方法未开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong></p>
<h3 id="2-2-场景二"><a href="#2-2-场景二" class="headerlink" title="2.2 场景二"></a>2.2 场景二</h3><p>外围方法开启事务。</p>
<p><strong>验证方法1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void transaction_exception_required_requiresNew_requiresNew()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    </span><br><span class="line">    User2 user3&#x3D;new User2();</span><br><span class="line">    user3.setName(&quot;王五&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user3);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void transaction_required_requiresNew_requiresNew_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    </span><br><span class="line">    User2 user3&#x3D;new User2();</span><br><span class="line">    user3.setName(&quot;王五&quot;);</span><br><span class="line">    user2Service.addRequiresNewException(user3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void transaction_required_requiresNew_requiresNew_exception_try()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    User2 user3&#x3D;new User2();</span><br><span class="line">    user3.setName(&quot;王五&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        user2Service.addRequiresNewException(user3);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        System.out.println(&quot;回滚&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别执行验证方法，结果：</p>
<table>
<thead>
<tr>
<th>验证方法序号</th>
<th>数据库结果</th>
<th>结果分析</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>“张三”未插入，“李四”插入，“王五”插入。</td>
<td>外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中，外围方法抛出异常只回滚和外围方法同一事务的方法，故插入“张三”的方法回滚。</td>
</tr>
<tr>
<td>2</td>
<td>“张三”未插入，“李四”插入，“王五”未插入。</td>
<td>外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中。插入“王五”方法抛出异常，首先插入 “王五”方法的事务被回滚，异常继续抛出被外围方法感知，外围方法事务亦被回滚，故插入“张三”方法也被回滚。</td>
</tr>
<tr>
<td>3</td>
<td>“张三”插入，“李四”插入，“王五”未插入。</td>
<td>外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中。插入“王五”方法抛出异常，首先插入“王五”方法的事务被回滚，异常被catch不会被外围方法感知，外围方法事务不回滚，故插入“张三”方法插入成功。</td>
</tr>
</tbody></table>
<p><strong>结论：在外围方法开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰。</strong></p>
<h2 id="3-PROPAGATION-NESTED"><a href="#3-PROPAGATION-NESTED" class="headerlink" title="3.PROPAGATION_NESTED"></a>3.PROPAGATION_NESTED</h2><p>我们为User1Service和User2Service相应方法加上<code>Propagation.NESTED</code>属性。<br><strong>User1Service方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User1ServiceImpl implements User1Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.NESTED)</span><br><span class="line">    public void addNested(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User2Service方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User2ServiceImpl implements User2Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.NESTED)</span><br><span class="line">    public void addNested(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.NESTED)</span><br><span class="line">    public void addNestedException(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-场景一"><a href="#3-1-场景一" class="headerlink" title="3.1 场景一"></a>3.1 场景一</h3><p>此场景外围方法没有开启事务。</p>
<p><strong>验证方法1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_exception_nested_nested()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNested(user2);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_nested_nested_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNestedException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别执行验证方法，结果：</p>
<table>
<thead>
<tr>
<th>验证方法序号</th>
<th>数据库结果</th>
<th>结果分析</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>“张三”、“李四”均插入。</td>
<td>外围方法未开启事务，插入“张三”、“李四”方法在自己的事务中独立运行，外围方法异常不影响内部插入“张三”、“李四”方法独立的事务。</td>
</tr>
<tr>
<td>2</td>
<td>“张三”插入，“李四”未插入。</td>
<td>外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,所以插入“李四”方法抛出异常只会回滚插入“李四”方法，插入“张三”方法不受影响。</td>
</tr>
</tbody></table>
<p><strong>结论：通过这两个方法我们证明了在外围方法未开启事务的情况下<code>Propagation.NESTED</code>和<code>Propagation.REQUIRED</code>作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong></p>
<h3 id="3-2-场景二"><a href="#3-2-场景二" class="headerlink" title="3.2 场景二"></a>3.2 场景二</h3><p>外围方法开启事务。</p>
<p><strong>验证方法1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_exception_nested_nested()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNested(user2);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_nested_nested_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNestedException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_nested_nested_exception_try()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        user2Service.addNestedException(user2);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        System.out.println(&quot;方法回滚&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别执行验证方法，结果：</p>
<table>
<thead>
<tr>
<th>验证方法序号</th>
<th>数据库结果</th>
<th>结果分析</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>“张三”、“李四”均未插入。</td>
<td>外围方法开启事务，内部事务为外围事务的子事务，外围方法回滚，内部方法也要回滚。</td>
</tr>
<tr>
<td>2</td>
<td>“张三”、“李四”均未插入。</td>
<td>外围方法开启事务，内部事务为外围事务的子事务，内部方法抛出异常回滚，且外围方法感知异常致使整体事务回滚。</td>
</tr>
<tr>
<td>3</td>
<td>“张三”插入、“李四”未插入。</td>
<td>外围方法开启事务，内部事务为外围事务的子事务，插入“李四”内部方法抛出异常，可以单独对子事务回滚。</td>
</tr>
</tbody></table>
<p><strong>结论：以上试验结果我们证明在外围方法开启事务的情况下<code>Propagation.NESTED</code>修饰的内部方法属于外部事务的子事务，外围主事务回滚，子事务一定回滚，而内部子事务可以单独回滚而不影响外围主事务和其他子事务</strong></p>
<h2 id="4-REQUIRED-REQUIRES-NEW-NESTED异同"><a href="#4-REQUIRED-REQUIRES-NEW-NESTED异同" class="headerlink" title="4. REQUIRED,REQUIRES_NEW,NESTED异同"></a>4. REQUIRED,REQUIRES_NEW,NESTED异同</h2><p>由“1.2 场景二”和“3.2 场景二”对比，我们可知：<br><strong>NESTED和REQUIRED修饰的内部方法都属于外围方法事务，如果外围方法抛出异常，这两种方法的事务都会被回滚。但是REQUIRED是加入外围方法事务，所以和外围事务同属于一个事务，一旦REQUIRED事务抛出异常被回滚，外围方法事务也将被回滚。而NESTED是外围方法的子事务，有单独的保存点，所以NESTED方法抛出异常被回滚，不会影响到外围方法的事务。</strong></p>
<p>由“2.2 场景二”和“3.2 场景二”对比，我们可知：<br><strong>NESTED和REQUIRES_NEW都可以做到内部方法事务回滚而不影响外围方法事务。但是因为NESTED是嵌套事务，所以外围方法回滚之后，作为外围方法事务的子事务也会被回滚。而REQUIRES_NEW是通过开启新的事务实现的，内部事务和外围事务是两个事务，外围事务回滚不会影响内部事务。</strong></p>
<h2 id="5-其他事务传播行为"><a href="#5-其他事务传播行为" class="headerlink" title="5. 其他事务传播行为"></a>5. 其他事务传播行为</h2><p>鉴于文章篇幅问题，其他事务传播行为的测试就不在此一一描述了，感兴趣的读者可以去源码中自己寻找相应测试代码和结果解释。传送门：<a href="https://github.com/TmTse/transaction-test" target="_blank" rel="noopener">https://github.com/TmTse/tran…</a></p>
<h1 id="模拟用例"><a href="#模拟用例" class="headerlink" title="模拟用例"></a>模拟用例</h1><p>介绍了这么多事务传播行为，我们在实际工作中如何应用呢？下面我来举一个示例：</p>
<p>假设我们有一个注册的方法，方法中调用添加积分的方法，如果我们希望添加积分不会影响注册流程（即添加积分执行失败回滚不能使注册方法也回滚），我们会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">     </span><br><span class="line">     @Transactional</span><br><span class="line">     public void register(User user)&#123;</span><br><span class="line">                </span><br><span class="line">         try &#123;</span><br><span class="line">             membershipPointService.addPoint(Point point);</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F;省略...</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F;省略...</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还规定注册失败要影响<code>addPoint()</code>方法（注册方法回滚添加积分方法也需要回滚），那么<code>addPoint()</code>方法就需要这样实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MembershipPointServiceImpl implements MembershipPointService&#123;</span><br><span class="line">     </span><br><span class="line">     @Transactional(propagation &#x3D; Propagation.NESTED)</span><br><span class="line">     public void addPoint(Point point)&#123;</span><br><span class="line">                </span><br><span class="line">         try &#123;</span><br><span class="line">             recordService.addRecord(Record record);</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F;省略...</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F;省略...</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到了在<code>addPoint()</code>中还调用了<code>addRecord()</code>方法，这个方法用来记录日志。他的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class RecordServiceImpl implements RecordService&#123;</span><br><span class="line">     </span><br><span class="line">     @Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)</span><br><span class="line">     public void addRecord(Record record)&#123;</span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line">         &#x2F;&#x2F;省略...</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到<code>addRecord()</code>方法中<code>propagation = Propagation.NOT_SUPPORTED</code>，因为对于日志无所谓精确，可以多一条也可以少一条，所以<code>addRecord()</code>方法本身和外围<code>addPoint()</code>方法抛出异常都不会使<code>addRecord()</code>方法回滚，并且<code>addRecord()</code>方法抛出异常也不会影响外围<code>addPoint()</code>方法的执行。</p>
<p>通过这个例子相信大家对事务传播行为的使用有了更加直观的认识，通过各种属性的组合确实能让我们的业务实现更加灵活多样。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://segmentfault.com/a/1190000013341344" target="_blank" rel="noopener">Spring事务传播行为详解</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/01/%E5%B8%B8%E7%94%A8%E7%9A%84http%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%BB%A5%E5%8F%8A%E5%93%8D%E5%BA%94%E5%A4%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/01/%E5%B8%B8%E7%94%A8%E7%9A%84http%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%BB%A5%E5%8F%8A%E5%93%8D%E5%BA%94%E5%A4%B4/" class="post-title-link" itemprop="url">常用的http请求头以及响应头</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-02 05:50:52 / 修改时间：13:56:25" itemprop="dateCreated datePublished" datetime="2020-08-02T05:50:52+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、常用的http请求头"><a href="#一、常用的http请求头" class="headerlink" title="一、常用的http请求头"></a>一、常用的http请求头</h3><h3 id="1-Accept"><a href="#1-Accept" class="headerlink" title="1.Accept"></a><strong>1.Accept</strong></h3><ul>
<li><strong>Accept: text/html</strong> 浏览器可以接受服务器回发的类型为 text/html。</li>
<li><strong>Accept: */*</strong>  代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)。</li>
</ul>
<h3 id="2-Accept-Encoding"><a href="#2-Accept-Encoding" class="headerlink" title="2.Accept-Encoding"></a>2.Accept-Encoding</h3><ul>
<li><strong>Accept-Encoding: gzip, deflate</strong> 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）。</li>
</ul>
<h3 id="3-Accept-Language"><a href="#3-Accept-Language" class="headerlink" title="3.Accept-Language"></a>3.Accept-Language</h3><ul>
<li><strong>Accept-Language:zh-CN,zh;q=0.9</strong> 浏览器申明自己接收的语言。</li>
</ul>
<h3 id="4-Connection"><a href="#4-Connection" class="headerlink" title="4.Connection"></a>4.Connection</h3><ul>
<li><strong>Connection: keep-alive</strong> 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</li>
<li><strong>Connection: close</strong> 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</li>
</ul>
<h3 id="5-Host（发送请求时，该报头域是必需的）"><a href="#5-Host（发送请求时，该报头域是必需的）" class="headerlink" title="5.Host（发送请求时，该报头域是必需的）"></a>5.Host（发送请求时，该报头域是必需的）</h3><ul>
<li><strong>Host:<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></strong> 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。</li>
</ul>
<h3 id="6-Referer"><a href="#6-Referer" class="headerlink" title="6.Referer"></a>6.Referer</h3><ul>
<li><strong>Referer:<a href="https://www.baidu.com/?tn=62095104_8_oem_dg" target="_blank" rel="noopener">https://www.baidu.com/?tn=62095104_8_oem_dg</a></strong> 当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。</li>
</ul>
<h3 id="7-User-Agent"><a href="#7-User-Agent" class="headerlink" title="7.User-Agent"></a>7.User-Agent</h3><ul>
<li><strong>User-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36</strong> 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。</li>
</ul>
<h3 id="8-Cache-Control"><a href="#8-Cache-Control" class="headerlink" title="8.Cache-Control"></a>8.Cache-Control</h3><ul>
<li><strong>Cache-Control:private</strong> 默认为private 响应只能够作为私有的缓存，不能再用户间共享</li>
<li><strong>`\</strong>Cache-Control:public** `**响应会被缓存，并且在多用户间共享。正常情况, 如果要求HTTP认证,响应会自动设置为 private.</li>
<li><strong>Cache-Control:must-revalidate</strong> 响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。</li>
<li><strong>Cache-Control:no-cache</strong> 响应不会被缓存,而是实时向服务器端请求资源。</li>
<li><strong>Cache-Control:max-age=10</strong> 设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。</li>
<li><strong><code>Cache-Control:no-store</code></strong>在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。</li>
</ul>
<h3 id="9-Cookie"><a href="#9-Cookie" class="headerlink" title="9.Cookie"></a>9.Cookie</h3><p>Cookie是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如cookie会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然cookie里面的数据不仅仅是上述范围，还有很多信息可以存储是cookie里面，比如sessionid等。</p>
<h3 id="10-Range（用于断点续传）"><a href="#10-Range（用于断点续传）" class="headerlink" title="10.Range（用于断点续传）"></a>10.Range（用于断点续传）</h3><ul>
<li><strong>Range:bytes=0-5</strong> 指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。</li>
</ul>
<h2 id="二、常用的http响应头"><a href="#二、常用的http响应头" class="headerlink" title="二、常用的http响应头"></a>二、常用的http响应头</h2><h3 id="1-Cache-Control（对应请求中的Cache-Control）"><a href="#1-Cache-Control（对应请求中的Cache-Control）" class="headerlink" title="1.Cache-Control（对应请求中的Cache-Control）"></a>1.Cache-Control（对应请求中的Cache-Control）</h3><ul>
<li><strong>Cache-Control:private</strong> 默认为private  响应只能够作为私有的缓存，不能再用户间共享</li>
<li><strong><em>\</em>Cache-Control:public**</strong> 浏览器和缓存服务器都可以缓存页面信息。</li>
<li><strong>Cache-Control:must-revalidate</strong>  对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时。</li>
<li><strong>Cache-Control:no-cache</strong>  浏览器和缓存服务器都不应该缓存页面信息。</li>
<li><strong>Cache-Control:max-age=10</strong> 是通知浏览器10秒之内不要烦我，自己从缓冲区中刷新。</li>
<li><strong>Cache-Control:no-store</strong> 请求和响应的信息都不应该被存储在对方的磁盘系统中。</li>
</ul>
<h3 id="2-Content-Type"><a href="#2-Content-Type" class="headerlink" title="2.Content-Type"></a>2.Content-Type</h3><ul>
<li><strong>Content-Type：text/html;charset=UTF-8</strong> 告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。</li>
</ul>
<h3 id="3-Content-Encoding"><a href="#3-Content-Encoding" class="headerlink" title="3.Content-Encoding"></a>3.Content-Encoding</h3><ul>
<li><strong>Content-Encoding:gzip</strong> 告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。</li>
</ul>
<h3 id="4-Date"><a href="#4-Date" class="headerlink" title="4.Date"></a>4.Date</h3><ul>
<li><strong>Date: Tue, 03 Apr 2018 03:52:28 GMT</strong> 这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。</li>
</ul>
<h3 id="5-Server"><a href="#5-Server" class="headerlink" title="5.Server"></a>5.Server</h3><ul>
<li><strong>Server：Tengine/1.4.6</strong> 这个是服务器和相对应的版本，只是告诉客户端服务器信息<strong>。</strong></li>
</ul>
<h3 id="6-Transfer-Encoding"><a href="#6-Transfer-Encoding" class="headerlink" title="6.Transfer-Encoding"></a>6.Transfer-Encoding</h3><ul>
<li><strong>Transfer-Encoding：chunked</strong> 这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。</li>
</ul>
<h3 id="7-Expires"><a href="#7-Expires" class="headerlink" title="7.Expires"></a>7.Expires</h3><ul>
<li><strong>Expires:Sun, 1 Jan 2000 01:00:00 GMT</strong> 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有Cache-Control：max-age=*这个响应头准确的，因为max-age=date中的date是个相对时间，不仅更好理解，也更准确。</li>
</ul>
<h3 id="8-Last-Modified"><a href="#8-Last-Modified" class="headerlink" title="8.Last-Modified"></a>8.Last-Modified</h3><ul>
<li><strong>Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</strong> 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</li>
</ul>
<h3 id="9-Connection"><a href="#9-Connection" class="headerlink" title="9.Connection"></a>9.Connection</h3><ul>
<li><strong>Connection：keep-alive</strong> 这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。</li>
</ul>
<h3 id="10-Etag"><a href="#10-Etag" class="headerlink" title="10.Etag"></a><strong>10.Etag</strong></h3><ul>
<li><strong>ETag: “737060cd8c284d8af7ad3082f209582d”</strong> 就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。</li>
</ul>
<h3 id="11-Refresh"><a href="#11-Refresh" class="headerlink" title="11.Refresh"></a>11.Refresh</h3><ul>
<li><strong>Refresh: 5; url=<a href="http://baidu.com" target="_blank" rel="noopener">http://baidu.com</a></strong> 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。</li>
</ul>
<h3 id="12-Access-Control-Allow-Origin"><a href="#12-Access-Control-Allow-Origin" class="headerlink" title="12.Access-Control-Allow-Origin"></a>12.Access-Control-Allow-Origin</h3><ul>
<li><strong>Access-Control-Allow-Origin: *</strong>  <em>号代表所有网站可以跨域资源共享，如果当前字段为</em>那么Access-Control-Allow-Credentials就不能为true</li>
<li><strong>Access-Control-Allow-Origin: <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></strong> 指定哪些网站可以跨域资源共享</li>
</ul>
<h3 id="13-Access-Control-Allow-Methods"><a href="#13-Access-Control-Allow-Methods" class="headerlink" title="13.Access-Control-Allow-Methods"></a>13.Access-Control-Allow-Methods</h3><ul>
<li><strong>Access-Control-Allow-Methods：GET,POST,PUT,DELETE</strong> 允许哪些方法来访问</li>
</ul>
<h3 id="14-Access-Control-Allow-Credentials"><a href="#14-Access-Control-Allow-Credentials" class="headerlink" title="14.Access-Control-Allow-Credentials"></a>14.Access-Control-Allow-Credentials</h3><ul>
<li><strong>Access-Control-Allow-Credentials: true</strong> 是否允许发送cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。如果access-control-allow-origin为*，当前字段就不能为true</li>
</ul>
<h3 id="15-Content-Range"><a href="#15-Content-Range" class="headerlink" title="15.Content-Range"></a><strong>15.Content-Range</strong></h3><ul>
<li><strong>Content-Range: bytes 0-5/7877</strong> 指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。</li>
</ul>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/6844903745004765198" target="_blank" rel="noopener">常用的http请求头以及响应头</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/01/Cookie%20%E5%92%8C%20Session%20%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/01/Cookie%20%E5%92%8C%20Session%20%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Cookie 和 Session 关系和区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-02 02:26:29 / 修改时间：10:27:37" itemprop="dateCreated datePublished" datetime="2020-08-02T02:26:29+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在技术面试中，经常被问到“Cookie和Session的区别”，大家都知道一些，Session比Cookie安全，Session是存储在服务器端的，Cookie是存储在客户端的，然而如果让你更详细地说明，恐怕就不怎么清楚了。</p>
<p>本文分别对Cookie与Session做一个介绍和总结，并分别对两个知识点进行对比分析，让大家对Cookie和Session有更深入的了解。</p>
<h2 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP"></a>什么是HTTP</h2><p>首先要先介绍什么是HTTP</p>
<p><strong>HTTP</strong>:超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p>
<p>HTTP 是无状态协议，说明它不能以状态来区分和管理请求和响应。也就是说，服务器单从网络连接上无从知道客户身份。</p>
<p>可是怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621eec70c0418a2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1.Cookie"></a>1.Cookie</h2><h3 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h3><p>Cookie翻译过来是‘ 小甜饼’，Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，实际上Cookie是服务器在<strong>本地机器</strong>上存储的一小段文本，并随着每次请求发送到服务器。</p>
<p><strong>Cookie技术通过请求和响应报文中写入Cookie信息来控制客户端的状态。</strong></p>
<p>Cookie会根据响应报文里的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下客户端再向服务端发起请求时，客户端会自动在请求报文中加入Cookie值之后发送出去.</p>
<p>之后服务端发现客户端发送过来的Cookie后，会检查是那个客户端发送过来的请求，然后对服务器上的记录，最后得到了之前的状态信息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621f0b5f29d7f7c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>客户端保存了Cookie之后的发起请求</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621f13fade59484?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621f407b4b82236?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>上图很清晰地展示了发生Cookie 交互的情景，HTTP 请求报文和响应报文的内容如图所示。</p>
<p>第一可以很明显的可出首部字段内没有Cookie的相关信息，其次也能看到set-Cookie里的信息，这就是服务器端生撑的Cookei信息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621f4051a540bbb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>看之后请求，请求报文里都自动发送Cookie信息了。</p>
<h3 id="set-Cookie的字段的属性"><a href="#set-Cookie的字段的属性" class="headerlink" title="set-Cookie的字段的属性"></a>set-Cookie的字段的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: logcookie&#x3D;3qjj; expires&#x3D;Wed, 13-Mar-2019 12:08:53 GMT; Max-Age&#x3D;31536000; path&#x3D;&#x2F;;</span><br><span class="line"> domain&#x3D;fafa.com;secure; HttpOnly;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>



<p>以上面的set-cookie的例子，说一下set-cookie的属性</p>
<p>1.<code>logcookie=3qjj</code> 赋予Cookie的名称和值，logcookie是名字 ，3qjj是值</p>
<p>2.expires 是设置cookie有效期。当省略expires属性时，Cookie仅在关闭浏览器之前有效。可以通过覆盖已过期的Cookie，设置这个Cookie的过期时间是过去的时间，实现对客户端Cookie 的实质性删除操作。</p>
<p>3.path 是限制指定Cookie 的发送范围的文件目录。不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱有期待。</p>
<p>4.domain 通过domain属性指定的域名可以做到与结尾匹配一致。比如，指定domain是fafa.com，除了fafa.com那么<a href="http://www.fafa.com等都可以发送Cookie。" target="_blank" rel="noopener">www.fafa.com等都可以发送Cookie。</a></p>
<p>5.secure 设置web页面只有在HTTPS安全连接时，才可以发送Cookie。HHTP则不可以进行回收。</p>
<p>6.HttpOnly 它使JavaScript 脚本无法获得Cookie，通过上述设置，通常从Web 页面内还可以对Cookie 进行读取操作。但使用JavaScript 的document.cookie 就无法读取附加HttpOnly 属性后的Cookie 的内容了</p>
<h2 id="2-Session管理和Cookie应用"><a href="#2-Session管理和Cookie应用" class="headerlink" title="2.Session管理和Cookie应用"></a>2.Session管理和Cookie应用</h2><h3 id="什么是Session"><a href="#什么是Session" class="headerlink" title="什么是Session"></a>什么是Session</h3><p>上面我讲到服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用。</p>
<p> PHP中的Session在默认情况下是使用客户端的Cookie来保存Session ID的，所以当客户端的cookie出现问题的时候就会影响Session了。必须注意的是：Session不一定必须依赖Cookie，这也是Session相比Cookie的高明之处。当客户端的Cookie被禁用或出现问题时，PHP会自动把Session ID附着在URL中，这样再通过Session ID就能跨页使用Session变量了。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621f6d2880ac3ab?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img">1.客户端把信息放入报文的实体部分，通常是以POST 方法把请求发送给服务器。</p>
<p>2.服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的信息进行验证，然后把用户的认证状态与Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段Set-Cookie 内写入Session ID（如PHPSESSID=l128ogl…）。你可以把Session ID 想象成一种用以区分不同用户的唯一Id。</p>
<p>步骤三：客户端接收到从服务器端发来的Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID 也随之发送到服务器。服务器端可通过验证接收到的Session ID 验证状态。</p>
<h2 id="3-Cookie与Session的区别"><a href="#3-Cookie与Session的区别" class="headerlink" title="3.Cookie与Session的区别"></a>3.Cookie与Session的区别</h2><ol>
<li>cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的；</li>
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；</li>
<li>单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；</li>
</ol>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/6844903575684907016" target="_blank" rel="noopener">Cookie 和 Session 关系和区别</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/01/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20RESTful%20%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/01/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20RESTful%20%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/" class="post-title-link" itemprop="url">如何理解 RESTful 的幂等性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-02 02:16:03 / 修改时间：10:23:45" itemprop="dateCreated datePublished" datetime="2020-08-02T02:16:03+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个HTTP方法是<strong>幂等</strong>的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener"><code>GET</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD" target="_blank" rel="noopener"><code>HEAD</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/PUT" target="_blank" rel="noopener"><code>PUT</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/DELETE" target="_blank" rel="noopener"><code>DELETE</code></a> 等方法都是<strong>幂等</strong>的，而 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener"><code>POST</code></a> 方法不是。所有的 <a href="https://developer.mozilla.org/en-US/docs/Glossary/safe" target="_blank" rel="noopener">safe</a> 方法(指不修改资源的 HTTP 方法)也都是幂等的。</p>
<p>幂等性只与后端服务器的实际状态有关，而每一次请求接收到的状态码不一定相同。例如，第一次调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/DELETE" target="_blank" rel="noopener"><code>DELETE</code></a> 方法有可能返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200" target="_blank" rel="noopener"><code>200</code></a>，但是后续的请求可能会返回<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/404" target="_blank" rel="noopener"><code>404</code></a>。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/DELETE" target="_blank" rel="noopener"><code>DELETE</code></a> 的言外之意是，开发者<strong>不应该使用<code>DELETE</code>方法实现具有删除最后条目功能的 RESTful API</strong>。</p>
<p>需要注意的是，服务器不一定会确保请求方法的幂等性，有些应用可能会错误地打破幂等性约束。</p>
<p><code>GET /pageX HTTP/1.1</code>是幂等的。连续调用多次，客户端接收到的结果都是一样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /pageX HTTP/1.1   </span><br><span class="line">GET /pageX HTTP/1.1   </span><br><span class="line">GET /pageX HTTP/1.1   </span><br><span class="line">GET /pageX HTTP/1.1</span><br></pre></td></tr></table></figure>

<p><code>POST /add_row HTTP/1.1</code>不是幂等的。如果调用多次，就会增加多行记录：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /add_row HTTP/1.1</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 2nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 3rd row</span><br></pre></td></tr></table></figure>

<p><code>DELETE /idX/delete HTTP/1.1</code>是幂等的，即便是不同请求之间接收到的状态码不一样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</span><br></pre></td></tr></table></figure>

<h2 id="安全方法"><a href="#安全方法" class="headerlink" title="安全方法"></a>安全方法</h2><p>安全方法是指不修改资源的 HTTP 方法。譬如，当使用 GET 或者 HEAD 作为资源 URL，都必须不去改变资源。然而，这并不全准确。意思是：它不改变资源的 表示形式。对于安全方法，它仍然可能改变服务器上的内容或资源，但这必须不导致不同的表现形式。</p>
<p>这表示下述是不对的，因为它实际上将删除博客文章：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;blog&#x2F;1234&#x2F;delete HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<p>安全方法是那些可以被缓存、对资源无损预加载的方法。</p>
<h2 id="幂等性分析"><a href="#幂等性分析" class="headerlink" title="幂等性分析"></a>幂等性分析</h2><p>HTTP幂等方法，是指无论调用多少次都不会有不同结果的 HTTP 方法。不管你调用一次，还是调用一百次，一千次，结果都是相同的。</p>
<p>还是以之前的博文的例子为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET     &#x2F;tickets       # 获取ticket列表</span><br><span class="line">GET     &#x2F;tickets&#x2F;12    # 查看某个具体的ticket</span><br><span class="line">POST    &#x2F;tickets       # 新建一个ticket</span><br><span class="line">PUT     &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br><span class="line">PATCH   &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br><span class="line">DELETE  &#x2F;tickets&#x2F;12    # 删除ticekt 12</span><br></pre></td></tr></table></figure>

<h3 id="HTTP-GET方法"><a href="#HTTP-GET方法" class="headerlink" title="HTTP GET方法"></a>HTTP GET方法</h3><p>HTTP GET方法，用于获取资源，不管调用多少次接口，结果都不会改变，所以是幂等的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET     &#x2F;tickets       # 获取ticket列表</span><br><span class="line">GET     &#x2F;tickets&#x2F;12    # 查看某个具体的ticket</span><br></pre></td></tr></table></figure>

<p>只是查询数据，不会影响到资源的变化，因此我们认为它幂等。</p>
<p>值得注意，幂等性指的是作用于结果而非资源本身。怎么理解呢？例如，这个HTTP GET方法可能会每次得到不同的返回内容，但并不影响资源。</p>
<p>可能你会问有这种情况么？当然有咯。例如，我们有一个接口获取当前时间，我们就应该设计成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET     &#x2F;service_time # 获取服务器当前时间</span><br></pre></td></tr></table></figure>

<p>它本身不会对资源本身产生影响，因此满足幂等性。</p>
<h3 id="HTTP-POST方法"><a href="#HTTP-POST方法" class="headerlink" title="HTTP POST方法"></a>HTTP POST方法</h3><p>HTTP POST方法是一个非幂等方法，因为调用多次，都将产生新的资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST    &#x2F;tickets       # 新建一个ticket</span><br></pre></td></tr></table></figure>

<p>因为它会对资源本身产生影响，每次调用都会有新的资源产生，因此不满足幂等性。</p>
<h3 id="HTTP-PUT方法"><a href="#HTTP-PUT方法" class="headerlink" title="HTTP PUT方法"></a>HTTP PUT方法</h3><p>HTTP PUT方法是不是幂等的呢？我们来看下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT     &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br></pre></td></tr></table></figure>

<p>因为它直接把实体部分的数据替换到服务器的资源，我们多次调用它，只会产生一次影响，但是有相同结果的 HTTP 方法，所以满足幂等性。</p>
<h3 id="HTTP-PATCH方法"><a href="#HTTP-PATCH方法" class="headerlink" title="HTTP PATCH方法"></a>HTTP PATCH方法</h3><p>HTTP PATCH方法是非幂等的。HTTP POST方法和HTTP PUT方法可能比较好理解，但是HTTP PATCH方法只是更新部分资源，怎么是非幂等的呢?</p>
<p>因为，PATCH提供的实体则需要根据程序或其它协议的定义，解析后在服务器上执行，以此来修改服务器上的资源。换句话说，PATCH请求是会执行某个程序的，如果重复提交，程序可能执行多次，对服务器上的资源就可能造成额外的影响，这就可以解释它为什么是非幂等的了。</p>
<p>可能你还不能理解这点。我们举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATCH   &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br></pre></td></tr></table></figure>

<p>此时，我们服务端对方法的处理是，当调用一次方法，更新部分字段，将这条ticket记录的操作记录加一，这次，每次调用的资源是不是变了呢，所以它是有可能是非幂等的操作。</p>
<h3 id="HTTP-DELETE方法"><a href="#HTTP-DELETE方法" class="headerlink" title="HTTP DELETE方法"></a>HTTP DELETE方法</h3><p>HTTP DELETE方法用于删除资源，会将资源删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE  &#x2F;tickets&#x2F;12    # 删除ticekt 12</span><br></pre></td></tr></table></figure>

<p>调用一次和多次对资源产生影响是相同的，所以也满足幂等性。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="部分-HTTP-方法概览"><a href="#部分-HTTP-方法概览" class="headerlink" title="(部分) HTTP 方法概览"></a>(部分) HTTP 方法概览</h3><table>
<thead>
<tr>
<th align="left">HTTP Method</th>
<th align="left">Idempotent</th>
<th align="left">Safe</th>
</tr>
</thead>
<tbody><tr>
<td align="left">OPTIONS</td>
<td align="left">yes</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">GET</td>
<td align="left">yes</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">HEAD</td>
<td align="left">yes</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">PUT</td>
<td align="left">yes</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">POST</td>
<td align="left">no</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="left">yes</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">PATCH</td>
<td align="left">no</td>
<td align="left">no</td>
</tr>
</tbody></table>
<h2 id="如何设计符合幂等性的高质量RESTful-API"><a href="#如何设计符合幂等性的高质量RESTful-API" class="headerlink" title="如何设计符合幂等性的高质量RESTful API"></a>如何设计符合幂等性的高质量RESTful API</h2><h3 id="HTTP-GET方法-vs-HTTP-POST方法"><a href="#HTTP-GET方法-vs-HTTP-POST方法" class="headerlink" title="HTTP GET方法 vs HTTP POST方法"></a>HTTP GET方法 vs HTTP POST方法</h3><p>也许，你会想起一个面试题。HTTP请求的GET与POST方式有什么区别？你可能会回答到：GET方式通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。但是，我们现在从RESTful的资源角度来看待问题，HTTP GET方法是幂等的，所以它适合作为查询操作，HTTP POST方法是非幂等的，所以用来表示新增操作。</p>
<p>但是，也有例外，我们有的时候可能需要把查询方法改造成HTTP POST方法。比如，超长（1k）的GET URL使用POST方法来替代，因为GET受到URL长度的限制。虽然，它不符合幂等性，但是它是一种折中的方案。</p>
<h3 id="HTTP-POST方法-vs-HTTP-PUT方法"><a href="#HTTP-POST方法-vs-HTTP-PUT方法" class="headerlink" title="HTTP POST方法 vs HTTP PUT方法"></a>HTTP POST方法 vs HTTP PUT方法</h3><p>对于HTTP POST方法和TTP PUT方法，我们一般的理解是POST表示创建资源，PUT表示更新资源。当然，这个是正确的理解。</p>
<p>但是，实际上，两个方法都用于创建资源，更为本质的差别是在幂等性。HTTP POST方法是非幂等，所以用来表示创建资源，HTTP PUT方法是幂等的，因此表示更新资源更加贴切。</p>
<h3 id="HTTP-PUT方法-vs-HTTP-PATCH方法"><a href="#HTTP-PUT方法-vs-HTTP-PATCH方法" class="headerlink" title="HTTP PUT方法 vs HTTP PATCH方法"></a>HTTP PUT方法 vs HTTP PATCH方法</h3><p>此时，你看会有另外一个问题。HTTP PUT方法和HTTP PATCH方法，都是用来表述更新资源，它们之间有什么区别呢？我们一般的理解是PUT表示更新全部资源，PATCH表示更新部分资源。首先，这个是我们遵守的第一准则。根据上面的描述，PATCH方法是非幂等的，因此我们在设计我们服务端的RESTful API的时候，也需要考虑。如果，我们想要明确的告诉调用者我们的资源是幂等的，我的设计更倾向于使用HTTP PUT方法。</p>
<hr>
<p>本文整理自</p>
<p><a href="">如何理解 RESTful 的幂等性</a></p>
<p>[RESTful 手册](<a href="https://sofish.github.io/restcookbook/http" target="_blank" rel="noopener">https://sofish.github.io/restcookbook/http</a> methods/idempotency/)</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/幂等" target="_blank" rel="noopener">幂等</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%9A%84KMP%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/21/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%9A%84KMP%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">字符串匹配的KMP算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-21 13:39:55 / 修改时间：21:43:31" itemprop="dateCreated datePublished" datetime="2020-07-21T13:39:55+08:00">2020-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">程序设计</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="http://en.wikipedia.org/wiki/String_searching_algorithm" target="_blank" rel="noopener">字符串匹配</a>是计算机的基本任务之一。</p>
<p>举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”？</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050101.jpg" alt="img"></p>
<p>许多算法可以完成这个任务，<a href="http://en.wikipedia.org/wiki/Knuth–Morris–Pratt_algorithm" target="_blank" rel="noopener">Knuth-Morris-Pratt算法</a>（简称KMP）是最常用的之一。它以三个发明者命名，起头的那个K就是著名科学家Donald Knuth。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050102.jpg" alt="img"></p>
<p>这种算法不太容易理解，网上有很多<a href="http://www.google.com/search?q=Knuth-Morris-Pratt+algorithm" target="_blank" rel="noopener">解释</a>，但读起来都很费劲。直到读到<a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="noopener">Jake Boxer</a>的文章，我才真正理解这种算法。下面，我用自己的语言，试图写一篇比较好懂的KMP算法解释。</p>
<p>1.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050103.png" alt="img"></p>
<p>首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。</p>
<p>2.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050104.png" alt="img"></p>
<p>因为B与A不匹配，搜索词再往后移。</p>
<p>3.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050105.png" alt="img"></p>
<p>就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。</p>
<p>4.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050106.png" alt="img"></p>
<p>接着比较字符串和搜索词的下一个字符，还是相同。</p>
<p>5.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png" alt="img"></p>
<p>直到字符串有一个字符，与搜索词对应的字符不相同为止。</p>
<p>6.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050108.png" alt="img"></p>
<p>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p>
<p>7.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png" alt="img"></p>
<p>一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。</p>
<p>8.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png" alt="img"></p>
<p>怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。</p>
<p>9.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png" alt="img"></p>
<p>已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：</p>
<blockquote>
<p>　　移动位数 = 已匹配的字符数 - 对应的部分匹配值</p>
</blockquote>
<p>因为 6 - 2 等于4，所以将搜索词向后移动4位。</p>
<p>10.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050110.png" alt="img"></p>
<p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。</p>
<p>11.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050111.png" alt="img"></p>
<p>因为空格与A不匹配，继续后移一位。</p>
<p>12.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050112.png" alt="img"></p>
<p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。</p>
<p>13.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050113.png" alt="img"></p>
<p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。</p>
<p>14.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050114.png" alt="img"></p>
<p>下面介绍《部分匹配表》是如何产生的。</p>
<p>首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p>
<p>15.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png" alt="img"></p>
<p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，</p>
<blockquote>
<p>　　－　“A”的前缀和后缀都为空集，共有元素的长度为0；</p>
<p>　　－　“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</p>
<p>　　－　“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</p>
<p>　　－　“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</p>
<p>　　－　“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</p>
<p>　　－　“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</p>
<p>　　－　“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</p>
</blockquote>
<p>16.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050112.png" alt="img"></p>
<p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p>
<hr>
<p>本文整理自</p>
<p><a href="[http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html](http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html)">字符串匹配的KMP算法</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EricMa"
      src="/images/eric.png">
  <p class="site-author-name" itemprop="name">EricMa</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">225</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Eric-Ma-C" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Eric-Ma-C" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chaoma@zju.edu.cn" title="E-Mail → mailto:chaoma@zju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EricMa</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">848k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
