<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Eric&#39;s Blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Eric&#39;s Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="EricMa">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Eric's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Eric's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Better Code, Better Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/22/ConcurrentHashMap%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/22/ConcurrentHashMap%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">ConcurrentHashMap简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-22 09:06:06 / 修改时间：17:09:09" itemprop="dateCreated datePublished" datetime="2020-06-22T09:06:06+08:00">2020-06-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在开发中，我们经常使用 HashMap 容器来存储 K-V 键值对，但是在并发多线程的情况下，HashMap 容器又是不安全的，<strong>因为在 put 元素的时候，如果触发扩容操作，也就是 rehash ，就会将原数组的内容重新 hash 到新的扩容数组中，但是在扩容这个过程中，其他线程也在进行 put 操作，如果这两个元素 hash 值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的</strong>。</p>
<p>那有没有安全的 Map 容器呢？有的，目前 JDK 中提供了三种安全的 Map 容器：</p>
<ul>
<li>HashTable</li>
<li>Collections.SynchronizedMap（同步包装器提供的方法）</li>
<li>ConcurrentHashMap</li>
</ul>
<p>先来看看前两种容器，它们都是利用非常粗粒度的同步方式，在高并发情况下，性能比较低下。Hashtable 是在 put、get、size 等各种方法加上“synchronized” 锁来保证安全，这就导致了所有并发操作都要竞争同一把锁，一个线程在进行同步操作时，其他线程只能等待，大大降低了并发操作的效率。</p>
<p>再来看看 Collections 提供的同步包装器 SynchronizedMap ，我们可以先来看看 SynchronizedMap 的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1978198479659022715L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     <span class="comment">// Backing Map</span></span><br><span class="line">        <span class="keyword">final</span> Object      mutex;        <span class="comment">// Object on which to synchronize</span></span><br><span class="line"></span><br><span class="line">        SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">            <span class="keyword">this</span>.m = Objects.requireNonNull(m);</span><br><span class="line">            mutex = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123;</span><br><span class="line">            <span class="keyword">this</span>.m = m;</span><br><span class="line">            <span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.size();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.isEmpty();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.containsKey(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.containsValue(value);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.get(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.remove(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;m.putAll(map);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;m.clear();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从源码中，我们可以看出 SynchronizedMap 虽然方法没有加 synchronized 锁，但是利用了“this”作为互斥的 mutex，所以在严格意义上 SynchronizedMap 跟 HashTable 一样，并没有实际的改进。</p>
<p>第三个 ConcurrentHashMap 也是这篇文章的主角，它相对前两种安全的 Map 容器来说，在设计和思想上有较大的变化，也极大的提高了 Map 的并发效率。就 ConcurrentHashMap 容器本身的实现来说，版本之间就会产生较大的差异，典型的就是 JDK1.7 和 JDK1.8 这两个版本，可以说是发生了翻天覆地的变化，在本文中也会介绍这两个版本的 ConcurrentHashMap 实现，主要的重点放在 JDK 1.8 版本上，我个人觉得 JDK 1.7 已经成为了过去式，没必要深入研究。</p>
<h2 id="ConcurrentHashMap-在-JDK-1-7-中的实现"><a href="#ConcurrentHashMap-在-JDK-1-7-中的实现" class="headerlink" title="ConcurrentHashMap 在 JDK 1.7 中的实现"></a>ConcurrentHashMap 在 JDK 1.7 中的实现</h2><p>在 JDK 1.7 版本及之前的版本中，ConcurrentHashMap 为了解决 HashTable 会锁住整个 hash 表的问题，提出了<strong>分段锁的解决方案</strong>，分段锁就是将一个大的 hash 表分解成若干份小的 hash 表，需要加锁时就针对小的 hash 表进行加锁，从而来提升 hash 表的性能。JDK1.7 中的 ConcurrentHashMap 引入了 Segment 对象，将整个 hash 表分解成一个一个的 Segment 对象，每个 Segment 对象呢可以看作是一个细粒度的 HashMap。</p>
<p><strong>Segment 对象继承了 ReentrantLock 类，因为 Segment 对象它就变成了一把锁，这样就可以保证数据的安全。</strong> 在 Segment 对象中通过 HashEntry 数组来维护其内部的 hash 表。每个 HashEntry 就代表了 map 中的一个 K-V，如果发生 hash 冲突时，在该位置就会形成链表。</p>
<p>JDK1.7 中，ConcurrentHashMap 的整体结构可以描述为下图的样子：</p>
<p><img src="https://segmentfault.com/img/remote/1460000021237441" alt="ConcurrentHashMap 1.7 存储结构"></p>
<p>我们对 ConcurrentHashMap 最关心的地方莫过于如何解决 HashMap put 时候扩容引起的不安全问题？一起来看看 JDK1.7 中 ConcurrentHashMap 是如何解决这个问题的，我们先从 put 方法开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       Segment&lt;K,V&gt; s;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="comment">// 二次哈希，以保证数据的分散性，避免哈希冲突</span></span><br><span class="line">       <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">       <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">       <span class="comment">// Unsafe 调用方式，直接获取相应的 Segment</span></span><br><span class="line">       <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">           s = ensureSegment(j);</span><br><span class="line">       <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在 put 方法中，首先是通过二次哈希减小哈希冲突的可能行，根据 hash 值以 Unsafe 调用方式，直接获取相应的 Segment，最终将数据添加到容器中是由 segment对象的 put 方法来完成。Segment对象的 put 方法源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无论如何，确保获取锁 scanAndLockForPut会去查找是否有key相同Node</span></span><br><span class="line">    ConcurrentHashMap.HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">            scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ConcurrentHashMap.HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        ConcurrentHashMap.HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (ConcurrentHashMap.HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="comment">// 更新已存在的key</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                        (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> ConcurrentHashMap.HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Segment 对象本身就是一把锁，所以在新增数据的时候，相应的 Segment对象块是被锁住的，其他线程并不能操作这个 Segment 对象，这样就保证了数据的安全性，<strong>在扩容时也是这样的，在 JDK1.7 中的 ConcurrentHashMap扩容只是针对 Segment 对象中的 HashEntry 数组进行扩容，还是因为 Segment 对象是一把锁，所以在 rehash 的过程中，其他线程无法对 segment 的 hash 表做操作，这就解决了 HashMap 中 put 数据引起的闭环问题</strong>。</p>
<p>关于 JDK1.7 中的 ConcurrentHashMap 就聊这么多，我们只需要直到在 JDK1.7 中 ConcurrentHashMap 采用<strong>分段锁</strong>的方式来解决 HashMap 不安全问题。</p>
<h2 id="ConcurrentHashMap-在-JDK1-8-中的实现"><a href="#ConcurrentHashMap-在-JDK1-8-中的实现" class="headerlink" title="ConcurrentHashMap 在 JDK1.8 中的实现"></a>ConcurrentHashMap 在 JDK1.8 中的实现</h2><p>在 JDK1.8 中 ConcurrentHashMap 又发生了翻天覆地的变化，从实现的代码量上就可以看出来，在 1.7 中不到 2000行代码，而在 1.8 中已经 6000多行代码了 。废话不多说，我们来看看有那些变化。</p>
<p>先从容器安全说起，<strong>在容器安全上，1.8 中的 ConcurrentHashMap 放弃了 JDK1.7 中的分段技术，而是采用了 CAS 机制 + synchronized 来保证并发安全性，但是在 ConcurrentHashMap 实现里保留了 Segment 定义，这仅仅是为了保证序列化时的兼容性而已，并没有任何结构上的用处。</strong> 这里插播个 CAS 机制的知识点：</p>
<h5 id="CAS-机制"><a href="#CAS-机制" class="headerlink" title="CAS 机制"></a>CAS 机制</h5><p>CAS 典型的应用莫过于 AtomicInteger 了，CAS 属于原子操作的一种，能够保证一次读写操作是原子的。CAS 通过将内存中的值与期望值进行比较，只有在两者相等时才会对内存中的值进行修改，CAS 是在保证性能的同时提供并发场景下的线程安全性。在 Java 中 CAS 实现位于 sun.misc.Unsafe 类中，该类中定义了大量的 native 方法，CAS 的实现有以下几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object expected, Object x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> expected, <span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们只能看到定义，并不能看到具体的实现，具体的实现依赖于操作系统，我们就不去管这些了，简单了解方法里面的参数是啥意思就行了：</p>
<ul>
<li>o ：目标操作对象</li>
<li>offset ：目标操作数内存偏移地址</li>
<li>expected ：期望值</li>
<li>x ：更新值</li>
</ul>
<p>CAS 机制虽然无需加锁、安全且高效，但也存在一些缺点，概括如下：</p>
<ul>
<li>循环检查的时间可能较长，不过可以限制循环检查的次数</li>
<li>只能对一个共享变量执行原子操作</li>
<li>存在 ABA 问题（ABA 问题是指在 CAS 两次检查操作期间，目标变量的值由 A 变为 B，又变回 A，但是 CAS 看不到这中间的变换，对它来说目标变量的值并没有发生变化，一直是 A，所以 CAS 操作会继续更新目标变量的值。）</li>
</ul>
<p>在存储结构上，<strong>JDK1.8 中 ConcurrentHashMap 放弃了 HashEntry 结构而是采用了跟 HashMap 结构非常相似，采用 Node 数组加链表（链表长度大于8时转成红黑树）的形式</strong>，Node 节点设计如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">        ...省略...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>跟 HashMap 一样 Key 字段被 final 修饰，说明在生命周期内，key 是不可变的， val 字段被 volatile 修饰了，这就保证了 val 字段的可见性。</p>
<p>JDK1.8 中的 ConcurrentHashMap 结构如下图所示：</p>
<p><img src="https://segmentfault.com/img/remote/1460000021237442" alt="JDK1.8 ConcurrentHashMap 结构图"></p>
<p>在这里我提一下 ConcurrentHashMap 默认构造函数，我觉得这个地方比较有意思，ConcurrentHashMap 的默认构造函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现没这个构造函数啥事没干，为啥要这样设计？这样做的好处是实现了懒加载（lazy-load 形式），有效避免了初始化的开销，这也是 JDK1.7 中ConcurrentHashMap 被很多人抱怨的地方。</p>
<p>结构上的变化就聊上面的两点，跟上面一样，我们还是来看看我们关心的问题，如何解决 HashMap 扩容时不安全的问题，带着这个问题来阅读 ConcurrentHashMap 的源代码，关于 ConcurrentHashMap 的源代码，在本文中主要聊新增（putVal ）和扩容（transfer ）这两个方法，其他方法就不在一一介绍了。</p>
<h3 id="putVal-方法"><a href="#putVal-方法" class="headerlink" title="putVal 方法"></a>putVal 方法</h3><p>ConcurrentHashMap 新增元素并不是直接调用 putVal 方法，而是使用 put 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 put 方法调用了 putVal 方法，换一句话来说就是 putVal 是具体的新增方法，是 put 方法的具体实现，在 putVal 方法源码加上了注释，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 key 为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 两次 hash ，减少碰撞次数</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 记录链表节点得个数</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 无条件得循环遍历整个 node 数组，直到成功</span></span><br><span class="line">    <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        ConcurrentHashMap.Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// lazy-load 懒加载的方式，如果当前 tab 容器为空，则初始化 tab 容器</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过Unsafe.getObjectVolatile()的方式获取数组对应index上的元素，如果元素为空，则直接无所插入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//// 利用CAS去进行无锁线程安全操作</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                    <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 fh == -1 ，说明正在扩容，那么该线程也去帮扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 协作扩容操作</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果上面都不满足，说明存在 hash 冲突，则使用 synchronized 加锁。锁住链表或者红黑树的头结点，来保证操作安全</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;<span class="comment">// 表示该节点是链表</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历该节点上的链表</span></span><br><span class="line">                        <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//这里涉及到相同的key进行put就会覆盖原先的value</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                            (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ConcurrentHashMap.Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;<span class="comment">//插入链表尾部</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                        value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ConcurrentHashMap.TreeBin) &#123;<span class="comment">// 该节点是红黑树节点</span></span><br><span class="line">                        ConcurrentHashMap.Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((ConcurrentHashMap.TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入完之后，判断链表长度是否大于8，大于8就需要转换为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">// 如果存在相同的key ，返回原来的值</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计 size，并且检测是否需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在源码中有比较详细的注释，如果你想了解详细的实现，可以逐行读源码，在这里我们来对 putVal 方法做一个总结，putVal 方法主要做了以下几件事：</p>
<ul>
<li><strong>第一步</strong>、在 ConcurrentHashMap 中不允许 key val 字段为空，所以第一步先校验key value 值，key、val 两个字段都不能是 null 才继续往下走，否则直接返回一个 NullPointerException 错误，这点跟 HashMap 有区别，HashMap 是可以允许为空的。</li>
<li><strong>第二步</strong>、判断容器是否初始化，如果容器没有初始化，则调用 initTable 方法初始化，initTable 方法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 负数表示正在初始化或扩容，等待</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 自旋等待</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// 执行 CAS 操作，期望将 sizeCtl 设置为 -1，-1 是正在初始化的标识</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// CAS 抢到了锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 对 table 进行初始化，初始化长度为指定值，或者默认值 16</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// sc 在初始化的时候用户可能会自定义，如果没有自定义，则是默认的</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">// 创建数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 指定下次扩容的大小，相当于 0.75 × n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Table 本质上就是一个 Node 数组，其初始化过程也就是对 Node 数组的初始化过程，方法中使用了 CAS 策略执行初始化操作。初始化流程为：</p>
<p>1、判断 sizeCtl 值是否小于 0，如果小于 0 则表示 ConcurrentHashMap 正在执行初始化操作，所以需要先等待一会，如果其它线程初始化失败还可以顶替上去<br>2、如果 sizeCtl 值大于等于 0，则基于 CAS 策略抢占标记 sizeCtl 为 -1，表示 ConcurrentHashMap 正在执行初始化，然后构造 table，并更新 sizeCtl 的值</p>
<ul>
<li><strong>第三步</strong>、根据双哈希之后的 hash 值找到数组对应的下标位置，如果该位置未存放节点，也就是说不存在 hash 冲突，则使用 CAS 无锁的方式将数据添加到容器中，并且结束循环。</li>
<li><strong>第四步</strong>、如果并未满足第三步，则会判断容器是否正在被其他线程进行扩容操作，如果正在被其他线程扩容，则放弃添加操作，加入到扩容大军中（ConcurrentHashMap 扩容操作采用的是多线程的方式，后面我们会讲到），扩容时并未跳出死循环，<strong>这一点就保证了容器在扩容时并不会有其他线程进行数据添加操作，这也保证了容器的安全性</strong>。</li>
<li><strong>第五步</strong>、如果 hash 冲突，则进行链表操作或者红黑树操作（如果链表树超过8，则修改链表为红黑树），<strong>在进行链表或者红黑树操作时，会使用 synchronized 锁把头节点被锁住了，保证了同时只有一个线程修改链表，防止出现链表成环</strong>。</li>
<li><strong>第六步</strong>、进行 addCount(1L, binCount) 操作，该操作会更新 size 大小，判断是否需要扩容，addCount 方法源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// X传入的是1，check 传入的是 putVal 方法里的 binCount，没有hash冲突的话为0，冲突就会大于1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    ConcurrentHashMap.CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">// 统计ConcurrentHashMap里面节点个数</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">            !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        ConcurrentHashMap.CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                        U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check就是binCount，binCount 最小都为0，所以这个条件一定会为true</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ConcurrentHashMap.Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 这儿是自旋，需同时满足下面的条件</span></span><br><span class="line">        <span class="comment">// 1. 第一个条件是map.size 大于 sizeCtl，也就是说需要扩容</span></span><br><span class="line">        <span class="comment">// 2. 第二个条件是`table`不为null</span></span><br><span class="line">        <span class="comment">// 3. 第三个条件是`table`的长度不能超过最大容量</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">// 该判断表示已经有线程在进行扩容操作了</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果可以帮助扩容，那么将 sc 加 1. 表示多了一个线程在帮助扩容</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不在扩容，将 sc 更新：标识符左移 16 位 然后 + 2. 也就是变成一个负数。高 16 位是标识符，低 16 位初始是 2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                    (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>addCount 方法做了两个工作：<br>1、对 map 的 size 加一<br>2、检查是否需要扩容，或者是否正在扩容。如果需要扩容，就调用扩容方法，如果正在扩容，就帮助其扩容。</p>
<h3 id="扩容-transfer-方法"><a href="#扩容-transfer-方法" class="headerlink" title="扩容 transfer 方法"></a>扩容 transfer 方法</h3><p>扩容 transfer 方法是一个非常牛逼的方法，在看具体的 transfer 源码之前，<strong>我们先来了解一下什么时候会触发扩容操作，不出意外的话，以下两种情况下可能触发扩容操作</strong>：</p>
<ul>
<li><strong>调用 put 方法新增元素之后，会调用 addCount 方法来更新 size 大小，并检查是否需要进行扩容，当数组元素个数达到阈值时，会触发transfer方法</strong></li>
<li><strong>触发了 tryPresize 操作， tryPresize 操作会触发扩容操作</strong>，有两种情况会触发 tryPresize 操作：<ul>
<li>第一种情况：当某节点的链表元素个数达到阈值 8 时，这时候需要将链表转成红黑树，在结构转换之前会，会先判断数组长度 n 是否小于阈值MIN_TREEIFY_CAPACITY，默认是64，如果小于则会调用tryPresize方法把数组长度扩大到原来的两倍，并触发transfer方法，重新调整节点的位置。</li>
<li>第二种情况：在 putAll 操作时会先触发 tryPresize 操作。</li>
</ul>
</li>
</ul>
<p>tryPresize 方法源码如下：</p>
<p><img src="https://segmentfault.com/img/remote/1460000021237443" alt="tryPresize 方法源码"></p>
<p>好了，知道什么时候会触发扩容后，我们来看看 扩容 transfer 方法的源码，这也是一块硬骨头，非常难啃，希望我可以尽量的把它讲清楚，transfer 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(ConcurrentHashMap.Node&lt;K,V&gt;[] tab, ConcurrentHashMap.Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">// 多线程扩容，每核处理的量小于16，则强制赋值16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">// nextTab 为空，先实例化一个新的数组</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="comment">// 新数组的大小是原来的两倍</span></span><br><span class="line">            ConcurrentHashMap.Node&lt;K,V&gt;[] nt = (ConcurrentHashMap.Node&lt;K,V&gt;[])<span class="keyword">new</span> ConcurrentHashMap.Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新成员变量</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// 更新转移下标，就是 老的 tab 的 length</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bound ：该线程此次可以处理的区间的最小下标，超过这个下标，就需要重新领取区间或者结束扩容</span></span><br><span class="line">    <span class="comment">// advance： 该参数</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">// 创建一个 fwd 节点，用于占位。当别的线程发现这个槽位中是 fwd 类型的节点，则跳过这个节点。</span></span><br><span class="line">    ConcurrentHashMap.ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ConcurrentHashMap.ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// advance 变量指的是是否继续递减转移下一个桶，如果为 true，表示可以继续向后推进，反之，说明还没有处理好当前桶，不能推进</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 完成状态，如果是 true，表示扩容结束</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">// 死循环,i 表示下标，bound 表示当前线程可以处理的当前桶区间最小下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        ConcurrentHashMap.Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                    (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                            nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                    nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">            <span class="comment">// 这儿多判断一次，是否为了防止可能出现的remove()操作</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 旧链表上该节点的数据，会被分成低位和高位，低位就是在新链表上的位置跟旧链表上一样，</span></span><br><span class="line">                    <span class="comment">// 高位就是在新链表的位置是旧链表位置加上旧链表的长度</span></span><br><span class="line">                    ConcurrentHashMap.Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        ConcurrentHashMap.Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="comment">// 该节点哈希值与旧链表长度与运算，结果为0，则在低位节点上，反之，在高位节点上</span></span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 在nextTable i + n 位置处插上链表</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 在table i 位置处插上ForwardingNode 表示该节点已经处理过了</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ConcurrentHashMap.TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 如果是TreeBin，则按照红黑树进行处理，处理逻辑与上面一致</span></span><br><span class="line">                        <span class="comment">// 红黑树的逻辑跟节点一模一样，最后也会分高位和低位</span></span><br><span class="line">                        ConcurrentHashMap.TreeBin&lt;K,V&gt; t = (ConcurrentHashMap.TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        ConcurrentHashMap.TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        ConcurrentHashMap.TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            ConcurrentHashMap.TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> ConcurrentHashMap.TreeNode&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果树的节点数小于等于 6，那么转成链表，反之，创建一个新的树</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> ConcurrentHashMap.TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> ConcurrentHashMap.TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想知道具体的实现细节，请逐行读源码，如果遇到不懂得，欢迎留言交流，跟 putVal 方法一样，我们同样来对 transfer 方法进行总结，transfer 大致做了以下几件事件：</p>
<ul>
<li><strong>第一步</strong>：计算出每个线程每次可以处理的个数，根据 Map 的长度，计算出每个线程（CPU）需要处理的桶（table数组的个数），默认每个线程每次处理 16 个桶，如果小于 16 个，则强制变成 16 个桶。</li>
<li><strong>第二步</strong>：对 nextTab 初始化，如果传入的新 table nextTab 为空，则对 nextTab 初始化，默认是原 table 的两倍</li>
<li><strong>第三步</strong>：引入 ForwardingNode、advance、finishing 变量来辅助扩容，ForwardingNode 表示该节点已经处理过，不需要在处理，advance 表示该线程是否可以下移到下一个桶（true：表示可以下移），finishing 表示是否结束扩容（true：结束扩容，false：未结束扩容） ，具体的逻辑就不说了</li>
<li><strong>第四步</strong>：跳过一些其他细节，直接到数据迁移这一块，<strong>在数据转移的过程中会加 synchronized 锁，锁住头节点，同步化操作，防止 putVal 的时候向链表插入数据</strong></li>
<li><strong>第五步</strong>：进行数据迁移，<strong>如果这个桶上的节点是链表或者红黑树，则会将节点数据分为低位和高位，计算的规则是通过该节点的 hash 值跟为扩容之前的 table 容器长度进行位运算（&amp;），如果结果为 0 ，则将数据放在新表的低位（当前 table 中为 第 i 个位置，在新表中还是第 i 个位置），结果不为 0 ，则放在新表的高位（当前 table 中为第 i 个位置，在新表中的位置为 i + 当前 table 容器的长度）</strong>。</li>
<li><strong>第六步</strong>：如果桶挂载的是红黑树，不仅需要分离出低位节点和高位节点，还需要判断低位和高位节点在新表以链表还是红黑树的形式存放。</li>
</ul>
<hr>
<p>本文整理自</p>
<p><a href="https://segmentfault.com/a/1190000021237438" target="_blank" rel="noopener">ConcurrentHashMap</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/21/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/21/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="post-title-link" itemprop="url">序列化与反序列化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-21 09:31:40 / 修改时间：17:42:47" itemprop="dateCreated datePublished" datetime="2020-06-21T09:31:40+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>序列化与反序列化是开发过程中不可或缺的一步，简单来说，序列化是将对象转换成<strong>字节流</strong>的过程，而反序列化的是将字节流恢复成对象的过程。两者的关系如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/23/168786827eb84b58?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>序列化与反序列化是一个标准（具体参考<a href="">XDR:外部数据表示标准 RFC 1014</a>），它是编程语言的一种共性，只是有些编程语言是内置的（如Java，PHP等），有些语言是通过第三方库来实现的（如C/C++）。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><strong>对象的持久化</strong>（将对象内容保存到数据库或文件中）</li>
<li><strong>远程数据传输</strong>（将对象发送给其他计算机系统）</li>
</ul>
<h3 id="为什么需要序列化与反序列化？"><a href="#为什么需要序列化与反序列化？" class="headerlink" title="为什么需要序列化与反序列化？"></a>为什么需要序列化与反序列化？</h3><p>序列化与序列化主要解决的是数据的一致性问题。简单来说，就是输入数据与输出数据是一样的。</p>
<p>对于数据的本地持久化，只需要将数据转换为字符串进行保存即可是实现，但对于远程的数据传输，<em>由于操作系统，硬件等差异，会出现内存大小端，内存对齐等问题</em>，导致接收端无法正确解析数据，为了解决这种问题，Sun Microsystems在20世纪80年代提出了XDR规范，于1995年正式成为IETF标准。</p>
<h3 id="Java中的序列化与反序列化"><a href="#Java中的序列化与反序列化" class="headerlink" title="Java中的序列化与反序列化"></a>Java中的序列化与反序列化</h3><p>Java语言内置了序列化和反序列化，通过Serializable接口实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> birthday;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="序列化兼容性"><a href="#序列化兼容性" class="headerlink" title="序列化兼容性"></a>序列化兼容性</h4><p>序列化的兼容性指的是对象的结构变化（如增删字段，修改字段，字段修饰符的改变等）对序列化的影响。为了能够识别对象结构的变化，Serializable使用serialVersionUID字段来标识对象的结构。默认情况下，它会根据对象的数据结构自动生成，结构发生变化后，它的值也会跟随变化。虚拟机在反序列化的时候会检查serialVersionUID的值，如果字节码中的serialVersionUID和要被转换的类型的serialVersionUID不一致，就无法进行正常的反序列化。</p>
<p>示例：将Account对象保存到文件中，然后在Account类中添加address字段，再从文件中读取之前保存的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将Account对象保存到文件中</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">oos.writeObject(account);</span><br><span class="line">oos.flush();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改Account对象的结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> birthday;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String address;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">this</span>.age = age;</span><br><span class="line">	    <span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取Account的内容</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">Account account2 = (Account)ois.readObject();</span><br></pre></td></tr></table></figure>

<p>由于在保存Account对象后修改了Account的结构，会导致serialVersionUID的值发生变化，在读文件（反序列化）的时候就会出错。所以为了更好的兼容性，在序列化的时候，<strong>最好将serialVersionUID的值设置为固定的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> birthday;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="序列化的存储规则"><a href="#序列化的存储规则" class="headerlink" title="序列化的存储规则"></a>序列化的存储规则</h4><p>Java中的序列化在将对象持久化（序列化）的时候，为了节省磁盘空间，对于相同的对象会进行优化。当多次保存相同的对象时，其实保存的只是第一个对象的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将account对象保存两次，第二次保存时修改其用户名</span></span><br><span class="line">Account account = <span class="keyword">new</span> Account(<span class="string">"Freeman"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">oos.writeObject(account);</span><br><span class="line">System.out.println(<span class="string">"fileSize="</span> +file.length());</span><br><span class="line">account.setUserName(<span class="string">"Tom"</span>);</span><br><span class="line">oos.writeObject(account);</span><br><span class="line">System.out.println(<span class="string">"fileSize="</span> +file.length());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取两次保存的account对象</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">Account account2 = (Account)ois.readObject();</span><br><span class="line">Account account3 = (Account)ois.readObject();</span><br><span class="line">System.out.println(<span class="string">"account2.name="</span> + account2.getUserName() + <span class="string">"\n  account3.name="</span> + account3.getUserName() + <span class="string">"\naccount2==account3 -&gt; "</span> + account2.equals(account3));</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">account2.name=Freeman  </span><br><span class="line">account3.name=Freeman </span><br><span class="line">account2==account3 -&gt; <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>所以在对同一个对象进行多次序列化的时候，最好通过clone一个新的对象再进行序列化。</p>
<h4 id="序列化对单例的影响"><a href="#序列化对单例的影响" class="headerlink" title="序列化对单例的影响"></a>序列化对单例的影响</h4><p>反序列化的时候，JVM会根据序列化生成的内容构造新的对象，对于实现了Serializable的单例类来说，这相当于开放了构造方法。为了保证单例类实例的唯一性，我们需要重写resolveObject方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在反序列化的时候被调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回根据字节码创建的新对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ObjectStreamException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span><span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="控制序列化过程"><a href="#控制序列化过程" class="headerlink" title="控制序列化过程"></a>控制序列化过程</h4><p>虽然直接使用Serializable很方便，但有时我们并不想序列化所有的字段，如标识选中状态的isSelected字段，涉及安全问题的password字段等。此时可通过通过以下方法实现：</p>
<ol>
<li>给不想序列化的字段添加static或transient修饰词：</li>
</ol>
<p>Java中的序列化保存的只是对象的成员变量，既不包括static成员（static成员属于类），也不包括成员方法。同时Java为了让序列化更灵活，提供了transient关键字，用来关闭字段的序列化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Account implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">    private String userName;</span><br><span class="line">    private static String idcard;</span><br><span class="line">    private transient String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>直接使用Externalizable接口控制序列化过程：</li>
</ol>
<p>Externalizable也是Java提供的序列化接口，与Serializable不同的是，默认情况下，它不会序列化任何成员变量，所有的序列化，反序列化工作都需要手动完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Account implements Externalizable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line">    </span><br><span class="line">	private String userName;</span><br><span class="line">	private String idcard;</span><br><span class="line">	private String password;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void writeExternal(ObjectOutput out) throws IOException &#123;</span><br><span class="line">		out.writeObject(userName);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">		userName &#x3D; (String) in.readObject();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>自己实现序列化/反序列化过程</p>
<p>public class Account implements Serializable {</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">private String userName;</span><br><span class="line">private transient String idcard;</span><br><span class="line">private String password;</span><br><span class="line"></span><br><span class="line">private void writeObject(ObjectOutputStream oos)throws IOException &#123;</span><br><span class="line">	&#x2F;&#x2F; 调用默认的序列化方法，序列化非transient&#x2F;static字段</span><br><span class="line">	oos.defaultWriteObject();</span><br><span class="line">	oos.writeObject(idcard);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">	&#x2F;&#x2F; 调用默认的反序列化方法，发序列化非transient&#x2F;static字段</span><br><span class="line">	ois.defaultReadObject();</span><br><span class="line">	idcard &#x3D; (String)ois.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
</li>
</ol>
<p>关于Java序列化算法的详细介绍可参考：<a href="https://longdick.iteye.com/blog/458557" target="_blank" rel="noopener">Java序列化算法透析</a></p>
<h4 id="Java序列化注意事项"><a href="#Java序列化注意事项" class="headerlink" title="Java序列化注意事项"></a>Java序列化注意事项</h4><ol>
<li>通过Serializable序列化的对象，在反序列化的时候，直接根据字节码构造对象，并不会调用对象的构造方法；</li>
<li>通过Serializable序列化子类时，如果父类没有实现Serializable接口，那么父类需要提供默认的构造方法，否则在反序列化的时候抛出java.io.NotSerializableException异常；</li>
<li>通过Externalizale实现序列化时，反序列化的时候需要调用对象的默认构造方法；</li>
<li>由于Externalizale默认情况下不会对任何成员变量进行序列化，所以transient关键字只能在Serializable序列化方式中使用；</li>
</ol>
<h3 id="数据交换协议"><a href="#数据交换协议" class="headerlink" title="数据交换协议"></a>数据交换协议</h3><p>序列化与反序列化为数据交换提供了可能，但是因为传递的是字节码，可读性差。在应用层开发过程中不易调试，为了解决这种问题，最直接的想法就是将对象的内容转换为字符串的形式进行传递。具体的传输格式可自行定义，但自定义格式有一个很大的问题——兼容性，如果引入其他系统的模块，就需要对数据格式进行转换，维护其他的系统时，还要先了解一下它的序列化方式。为了统一数据传输的格式，出现了几种数据交换协议，如：JSON, Protobuf，XML。这些数据交换协议可视为是应用层面的序列化/反序列化。</p>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON（JavaScript Object Notation）是一种轻量级，完全独立于语言的<strong>数据交换格式</strong>。目前被广泛应用在前后端的数据交互中。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>JSON中的元素都是键值对——key:value形式，键值对之间以”:”分隔，每个键需用双引号引起来，值的类型为String时也需要双引号。其中value的类型包括：对象，数组，值，每种类型具有不同的语法表示。</p>
<h6 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h6><p>对象是一个无序的键值对集合。以”{“开始，以”}”结束， 每个成员以”,”分隔。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;value&quot; : &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Freeman&quot;,</span><br><span class="line">    &quot;gender&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><p>数组是一个有序的集合，以”[“开始，以”]”结束，成员之间以”,”分隔。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;value&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;zhangsan&quot;,</span><br><span class="line">        &quot;gender&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;lisi&quot;,</span><br><span class="line">        &quot;gender&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h6 id="值"><a href="#值" class="headerlink" title="值"></a>值</h6><p>值类型表示JSON中的基本类型，包括String，Number(byte, short, int, long, float, double), boolean。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;name&quot;: &quot;Freeman&quot;</span><br><span class="line">&quot;gender&quot;: 1</span><br><span class="line">&quot;registered&quot;: false</span><br><span class="line">&quot;article&quot;: null</span><br></pre></td></tr></table></figure>

<p>==注意==：对象，数组，值这三种元素可互相嵌套！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 1,</span><br><span class="line">    &quot;msg&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;zhangsan&quot;,</span><br><span class="line">            &quot;gender&quot;: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;lisi&quot;,</span><br><span class="line">            &quot;gender&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>对于JSON，目前流行的第三方库有<a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a>, <a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">fastjson</a>：关于Gson的详细介绍，参考<a href="https://juejin.im/post/5c46fb376fb9a049ca37af33" target="_blank" rel="noopener">Gson使用教程</a></p>
<h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><p><a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">Protobuf</a>是Google实现的一种与语言无关，与平台无关，可扩展的序列化方式，比XML更小，更快，使用更简单。</p>
<p>Protobuf具有很高的效率，并且几乎为主流的开发语言都提供了支持，具体参考<a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">Protobuf开发文档</a>。</p>
<p>在Android中使用Protobuf，需要<a href="https://github.com/google/protobuf-gradle-plugin" target="_blank" rel="noopener">protobuf-gradle-plugin</a>插件，具体使用查看其项目说明。</p>
<h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>XML（Extensible Markup Language）可扩展标记语言，通过标签描述数据。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;person&gt;</span><br><span class="line">    &lt;name&gt;Freeman&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;gender&gt;1&lt;&#x2F;gender&gt;</span><br><span class="line">&lt;&#x2F;person&gt;</span><br></pre></td></tr></table></figure>

<p>使用这种方式传输数据时，只需要将对象转换成这种标签形式，在接收到数据后，将其转换成相应的对象。</p>
<p>关于JAVA开发中对XML的解析可参考<a href="http://www.cnblogs.com/lanxuezaipiao/archive/2013/05/17/3082949.html" target="_blank" rel="noopener">四种生成和解析XML文档的方法详解</a></p>
<h4 id="数据交换协议如何选择"><a href="#数据交换协议如何选择" class="headerlink" title="数据交换协议如何选择"></a>数据交换协议如何选择</h4><p>从性能，数据大小，可读性三方面进行比较，结果如下：</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>性能</th>
<th>数据大小</th>
<th>可读性</th>
</tr>
</thead>
<tbody><tr>
<td>JSON</td>
<td>良</td>
<td>良</td>
<td>优</td>
</tr>
<tr>
<td>Protobuf</td>
<td>优</td>
<td>优</td>
<td>差</td>
</tr>
<tr>
<td>XML</td>
<td>中</td>
<td>中</td>
<td>中</td>
</tr>
</tbody></table>
<p>对于数据量不是很大，实时性不是特别高的交互，JSON完全可以满足要求，毕竟它的可读性高，出现问题容易定位（注：它是目前前端，app和后端交换数据使用的主流协议）。而对于实时性要求很高，或数据量大的场景，可使用Protobuf协议。具体数据交换协议的比较可参考<a href="https://note.youdao.com/" target="_blank" rel="noopener">github.com/eishay/jvm-…</a></p>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5c47c8aae51d4551363ff2f9" target="_blank" rel="noopener">序列化与反序列化</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/21/HashSet%E9%9B%86%E5%90%88%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/21/HashSet%E9%9B%86%E5%90%88%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84/" class="post-title-link" itemprop="url">HashSet集合是怎么实现不重复的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-21 08:29:41 / 修改时间：16:32:26" itemprop="dateCreated datePublished" datetime="2020-06-21T08:29:41+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span><br><span class="line"> * <span class="function"><span class="keyword">default</span> initial <span class="title">capacity</span> <span class="params">(<span class="number">16</span>)</span> and load <span class="title">factor</span> <span class="params">(<span class="number">0.75</span>)</span>.</span></span><br><span class="line"><span class="function"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，HashSet底层是hashmap存储的。借大神的话</p>
<blockquote>
<p>HashSet 就是HashMap的马甲           —–someone</p>
</blockquote>
<p>很形象哈。</p>
<h2 id="add-方法"><a href="#add-方法" class="headerlink" title="add()方法"></a>add()方法</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"> private transient HashMap&lt;E,<span class="built_in">Object</span>&gt; map;</span><br><span class="line"> private <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Object</span> PRESENT = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Adds </span>the<span class="markdown"> specified element to this set if it is not already present.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>More formally, adds </span>the<span class="markdown"> specified element <span class="xml"><span class="tag">&lt;<span class="name">tt</span>&gt;</span></span>e<span class="xml"><span class="tag">&lt;/<span class="name">tt</span>&gt;</span></span> to this set if</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>this set contains no element <span class="xml"><span class="tag">&lt;<span class="name">tt</span>&gt;</span></span>e2<span class="xml"><span class="tag">&lt;/<span class="name">tt</span>&gt;</span></span> </span>such<span class="markdown"> that</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">tt</span>&gt;</span></span>(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))<span class="xml"><span class="tag">&lt;/<span class="name">tt</span>&gt;</span></span>.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>If this set already contains </span>the<span class="markdown"> element, </span>the<span class="markdown"> call leaves </span>the<span class="markdown"> set</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>unchanged and returns <span class="xml"><span class="tag">&lt;<span class="name">tt</span>&gt;</span></span>false<span class="xml"><span class="tag">&lt;/<span class="name">tt</span>&gt;</span></span>.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param e element to be added to this set</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return <span class="xml"><span class="tag">&lt;<span class="name">tt</span>&gt;</span></span>true<span class="xml"><span class="tag">&lt;/<span class="name">tt</span>&gt;</span></span> if this set did not already contain </span>the<span class="markdown"> specified</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>element</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>add方法的参数（要存储的value）作为HashMap的key，<code>PRESENT（Object PRESENT = new Object();）</code>作为固定value。</strong></p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>HashMap中的put方法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, <span class="keyword">value</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param hash hash for key</span></span><br><span class="line"><span class="comment">  * @param key the key</span></span><br><span class="line"><span class="comment">  * @param value the value to put</span></span><br><span class="line"><span class="comment">  * @param onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">  * @param evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">  * @return previous value, or null if none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function">final V <span class="title">putVal</span>(<span class="params"><span class="keyword">int</span> hash, K key, V <span class="keyword">value</span>, boolean onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                boolean evict</span>)</span> &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">         tab[i] = newNode(hash, key, <span class="keyword">value</span>, <span class="literal">null</span>);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.<span class="keyword">equals</span>(k))))</span><br><span class="line">             e = p;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p instanceof TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, <span class="keyword">value</span>);</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                     p.next = newNode(hash, key, <span class="keyword">value</span>, <span class="literal">null</span>);</span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.<span class="keyword">equals</span>(k))))</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                 e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里边有两个看点：</strong></p>
<ul>
<li>HashMap中key存储是hash后的值，对于String类型的相同值的hash值是一致的（其他接触类型类似，自定义对象类型需要重写hashcode方法与equel方法）。换句话说相同的值在hashMap中的存储位置是一样的。</li>
<li>基于上一点来看看怎么存储重复值的。如下代码对于hashMap中已经存在的key，key不变，新value覆盖就value。对于HashSet而言新旧value都是PRESENT对象，所以set在存储的时候就不会重复。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">  V oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">        e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以hashset中存储的值输出的顺序和存储的先后顺序不一致，而是按照值的hash顺序输出。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>通过分析HashSet的实现原理，可以肯定的是它的去重效率是很高的，前提是去重对象需要有hashcode、equel方法的实现。除此外HashMap所拥有的大多数特性都适用于HashSet。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://www.jianshu.com/p/f6ae7a79113d" target="_blank" rel="noopener">HashSet集合是怎么实现不重复的</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/20/MySQL-InnoDB-MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/20/MySQL-InnoDB-MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">MySQL-InnoDB-MVCC多版本并发控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-21 07:22:08 / 修改时间：15:42:47" itemprop="dateCreated datePublished" datetime="2020-06-21T07:22:08+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近正在啃《高性能MySQL》这本书, 当看到事务相关知识时,决定对该知识点稍微深入一下, 《高性能MySQL》中在介绍事务相关知识点时, 显然不是特别深入, 很多比较底层的知识点并没有太多的深入, 当然此处并不是要对本书做什么评判,言归正传, 这里主要先说一下本人在啃相关知识点时的曲折之路:</p>
<ol>
<li>首先是事务相关ACID特性, 之前已经有相关笔记进行过介绍, 这里不再重复;</li>
<li>接下来是高并发事务相关的问题, 像是 <code>脏读</code>, <code>不可重复读</code>, <code>幻读</code>, <code>更新丢失</code>等问题之前也有相关笔记;</li>
<li>再下来就是MySQL应对高并发事务是如何给出解决方案的(其中包含各个隔离级别的简介);</li>
<li>然后就是各个隔离级别的具体介绍及与锁的关系, 也就是在这部分知识点, 发现了之前并没有过多关心的知识点 <code>MVCC多版本并发控制</code>, 然后一发不可收拾了…</li>
</ol>
<h2 id="入题"><a href="#入题" class="headerlink" title="入题"></a>入题</h2><p>下面先引用一些前辈们比较优秀的文章:</p>
<blockquote>
<p><a href="http://mysql.taobao.org/monthly/2017/12/01/" target="_blank" rel="noopener">阿里数据库内核’2017/12’月报</a>中对MVCC的解释是:<br><strong>多版本控制</strong>: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。</p>
</blockquote>
<blockquote>
<p>&lt;高性能MySQL&gt;中对MVCC的部分介绍</p>
<ul>
<li>MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。<strong>基于提升并发性能的考虑</strong>, 它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL, 包括Oracle,PostgreSQL等其他数据库系统也都实现了MVCC, 但各自的实现机制不尽相同, 因为MVCC没有一个统一的实现标准。</li>
<li>可以认为<strong>MVCC是行级锁的一个变种</strong>, 但是<strong>它在很多情况下避免了加锁操作, 因此开销更低</strong>。虽然实现机制有所不同, 但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</li>
<li>MVCC的实现方式有多种, 典型的有<strong>乐观(optimistic)并发控制</strong> 和 <strong>悲观(pessimistic)并发控制</strong>。</li>
<li>MVCC<strong>只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作</strong>。其他两个隔离级别和MVCC不兼容, 因为 <code>READ UNCOMMITTED</code> 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 <code>SERIALIZABLE</code> 则会对所有读取的行都加锁。</li>
</ul>
<p><strong>从书中可以了解到:</strong></p>
<ul>
<li>MVCC是被Mysql中 <code>事务型存储引擎InnoDB</code> 所支持的;</li>
<li><strong>应对高并发事务, MVCC比<code>单纯的加锁</code>更高效</strong>;</li>
<li>MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;</li>
<li>MVCC可以使用 <code>乐观(optimistic)锁</code> 和 <code>悲观(pessimistic)锁</code>来实现;</li>
<li>各数据库中MVCC实现并不统一</li>
<li>但是书中提到 “InnoDB的MVCC是通过在每行记录后面保存<strong>两个隐藏的列</strong>来实现的”(网上也有很多此类观点), 但其实并不准确, 可以参考<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html" target="_blank" rel="noopener">MySQL官方文档</a>, 可以看到, InnoDB存储引擎在数据库每行数据的后面添加了<strong>三个字段</strong>, 和MVCC有关系的有两个(数据行的版本号 （DB_TRX_ID）和删除版本号 (DB_ROLL_PT))</li>
</ul>
</blockquote>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>1.<code>read view</code>, <code>快照snapshot</code></p>
<blockquote>
<p><a href="http://mysql.taobao.org/monthly/2017/10/01/" target="_blank" rel="noopener">淘宝数据库内核月报/2017/10/01/</a><br>此文虽然是以PostgreSQL进行的说明, 但并不影响理解, 在”事务快照的实现”该部分有细节需要注意:<br>事务快照是用来存储数据库的事务运行情况。一个事务快照的创建过程可以概括为：<br>查看当前所有的未提交并活跃的事务，存储在数组中<br>选取未提交并活跃的事务中最小的XID，记录在快照的xmin中<br><strong>选取所有已提交事务中最大的XID，加1后记录在xmax中</strong></p>
</blockquote>
<p>注意: 上文中在PostgreSQL中snapshot的概念, 对应MySQL中, 其实就是你在网上看到的<code>read view</code>,<code>快照</code>这些概念;<br>比如<a href="http://hedengcheng.com/?p=148#_Toc322691905" target="_blank" rel="noopener">何登成</a>就有关于<code>Read view</code>的介绍;<br>而 <a href="https://www.cnblogs.com/digdeep/p/4947694.html" target="_blank" rel="noopener">此文</a> 却仍是使用<code>快照</code>来介绍;</p>
<p>2.read view 主要是用来做可见性判断的, 比较普遍的解释便是”本事务不可见的当前其他活跃事务”, 但正是该解释, 可能会造成一节理解上的误区, 所以此处提供两个参考, 供给大家<strong>避开理解误区</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read view中的&#96;高水位low_limit_id&#96;可以参考 https:&#x2F;&#x2F;github.com&#x2F;zhangyachen&#x2F;zhangyachen.github.io&#x2F;issues&#x2F;68, https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;66320138</span><br><span class="line">其实上面第1点中加粗部分也是相关高水位的介绍( 注意进行了+1 )</span><br></pre></td></tr></table></figure>

<p>3.另外, 对于read view快照的生成时机, 也非常关键, <strong>正是因为生成时机的不同, 造成了RC,RR两种隔离级别的不同可见性</strong>;</p>
<ul>
<li>在innodb中(默认repeatable read级别), 事务在begin/start transaction之后的第一条select读操作后, 会创建一个快照(read view), 将当前系统中活跃的其他事务记录记录起来;</li>
<li>在innodb中(默认repeatable committed级别), 事务中每条select语句都会创建一个快照(read view);</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_consistent_read" target="_blank" rel="noopener">参考</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">With REPEATABLE READ isolation level, the snapshot is based on the time when the first read operation is performed.</span><br><span class="line"> 使用REPEATABLE READ隔离级别，快照是基于执行第一个读操作的时间。</span><br><span class="line">With READ COMMITTED isolation level, the snapshot is reset to the time of each consistent read operation.</span><br><span class="line">使用READ COMMITTED隔离级别，快照被重置为每个一致的读取操作的时间。</span><br></pre></td></tr></table></figure>

<p>4.undo-log</p>
<ul>
<li>Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。</li>
<li>Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作（例如bug#69812）。</li>
<li>大多数对数据的变更操作包括INSERT/DELETE/UPDATE，其中INSERT操作在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除（谁会对刚插入的数据有可见性需求呢！！），而对于UPDATE/DELETE则需要维护多版本信息，在InnoDB里，UPDATE和DELETE操作产生的Undo日志被归成一类，即update_undo</li>
<li>另外, 在回滚段中的undo logs分为: <code>insert undo log</code> 和 <code>update undo log</code><ul>
<li>insert undo log : 事务对insert新记录时产生的undolog, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。</li>
<li>update undo log : 事务对记录进行delete和update操作时产生的undo log, 不仅在事务回滚时需要, 一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。</li>
</ul>
</li>
</ul>
<p>5.InnoDB存储引擎在数据库每行数据的后面添加了三个字段</p>
<ul>
<li>6字节的<code>事务ID</code>(<code>DB_TRX_ID</code>)字段: 用来标识最近一次对本行记录做修改(insert|update)的事务的标识符, 即最后一次修改(insert|update)本行记录的事务id。<br>至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted, <strong>并非真正删除</strong>。</li>
<li>7字节的<code>回滚指针</code>(<code>DB_ROLL_PTR</code>)字段: 指写入回滚段(rollback segment)的 <code>undo log</code> record (撤销日志记录记录)。<br>如果一行记录被更新, 则 <code>undo log</code> record 包含 ‘重建该行记录被更新之前内容’ 所必须的信息。</li>
<li>6字节的<code>DB_ROW_ID</code>字段: 包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。<br>结合聚簇索引的相关知识点, 我的理解是, 如果我们的表中没有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 但聚簇索引会使用DB_ROW_ID的值来作为主键; 如果我们有自己的主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID 了 。<br>关于聚簇索引, 《高性能MySQL》中的篇幅对我来说已经够用了, 稍后会整理一下以前的学习笔记, 然后更新上来。</li>
</ul>
<p>6.可见性比较算法（这里每个比较算法后面的描述是建立在rr级别下，rc级别也是使用该比较算法,此处未做描述）<br>设要读取的行的最后提交事务id(即当前数据行的稳定事务id)为 <code>trx_id_current</code><br>当前新开事务id为 <code>new_id</code><br>当前新开事务创建的快照<code>read view</code> 中最早的事务id为<code>up_limit_id</code>, 最迟的事务id为<code>low_limit_id</code>(注意这个low_limit_id=未开启的事务id=当前最大事务id+1)<br>比较:</p>
<ul>
<li>1.<code>trx_id_current &lt; up_limit_id</code>, 这种情况比较好理解, 表示, 新事务在读取该行记录时, 该行记录的稳定事务ID是小于, 系统当前所有活跃的事务, 所以当前行稳定数据对新事务可见, 跳到步骤5.</li>
<li>2.<code>trx_id_current &gt;= trx_id_last</code>, 这种情况也比较好理解, 表示, 该行记录的稳定事务id是在本次新事务创建之后才开启的, 但是却在本次新事务执行第二个select前就commit了，所以该行记录的当前值不可见, 跳到步骤4。</li>
<li>3.<code>trx_id_current &lt;= trx_id_current &lt;= trx_id_last</code>, 表示: 该行记录所在事务在本次新事务创建的时候处于活动状态，从up_limit_id到low_limit_id进行遍历，如果trx_id_current等于他们之中的某个事务id的话，那么不可见, 调到步骤4,否则表示可见。</li>
<li>4.从该行记录的 DB_ROLL_PTR 指针所指向的回滚段中取出最新的undo-log的版本号, 将它赋值该 <code>trx_id_current</code>，然后跳到步骤1重新开始判断。</li>
<li>5.将该可见行的值返回。</li>
</ul>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><ol>
<li>下面是一个非常简版的演示事务对某行记录的更新过程, 当然, InnoDB引擎在内部要做的工作非常多:<br><img src="https://segmentfault.com/img/bV1IKz?w=1072&h=1084" alt="clipboard.png"></li>
<li>下面是一套比较算法的应用过程, 比较长<br><img src="https://segmentfault.com/img/remote/1460000012764806" alt="比较算法"></li>
</ol>
<h2 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h2><p>1.MySQL的InnoDB存储引擎默认事务隔离级别是RR(可重复读), 是通过 “行排他锁+MVCC” 一起实现的, 不仅可以保证可重复读, 还可以<strong>部分</strong>防止幻读, 而非完全防止;</p>
<p>2.为什么是部分防止幻读, 而不是完全防止?</p>
<ul>
<li>效果: 在如果事务B在事务A执行中, insert了一条数据并提交, 事务A再次查询, 虽然读取的是undo中的旧版本数据(防止了部分幻读), 但是事务A中执行update或者delete都是可以成功的!!</li>
<li>因为在innodb中的操作可以分为<code>当前读(current read)</code>和<code>快照读(snapshot read)</code>:</li>
</ul>
<p>3.快照读(snapshot read)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单的select操作(当然不包括 select ... lock in share mode, select ... for update)</span><br></pre></td></tr></table></figure>

<p>4.当前读(current read) <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" target="_blank" rel="noopener">官网文档 Locking Reads</a></p>
<ul>
<li>select … lock in share mode</li>
<li>select … for update</li>
<li>insert</li>
<li>update</li>
<li>delete</li>
</ul>
<p>在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。<br>innodb在快照读的情况下并没有真正的避免幻读, 但是在当前读的情况下避免了不可重复读和幻读!!!</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>一般我们认为MVCC有下面几个特点：<ul>
<li>每行数据都存在一个版本，每次数据更新时都更新该版本</li>
<li><strong>修改时Copy出当前版本, 然后随意修改，各个事务之间无干扰</strong></li>
<li>保存时比较版本号，如果成功(commit)，则覆盖原记录, 失败则放弃copy(rollback)</li>
<li>就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有<strong>乐观锁</strong>的味道, 因为这看起来正是，<strong>在提交的时候才能知道到底能否提交成功</strong></li>
</ul>
</li>
<li>而InnoDB实现MVCC的方式是:<ul>
<li>事务以排他锁的形式修改原始数据</li>
<li>把修改前的数据存放于undo log，通过回滚指针与主数据关联</li>
<li>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</li>
</ul>
</li>
<li><strong>二者最本质的区别是</strong>: 当修改数据时是否要<code>排他锁定</code>，如果锁定了还算不算是MVCC？</li>
</ol>
<ul>
<li>Innodb的实现真算不上MVCC, 因为并没有实现核心的多版本共存, <code>undo log</code> 中的内容只是串行化的结果, 记录了多个事务的过程, 不属于多版本共存。但理想的MVCC是难以实现的, 当事务仅修改一行记录使用理想的MVCC模式是没有问题的, 可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的MVCC就无能为力了。</li>
<li>比如, 如果事务A执行理想的MVCC, 修改Row1成功, 而修改Row2失败, 此时需要回滚Row1, 但因为Row1没有被锁定, 其数据可能又被事务B所修改, 如果此时回滚Row1的内容，则会破坏事务B的修改结果，导致事务B违反ACID。 这也正是所谓的 <code>第一类更新丢失</code> 的情况。</li>
<li>也正是因为InnoDB使用的MVCC中结合了排他锁, 不是纯的MVCC, 所以第一类更新丢失是不会出现了, 一般说更新丢失都是指第二类丢失更新。</li>
</ul>
<hr>
<p>本文整理自</p>
<p><a href="https://segmentfault.com/a/1190000012650596" target="_blank" rel="noopener">MySQL-InnoDB-MVCC多版本并发控制</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/20/%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/20/%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/" class="post-title-link" itemprop="url">服务降级</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-21 07:05:20 / 修改时间：15:06:41" itemprop="dateCreated datePublished" datetime="2020-06-21T07:05:20+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>​    什么是服务降级？当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</p>
<p>​    如果还是不理解，那么可以举个栗子：假如目前有很多人想要给我付钱，但我的服务器除了正在运行支付的服务之外，还有一些其它的服务在运行，比如搜索、定时任务和详情等等。然而这些不重要的服务就占用了JVM的不少内存与CPU资源，为了能把钱都收下来（钱才是目标），我设计了一个动态开关，把这些不重要的服务直接在最外层拒掉，这样处理后的后端处理收钱的服务就有更多的资源来收钱了（收钱速度更快了），这就是一个简单的服务降级的使用场景。</p>
<h1 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2 使用场景"></a>2 使用场景</h1><p>​    服务降级主要用于什么场景呢？当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，我们可以将一些 <strong>不重要</strong> 或 <strong>不紧急</strong> 的服务或任务进行服务的 <strong>延迟使用</strong> 或 <strong>暂停使用</strong>。</p>
<h1 id="3-核心设计"><a href="#3-核心设计" class="headerlink" title="3 核心设计"></a>3 核心设计</h1><h2 id="3-1-分布式开关"><a href="#3-1-分布式开关" class="headerlink" title="3.1 分布式开关"></a>3.1 分布式开关</h2><p>​    根据上述需求，我们可以设置一个分布式开关，用于实现服务的降级，然后集中式管理开关配置信息即可。具体方案如下：</p>
<p><img src="https://static.oschina.net/uploads/space/2018/0406/105147_dBiu_873167.png" alt="img"></p>
<p>服务降级-分布式开关</p>
<h2 id="3-2-自动降级"><a href="#3-2-自动降级" class="headerlink" title="3.2 自动降级"></a>3.2 自动降级</h2><ul>
<li><strong>超时降级</strong> —— 主要配置好超时时间和超时重试次数和机制，并使用异步机制探测恢复情况</li>
<li><strong>失败次数降级</strong> —— 主要是一些不稳定的API，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况</li>
<li><strong>故障降级</strong> —— 如要调用的远程服务挂掉了（网络故障、DNS故障、HTTP服务返回错误的状态码和RPC服务抛出异常），则可以直接降级</li>
<li><strong>限流降级</strong> —— 当触发了限流超额时，可以使用暂时屏蔽的方式来进行短暂的屏蔽</li>
</ul>
<p>​    当我们去秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时开发者会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。</p>
<h2 id="3-3-配置中心"><a href="#3-3-配置中心" class="headerlink" title="3.3 配置中心"></a>3.3 配置中心</h2><p>​    微服务降级的配置信息是集中式的管理，然后通过可视化界面进行友好型的操作。配置中心和应用之间需要网络通信，因此可能会因网络闪断或网络重启等因素，导致配置推送信息丢失、重启或网络恢复后不能再接受、变更不及时等等情况，因此服务降级的配置中心需要实现以下几点特性，从而尽可能的保证配置变更即使达到：</p>
<p><img src="https://static.oschina.net/uploads/space/2018/0406/105300_ygtF_873167.png" alt="img"></p>
<p>服务降级-配置中心</p>
<ul>
<li><strong>启动主动拉取配置</strong> —— 用于初始化配置（减少第一次定时拉取周期）</li>
<li><strong>发布订阅配置</strong> —— 用于实现配置及时变更（可以解决90%左右的配置变更）</li>
<li><strong>定时拉取配置</strong> —— 用于解决发布订阅失效或消失丢失的情况（可以解决9%左右的发布订阅失效的消息变更）</li>
<li><strong>离线文件缓存配置</strong> —— 用于临时解决重启后连接不上配置中心的问题</li>
<li><strong>可编辑式配置文档</strong> —— 用于直接编辑文档的方式来实现配置的定义</li>
<li><strong>提供Telnet命令变更配置</strong> —— 用于解决配置中心失效而不能变更配置的常见</li>
</ul>
<h2 id="3-4-处理策略"><a href="#3-4-处理策略" class="headerlink" title="3.4 处理策略"></a>3.4 处理策略</h2><p>​    当触发服务降级后，新的交易再次到达时，我们该如何来处理这些请求呢？从微服务架构全局的视角来看，我们通常有以下是几种常用的降级处理方案：</p>
<ul>
<li><strong>页面降级</strong> —— 可视化界面禁用点击按钮、调整静态页面</li>
<li><strong>延迟服务</strong> —— 如定时任务延迟处理、消息入MQ后延迟处理</li>
<li><strong>写降级</strong> —— 直接禁止相关写操作的服务请求</li>
<li><strong>读降级</strong> —— 直接禁止相关度的服务请求</li>
<li><strong>缓存降级</strong> —— 使用缓存方式来降级部分读频繁的服务接口</li>
</ul>
<p>​    针对后端代码层面的降级处理策略，则我们通常使用以下几种处理措施进行降级处理：</p>
<ul>
<li><strong>抛异常</strong></li>
<li><strong>返回NULL</strong></li>
<li><strong>调用Mock数据</strong></li>
<li><strong>调用Fallback处理逻辑</strong></li>
</ul>
<h1 id="4-高级特性"><a href="#4-高级特性" class="headerlink" title="4 高级特性"></a>4 高级特性</h1><p>​    我们已经为每个服务都做好了一个降级开关，也已经在线上验证通过了，感觉完全没问题了。<br>​    <strong>场景一</strong>：某一天，运营搞了一次活动，突然跑过来说，现在流量已经快涨到上限了，有没有批量降级所有不重要服务的方式？开发一脸懵逼的看着，这又不是操作DB，哪里有批量操作呀。<br>​    <strong>场景二</strong>：某一天，运营又搞事了，说我们等下要搞一个活动，让我们赶紧提前把不重要的服务都降级了，开发又是一脸懵逼，我怎么知道要降级哪些服务呀。<br>​    <strong>反思</strong>：服务降级的功能虽然是实现了，可是没有考虑实施时的体验。服务太多，不知道该降级哪些服务，单个操作降级速度太慢……</p>
<h2 id="4-1-分级降级"><a href="#4-1-分级降级" class="headerlink" title="4.1 分级降级"></a>4.1 分级降级</h2><p>​    当微服务架构发生不同程度的情况时，我们可以根据服务的对比而进行选择式舍弃（即丢车保帅的原则），从而进一步保障核心的服务的正常运作。</p>
<p>​    如果等线上服务即将发生故障时，才去逐个选择哪些服务该降级、哪些服务不能降级，然而线上有成百上千个服务，则肯定是来不及降级就会被拖垮。同时，在大促或秒杀等活动前才去梳理，也是会有不少的工作量，因此建议在开发期就需要架构师或核心开发人员来提前梳理好，是否能降级的初始评估值，即是否能降级的默认值。</p>
<p>​    为了便于批量操作微服务架构中服务的降级，我们可以从全局的角度来建立服务重要程度的评估模型，如果有条件的话，建议可以使用 <strong>层次分析法（The analytic hierarchy process，简称AHP）</strong> 的数学建模模型（或其它模型）来进行定性和定量的评估（肯定比架构师直接拍脑袋决定是否降级好很多倍，当然难度和复杂度也会高许多，即你需要一个会数学建模人才），而层次分析法的基本思路是人对一个复杂的决策问题的思维和判断过程大体上是一样的。</p>
<p>​    以下是个人给出的最终评价模型，可作为服务降级的评价参考模型进行设计：</p>
<p>​    我们利用数学建模的方式或架构师直接拍脑袋的方式，结合服务能否降级的优先原则，并根据台风预警（都属于风暴预警）的等级进行参考设计，可将微服务架构的所有服务进行故障风暴等级划分为以下四种：</p>
<p><strong>评估模型</strong>：</p>
<ul>
<li><strong>蓝色风暴</strong> —— 表示需要小规模降级非核心服务</li>
<li><strong>黄色风暴</strong> —— 表示需要中等规模降级非核心服务</li>
<li><strong>橙色风暴</strong> —— 表示需要大规模降级非核心服务</li>
<li><strong>红色风暴</strong> —— 表示必须降级所有非核心服务</li>
</ul>
<p><strong>设计说明</strong>：</p>
<ul>
<li>故障严重程度为：蓝色＜黄色＜橙色＜红色</li>
<li>建议根据二八原则可以将服务划分为：80%的非核心服务+20%的核心服务</li>
</ul>
<p>​    以上模型只是整体微服务架构的服务降级评估模型，具体大促或秒杀活动时，建议以具体主题为中心进行建立（不同主题的活动，因其依赖的服务不同，而使用不同的进行降级更为合理）。当然模型可以使用同一个，但其数据需要有所差异。最好能建立一套模型库，然后实施时只需要输入相关服务即可输出最终降级方案，即输出本次大促或秒杀时，当发生蓝色风暴时需要降级的服务清单、当发生黄色风暴时需要降级的服务清单……</p>
<h2 id="4-2-降级权值"><a href="#4-2-降级权值" class="headerlink" title="4.2 降级权值"></a>4.2 降级权值</h2><p>​    微服务架构中有服务权值的概念，主要用于负载时的权重选择，同样服务降级权值也是类似，<strong>主要用于服务降级选择时的细粒度优先级抉择</strong>。所有的服务直接使用以上简单的四级划分方式进行统一处理，显然粒度太粗，或者说出于同一级的多个服务需要降级时的 <strong>降级顺序</strong> 该如何？甚至我想要人工智能化的 <strong>自动降级</strong>，又该如何更细粒度的控制？</p>
<p>​    基于上述的这些AI化的需求，我们可以为每一个服务分配一个降级权值，从而便于更加智能化的实现服务治理。而其评估的数值，同样也可以使用数学模型的方式进行 <strong>定性</strong> 与 <strong>定量</strong> 的评估出来，也可以架构师根据经验直接拍脑袋来确定。</p>
<h1 id="5-总结与展望"><a href="#5-总结与展望" class="headerlink" title="5 总结与展望"></a>5 总结与展望</h1><p>​    以上提供了半实际与半理论的服务降级方案，使用者可以根据其公司的实际情况进行适当的选择，而完整的方案，笔者目前也没有发现有实施过的，但可以建议有长远服务治理规划的大厂进行完整方案的研究与实施，会对未来人工智能万物互联的时代有较好的治理价值存在（个人看法）。而小厂出于成本和其发挥的价值的考虑，不建议使用这么复杂的方案，但可以实现分布式开关和简单分级降级的功能特性。</p>
<p>​    本文主要以服务降级为核心进行更加理想的治理微服务架构，其中建议运用数学领域的适当模型来实现 <strong>定性</strong> 和 <strong>定量</strong> 的合理分析和治理微服务，为未来 <strong>人工智能治理微服务</strong>（Artificial Intelligence Governance Micro Service，简称AIGMS）提供方案支持。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://my.oschina.net/yu120/blog/1790398" target="_blank" rel="noopener">服务降级</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/20/MySQL%20%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/20/MySQL%20%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">MySQL 分库分表方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-21 06:49:38 / 修改时间：15:04:48" itemprop="dateCreated datePublished" datetime="2020-06-21T06:49:38+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>公司最近在搞服务分离，数据切分方面的东西，因为单张包裹表的数据量实在是太大，并且还在以每天60W的量增长。 之前了解过数据库的分库分表，读过几篇博文，但就只知道个模糊概念， 而且现在回想起来什么都是模模糊糊的。</p>
<p>今天看了一下午的数据库分库分表，看了很多文章，现在做个总结，“摘抄”下来。（但更期待后期的实操） 会从以下几个方面说起： </p>
<p>第一部分：实际网站发展过程中面临的问题。 </p>
<p>第二部分：有哪几种切分方式，垂直和水平的区别和适用面。</p>
<p>第三部分：目前市面有的一些开源产品，技术，它们的优缺点是什么。</p>
<p>第四部分：可能是最重要的，为什么不建议水平分库分表！？这能让你能在规划前期谨慎的对待，规避掉切分造成的问题。</p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>库：database；表：table；分库分表：sharding</p>
<h2 id="数据库架构演变"><a href="#数据库架构演变" class="headerlink" title="数据库架构演变"></a>数据库架构演变</h2><p>刚开始我们只用单机数据库就够了，随后面对越来越多的请求，我们<strong>将数据库的写操作和读操作进行分离</strong>， 使用多个从库副本（Slaver Replication）负责读，使用主库（Master）负责写， <strong>从库请求主库同步更新数据</strong>，保持数据一致。架构上就是数据库主从同步。 <strong>从库可以水平扩展</strong>，所以更多的读请求不成问题。</p>
<p>但是当用户量级上来后，<strong>写请求越来越多，该怎么办</strong>？加一个Master是不能解决问题的， 因为数据要保存一致性，写操作需要2个master之间同步，相当于是重复了，而且更加复杂。</p>
<p>这时就需要用到分库分表（sharding），<strong>对写操作进行切分</strong>。</p>
<h2 id="分库分表前的问题"><a href="#分库分表前的问题" class="headerlink" title="分库分表前的问题"></a>分库分表前的问题</h2><p>任何问题都是太大或者太小的问题，我们这里面对的数据量太大的问题。</p>
<h3 id="用户请求量太大"><a href="#用户请求量太大" class="headerlink" title="用户请求量太大"></a>用户请求量太大</h3><p>因为单服务器TPS，内存，IO都是有限的。 解决方法：分散请求到多个服务器上； 其实用户请求和执行一个sql查询是本质是一样的，都是请求一个资源，只是用户请求还会经过网关，路由，http服务器等。</p>
<h3 id="单库太大"><a href="#单库太大" class="headerlink" title="单库太大"></a>单库太大</h3><p>单个数据库处理能力有限；单库所在服务器上磁盘空间不足；单库上操作的IO瓶颈 解决方法：切分成更多更小的库</p>
<h3 id="单表太大"><a href="#单表太大" class="headerlink" title="单表太大"></a>单表太大</h3><p>CRUD都成问题；索引膨胀，查询超时 解决方法：切分成多个数据集更小的表。</p>
<h2 id="分库分表的方式方法"><a href="#分库分表的方式方法" class="headerlink" title="分库分表的方式方法"></a>分库分表的方式方法</h2><p>一般就是垂直切分和水平切分，这是一种结果集描述的切分方式，是物理空间上的切分。 我们从面临的问题，开始解决，阐述： 首先是用户请求量太大，我们就堆机器搞定（这不是本文重点）。</p>
<p>然后是单个库太大，这时我们要看是因为表多而导致数据多，还是因为单张表里面的数据多。 如果是因为<strong>表多</strong>而数据多，使用<strong>垂直切分</strong>，根据业务<strong>切分成不同的库</strong>。</p>
<p>如果是因为<strong>单张表的数据量太大</strong>，这时要用<strong>水平切分</strong>，即把表的数据按某种规则切分成多张表，甚至多个库上的多张表。 分库分表的顺序应该是<strong>先垂直分，后水平分</strong>。 因为<strong>垂直分更简单</strong>，更符合我们处理现实世界问题的方式。</p>
<h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><ol>
<li><h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h4><p>也就是“<strong>大表拆小表</strong>”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的<strong>拆分到“扩展表“</strong>。 一般是<strong>针对那种几百列的大表</strong>，也避免查询时，数据量太大造成的“跨页”问题。</p>
</li>
<li><h4 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h4><p>垂直分库针对的是<strong>一个系统中的不同业务</strong>进行拆分，比如用户User一个库，商品Producet一个库，订单Order一个库。 <strong>切分后，要放在多个服务器上</strong>，而不是一个服务器上。为什么？ 我们想象一下，一个购物网站对外提供服务，会有用户，商品，订单等的CRUD。没拆分之前， 全部都是落到单一的库上的，这会让数据库的单库处理能力成为瓶颈。按垂直分库后，如果还是放在一个数据库服务器上， 随着用户量增大，这会让单个数据库的处理能力成为瓶颈，还有单个服务器的磁盘空间，内存，tps等非常吃紧。 所以我们要拆分到多个服务器上，这样上面的问题都解决了，以后也不会面对单机资源问题。</p>
<p>数据库业务层面的拆分，和服务的“治理”，“降级”机制类似，也能对不同业务的数据分别的进行管理，维护，监控，扩展等。 数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。 数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈。</p>
</li>
</ol>
<h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><ol>
<li><h4 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h4><p>针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用。</p>
</li>
<li><h4 id="水平分库分表"><a href="#水平分库分表" class="headerlink" title="水平分库分表"></a>水平分库分表</h4><p>将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。</p>
</li>
<li><h4 id="水平分库分表切分规则"><a href="#水平分库分表切分规则" class="headerlink" title="水平分库分表切分规则"></a>水平分库分表切分规则</h4></li>
<li><ol>
<li><p>RANGE</p>
<p>从0到10000一个表，10001到20000一个表；</p>
</li>
<li><p>HASH取模</p>
<p>一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 取用户id，然后hash取模，分配到不同的数据库上。</p>
</li>
<li><p>地理区域</p>
<p>比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。</p>
</li>
<li><p>时间</p>
<p>按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。</p>
</li>
</ol>
</li>
</ol>
<h2 id="分库分表后面临的问题"><a href="#分库分表后面临的问题" class="headerlink" title="分库分表后面临的问题"></a>分库分表后面临的问题</h2><h3 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h3><p>分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p>
<h3 id="多库结果集合并（group-by，order-by）"><a href="#多库结果集合并（group-by，order-by）" class="headerlink" title="多库结果集合并（group by，order by）"></a>多库结果集合并（group by，order by）</h3><p>TODO</p>
<h3 id="跨库join"><a href="#跨库join" class="headerlink" title="跨库join"></a>跨库join</h3><p>TODO 分库分表后表之间的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表， 结果原本一次查询能够完成的业务，可能需要多次查询才能完成。 粗略的解决方法： 全局表：基础数据，所有库都拷贝一份。 字段冗余：这样有些字段就不用join去查询了。 系统层组装：分别查询出所有，然后组装起来，较复杂。</p>
<h2 id="分库分表方案产品"><a href="#分库分表方案产品" class="headerlink" title="分库分表方案产品"></a>分库分表方案产品</h2><p>目前市面上的分库分表中间件相对较多，其中基于代理方式的有MySQL Proxy和Amoeba， 基于Hibernate框架的是Hibernate Shards，基于jdbc的有当当sharding-jdbc， 基于mybatis的类似maven插件式的有蘑菇街的蘑菇街TSharding， 通过重写spring的ibatis template类的Cobar Client。</p>
<p>还有一些大公司的开源产品：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/30/164e9fe9ff548c7e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/entry/5b5eb7f2e51d4519700f7d3c" target="_blank" rel="noopener">MySQL 分库分表方案</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/20/%E4%B8%BA%E4%BB%80%E4%B9%88%20TCP%20%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/20/%E4%B8%BA%E4%BB%80%E4%B9%88%20TCP%20%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/" class="post-title-link" itemprop="url">为什么 TCP 建立连接需要三次握手</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-21 05:18:28 / 修改时间：13:47:31" itemprop="dateCreated datePublished" datetime="2020-06-21T05:18:28+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TCP 协议是我们几乎每天都会接触到的网络协议，绝大多数网络连接的建立都是基于 TCP 协议的，学过计算机网络或者对 TCP 协议稍有了解的人都知道 —— 使用 TCP 协议建立连接需要经过三次握手（three-way handshake）。</p>
<p>如果让我们简单说说 TCP 建立连接的过程，相信很多准备过面试的人都会非常了解，但是一旦想要深究『为什么 TCP 建立连接需要三次握手？』，作者相信大多数人都没有办法回答这个问题或者会给出错误的答案，这边文章就会讨论究竟为什么我们需要三次握手才能建立 TCP 连接？</p>
<blockquote>
<p>需要注意的是我们会将重点放到为什么需要 TCP 建立连接需要<strong>『三次握手』</strong>，而<em>不仅仅</em>是为什么需要<strong>『三次』</strong>握手。</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在具体分析今天的问题之前，我们首先可以了解一下最常见的错误类比，这个对 TCP 连接过程的错误比喻误导了很多人，作者在比较长的一段时间内也认为它能够很好地描述 TCP 建立连接为什么需要三次握手：</p>
<ol>
<li>你听得到吗？</li>
<li>我能听到，你听得到？</li>
<li>我也能听到；</li>
</ol>
<p>这种用类比来解释问题往往就会面临『十个类比九个错』的尴尬局面，如果别人用类比回答你的为什么，你需要仔细想一想它的类比里究竟哪里有漏洞；类比带来的解释往往只能有片面的相似性，我们永远也无法找到绝对正确的类比，它只在我们想要通俗易懂地展示事物的特性时才能发挥较大的作用，我们在文章的后面会介绍为什么这里的类比有问题，各位读者也可以带着疑问来阅读剩下的内容。</p>
<p>很多人尝试回答或者思考这个问题的时候其实关注点都放在了三次握手中的<strong>三次</strong>上面，这确实很重要，但是如果重新审视这个问题，我们对于『什么是连接』真的清楚？只有知道<strong>连接的定义</strong>，我们才能去尝试回答为什么 TCP 建立连接需要三次握手。</p>
<blockquote>
<p>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</p>
</blockquote>
<p><a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC 793 - Transmission Control Protocol</a> 文档中非常清楚地定义了 TCP 中的连接是什么，我们简单总结一下：用于保证可靠性和流控制机制的信息，包括 Socket、序列号以及窗口大小叫做连接。</p>
<p><img src="https://img.draveness.me/what-is-tcp-connection.png" alt="what-is-tcp-connection"></p>
<p>所以，建立 TCP 连接就是通信的双方需要对上述的三种信息达成共识，连接中的一对 Socket 是由互联网地址标志符和端口组成的，窗口大小主要用来做流控制，最后的序列号是用来追踪通信发起方发送的数据包序号，接收方可以通过序列号向发送方确认某个数据包的成功接收。</p>
<p>到这里，我们将原有的问题转换成了『为什么需要通过三次握手才可以初始化 Sockets、窗口大小和初始序列号？』，那么接下来我们就开始对这个细化的问题进行分析并寻找解释。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>这篇文章主要会从以下几个方面介绍为什么我们需要通过三次握手才可以初始化 Sockets、窗口大小、初始序列号并建立 TCP 连接：</p>
<ul>
<li>通过三次握手才能阻止重复历史连接的初始化；</li>
<li>通过三次握手才能对通信双方的初始序列号进行初始化；</li>
<li>讨论其他次数握手建立连接的可能性；</li>
</ul>
<p>这几个论点中的第一个是 TCP 选择使用三次握手的最主要原因，其他的几个原因相比之下都是次要的原因，我们在这里对它们的讨论只是为了让整个视角更加丰富，通过多方面理解这一有趣的设计决策。</p>
<h3 id="历史连接"><a href="#历史连接" class="headerlink" title="历史连接"></a>历史连接</h3><p><a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC 793 - Transmission Control Protocol</a> 其实就指出了 TCP 连接使用三次握手的首要原因 —— <strong>为了阻止历史的重复连接初始化造成的混乱问题</strong>，防止使用 TCP 协议通信的双方建立了错误的连接。</p>
<blockquote>
<p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</p>
</blockquote>
<p><img src="https://img.draveness.me/tcp-recovery-from-old-duplicate-syn.png" alt="tcp-recovery-from-old-duplicate-syn"></p>
<p>想象一下这个场景，如果通信双方的通信次数只有两次，那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果 TCP 建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。</p>
<p>所以，TCP 选择使用三次握手来建立连接并在连接引入了 <code>RST</code> 这一控制消息，接收方当收到请求时会将发送方发来的 <code>SEQ+1</code> 发送给对方，这时<strong>由发送方来判断当前连接是否是历史连接</strong>：</p>
<ul>
<li>如果当前连接是历史连接，即 <code>SEQ</code> 过期或者超时，那么发送方就会直接发送 <code>RST</code> 控制消息中止这一次连接；</li>
<li>如果当前连接不是历史连接，那么发送方就会发送 <code>ACK</code> 控制消息，通信双方就会成功建立连接；</li>
</ul>
<p><strong>使用三次握手和 <code>RST</code> 控制消息将是否建立连接的最终控制权交给了发送方</strong>，因为<strong>只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的</strong>，这也是 TCP 使用三次握手建立连接的最主要原因。</p>
<h3 id="初始序列号"><a href="#初始序列号" class="headerlink" title="初始序列号"></a>初始序列号</h3><p>另一个使用三次握手的重要的原因就是通信双方都需要获得一个用于发送信息的初始化序列号，作为一个可靠的传输层协议，TCP 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：</p>
<ul>
<li>数据包被发送方多次发送造成数据的重复；</li>
<li>数据包在传输的过程中被路由或者其他节点丢失；</li>
<li>数据包到达接收方可能无法按照发送顺序；</li>
</ul>
<p>为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：</p>
<ul>
<li>接收方可以通过序列号对重复的数据包进行去重；</li>
<li>发送方会在对应数据包未被 ACK 时进行重复发送；</li>
<li>接收方可以根据数据包的序列号对它们进行重新排序；</li>
</ul>
<p>序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 <code>SYN</code> 控制消息并携带自己期望的初始化序列号 <code>SEQ</code>，对方在收到 <code>SYN</code> 消息之后会通过 <code>ACK</code> 控制消息以及 <code>SEQ+1</code> 来进行确认。</p>
<p><img src="https://img.draveness.me/basic-4-way-handshake.png" alt="basic-4-way-handshake"></p>
<p>如上图所示，通信双方的两个 <code>TCP A/B</code> 分别向对方发送 <code>SYN</code> 和 <code>ACK</code> 控制消息，等待通信双方都获取到了自己期望的初始化序列号之后就可以开始通信了，由于 TCP 消息头的设计，我们可以将中间的两次通信合成一个，<code>TCP B</code> 可以向 <code>TCP A</code> 同时发送 <code>ACK</code> 和 <code>SYN</code> 控制消息，这也就帮助我们将四次通信减少至三次。</p>
<blockquote>
<p>A three way handshake is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN’s. The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN. The three way handshake and the advantages of a clock-driven scheme are discussed in [3].</p>
</blockquote>
<p>除此之外，网络作为一个分布式的系统，其中并不存在一个用于计数的全局时钟，而 TCP 可以通过不同的机制来初始化序列号，作为 TCP 连接的接收方我们无法判断对方传来的初始化序列号是否过期，所以我们需要交由对方来判断，TCP 连接的发起方可以通过保存发出的序列号判断连接是否过期，如果让接收方来保存并判断序列号却是不现实的，这也再一次强化了我们在上一节中提出的观点 —— 避免历史错连接的初始化。</p>
<h3 id="通信次数"><a href="#通信次数" class="headerlink" title="通信次数"></a>通信次数</h3><p>当我们讨论 TCP 建立连接需要的通信次数时，我们经常会执着于为什么通信三次才可以建立连接，而不是两次或者四次；讨论使用更多的通信次数来建立连接往往是没有意义的，因为我们总可以<strong>使用更多的通信次数交换相同的信息</strong>，所以使用四次、五次或者更多次数建立连接在技术上都是完全可以实现的。</p>
<p><img src="https://img.draveness.me/basic-3-way-handshake.png" alt="basic-3-way-handshake"></p>
<p>这种增加 TCP 连接通信次数的问题往往没有讨论的必要性，我们追求的其实是用更少的通信次数（理论上的边界）完成信息的交换，也就是为什么我们在上两节中也一再强调使用『两次握手』没有办法建立 TCP 连接，<strong>使用三次握手是建立连接所需要的最小次数</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们在这篇文章中讨论了为什么 TCP 建立连接需要经过三次握手，在具体分析这个问题之前，我们首先重新思考了 TCP 连接究竟是什么，<a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC 793 - Transmission Control Protocol - IETF Tools</a> 对 TCP 连接有着非常清楚的定义 —— 用于保证可靠性和流控制机制的数据，包括 Socket、序列号以及窗口大小。</p>
<p>TCP 建立连接时通过三次握手可以有效地避免历史错误连接的建立，减少通信双方不必要的资源消耗，三次握手能够帮助通信双方获取初始化序列号，它们能够保证数据包传输的不重不丢，还能保证它们的传输顺序，不会因为网络传输的问题发生混乱，到这里不使用『两次握手』和『四次握手』的原因已经非常清楚了：</p>
<ul>
<li>『两次握手』：无法避免历史错误连接的初始化，浪费接收方的资源；</li>
<li>『四次握手』：TCP 协议的设计可以让我们同时传递 <code>ACK</code> 和 <code>SYN</code> 两个控制信息，减少了通信次数，所以不需要使用更多的通信次数传输相同的信息；</li>
</ul>
<p>我们重新回到在文章开头提的问题，为什么使用类比解释 TCP 使用三次握手是错误的？这主要还是因为，这个类比没有解释清楚核心问题 —— 避免历史上的重复连接。到最后，我们还是来看一些比较开放的相关问题，有兴趣的读者可以仔细想一下下面的问题：</p>
<ul>
<li>除了使用序列号是否还有其他方式保证消息的不重不丢？</li>
<li>UDP 协议有连接的概念么，它能保证数据传输的可靠么？</li>
</ul>
<hr>
<p>本文整理自</p>
<p><a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/" target="_blank" rel="noopener">为什么 TCP 建立连接需要三次握手</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/18/Shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/Shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Shell脚本中参数处理方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-19 07:32:47 / 修改时间：15:34:59" itemprop="dateCreated datePublished" datetime="2020-06-19T07:32:47+08:00">2020-06-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="https://www.zmonster.me/2014/08/09/pare-arguments-in-shell-function.html#org242584d" target="_blank" rel="noopener">手工解析</a></li>
<li><a href="https://www.zmonster.me/2014/08/09/pare-arguments-in-shell-function.html#org039a802" target="_blank" rel="noopener">getopts</a></li>
<li><a href="https://www.zmonster.me/2014/08/09/pare-arguments-in-shell-function.html#org29fcbdf" target="_blank" rel="noopener">getopt</a></li>
<li><a href="https://www.zmonster.me/2014/08/09/pare-arguments-in-shell-function.html#orgefa2c7a" target="_blank" rel="noopener">getopts处理长选项</a></li>
<li><a href="https://www.zmonster.me/2014/08/09/pare-arguments-in-shell-function.html#org893ba73" target="_blank" rel="noopener">在函数中解析参数</a></li>
</ul>
<p>在Shell脚本中处理命令行参数，可以使用getopts/getopt来进行——当然，手工解析也是可以的。</p>
<p>下面通过一个特定的情景来讲一下这三种参数处理方法。</p>
<p>这两天写了一个安全删除的脚本，原理就是将指定的文件移动到某个特定的目录下并保存其原始路径信息，这和在Windows下以及在Linux的桌面环境下”将文件移动到回收站”的意义是一样的。就拿这个来做例子吧。</p>
<p>在这个脚本中，有五个选项，分别代表五种动作:</p>
<ol>
<li>-d : 将文件移动到回收站，该选项后需要指定一个文件或目录名</li>
<li>-l : 列出被移动到回收站的文件及其id，该选项不需要值</li>
<li>-b : 恢复被移动到回收站的文件，该选项需要指定一个文件对应的id</li>
<li>-c : 清空回收站，该选项不需要值</li>
<li>-h : 打印帮助信息</li>
</ol>
<h2 id="手工解析"><a href="#手工解析" class="headerlink" title="手工解析"></a>手工解析</h2><p>所谓的手工解析，就是取到参数后手工一个一个解析了，以下是手工解析上述情景参数的过程:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">while [ $# -gt 0 ];do</span><br><span class="line">    case $1 in</span><br><span class="line">        -d)</span><br><span class="line">            shift</span><br><span class="line">            file_to_trash=$1</span><br><span class="line">            trash $file_to_trash # trash is a function</span><br><span class="line">            ;;</span><br><span class="line">        -l)</span><br><span class="line">            print_trashed_file  # print_trashed_file is a function</span><br><span class="line">            ;;</span><br><span class="line">        -b)</span><br><span class="line">            shift</span><br><span class="line">            file_to_untrash=$1</span><br><span class="line">            untrash $file_to_untrash # untrash is a function</span><br><span class="line">            ;;</span><br><span class="line">        -c)</span><br><span class="line">            clean_all           # clean all is a function</span><br><span class="line">            ;;</span><br><span class="line">        -h)</span><br><span class="line">            usage</span><br><span class="line">            exit 0</span><br><span class="line">            ;;</span><br><span class="line">        \?)</span><br><span class="line">            usage</span><br><span class="line">            exit 1</span><br><span class="line">            ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>这里用到了’shift’这个命令，这个命令的作用是将参数列表以空格为分隔符左移一个单位，或者可以理解为将第一个参数给去掉了，比如获取的命令行参数为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-d hello.txt</span><br></pre></td></tr></table></figure>

<p>在执行了’shift’后，命令行参数就变成了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.txt</span><br></pre></td></tr></table></figure>

<p>这样，在使用了shift后，我们每次都只要去看参数列表中的第一个就行了。当然，其实不用’shift’也是可以的，比如说这样:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">i=1</span><br><span class="line">while [ $i -le $# ];do</span><br><span class="line">    case $&#123;!i&#125; in</span><br><span class="line">        -d)</span><br><span class="line">            i=$(expr $i + 1)</span><br><span class="line">            file_to_trash=$&#123;!i&#125;</span><br><span class="line">            trash $file_to_trash # trash is a function</span><br><span class="line">            ;;</span><br><span class="line">        -l)</span><br><span class="line">            print_trashed_file  # print_trashed_file is a function</span><br><span class="line">            ;;</span><br><span class="line">        -b)</span><br><span class="line">            i=$(expr $i + 1)</span><br><span class="line">            file_to_untrash=$&#123;!i&#125;</span><br><span class="line">            untrash $file_to_untrash # untrash is a function</span><br><span class="line">            ;;</span><br><span class="line">        -c)</span><br><span class="line">            clean_all           # clean all is a function</span><br><span class="line">            ;;</span><br><span class="line">        -h)</span><br><span class="line">            usage</span><br><span class="line">            exit 0</span><br><span class="line">            ;;</span><br><span class="line">        \?)</span><br><span class="line">            usage</span><br><span class="line">            exit 1</span><br><span class="line">            ;;</span><br><span class="line">    esac</span><br><span class="line">    i=$(expr $i + 1)</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>对比可以发现使用’shift’会稍微方便一点。</p>
<p>当然，上面的处理没有进行参数检查，这些检查应该要防止这些错误情况:参数个数为0、完全冲突的”动作”一起出现、选项需要值但未给值。</p>
<h2 id="getopts"><a href="#getopts" class="headerlink" title="getopts"></a>getopts</h2><p>‘getopts’是POSIX Shell中内置的一个命令，其使用方法是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getopts &lt;opt_string&gt; &lt;optvar&gt; &lt;arguments&gt;</span><br></pre></td></tr></table></figure>

<p>下面是在Shell中使用该命令的一个示例:</p>
<p><img src="https://www.zmonster.me/assets/img/getopts.gif" alt="getopts.gif"></p>
<p>本质上来说，’getopts’的处理和我们手工处理是差不多的，它不过是提供了更便利的方式而已。它的使用方式非常简单明了，其形式为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while getopts &lt;opt_string&gt; &lt;optvar&gt;</span><br><span class="line">    case $&lt;optvar&gt; in</span><br><span class="line">        # ...</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>其中<opt_string>是要处理的选项的一个集合，每个选项在其中用不包含连字符’-‘的字母来表示，每个代表选项的字母前后可以有一个冒号，前面有冒号表示当处理该选项出错时不输出’getopts’自身产生的错误信息，这方便我们自己编写对应的错误处理方法;后面的冒号表示这个选项需要一个值。对于我们这个”安全删除”的例子，这个<opt_string>应该是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d:lb:ch</span><br></pre></td></tr></table></figure>

<p>冒号的归属的话，先到先得吧，大概是这样。</p>
<p>在使用’getopts’时，有两个特殊的变量，它们是 <strong>OPTIND</strong> 和 <strong>OPTARG</strong> ，前者表示当前参数在参数列表中的位置——相当于手工解析第二种方法中那个自定义的变量 <strong>i</strong> ，其值初始时为1， 会在每次取了选项以及其值(如果有的话)后更新; <strong>OPTARG</strong> 则是在选项需要值时，存储这个选项对应的值。这样，我们这个例子用’getopts’就可以写成:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">while getopts d:lb:ch OPT;do</span><br><span class="line">    case $OPT in</span><br><span class="line">        d)</span><br><span class="line">            file_to_trash=$OPTARG</span><br><span class="line">            trash $file_to_trash # trash is a function</span><br><span class="line">            ;;</span><br><span class="line">        l)</span><br><span class="line">            print_trashed_file  # print_trashed_file is a function</span><br><span class="line">            ;;</span><br><span class="line">        b)</span><br><span class="line">            file_to_untrash=$OPTARG</span><br><span class="line">            untrash $file_to_untrash # untrash is a function</span><br><span class="line">            ;;</span><br><span class="line">        c)</span><br><span class="line">            clean_all           # clean all is a function</span><br><span class="line">            ;;</span><br><span class="line">        h)</span><br><span class="line">            usage</span><br><span class="line">            exit 0</span><br><span class="line">            ;;</span><br><span class="line">        \?)</span><br><span class="line">            usage</span><br><span class="line">            exit 1</span><br><span class="line">            ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>对比可以看到，相比手工解析的第一种办法，又更为简洁一点了。不过需要注意的是，’getopts’会从第一个参数开始，只按照<opt_string>指定的形式来寻找并解析参数，如果给出的实际命令行参数与其所描述的参数形式不符，则会出错中止。</p>
<p>比如说，对于上面的例子，假设这个脚本已经完全写好了，脚本名为 <strong>trash.sh</strong> ，其参数处理就是上面这样，那么如果我在终端里执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;trash.sh a -b hello.txt</span><br></pre></td></tr></table></figure>

<p>开始那个多余的参数’a’将会导致’getopts’在解析到选项’-b’前就出错终止。所以呢，像使用’getopts’这样的方法，其自由度不如手工解析，如果要保证脚本在任何情况下都能正确解析参数，它需要多做一点——当然啦，上面这个愚蠢的错误使用情况还是比较少出现的啦，反正我现在写的脚本里压根没考虑这样的情况。</p>
<h2 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h2><p>‘getopt’与’getopts’类似，不过’getopts’只能处理短选项，’getopt’则能处理短选项和长选项。所谓的短选项就是类似下面这样的选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a</span><br></pre></td></tr></table></figure>

<p>而下面这样的则是长选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--action&#x3D;delete</span><br></pre></td></tr></table></figure>

<p>当然，事无绝对，通过一些技巧，用’getopts’处理长选项也是可能的。这里先说一下如何用’getopt’来处理参数吧。</p>
<p>需要事先说明的一点是，’getopt’不是Shell内建的命令，而是’util-linux’这个软件包提供的功能，它不是POSIX标准的一部分，所以也有人<a href="http://mywiki.wooledge.org/BashFAQ/035#getopts" target="_blank" rel="noopener">建议不使用’getopt’</a>。</p>
<p>首先将之前说到的五种动作对应的短选项扩展一下，以便讲解’getopt’的使用:</p>
<ol>
<li>-d/–delete : 将文件移动到回收站，该选项后需要指定一个文件或目录名</li>
<li>-l/–list : 列出被移动到回收站的文件及其id，该选项不需要值</li>
<li>-b/–back : 恢复被移动到回收站的文件，该选项需要指定一个文件对应的id</li>
<li>-c/–clear : 清空回收站，该选项不需要值</li>
<li>-h/–help : 打印帮助信息</li>
</ol>
<p>‘getopt’既能处理短选项也能处理长选项，短选项通过参数 <strong>-o</strong> 指定，长选项通过参数 <strong>-l</strong> 指定。同’getopts’一样，它一次也只解析一个选项，所以也需要循环处理，不过与’getopts’不同的是，’getopt’没有使用 <strong>OPTIND</strong> 和 <strong>OPTARG</strong> 这两个变量，所以我们还得手动对参数进行’shift’，对需要值的选项，也得手动去取出值。</p>
<p>下面是在Shell中使用’getopt’的一个示例:</p>
<p><img src="https://www.zmonster.me/assets/img/getopt.gif" alt="getopt.gif"></p>
<p>可以看到，’getopt’将参数中以下形式的内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--longopt&#x3D;argument</span><br></pre></td></tr></table></figure>

<p>在返回结果中替换成下面这样的形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--longopt argument</span><br></pre></td></tr></table></figure>

<p>这样就可以通过循环和’shift’来进行处理了，不过在脚本中，’shift’命令是对命令行参数起作用的，即特殊变量”$@”，而我们在脚本中只能将’getopt’的返回结果作为字符串存储到一个变量中。为了让’shift’起作用，通常还要使用’set’命令来将变量的值赋给”$@”这个特殊变量。</p>
<p>真是有够麻烦的……算了，下面再集中吐槽吧……</p>
<p>然后，在设置好短选项和长选项后，在将实际的参数传给’getopt’时，要在实际参数前加上一个两个连字符 <strong>–</strong> ，而’getopt’会将这两个连字符放到返回结果的最后面，在处理时可以将这两个连字符视为结束标志。</p>
<p>以下是针对本文假设的情景，使用’getopt’解析参数的流程:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">arg=$(getopt -o d:lb:ch -l delete:,list,back:,clear,help -- $@)</span><br><span class="line"></span><br><span class="line">set -- "$arg"</span><br><span class="line"></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    case $1 in</span><br><span class="line">        -d|--delete)</span><br><span class="line">            file_to_trash=$2</span><br><span class="line">            trash $file_to_trash # trash is a function</span><br><span class="line">            shift 2</span><br><span class="line">            ;;</span><br><span class="line">        -l|--list)</span><br><span class="line">            print_trashed_file  # print_trashed_file is a function</span><br><span class="line">            shift</span><br><span class="line">            ;;</span><br><span class="line">        -b|--back)</span><br><span class="line">            file_to_untrash=$2</span><br><span class="line">            untrash $file_to_untrash # untrash is a function</span><br><span class="line">            shift</span><br><span class="line">            ;;</span><br><span class="line">        -c|--clear)</span><br><span class="line">            clean_all           # clean all is a function</span><br><span class="line">            shift</span><br><span class="line">            ;;</span><br><span class="line">        -h|--help)</span><br><span class="line">            usage</span><br><span class="line">            exit 0</span><br><span class="line">            ;;</span><br><span class="line">        --)</span><br><span class="line">            shift</span><br><span class="line">            break</span><br><span class="line">            ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>然而，知道了’getopt’的使用及其原理后，自然而然地可以发现，我可以不用去管这个结束标志，用”$#”这个表示参数个数的特殊变量，同样可以控制参数解析的流程，这完全和手工解析是同一个道理。我甚至可以将’getopt’的返回结果存储到一个数组里，直接循环处理这个数组，而不用使用’set’命令了。</p>
<p>好了，吐槽时间。</p>
<p>我之前写脚本都是用的’getopts’，一来我用不上长选项，二来’getopts’的使用足够简单。在写本文之前，我倒是知道’getopt’可以处理长选项，但没仔细了解过。这两天了解了一下，觉得还是别用’getopt’的好，理由如下:</p>
<ol>
<li><p>‘getopt’不是Shell内建命令，跨平台使用时可能会出现问题；</p>
</li>
<li><p>只是将’–longopt=val’这样的参数形式替换成了’–longopt val’，但因此增加了许多复杂性，比如使用了’set’命令，在使用’set’命令时还要考虑’getopt’的返回结果中有无Shell命令，有的话应该使用’eval’命令来消除可能导致的错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval set -- &quot;$arg&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用完还要进行与手工解析类似的工作，相比手工解析，并没有多大优势；</p>
</li>
<li><p>真的需要长选项吗？我觉得短选项就足够了</p>
</li>
</ol>
<h2 id="getopts处理长选项"><a href="#getopts处理长选项" class="headerlink" title="getopts处理长选项"></a>getopts处理长选项</h2><p>既然不建议使用’getopt’，那么怎么处理长选项呢？自然是有办法的。</p>
<p>为了方便讲解，这里假设一个简单的情景吧，在这个情景里，我们只需要处理两个可能的选项</p>
<ol>
<li>-f/–file: 设置文件名，该选项需要值</li>
<li>-h/–help: 打印帮助信息，该选项不需要值</li>
</ol>
<p>用’getopts’处理这种情况，可以这么做:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">filename=""</span><br><span class="line">while getopts f:h-: opt;do</span><br><span class="line">    case $opt in</span><br><span class="line">        -)</span><br><span class="line">            case $OPTARG in</span><br><span class="line">                help)</span><br><span class="line">                    usage</span><br><span class="line">                    exit 0</span><br><span class="line">                    ;;</span><br><span class="line">                file=*)</span><br><span class="line">                    filename=$&#123;OPTARG#*=&#125;</span><br><span class="line">                    ;;</span><br><span class="line">            esac</span><br><span class="line">            ;;</span><br><span class="line">        f)</span><br><span class="line">            filename=$OPTARG</span><br><span class="line">            ;;</span><br><span class="line">        h)</span><br><span class="line">            usage</span><br><span class="line">            exit 0</span><br><span class="line">            ;;</span><br><span class="line">        \?)</span><br><span class="line">            usage</span><br><span class="line">            exit 1</span><br><span class="line">            ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>当然，也许并不比手工解析简洁多少，但用起来肯定是比’getopt’要舒服的。</p>
<h2 id="在函数中解析参数"><a href="#在函数中解析参数" class="headerlink" title="在函数中解析参数"></a>在函数中解析参数</h2><p>有时候，我们也许想把参数解析的工作放到函数中去做，比如说定义了一个’main’函数然后在’main’函数中封装整个流程处理逻辑。又或者像我一样，写了几个小小的工具函数，放到了Bash的配置文件 <strong>.bashrc</strong> 中，参数解析的工作必须得在函数中做。</p>
<p>手工解析是能想到的最直接的办法，简单可行。</p>
<p>不过假如我们想用’getopts’来处理呢？动手尝试后，你会发现直接在函数中使用’getopts’是会出错的。要在函数中使用’getopts’，必须在这个函数中使用’getopts’前，将 <strong>OPTIND</strong> 这个被’getopts’使用的特殊变量设置为函数局部变量，像这样:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function main() &#123;</span><br><span class="line"></span><br><span class="line">    local OPTIND</span><br><span class="line"></span><br><span class="line">    while getopts d:lb:ch OPT;do</span><br><span class="line">       case $OPT in</span><br><span class="line">           d)</span><br><span class="line">               file_to_trash=$OPTARG</span><br><span class="line">               trash $file_to_trash # trash is a function</span><br><span class="line">               ;;</span><br><span class="line">           l)</span><br><span class="line">               print_trashed_file  # print_trashed_file is a function</span><br><span class="line">               ;;</span><br><span class="line">           b)</span><br><span class="line">               file_to_untrash=$OPTARG</span><br><span class="line">               untrash $file_to_untrash # untrash is a function</span><br><span class="line">               ;;</span><br><span class="line">           c)</span><br><span class="line">               clean_all           # clean all is a function</span><br><span class="line">               ;;</span><br><span class="line">           h)</span><br><span class="line">               usage</span><br><span class="line">               exit 0</span><br><span class="line">               ;;</span><br><span class="line">           \?)</span><br><span class="line">               usage</span><br><span class="line">               exit 1</span><br><span class="line">               ;;</span><br><span class="line">       esac</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main $@</span><br></pre></td></tr></table></figure>

<hr>
<p>本文整理自</p>
<p><a href="https://www.zmonster.me/2014/08/09/pare-arguments-in-shell-function.html" target="_blank" rel="noopener">Shell脚本中参数处理方法</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/18/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Redis常见问题总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-19 02:48:59 / 修改时间：11:18:19" itemprop="dateCreated datePublished" datetime="2020-06-19T02:48:59+08:00">2020-06-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>就我个人而言，我觉得Redis的基本使用是我们每个Java程序员都应该会的。《Redis实战》、《Redis设计与实现》是我比较推荐的两本学习Redis的书籍。</p>
<ol>
<li><strong>Redis的两种持久化操作以及如何保障数据安全（快照和AOF）</strong></li>
<li><strong>如何防止数据出错（Redis事务）</strong></li>
<li><strong>如何使用流水线来提升性能</strong></li>
<li><strong>Redis主从复制</strong></li>
<li><strong>Redis集群的搭建</strong></li>
<li><strong>Redis的几种淘汰策略</strong></li>
<li><strong>Redis集群宕机，数据迁移问题</strong></li>
<li><strong>Redis缓存使用有很多，怎么解决缓存雪崩和缓存穿透？</strong></li>
</ol>
<p><strong>下面就一些问题给大家详细说一下。</strong></p>
<h3 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h3><blockquote>
<p>Redis 是一个使用 C 语言写成的，开源的 key-value 数据库。。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。目前，Vmware在资助着redis项目的开发和维护。</p>
</blockquote>
<h3 id="Redis与Memcached的区别与比较"><a href="#Redis与Memcached的区别与比较" class="headerlink" title="Redis与Memcached的区别与比较"></a>Redis与Memcached的区别与比较</h3><p>1 、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</p>
<p>2 、Redis支持数据的备份，即master-slave模式的数据备份。</p>
<p>3 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中</p>
<p>4、 redis的速度比memcached快很多</p>
<p>5、Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/18/162d7773080d4570?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis与Memcached的区别与比较"></p>
<p>如果想要更详细了解的话，可以查看慕课网上的这篇手记（非常推荐） <strong>：《脚踏两只船的困惑 - Memcached与Redis》</strong>：<a href="https://www.imooc.com/article/23549" target="_blank" rel="noopener">www.imooc.com/article/235…</a></p>
<h3 id="Redis与Memcached的选择"><a href="#Redis与Memcached的选择" class="headerlink" title="Redis与Memcached的选择"></a>Redis与Memcached的选择</h3><p><strong>终极策略：</strong> 使用Redis的String类型做的事，都可以用Memcached替换，以此换取更好的性能提升； 除此以外，优先考虑Redis；</p>
<h3 id="使用redis有哪些好处？"><a href="#使用redis有哪些好处？" class="headerlink" title="使用redis有哪些好处？"></a>使用redis有哪些好处？</h3><p>(1) <strong>速度快</strong>，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p>
<p>(2)<strong>支持丰富数据类型</strong>，支持string，list，set，sorted set，hash</p>
<p>(3) <strong>支持事务</strong> ：redis对事务是部分支持的，如果是在入队时报错，那么都不会执行；在非入队时报错，那么成功的就会成功执行。详细了解请参考：《Redis事务介绍（四）》：<a href="https://blog.csdn.net/cuipeng0916/article/details/53698774" target="_blank" rel="noopener">blog.csdn.net/cuipeng0916…</a></p>
<p>redis监控：锁的介绍</p>
<p>(4) <strong>丰富的特性</strong>：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p>
<h3 id="Redis常见数据结构使用场景"><a href="#Redis常见数据结构使用场景" class="headerlink" title="Redis常见数据结构使用场景"></a>Redis常见数据结构使用场景</h3><h4 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. String</h4><blockquote>
<p><strong>常用命令:</strong>  set,get,decr,incr,mget 等。</p>
</blockquote>
<p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。</p>
<h4 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h4><blockquote>
<p><strong>常用命令：</strong> hget,hset,hgetall 等。</p>
</blockquote>
<p>Hash是一个<strong>String类型的field和value的映射表</strong>，hash特别适合用于存储对象。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。</p>
<p><strong>举个例子：</strong> 最近做的一个电商网站项目的首页就使用了redis的hash数据结构进行缓存，因为一个网站的首页访问量是最大的，所以通常网站的首页可以通过redis缓存来提高性能和并发量。我用<strong>jedis客户端</strong>来连接和操作我搭建的redis集群或者单机redis，利用jedis可以很容易的对redis进行相关操作，总的来说从搭一个简单的集群到实现redis作为缓存的整个步骤不难。感兴趣的可以看我昨天写的这篇文章：</p>
<p><strong>《一文轻松搞懂redis集群原理及搭建与使用》：</strong> <a href="https://juejin.im/post/5ad54d76f265da23970759d3" target="_blank" rel="noopener">juejin.im/post/5ad54d…</a></p>
<h4 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h4><blockquote>
<p><strong>常用命令:</strong> lpush,rpush,lpop,rpop,lrange等</p>
</blockquote>
<p>list就是链表，Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，最新消息排行等功能都可以用Redis的list结构来实现。</p>
<p>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<h4 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h4><blockquote>
<p><strong>常用命令：</strong> sadd,spop,smembers,sunion 等</p>
</blockquote>
<p>set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的。 当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同喜好、二度好友等功能。</p>
<h4 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5.Sorted Set"></a>5.Sorted Set</h4><blockquote>
<p><strong>常用命令：</strong> zadd,zrange,zrem,zcard等</p>
</blockquote>
<p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p>
<p><strong>举例：</strong> 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用Redis中的SortedSet结构进行存储。</p>
<h3 id="MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）"><a href="#MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）" class="headerlink" title="MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）"></a>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）</h3><p>   相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru</strong>：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-enviction</strong>：禁止驱逐(淘汰)数据</li>
</ol>
<h3 id="Redis的并发竞争问题如何解决"><a href="#Redis的并发竞争问题如何解决" class="headerlink" title="Redis的并发竞争问题如何解决?"></a>Redis的并发竞争问题如何解决?</h3><p>Redis为单进程<strong>单线程</strong>模式，<strong>采用队列模式将并发访问变为串行访问</strong>。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：</p>
<p> 1. 客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。  </p>
<ol start="2">
<li>服务器角度，利用setnx实现锁。</li>
</ol>
<p> 注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。</p>
<h3 id="Redis回收进程如何工作的-Redis回收使用的是什么算法"><a href="#Redis回收进程如何工作的-Redis回收使用的是什么算法" class="headerlink" title="Redis回收进程如何工作的? Redis回收使用的是什么算法?"></a>Redis回收进程如何工作的? Redis回收使用的是什么算法?</h3><p><strong>Redis内存回收:LRU算法（写的很不错，推荐）</strong>：<a href="https://www.cnblogs.com/WJ5888/p/4371647.html" target="_blank" rel="noopener">www.cnblogs.com/WJ5888/p/43…</a></p>
<h3 id="Redis-大量数据插入"><a href="#Redis-大量数据插入" class="headerlink" title="Redis 大量数据插入"></a>Redis 大量数据插入</h3><p>官方文档给的解释：<a href="http://www.redis.cn/topics/mass-insert.html" target="_blank" rel="noopener">www.redis.cn/topics/mass…</a></p>
<h3 id="Redis-分区的优势、不足以及分区类型"><a href="#Redis-分区的优势、不足以及分区类型" class="headerlink" title="Redis 分区的优势、不足以及分区类型"></a>Redis 分区的优势、不足以及分区类型</h3><p>官方文档提供的讲解：<a href="http://www.redis.net.cn/tutorial/3524.html" target="_blank" rel="noopener">www.redis.net.cn/tutorial/35…</a></p>
<h3 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h3><p><strong>《redis的持久化和缓存机制》</strong> ：<a href="https://github.com/Snailclimb/Java-Guide/blob/master/数据存储/春夏秋冬又一春之Redis持久化.md" target="_blank" rel="noopener">github.com/Snailclimb/…</a></p>
<p>扩容的话可以通过redis集群实现，之前做项目的时候用过自己搭的redis集群 然后写了一篇关于redis集群的文章：<strong>《一文轻松搞懂redis集群原理及搭建与使用》</strong>：<a href="https://juejin.im/post/5ad54d76f265da23970759d3" target="_blank" rel="noopener">juejin.im/post/5ad54d…</a></p>
<h3 id="Redis常见性能问题和解决方案"><a href="#Redis常见性能问题和解决方案" class="headerlink" title="Redis常见性能问题和解决方案:"></a>Redis常见性能问题和解决方案:</h3><ol>
<li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</li>
<li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</li>
<li>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</li>
<li>尽量避免在压力很大的主库上增加从库</li>
</ol>
<h3 id="Redis与消息队列"><a href="#Redis与消息队列" class="headerlink" title="Redis与消息队列"></a>Redis与消息队列</h3><blockquote>
<p>作者：翁伟 链接：<a href="https://www.zhihu.com/question/20795043/answer/345073457" target="_blank" rel="noopener">https://www.zhihu.com/question/20795043/answer/345073457</a></p>
</blockquote>
<p>不要使用redis去做消息队列，这不是redis的设计目标。但实在太多人使用redis去做去消息队列，redis的作者看不下去，另外基于redis的核心代码，另外实现了一个消息队列disque： antirez/disque:<a href="https://github.com/antirez/disque" target="_blank" rel="noopener">github.com/antirez/dis…</a>部署、协议等方面都跟redis非常类似，并且支持集群，延迟消息等等。</p>
<p>我在做网站过程接触比较多的还是使用redis做缓存，比如秒杀系统，首页缓存等等。</p>
<h3 id="好文Mark"><a href="#好文Mark" class="headerlink" title="好文Mark"></a>好文Mark</h3><p><strong>非常非常推荐下面几篇文章。。。</strong></p>
<p><strong>《Redis深入之道：原理解析、场景使用以及视频解读》</strong>：<a href="https://zhuanlan.zhihu.com/p/28073983" target="_blank" rel="noopener">zhuanlan.zhihu.com/p/28073983</a>: 主要介绍了：Redis集群开源的方案、Redis协议简介及持久化Aof文件解析、Redis短连接性能优化等等内容，文章干货太大，容量很大，建议时间充裕可以看看。另外文章里面还提供了视频讲解，可以说是非常非常用心了。</p>
<p><strong>《阿里云Redis混合存储典型场景：如何轻松搭建视频直播间系统》：</strong><a href="https://yq.aliyun.com/articles/582487?utm_content=m_46529" target="_blank" rel="noopener">yq.aliyun.com/articles/58…</a>: 主要介绍视频直播间系统，以及如何使用阿里云Redis混合存储实例方便快捷的构建大数据量，低延迟的视频直播间服务。还介绍到了我们之前提高过的redis的数据结构的使用场景</p>
<p><strong>《美团在Redis上踩过的一些坑-5.redis cluster遇到的一些问》</strong>：<a href="http://carlosfu.iteye.com/blog/2254573" target="_blank" rel="noopener">carlosfu.iteye.com/blog/225457…</a>：主要介绍了redis集群的两个常见问题，然后分享了 一些关于redis集群不错的文章。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5ad6e4066fb9a028d82c4b66" target="_blank" rel="noopener">面试中关于Redis的问题看这篇就够了</a></p>
<p><a href="https://www.cnblogs.com/Survivalist/p/8119891.html" target="_blank" rel="noopener">https://www.cnblogs.com/Survivalist/p/8119891.html</a></p>
<p><a href="http://www.redis.net.cn/tutorial/3524.html" target="_blank" rel="noopener">http://www.redis.net.cn/tutorial/3524.html</a></p>
<p><a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/18/MySql%20MVCC%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/MySql%20MVCC%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">MySql MVCC机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-19 01:45:34 / 修改时间：09:59:50" itemprop="dateCreated datePublished" datetime="2020-06-19T01:45:34+08:00">2020-06-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Multiversion concurrency control 多版本并发控制</p>
<p>并发访问（读或者写）数据库时，对正在事务内处理的数据做多版本的管理，用来避免由于写操作的堵塞，而引发读操作失败的并发问题。</p>
</blockquote>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>先看一个案例：</p>
<p>1.查看数据的事务隔离级别</p>
<p>对事务隔离级别不熟悉的同学可以参考文章 <a href="https://mp.weixin.qq.com/s/WIqoR0-l7h9SObIzmGDatQ" target="_blank" rel="noopener">【MySQL （三） | 五分钟搞清楚MySQL事务隔离级别】</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure>



<p><img src="https://user-gold-cdn.xitu.io/2019/2/17/168f8c4a50c54d63?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="查看数据库的事务隔离级别"></p>
<p>可见 数据库隔离级别使用的是MySQL默认的RR级别。</p>
<p><strong>REPEATABLE READ</strong> 意味着：</p>
<ul>
<li>同一个事务中多次执行同一个select,读取到的数据没有发生改变；</li>
<li>此时：允许幻读，但不允许不可重复读和脏读，所以RR隔离级别要求解决不可重复读；</li>
</ul>
<p>2.在不同会话中执行以下SQL</p>
<p>补充一下建表语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`test_zq`</span> (</span><br><span class="line">	<span class="string">`id`</span> <span class="built_in">int</span> (<span class="number">11</span>),</span><br><span class="line">	<span class="string">`test_id`</span> <span class="built_in">int</span> (<span class="number">11</span>)</span><br><span class="line">); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`test_zq`</span> (<span class="string">`id`</span>, <span class="string">`test_id`</span>) <span class="keyword">values</span>(<span class="string">'1'</span>,<span class="string">'18'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`test_zq`</span> (<span class="string">`id`</span>, <span class="string">`test_id`</span>) <span class="keyword">values</span>(<span class="string">'4'</span>,<span class="string">'8'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`test_zq`</span> (<span class="string">`id`</span>, <span class="string">`test_id`</span>) <span class="keyword">values</span>(<span class="string">'7'</span>,<span class="string">'4'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`test_zq`</span> (<span class="string">`id`</span>, <span class="string">`test_id`</span>) <span class="keyword">values</span>(<span class="string">'10'</span>,<span class="string">'1234'</span>);</span><br></pre></td></tr></table></figure>

<p>用户1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="comment">-- 更新 id 为 1 的数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> test_zq <span class="keyword">SET</span> test_id = <span class="number">20</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>用户2:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="comment">--查询 id 为 1 的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test_zq <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>执行结果大致如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/17/168f8c50888174f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="执行结果"></p>
<p>根据事务隔离级别来看，我们理论上对获得 X 锁（关于锁的概念可以参考 <a href="http://mp.weixin.qq.com/s?__biz=MzI1Mzg4OTMxNQ==&mid=100000550&idx=1&sn=8a5cdff008fc1eed7b5c623c1bdf4ed1&chksm=69ccdd6a5ebb547c7b7baf6be78763fc5065e0a58de202f3e25d8d8ed56e6d1c1146332cfec1#rd" target="_blank" rel="noopener">【MySQL （四） | 五分钟搞清楚InnoDB锁机制】</a>）的数据行是不能再被获取读锁而访问的，但是事实上我们依然访问到了这个数据！</p>
<p><strong>通过结果说明</strong>：我们可以在一个事务未进行 commit/rollback操作之前，另一个事务仍然可以读取到数据库中的数据，只不过是读取到的是其他事务未改变之前的数据。此处是利用了MVCC多数据做了多版本处理，读取的数据来源于快照。</p>
<p>3.同理，在不同会话中执行以下SQL</p>
<p>用户1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">SELECT * FROM test_zq WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>用户2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update test_zq set test_id &#x3D; 22 where id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>执行完之后再回到用户1进行一次数据查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test_zq WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/17/168f8c6166f8fecf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="执行结果2"></p>
<p>执行结果和上一步的执行结果一样，只不过区别在于2步骤中是先 update 后 select , 3 步骤是先 select 后 update.</p>
<p>虽然两者执行结果是一致的，但是我们要思考两个问题：</p>
<ul>
<li>他们的底层实现是一样的吗？</li>
<li>他们的实现和MVCC有什么关系呢？</li>
</ul>
<p>接下来我们便开始了解一下 MVCC 机制</p>
<h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><blockquote>
<p>MVCC，Multi-Version Concurrency Control，多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；在编程语言中实现事务内存。</p>
</blockquote>
<p>如果有人从数据库中读数据的同时，有另外的人写入数据，有可能读数据的人会看到『半写』或者不一致的数据。有很多种方法来解决这个问题，叫做并发控制方法。最简单的方法，通过加锁，让所有的读者等待写者工作完成，但是这样效率会很差。MVCC 使用了一种不同的手段，每个连接到数据库的读者，<strong>在某个瞬间看到的是数据库的一个快照</strong>，写者写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于其他的读者来说是不可见的。</p>
<p>当一个 MVCC 数据库需要更一个一条数据记录的时候，它不会直接用新数据覆盖旧数据，而是将旧数据标记为过时（obsolete）并在别处增加新版本的数据。这样就会有存储多个版本的数据，但是只有一个是最新的。这种方式允许读者读取在他读之前已经存在的数据，即使这些在读的过程中半路被别人修改、删除了，也对先前正在读的用户没有影响。<strong>这种多版本的方式避免了填充删除操作在内存和磁盘存储结构造成的空洞的开销，但是需要系统周期性整理（sweep through）以真实删除老的、过时的数据。</strong>对于面向文档的数据库（Document-oriented database，也即半结构化数据库）来说，这种方式允许系统将整个文档写到磁盘的一块连续区域上，当需要更新的时候，直接重写一个版本，而不是对文档的某些比特位、分片切除，或者维护一个链式的、非连续的数据库结构。</p>
<p>MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用<strong>时间戳或者事务 ID</strong>去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。<strong>读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据。</strong></p>
<p>一句话总结就是：</p>
<blockquote>
<p>MVCC(<code>Multiversion concurrency control</code>) 就是 同一份数据临时保留多版本的一种方式，进而实现并发控制</p>
</blockquote>
<p>哪么此处需要注意的点就是：</p>
<ul>
<li>在读写并发的过程中如何实现多版本？</li>
<li>在读写并发之后，如何实现旧版本的删除（毕竟很多时候只需要一份最新版的数据就够了）？</li>
</ul>
<p>下面介绍一下MySQL中对于 MVCC 的逻辑实现</p>
<h3 id="MVCC逻辑流程-插入"><a href="#MVCC逻辑流程-插入" class="headerlink" title="MVCC逻辑流程-插入"></a>MVCC逻辑流程-插入</h3><p>在MySQL中建表时，每个表都会有三列隐藏记录，其中和MVCC有关系的有两列</p>
<ul>
<li>数据行的版本号 （DB_TRX_ID）</li>
<li>删除版本号 (DB_ROLL_PT)</li>
</ul>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">test_id</th>
<th align="center">DB_TRX_ID</th>
<th align="center">DB_ROLL_PT</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>在插入数据的时候，假设系统的全局事务ID从1开始，以下SQL语句执行分析参考注释信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin;-- 获取到全局事务ID</span><br><span class="line">insert into &#96;test_zq&#96; (&#96;id&#96;, &#96;test_id&#96;) values(&#39;5&#39;,&#39;68&#39;);</span><br><span class="line">insert into &#96;test_zq&#96; (&#96;id&#96;, &#96;test_id&#96;) values(&#39;6&#39;,&#39;78&#39;);</span><br><span class="line">commit;-- 提交事务</span><br></pre></td></tr></table></figure>

<p>当执行完以上SQL语句之后，表格中的内容会变成：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">test_id</th>
<th align="center">DB_TRX_ID</th>
<th align="center">DB_ROLL_PT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">5</td>
<td align="center">68</td>
<td align="center">1</td>
<td align="center">NULL</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">78</td>
<td align="center">1</td>
<td align="center">NULL</td>
</tr>
</tbody></table>
<p>可以看到，插入的过程中会把全局事务ID记录到列 DB_TRX_ID 中去</p>
<h3 id="MVCC逻辑流程-删除"><a href="#MVCC逻辑流程-删除" class="headerlink" title="MVCC逻辑流程-删除"></a>MVCC逻辑流程-删除</h3><p>对上述表格做删除逻辑，执行以下SQL语句（假设获取到的事务逻辑ID为 3）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin；--获得全局事务ID &#x3D; 3</span><br><span class="line">delete test_zq where id &#x3D; 6;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>执行完上述SQL之后数据并没有被真正删除，而是对删除版本号做改变，如下所示：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">test_id</th>
<th align="center">DB_TRX_ID</th>
<th align="center">DB_ROLL_PT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">5</td>
<td align="center">68</td>
<td align="center">1</td>
<td align="center">NULL</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">78</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
</tbody></table>
<h3 id="MVCC逻辑流程-修改"><a href="#MVCC逻辑流程-修改" class="headerlink" title="MVCC逻辑流程-修改"></a>MVCC逻辑流程-修改</h3><p>修改逻辑和删除逻辑有点相似，修改数据的时候 会先复制一条当前记录行数据，同事标记这条数据的数据行版本号为当前是事务版本号，最后把原来的数据行的删除版本号标记为当前是事务。</p>
<p>执行以下SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;-- 获取全局系统事务ID 假设为 10</span><br><span class="line">update test_zq set test_id &#x3D; 22 where id &#x3D; 5;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>执行后表格实际数据应该是：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">test_id</th>
<th align="center">DB_TRX_ID</th>
<th align="center">DB_ROLL_PT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">5</td>
<td align="center">68</td>
<td align="center">1</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">78</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">22</td>
<td align="center">10</td>
<td align="center">NULL</td>
</tr>
</tbody></table>
<h3 id="MVCC逻辑流程-查询"><a href="#MVCC逻辑流程-查询" class="headerlink" title="MVCC逻辑流程-查询"></a>MVCC逻辑流程-查询</h3><p>此时，数据查询规则如下：</p>
<ul>
<li><p>查找<strong>数据行版本号早于当前事务版本号</strong>的数据行记录</p>
<p>也就是说，数据行的版本号要小于或等于当前是事务的系统版本号，这样也就确保了读取到的数据是当前事务开始前已经存在的数据，或者是自身事务改变过的数据</p>
</li>
<li><p>查找<strong>删除版本号</strong>要么为NULL，要么<strong>大于当前事务版本号</strong>的记录</p>
<p>这样确保查询出来的数据行记录在事务开启之前没有被删除</p>
</li>
</ul>
<p>根据上述规则，我们继续以上张表格为例，对此做查询操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;-- 假设拿到的系统事务ID为 12</span><br><span class="line">select * from test_zq;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>执行结果应该是：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">test_id</th>
<th align="center">DB_TRX_ID</th>
<th align="center">DB_ROLL_PT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">6</td>
<td align="center">22</td>
<td align="center">10</td>
<td align="center">NULL</td>
</tr>
</tbody></table>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5c68a4056fb9a049e063e0ab" target="_blank" rel="noopener">【MySQL（5）| 五分钟搞清楚 MVCC 机制】</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EricMa"
      src="/images/eric.png">
  <p class="site-author-name" itemprop="name">EricMa</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">168</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Eric-Ma-C" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Eric-Ma-C" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chaoma@zju.edu.cn" title="E-Mail → mailto:chaoma@zju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EricMa</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">543k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
