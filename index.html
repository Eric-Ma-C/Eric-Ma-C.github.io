<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Eric&#39;s Blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Eric&#39;s Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="EricMa">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Eric's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Eric's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Better Code, Better Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/29/%E7%90%86%E8%A7%A3virt%20res%20shr%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/29/%E7%90%86%E8%A7%A3virt%20res%20shr%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/" class="post-title-link" itemprop="url">理解virt res shr之间的关系</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-29 12:48:42 / 修改时间：20:50:20" itemprop="dateCreated datePublished" datetime="2020-12-29T12:48:42+08:00">2020-12-29</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>想必在linux上写过程序的同学都有分析进程占用多少内存的经历，或者被问到这样的问题——<code>你的程序在运行时占用了多少内存（物理内存）</code>？通常我们可以通过top命令查看进程占用了多少内存。这里我们可以看到VIRT、RES和SHR三个重要的指标，他们分别代表什么意思呢？这是本文需要跟大家一起探讨的问题。当然如果更加深入一点，你可能会问进程所占用的那些物理内存都用在了哪些地方？这时候top命令可能不能给到你你所想要的答案了，不过我们可以分析proc文件系统提供的smaps文件，这个文件详尽地列出了当前进程所占用物理内存的使用情况。</p>
<h4 id="本文将分为三个部分。"><a href="#本文将分为三个部分。" class="headerlink" title="本文将分为三个部分。"></a>本文将分为三个部分。</h4><p>第一部分简要阐述虚拟内存和驻留内存这两个重要的概念；</p>
<p>第二部分解释top命令中VIRT、RES以及SHR三个参数的实际参考意义；</p>
<p>最后一部分向大家介绍一下smaps文件的格式，通过分析smaps文件我们可以详细了解进程物理内存的使用情况，比如mmap文件占用了多少空间、动态内存开辟消耗了多少空间、函数调用栈消耗了多少空间等等。</p>
<h2 id="关于内存的两个概念"><a href="#关于内存的两个概念" class="headerlink" title="关于内存的两个概念"></a>关于内存的两个概念</h2><p>  要理解top命令关于内存使用情况的输出，我们必须首先搞清楚虚拟内存（Virtual Memory）和驻留内存（Resident Memory）两个概念。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>　　　首先需要强调的是虚拟内存不同于物理内存，虽然两者都包含内存字眼但是它们属于两个不同层面的概念。进程占用虚拟内存空间大并非意味着程序的物理内存也一定占用很大。虚拟内存是操作系统内核为了对进程地址空间进行管理（process address space management）而精心设计的一个逻辑意义上的内存空间概念。我们程序中的指针其实都是这个虚拟内存空间中的地址。比如我们在写完一段C++程序之后都需要采用g++进行编译，这时候编译器采用的地址其实就是虚拟内存空间的地址。因为这时候程序还没有运行，何谈物理内存空间地址？凡是程序运行过程中可能需要用到的指令或者数据都必须在虚拟内存空间中。既然说虚拟内存是一个逻辑意义上（假象的）的内存空间，为了能够让程序在物理机器上运行，那么必须有一套机制可以让这些假象的虚拟内存空间映射到物理内存空间（实实在在的RAM内存条上的空间）。这其实就是操作系统中页映射表（page table）所做的事情了。内核会为系统中每一个进程维护一份相互独立的页映射表。。页映射表的基本原理是将程序运行过程中需要访问的一段虚拟内存空间通过页映射表映射到一段物理内存空间上，这样CPU访问对应虚拟内存地址的时候就可以通过这种查找页映射表的机制访问物理内存上的某个对应的地址。“页（page）”是虚拟内存空间向物理内存空间映射的基本单元。</p>
<p>  下图1演示了虚拟内存空间和物理内存空间的相互关系，它们通过Page Table关联起来。其中虚拟内存空间中着色的部分分别被映射到物理内存空间对应相同着色的部分。而虚拟内存空间中灰色的部分表示在物理内存空间中没有与之对应的部分，也就是说灰色部分没有被映射到物理内存空间中。这么做也是本着“按需映射”的指导思想，因为虚拟内存空间很大，可能其中很多部分在一次程序运行过程中根本不需要访问，所以也就没有必要将虚拟内存空间中的这些部分映射到物理内存空间上。</p>
<p>  到这里为止已经基本阐述了什么是虚拟内存了。总结一下就是，虚拟内存是一个假象的内存空间，在程序运行过程中虚拟内存空间中需要被访问的部分会被映射到物理内存空间中。虚拟内存空间大只能表示程序运行过程中可访问的空间比较大，不代表物理内存空间占用也大。</p>
<p><img src="https://img.orchome.com/group1/M00/00/00/KmCudld5_zmAajUHAABd80xLId0540.png" alt="图1. 虚拟内存空间到物理内存空间映射"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图1. 虚拟内存空间到物理内存空间映射</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="驻留内存"><a href="#驻留内存" class="headerlink" title="驻留内存"></a>驻留内存</h3><p>　　驻留内存，顾名思义是指那些被映射到进程虚拟内存空间的物理内存。上图1中，在系统物理内存空间中被着色的部分都是驻留内存。比如，A1、A2、A3和A4是进程A的驻留内存；B1、B2和B3是进程B的驻留内存。进程的驻留内存就是进程实实在在占用的物理内存。一般我们所讲的进程占用了多少内存，其实就是说的占用了多少驻留内存而不是多少虚拟内存。因为虚拟内存大并不意味着占用的物理内存大。</p>
<p>　　关于虚拟内存和驻留内存这两个概念我们说到这里。下面一部分我们来看看top命令中VIRT、RES和SHR分别代表什么意思。</p>
<p>top命令中VIRT、RES和SHR的含义</p>
<p>   搞清楚了虚拟内存的概念之后解释VIRT的含义就很简单了。VIRT表示的是进程虚拟内存空间大小。对应到图1中的进程A来说就是A1、A2、A3、A4以及灰色部分所有空间的总和。也就是说VIRT包含了在已经映射到物理内存空间的部分和尚未映射到物理内存空间的部分总和。</p>
<p>　　RES的含义是指进程虚拟内存空间中已经映射到物理内存空间的那部分的大小。对应到图1中的进程A来说就是A1、A2、A3以及A4几个部分空间的总和。所以说，看进程在运行过程中占用了多少内存应该看RES的值而不是VIRT的值。</p>
<p>　　最后来看看SHR所表示的含义。SHR是share（共享）的缩写，它表示的是进程占用的共享内存大小。在上图1中我们看到进程A虚拟内存空间中的A4和进程B虚拟内存空间中的B3都映射到了物理内存空间的A4/B3部分。咋一看很奇怪。为什么会出现这样的情况呢？其实我们写的程序会依赖于很多外部的动态库（.so），比如libc.so、libld.so等等。这些动态库在内存中仅仅会保存/映射一份，如果某个进程运行时需要这个动态库，那么动态加载器会将这块内存映射到对应进程的虚拟内存空间中。多个进展之间通过共享内存的方式相互通信也会出现这样的情况。这么一来，就会出现不同进程的虚拟内存空间会映射到相同的物理内存空间。这部分物理内存空间其实是被多个进程所共享的，所以我们将他们称为共享内存，用SHR来表示。某个进程占用的内存除了和别的进程共享的内存之外就是自己的独占内存了。所以要计算进程独占内存的大小只要用RES的值减去SHR值即可。 </p>
<p>进程的smaps文件</p>
<p>　　通过top命令我们已经能看出进程的虚拟空间大小（VIRT）、占用的物理内存（RES）以及和其他进程共享的内存（SHR）。但是仅此而已，如果我想知道如下问题：</p>
<p>进程的虚拟内存空间的分布情况，比如heap占用了多少空间、文件映射（mmap）占用了多少空间、stack占用了多少空间？<br>进程是否有被交换到swap空间的内存，如果有，被交换出去的大小？<br>mmap方式打开的数据文件有多少页在内存中是脏页（dirty page）没有被写回到磁盘的？<br>mmap方式打开的数据文件当前有多少页面已经在内存中，有多少页面还在磁盘中没有加载到page cahe中？<br>等等<br>　　以上这些问题都无法通过top命令给出答案，但是有时候这些问题正是我们在对程序进行性能瓶颈分析和优化时所需要回答的问题。所幸的是，世界上解决问题的方法总比问题本身要多得多。linux通过proc文件系统为每个进程都提供了一个smaps文件，通过分析该文件我们就可以一一回答以上提出的问题。</p>
<p>　　在smaps文件中，每一条记录（如下图2所示）表示进程虚拟内存空间中一块连续的区域。其中第一行从左到右依次表示地址范围、权限标识、映射文件偏移、设备号、inode、文件路径。详细解释可以参见understanding-linux-proc-id-maps。</p>
<p>　　接下来8个字段的含义分别如下：</p>
<ul>
<li>Size：表示该映射区域在虚拟内存空间中的大小。</li>
<li>Rss：表示该映射区域当前在物理内存中占用了多少空间　　　　　　</li>
<li>Shared_Clean：和其他进程共享的未被改写的page的大小</li>
<li>Shared_Dirty： 和其他进程共享的被改写的page的大小</li>
<li>Private_Clean：未被改写的私有页面的大小。</li>
<li>Private_Dirty： 已被改写的私有页面的大小。</li>
<li>Swap：表示非mmap内存（也叫anonymous memory，比如malloc动态分配出来的内存）由于物理内存不足被swap到交换空间的大小。</li>
<li>Pss：该虚拟内存区域平摊计算后使用的物理内存大小(有些内存会和其他进程共享，例如mmap进来的)。比如该区域所映射的物理内存部分同时也被另一个进程映射了，且该部分物理内存的大小为1000KB，那么该进程分摊其中一半的内存，即Pss=500KB。</li>
</ul>
<p><img src="https://img.orchome.com/group1/M00/00/00/KmCudld5_1mACTIIAABwjJ5L35Q936.jpg" alt="screenshot"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图2. smaps文件中的一条记录</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<p>　　有了smap如此详细关于虚拟内存空间到物理内存空间的映射信息，相信大家已经能够通过分析该文件回答上面提出的4个问题。</p>
<p>　  最后希望所有读者能够通过阅读本文对进程的虚拟内存和物理内存有一个更加清晰认识，并能更加准确理解top命令关于内存的输出，最后可以通过smaps文件更进一步分析进程使用内存的情况。</p>
<p>作者：無名<br>链接：<a href="https://www.orchome.com/298" target="_blank" rel="noopener">https://www.orchome.com/298</a></p>
<hr>
<p>本文整理自</p>
<p><a href=""></a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/11/Python%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97(Class,%20Module)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/11/Python%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97(Class,%20Module)/" class="post-title-link" itemprop="url">Python类和模块(Class, Module)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-11 08:50:33 / 修改时间：16:54:16" itemprop="dateCreated datePublished" datetime="2020-12-11T08:50:33+08:00">2020-12-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Python是也是一个面对对象编程(Object-Oriented Programming)的语言，面对对象编程是一种设计思想，意味着我们把对象作为程序的基本单元，而每个对象包含了自己的属性和方法。面向对象编程主要有以下特点：</p>
<ol>
<li>封装（Encapsulation）：对外部世界隐藏对象的工作细节。</li>
<li>继承（Inheritance）：继承使子类具有父类的各种属性和方法，而不需要编写相同的代码。</li>
<li>多态（Polymorphism）：为不同的数据类型的实体提供统一的接口。</li>
</ol>
<p>使用OOP有以下的优点：</p>
<ol>
<li>提高软件开发的生产效率</li>
<li>使软件的可维护性更好</li>
<li>提高软件的质量</li>
</ol>
<p>在 Python 中，元组、列表和字典等数据类型是对象，函数也是对象。那么，我们能创建自己的对象吗？Of Course！跟其他 OOP 语言类似，我们使用<strong>类</strong>（class）来自定义对象。</p>
<h2 id="类和实例（Class-Instance）"><a href="#类和实例（Class-Instance）" class="headerlink" title="类和实例（Class, Instance）"></a>类和实例（Class, Instance）</h2><p>每个类都有自己的属性（attribute）和方法（method），比如一个人的身高、体重和年龄，这些都是属性，而吃饭、说话和洗澡都是方法。（要注意：在class外部定语的可执行函数叫做function，类内部的函数叫做方法method）</p>
<p>类的定义以class为开头，类名的首字母推荐要大写，冒号之后换行缩进紧跟着属性和方法的定义，属性无非就是一个变量的定义，而方法的定义和函数的定义是一样的，也是以def开头。请看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># class</span><br><span class="line">class Person:</span><br><span class="line">    # attribute fields</span><br><span class="line">    name &#x3D; &#39;William&#39;</span><br><span class="line">    age &#x3D; 45</span><br><span class="line">    # method</span><br><span class="line">    def greet(self):</span><br><span class="line">        print(&quot;Hi, my name is &quot; + self.name)</span><br><span class="line"># Create an Object</span><br><span class="line">p1 &#x3D; Person()</span><br><span class="line"># Call the method</span><br><span class="line">p1.greet()</span><br></pre></td></tr></table></figure>

<p>类的定义是一个具体实例（instance）的设计蓝图，在创建实例的时候，我们只要调用类名，然后加括号就可以了。在greet方法中，我们使用了特殊参数self，它永远指向创建的实例本身，所以self.name就会指向当前被创建实例的name属性。p1.greet()是方法调用的示范，我们只要在实例名后加上句号（.）紧跟着方法名，即可调用实例的方法。</p>
<p>我们也可以在创建好实例之后，对它的属性和方法进行修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Modify Object Properties</span><br><span class="line">p1.age &#x3D; 40</span><br><span class="line"></span><br><span class="line"># Delete Object Properties</span><br><span class="line">del p1.age</span><br><span class="line"></span><br><span class="line"># Delete Objects</span><br><span class="line">del p1</span><br></pre></td></tr></table></figure>

<p><code>__init__</code> 是 Python 中的特殊方法（special method），它用于初始化对象。它是一个实例被创建时最先被调用的函数，并且每次创建实例，它的<strong>init</strong>都会被调用，而且它的第一个参数永远是 <code>self</code>，指向创建的实例本身。（init是initial的简写，顾名思义就是用来初始化的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name &#x3D; &#39;Alice&#39;</span><br><span class="line">    def greet(self):</span><br><span class="line">        print(&quot;Hi, my name is &quot; + self.name)</span><br><span class="line">p1 &#x3D; Person()</span><br><span class="line">p1.greet()</span><br></pre></td></tr></table></figure>

<p>我们也可以在<strong>init</strong>方法中添加其他参数，这样我们的的初始化能更加灵活和方便，同时在创建实例的时候，需要传入与<strong>init</strong>方法匹配的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self, init_name):</span><br><span class="line">        self.name &#x3D; init_name</span><br><span class="line">    def greet(self):</span><br><span class="line">        print(&quot;Hi, my name is &quot; + self.name)</span><br><span class="line">p1 &#x3D; Person(&quot;David&quot;)</span><br><span class="line">p1.greet()</span><br></pre></td></tr></table></figure>

<h2 id="继承和多态（Inheritance，Polymorphism）"><a href="#继承和多态（Inheritance，Polymorphism）" class="headerlink" title="继承和多态（Inheritance，Polymorphism）"></a>继承和多态（Inheritance，Polymorphism）</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在面向对象编程中，当我们已经创建了一个类，而又想再创建一个与之相似的类，比如添加几个方法，或者修改原来的方法，这时我们不必从头开始，可以从原来的类派生出一个新的类，我们把原来的类称为父类或基类，而派生出的类称为子类，子类继承了父类的所有数据和方法。</p>
<p>让我们看一个简单的例子，首先我们定义一个 Animal 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Animal():</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">    def greet(self):</span><br><span class="line">        print(&#39;Hello, I am %s.&#39; % self.name)</span><br></pre></td></tr></table></figure>

<p>现在，我们想创建一个 Dog 类，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Dog():</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">    def greet(self):</span><br><span class="line">        print(&#39;WangWang.., I am %s. &#39; % self.name)</span><br></pre></td></tr></table></figure>

<p>可以看到，Dog 类和 Animal 类几乎是一样的，只是 <code>greet</code> 方法不一样，我们完全没必要创建一个新的类，可以直接创建子类（child class）来继承父类Animal：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line">    def greet(self):</span><br><span class="line">        print(&#39;WangWang.., I am %s. &#39; % self.name)</span><br></pre></td></tr></table></figure>

<p>Dog 类是从 Animal 类继承而来的，Dog 类自动获得了 Animal 类的所有数据和方法，而且还可以对从父类继承来的方法进行修改，调用的方式是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animal &#x3D; Animal(&#39;animal&#39;)</span><br><span class="line">animal.greet()</span><br><span class="line">dog &#x3D; Dog(&#39;dog&#39;)</span><br><span class="line">dog.greet()</span><br></pre></td></tr></table></figure>

<p>我们也可以在Dog 类中添加新的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line">    def greet(self):</span><br><span class="line">        print(&#39;WangWang.., I am %s. &#39; % self.name)</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#39;I am running!&#39;)</span><br><span class="line"></span><br><span class="line">dog &#x3D; Dog(&#39;dog&#39;)</span><br><span class="line">dog.greet()</span><br></pre></td></tr></table></figure>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态的概念其实不难理解，它是指对不同类型的参数进行相同的操作，根据对象（或类）类型的不同而表现出不同的行为。继承可以拿到父类的所有数据和方法，子类可以重写父类的方法，也可以新增自己特有的方法。有了继承，才有了多态，这样才能实现为不同的数据类型的实体提供统一的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Animal():</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">    def greet(self):</span><br><span class="line">        print(f&#39;Hello, I am &#123;self.name&#125;.&#39;)</span><br><span class="line"></span><br><span class="line">class Dog(Animal):</span><br><span class="line">    def greet(self):</span><br><span class="line">        print(f&#39;WangWang.., I am &#123;self.name&#125;.&#39;)</span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    def greet(self):</span><br><span class="line">        print(f&#39;MiaoMiao.., I am &#123;self.name&#125;&#39;)</span><br><span class="line"></span><br><span class="line">def hello(animal):</span><br><span class="line">    animal.greet()</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>cat</code> 和 <code>dog</code> 是两个不同的对象，对它们调用 <code>greet</code> 方法，它们会自动调用实际类型的 <code>greet</code> 方法，作出不同的响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dog &#x3D; Dog(&#39;dog&#39;)</span><br><span class="line">hello(dog)</span><br><span class="line">cat &#x3D; Cat(&#39;cat&#39;);</span><br><span class="line">hello(cat)</span><br></pre></td></tr></table></figure>

<h2 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h2><p>在某些情况下，我们希望实例对象可被用于<code>for...in</code>循环，这时我们需要在类中定义<code>__iter__</code>和<code>__next__</code>方法。其中，<code>__iter()__</code>方法返回迭代器对象本身<code>__next()__</code>方法返回容器的下一个元素，在没有后续元素时会抛出<code>StopIteration</code>异常。（Python 的 <code>for</code> 循环实质上是先通过内置函数 <code>iter()</code> 获得一个迭代器，然后再不断调用 <code>next()</code> 函数实现的。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Fib():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a, self.b &#x3D; 0, 1</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b &#x3D; self.b, self.a + self.b</span><br><span class="line">        return self.a</span><br><span class="line"></span><br><span class="line">fib &#x3D; Fib()</span><br><span class="line">for i in fib:</span><br><span class="line">    if i &gt; 10: </span><br><span class="line">         break</span><br><span class="line">    print(i)# 1, 1, 2, 3, 5, 8</span><br></pre></td></tr></table></figure>

<h2 id="访问限制-underscore"><a href="#访问限制-underscore" class="headerlink" title="访问限制 underscore"></a>访问限制 underscore</h2><p>在某些情况下，我们希望限制用户访问对象的属性或方法，也就是希望它是私有的，对外隐蔽。比如，对于上面的例子，我们希望 <code>name</code> 属性在外部不能被访问，我们可以在属性或方法的名称前面加上两个下划线，即 <code>__</code>，以下是对之前例子的改动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Animal():</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.__name &#x3D; name</span><br><span class="line">    def greet(self):</span><br><span class="line">        print(f&#39;Hello, I am self.__name.&#39;)</span><br><span class="line"></span><br><span class="line">animal &#x3D; Animal(&#39;a1&#39;)</span><br><span class="line">animal.__name # error</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在 Python 中，以双下划线开头，并且以双下划线结尾（即 <code>__xxx__</code>）的变量是特殊变量，特殊变量是可以直接访问的。所以，不要用 <code>__name__</code> 这样的变量名。另外，如果变量名前面只有一个下划线_，表示此变量不要随便访问，虽然它可以直接被访问。</p>
<h2 id="模块调用"><a href="#模块调用" class="headerlink" title="模块调用"></a>模块调用</h2><p>有时候一个模块中放不了许多的类，那么我们就要把一些类放入其他的模块中，当我们需要那些类的时候，只需要调用对应模块即可。创建一个模块很简单，只要把代码保存在一个文件中，然后加上后缀.py即可。你可以任意命名文件名，但是必须以.py为后缀。以下我们在animal.py文件中定义了多个不同的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># animal.py</span><br><span class="line">class Animal():</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">    def greet(self):</span><br><span class="line">        print(f&#39;Hello, I am &#123;self.name&#125;.&#39;)</span><br><span class="line"></span><br><span class="line">class Dog(Animal):</span><br><span class="line">    def greet(self):</span><br><span class="line">        print(f&#39;WangWang.., I am &#123;self.name&#125;.&#39;)</span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    def greet(self):</span><br><span class="line">        print(f&#39;MiaoMiao.., I am &#123;self.name&#125;&#39;)</span><br></pre></td></tr></table></figure>

<p>如果要在其他文件中调用单个类的不同方法，使用import语句即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from animal import Animal</span><br><span class="line">animal &#x3D; Animal(&#39;animal&#39;)</span><br><span class="line">animal.greet()</span><br></pre></td></tr></table></figure>

<p>调用多个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from animal import Dog, Cat</span><br><span class="line">dog &#x3D; Dog(&#39;duoduo&#39;)</span><br><span class="line">dog.greet()</span><br><span class="line">cat &#x3D; Cat(&#39;Kitty&#39;)</span><br><span class="line">cat.greet()</span><br></pre></td></tr></table></figure>

<p>其他调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># importing an entire module</span><br><span class="line">import animal</span><br><span class="line">cat &#x3D; animal.Cat(&#39;Kitty&#39;)</span><br><span class="line"></span><br><span class="line"># import all classes from a model</span><br><span class="line">from animal import *</span><br><span class="line">cat &#x3D; Cat(&#39;Kitty&#39;)</span><br><span class="line"></span><br><span class="line"># Using Aliases </span><br><span class="line">from animal import Cat as C</span><br><span class="line">cat &#x3D; C(&#39;Kitty&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="Python标准库（Python-Standard-Library）"><a href="#Python标准库（Python-Standard-Library）" class="headerlink" title="Python标准库（Python Standard Library）"></a>Python标准库（Python Standard Library）</h3><p>现在我们已经对函数和类有基础的认识了，我们来聊聊如何使用别人编写好的库，Python有自己的标准库，我们下载Python的时候，它们已经被默认安装了，其中有很多现成的模块供我们调用，我们试一下用random模块做做一些随机数操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from random import randint, choice</span><br><span class="line"># Generate a random number between 1 and 6</span><br><span class="line">print(randint(1, 6))</span><br><span class="line"></span><br><span class="line">players &#x3D; [&#39;alice&#39;, &#39;david&#39;, &#39;charles&#39;, &#39;michael&#39;]</span><br><span class="line"># choose a randomly chosen element</span><br><span class="line">random_pick &#x3D; choice(players)</span><br><span class="line">print(random_pick)</span><br></pre></td></tr></table></figure>

<h3 id="PIP包管理器"><a href="#PIP包管理器" class="headerlink" title="PIP包管理器"></a>PIP包管理器</h3><p>有的时候，我们想要使用别人编写好的模块，我们可以通过包管理器下载别人的包（package），包是由很多module组成的，来实现某种功能。库（library）是抽象概念，也可以是各种模块组成。而Python中最流行的包管理器就是pip。pip3的安装请大家自行搜索，网上有很多的教程，以下我会使用一个和图像处理相关的模块。</p>
<p>PIL（Python Image Library）是Python中的标准图像处理库。PIL功能强大，而且API非常简单易用。由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫<a href="https://github.com/python-pillow/Pillow" target="_blank" rel="noopener">Pillow</a>，支持最新Python 3.x，又加入了许多新特性，因此，我们可以直接安装使用Pillow。以下是安装pillow的命令行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pillow</span><br></pre></td></tr></table></figure>

<p>然后我们可以创建一个Python，使用PIL的模块，写出一段可以把照片弄模糊的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image, ImageFilter</span><br><span class="line"></span><br><span class="line"># Open an image</span><br><span class="line">im &#x3D; Image.open(&#39;test.jpg&#39;)</span><br><span class="line"># Use bluring filter</span><br><span class="line">im2 &#x3D; im.filter(ImageFilter.BLUR)</span><br><span class="line">im2.save(&#39;blur.jpg&#39;, &#39;jpeg&#39;)</span><br></pre></td></tr></table></figure>

<p>包管理器让我们可以直接使用前人的轮子，简化我们的开发过程。</p>
<h2 id="类的编写规范-Styling-Classes"><a href="#类的编写规范-Styling-Classes" class="headerlink" title="类的编写规范 Styling Classes"></a>类的编写规范 Styling Classes</h2><p>类的名字最好使用骆驼命名法（CamelCase），也就是让每个单词的第一个字母大写，不使用下划线分割单词。实例和模块的名字最好都使用Snake case，也就是所有字母都小写，然后使用下划线分割。当然这不是强制的，但这是工业界比较合理的命名规范，大家可以参照一下Google的Python代码规范：<a href="http://google.github.io/styleguide/pyguide.html" target="_blank" rel="noopener">http://google.github.io/styleguide/pyguide.html</a></p>
<p>您可以使用空行来组织代码，但不要过度使用它们。在一个类中，您可以在方法之间使用一个空行，而在一个模块中，您可以使用两个空行来分隔类。</p>
<p>如果需要从标准库和编写的模块中导入模块，请首先将标准库模块的调用语句写在最前面。然后添加一个空行，再调用自己编写的模块。在具有多个import语句的程序中，此约定使查看程序中使用的不同模块的来源更加容易。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://turingplanet.org/2019/09/21/%E7%B1%BB-class/" target="_blank" rel="noopener">Python类和模块(Class, Module)</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/24/SQL%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%8F%AA%E4%BF%9D%E7%95%99%E4%B8%80%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/SQL%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%8F%AA%E4%BF%9D%E7%95%99%E4%B8%80%E8%A1%8C/" class="post-title-link" itemprop="url">SQL删除重复数据，只保留一行</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-24 11:51:13 / 修改时间：19:54:56" itemprop="dateCreated datePublished" datetime="2020-08-24T11:51:13+08:00">2020-08-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在sql的使用中，我们总是碰到需要删除重复数据的情况，但是又不能全部删除完，必须要保留至少一个重复的数据。重复的记录根据两个字段<strong>a2,a3</strong>判断（实际使用中可以拓展为多个）</p>
<h3 id="eg：表A"><a href="#eg：表A" class="headerlink" title="eg：表A"></a>eg：表A</h3><table>
<thead>
<tr>
<th>a1</th>
<th>a2</th>
<th>a3</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<p>在上述的表中第三行和第四行重复，我们要选择一行删除，流程如下：</p>
<ol>
<li>选择重复的行：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *,<span class="keyword">count</span>(*) </span><br><span class="line"><span class="keyword">from</span> A <span class="keyword">group</span> <span class="keyword">by</span> a2,a3 </span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>a1</th>
<th>a2</th>
<th>a3</th>
<th>count(*)</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<ol>
<li>使用in来找到我们想要的ID</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> A </span><br><span class="line"><span class="keyword">WHERE</span> (a2,a3) <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> A.<span class="string">`a2`</span>,A.<span class="string">`a3`</span> </span><br><span class="line"><span class="keyword">FROM</span> A </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> A.<span class="string">`a2`</span>,A.<span class="string">`a3`</span> </span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>得到的结果如下:</p>
<p>|a1|a2|a3|<br>| — | — |<br>|3|2|2|<br>|4|2|2|<br>|6|2|2|<br> 那么后面就很好办了：</p>
<p>3.选出要删除的值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> A </span><br><span class="line"><span class="keyword">WHERE</span> (a2, a3) <span class="keyword">IN</span> </span><br><span class="line">  (<span class="keyword">SELECT</span> <span class="string">`a2`</span>,<span class="string">`a3`</span> </span><br><span class="line">  <span class="keyword">FROM</span> A </span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> A.<span class="string">`a2`</span>,A.<span class="string">`a3`</span> </span><br><span class="line">  <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">1</span>) </span><br><span class="line">  <span class="keyword">AND</span> a1 <span class="keyword">NOT</span> <span class="keyword">IN</span> </span><br><span class="line">  (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(a1) </span><br><span class="line">  <span class="keyword">FROM</span> A </span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> A.<span class="string">`a2`</span>,A.<span class="string">`a3`</span> </span><br><span class="line">  <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">1</span>) ;</span><br></pre></td></tr></table></figure>

<p>结果是保留a1最小的值，其他选项全部选出，<br> <strong>请注意</strong>此时并不是将Select 改为delete就可以了，如果你直接这样子改的话，会报如下错误：</p>
<blockquote>
<p>You can’t specify target table ‘A’ for update in FROM clause</p>
</blockquote>
<p>该错误提示你，不能先select出同一表中的某些值，再update这个表(在同一语句中）。所以要稍微修改一下。</p>
<ol>
<li>删除值<br> sql语句如下：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//创建中间表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> F(a1 <span class="built_in">INTEGER</span>,a2 <span class="built_in">INTEGER</span>,a3 <span class="built_in">INTEGER</span>);</span><br><span class="line">//将要删除的数据插入中间表</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> F (</span><br><span class="line"><span class="keyword">SELECT</span> *  </span><br><span class="line"><span class="keyword">FROM</span> A </span><br><span class="line"><span class="keyword">WHERE</span> (a2, a3) <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="string">`a2`</span>,<span class="string">`a3`</span> </span><br><span class="line">  <span class="keyword">FROM</span> A <span class="keyword">GROUP</span> <span class="keyword">BY</span> A.<span class="string">`a2`</span>,A.<span class="string">`a3`</span> </span><br><span class="line">  <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">1</span>) </span><br><span class="line">  <span class="keyword">AND</span> a1 <span class="keyword">NOT</span> <span class="keyword">IN</span> </span><br><span class="line">  (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(a1) <span class="keyword">FROM</span> A </span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> A.<span class="string">`a2`</span>,A.<span class="string">`a3`</span> </span><br><span class="line">  <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">1</span>)) ;</span><br><span class="line">//删除中间表</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> a1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> a1 <span class="keyword">FROM</span> F);</span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> A;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p>|a1|a2|a3|<br>|—|—|<br>|1|1|1|<br>|2|1|2|<br>|3|2|2|<br>|5|3|3|</p>
<p>完毕</p>
<p>注：如果说不用保留一行数据的话那么就简单多了，只需要一个很简单的sql语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> (a2,a3) <span class="keyword">IN</span> (<span class="keyword">SELECT</span> a2,a3 <span class="keyword">FROM</span> A <span class="keyword">GROUP</span> <span class="keyword">BY</span> a2,a3 <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<hr>
<p>本文整理自</p>
<p><a href="https://www.jianshu.com/p/4f64d63b3351" target="_blank" rel="noopener">SQL删除重复数据，只保留一行</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/24/MySQL%20%E7%99%BE%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/MySQL%20%E7%99%BE%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">MySQL 百万级数据量分页查询方法及其优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-24 11:40:54 / 修改时间：19:48:37" itemprop="dateCreated datePublished" datetime="2020-08-24T11:40:54+08:00">2020-08-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="方法1-直接使用数据库提供的SQL语句"><a href="#方法1-直接使用数据库提供的SQL语句" class="headerlink" title="方法1: 直接使用数据库提供的SQL语句"></a><strong>方法1: 直接使用数据库提供的SQL语句</strong></h4><ul>
<li>语句样式: MySQL中,可用如下方法: SELECT * FROM 表名称 LIMIT M,N</li>
<li>适应场景: 适用于数据量较少的情况(元组百/千级)</li>
<li>原因/缺点: 全表扫描,速度会很慢 且 有的数据库结果集返回不稳定(如某次返回1,2,3,另外的一次返回2,1,3). Limit限制的是从结果集的M位置处取出N条输出,其余抛弃.</li>
</ul>
<h4 id="方法2-建立主键或唯一索引-利用索引-假设每页10条"><a href="#方法2-建立主键或唯一索引-利用索引-假设每页10条" class="headerlink" title="方法2: 建立主键或唯一索引, 利用索引(假设每页10条)"></a><strong>方法2: 建立主键或唯一索引, 利用索引(假设每页10条)</strong></h4><ul>
<li>语句样式: MySQL中,可用如下方法: SELECT * FROM 表名称 WHERE id_pk &gt; (pageNum*10) LIMIT M</li>
<li>适应场景: 适用于数据量多的情况(元组数上万)</li>
<li>原因: 索引扫描,速度会很快. 有朋友提出: 因为数据查询出来并不是按照pk_id排序的，所以会有漏掉数据的情况，只能方法3</li>
</ul>
<h4 id="方法3-基于索引再排序"><a href="#方法3-基于索引再排序" class="headerlink" title="方法3: 基于索引再排序"></a><strong>方法3: 基于索引再排序</strong></h4><ul>
<li>语句样式: MySQL中,可用如下方法: SELECT * FROM 表名称 WHERE id_pk &gt; (pageNum*10) ORDER BY id_pk ASC LIMIT M</li>
<li>适应场景: 适用于数据量多的情况(元组数上万). 最好ORDER BY后的列对象是主键或唯一所以,使得ORDERBY操作能利用索引被消除但结果集是稳定的(稳定的含义,参见方法1)</li>
<li>原因: 索引扫描,速度会很快. 但MySQL的排序操作,只有ASC没有DESC(DESC是假的,未来会做真正的DESC,期待…).</li>
</ul>
<h4 id="方法4-基于索引使用prepare"><a href="#方法4-基于索引使用prepare" class="headerlink" title="方法4: 基于索引使用prepare"></a><strong>方法4: 基于索引使用prepare</strong></h4><p>第一个问号表示pageNum，第二个？表示每页元组数</p>
<ul>
<li>语句样式: MySQL中,可用如下方法: PREPARE stmt_name FROM SELECT * FROM 表名称 WHERE id_pk &gt; (？* ？) ORDER BY id_pk ASC LIMIT M</li>
<li>适应场景: 大数据量</li>
<li>原因: 索引扫描,速度会很快. prepare语句又比一般的查询语句快一点。</li>
</ul>
<h4 id="方法5-利用MySQL支持ORDER操作可以利用索引快速定位部分元组-避免全表扫描"><a href="#方法5-利用MySQL支持ORDER操作可以利用索引快速定位部分元组-避免全表扫描" class="headerlink" title="方法5: 利用MySQL支持ORDER操作可以利用索引快速定位部分元组,避免全表扫描"></a><strong>方法5: 利用MySQL支持ORDER操作可以利用索引快速定位部分元组,避免全表扫描</strong></h4><p>比如: 读第1000到1019行元组(pk是主键/唯一键).</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> pk&gt;=<span class="number">1000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> pk <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">20</span></span><br></pre></td></tr></table></figure>

<h4 id="方法6-利用子查询-连接-索引快速定位元组的位置-然后再读取元组"><a href="#方法6-利用子查询-连接-索引快速定位元组的位置-然后再读取元组" class="headerlink" title="方法6: 利用子查询/连接+索引快速定位元组的位置,然后再读取元组."></a><strong>方法6: 利用子查询/连接+索引快速定位元组的位置,然后再读取元组.</strong></h4><p>比如(id是主键/唯一键,蓝色字体时变量)</p>
<p>利用子查询示例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt;=</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> your_table <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">LIMIT</span> ($page<span class="number">-1</span>)*$pagesize <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">LIMIT</span> $pagesize</span><br></pre></td></tr></table></figure>

<p>利用连接示例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> your_table <span class="keyword">AS</span> t1</span><br><span class="line"><span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> your_table <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">LIMIT</span> ($page<span class="number">-1</span>)*$pagesize <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.id &lt;= t2.id <span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.id <span class="keyword">desc</span> <span class="keyword">LIMIT</span> $pagesize;</span><br></pre></td></tr></table></figure>

<p>mysql大数据量使用limit分页，随着页码的增大，查询效率越低下。</p>
<h4 id="测试实验"><a href="#测试实验" class="headerlink" title="测试实验"></a><strong>测试实验</strong></h4><h5 id="1-直接用limit-start-count分页语句，-也是我程序中用的方法："><a href="#1-直接用limit-start-count分页语句，-也是我程序中用的方法：" class="headerlink" title="1.  直接用limit start, count分页语句， 也是我程序中用的方法："></a>1.  直接用limit start, count分页语句， 也是我程序中用的方法：</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="keyword">start</span>, <span class="keyword">count</span></span><br></pre></td></tr></table></figure>

<p>当起始页较小时，查询没有性能问题，我们分别看下从10， 100， 1000， 10000开始分页的执行时间（每页取20条）。</p>
<p>如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">10</span>, <span class="number">20</span>   <span class="number">0.016</span>秒</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">100</span>, <span class="number">20</span>   <span class="number">0.016</span>秒</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">1000</span>, <span class="number">20</span>   <span class="number">0.047</span>秒</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">10000</span>, <span class="number">20</span>   <span class="number">0.094</span>秒</span><br></pre></td></tr></table></figure>

<p>我们已经看出随着起始记录的增加，时间也随着增大， 这说明分页语句limit跟起始页码是有很大关系的，那么我们把起始记录改为40w看下（也就是记录的一般左右）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">400000</span>, <span class="number">20</span>   <span class="number">3.229</span>秒</span><br></pre></td></tr></table></figure>

<p>再看我们取最后一页记录的时间</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">866613</span>, <span class="number">20</span>   <span class="number">37.44</span>秒</span><br></pre></td></tr></table></figure>

<p>像这种分页最大的页码页显然这种时间是无法忍受的。</p>
<p>从中我们也能总结出两件事情：</p>
<ol>
<li>limit语句的查询时间与起始记录的位置成正比</li>
<li>mysql的limit语句是很方便，但是对记录很多的表并不适合直接使用。</li>
</ol>
<h5 id="2-对limit分页问题的性能优化方法"><a href="#2-对limit分页问题的性能优化方法" class="headerlink" title="2.  对limit分页问题的性能优化方法"></a><strong>2.  对limit分页问题的性能优化方法</strong></h5><p>利用表的覆盖索引来加速分页查询</p>
<p>我们都知道，利用了索引查询的语句中如果只包含了那个索引列（覆盖索引），那么这种情况会查询很快。</p>
<p>因为利用索引查找有优化算法，且数据就在查询索引上面，不用再去找相关的数据地址了，这样节省了很多时间。另外Mysql中也有相关的索引缓存，在并发高的时候利用缓存就效果更好了。</p>
<p>在我们的例子中，我们知道id字段是主键，自然就包含了默认的主键索引。现在让我们看看利用覆盖索引的查询效果如何。</p>
<p>这次我们之间查询最后一页的数据（利用覆盖索引，只包含id列），如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">866613</span>, <span class="number">20</span> <span class="number">0.2</span>秒</span><br></pre></td></tr></table></figure>

<p>相对于查询了所有列的37.44秒，提升了大概100多倍的速度</p>
<p>那么如果我们也要查询所有列，有两种方法，一种是id&gt;=的形式，另一种就是利用join，看下实际情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> <span class="keyword">ID</span> &gt; =(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">866613</span>, <span class="number">1</span>) <span class="keyword">limit</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>查询时间为0.2秒！</p>
<p>另一种写法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> product a <span class="keyword">JOIN</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">866613</span>, <span class="number">20</span>) b <span class="keyword">ON</span> a.ID = b.id</span><br></pre></td></tr></table></figure>

<p>查询时间也很短！</p>
<h5 id="3-复合索引优化方法"><a href="#3-复合索引优化方法" class="headerlink" title="3.  复合索引优化方法"></a><strong>3.  复合索引优化方法</strong></h5><p>MySql 性能到底能有多高？MySql 这个数据库绝对是适合dba级的高手去玩的，一般做一点1万篇新闻的小型系统怎么写都可以，用xx框架可以实现快速开发。可是数据量到了10万，百万至千万，他的性能还能那么高吗？一点小小的失误，可能造成整个系统的改写，甚至更本系统无法正常运行！好了，不那么多废话了。</p>
<p>用事实说话，看例子：</p>
<p>数据表 collect ( id, title ,info ,vtype) 就这4个字段，其中 title 用定长，info 用text, id 是逐渐，vtype是tinyint，vtype是索引。这是一个基本的新闻系统的简单模型。现在往里面填充数据，填充10万篇新闻。最后collect 为 10万条记录，数据库表占用硬1.6G。</p>
<p>OK ,看下面这条sql语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title <span class="keyword">from</span> <span class="keyword">collect</span> <span class="keyword">limit</span> <span class="number">1000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>很快；基本上0.01秒就OK，再看下面的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title <span class="keyword">from</span> <span class="keyword">collect</span> <span class="keyword">limit</span> <span class="number">90000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>从9万条开始分页，结果？</p>
<p>8-9秒完成，my god 哪出问题了？其实要优化这条数据，网上找得到答案。看下面一条语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">collect</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">90000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>很快，0.04秒就OK。为什么？因为用了id主键做索引当然快。网上的改法是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,title <span class="keyword">from</span> <span class="keyword">collect</span> <span class="keyword">where</span> <span class="keyword">id</span>&gt;=(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">collect</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">90000</span>,<span class="number">1</span>) <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这就是用了id做索引的结果。可是问题复杂那么一点点，就完了。看下面的语句</p>
<p>select id from collect where vtype=1 order by id limit 90000,10; 很慢，用了8-9秒！</p>
<p>到了这里我相信很多人会和我一样，有崩溃感觉！vtype 做了索引了啊？怎么会慢呢？vtype做了索引是不错，你直接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">collect</span> <span class="keyword">where</span> vtype=<span class="number">1</span> <span class="keyword">limit</span> <span class="number">1000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>是很快的，基本上0.05秒，可是提高90倍，从9万开始，那就是0.05*90=4.5秒的速度了。和测试结果8-9秒到了一个数量级。</p>
<p>从这里开始有人提出了分表的思路，这个和dis #cuz 论坛是一样的思路。思路如下：</p>
<p>建一个索引表：t (id,title,vtype) 并设置成定长，然后做分页，分页出结果再到 collect 里面去找info 。是否可行呢？实验下就知道了。</p>
<p>10万条记录到 t(id,title,vtype) 里，数据表大小20M左右。用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> vtype=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">90000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>很快了。基本上0.1-0.2秒可以跑完。为什么会这样呢？我猜想是因为collect 数据太多，所以分页要跑很长的路。limit 完全和数据表的大小有关的。其实这样做还是全表扫描，只是因为数据量小，只有10万才快。OK， 来个疯狂的实验，加到100万条，测试性能。加了10倍的数据，马上t表就到了200多M，而且是定长。还是刚才的查询语句，时间是0.1-0.2秒完成！分表性能没问题？</p>
<p>错！因为我们的limit还是9万，所以快。给个大的，90万开始</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> vtype=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">900000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>看看结果，时间是1-2秒！why ?</p>
<p>分表了时间还是这么长，非常之郁闷！有人说定长会提高limit的性能，开始我也以为，因为一条记录的长度是固定的，mysql 应该可以算出90万的位置才对啊？可是我们高估了mysql 的智能，他不是商务数据库，事实证明定长和非定长对limit影响不大？怪不得有人说discuz到了100万条记录就会很慢，我相信这是真的，这个和数据库设计有关！</p>
<p>难道MySQL 无法突破100万的限制吗？？？到了100万的分页就真的到了极限？</p>
<p>答案是：NO 为什么突破不了100万是因为不会设计mysql造成的。下面介绍非分表法，来个疯狂的测试！一张表搞定100万记录，并且10G 数据库，如何快速分页！</p>
<p>好了，我们的测试又回到 collect表，开始测试结论是：</p>
<p>30万数据，用分表法可行，超过30万他的速度会慢道你无法忍受！当然如果用分表+我这种方法，那是绝对完美的。但是用了我这种方法后，不用分表也可以完美解决！</p>
<p>答案就是：复合索引！有一次设计mysql索引的时候，无意中发现索引名字可以任取，可以选择几个字段进来，这有什么用呢？</p>
<p>开始的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">collect</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">90000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这么快就是因为走了索引，可是如果加了where 就不走索引了。抱着试试看的想法加了 search(vtype,id) 这样的索引。</p>
<p>然后测试</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">collect</span> <span class="keyword">where</span> vtype=<span class="number">1</span> <span class="keyword">limit</span> <span class="number">90000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>非常快！0.04秒完成！</p>
<p>再测试:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> ,title <span class="keyword">from</span> <span class="keyword">collect</span> <span class="keyword">where</span> vtype=<span class="number">1</span> <span class="keyword">limit</span> <span class="number">90000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>非常遗憾，8-9秒，没走search索引！</p>
<p>再测试：search(id,vtype)，还是select id 这个语句，也非常遗憾，0.5秒。</p>
<p>综上：如果对于有where 条件，又想走索引用limit的，必须设计一个索引，将where 放第一位，limit用到的主键放第2位，而且只能select 主键！</p>
<p>完美解决了分页问题了。可以快速返回id就有希望优化limit ， 按这样的逻辑，百万级的limit 应该在0.0x秒就可以分完。看来mysql 语句的优化和索引时非常重要的！</p>
<hr>
<p>本文整理自</p>
<p><a href="cnblogs.com/geningchao/p/6649907.html">MySQL 百万级数据量分页查询方法及其优化</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/18/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/18/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Linux内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-19 02:02:51 / 修改时间：10:05:32" itemprop="dateCreated datePublished" datetime="2020-08-19T02:02:51+08:00">2020-08-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天来带大家研究一下<code>Linux</code>内存管理。对于精通 <code>CURD</code> 的业务同学，内存管理好像离我们很远，但这个知识点虽然冷门（估计很多人学完根本就没机会用上）但绝对是基础中的基础，这就像武侠中的内功修炼，学完之后看不到立竿见影的效果，但对你日后的开发工作是大有裨益的，因为你站的更高了。</p>
<p>前提约定：本文讨论技术内容前提，操作系统环境都是 <code>x86</code>架构的 32 位 <code>Linux</code>系统。</p>
<h2 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h2><p>即使是现代操作系统中，内存依然是计算机中很宝贵的资源，看看你电脑几个T固态硬盘，再看看内存大小就知道了。为了充分利用和管理系统内存资源，Linux采用虚拟内存管理技术，利用虚拟内存技术让每个进程都有<code>4GB</code> 互不干涉的虚拟地址空间。</p>
<p>进程初始化分配和操作的都是基于这个「虚拟地址」，只有当进程需要实际访问内存资源的时候才会建立虚拟地址和物理地址的映射，调入物理内存页。</p>
<p>打个不是很恰当的比方。这个原理其实和现在的某某网盘一样，假如你的网盘空间是<code>1TB</code>，真以为就一口气给了你这么大空间吗？那还是太年轻，都是在你往里面放东西的时候才给你分配空间，你放多少就分多少实际空间给你，但你和你朋友看起来就像大家都拥有<code>1TB</code>空间一样。</p>
<h3 id="虚拟地址的好处"><a href="#虚拟地址的好处" class="headerlink" title="虚拟地址的好处"></a>虚拟地址的好处</h3><ul>
<li>避免用户直接访问物理内存地址，防止一些破坏性操作，保护操作系统</li>
<li>每个进程都被分配了4GB的虚拟内存，用户程序可使用比实际物理内存更大的地址空间</li>
</ul>
<p><code>4GB</code> 的进程虚拟地址空间被分成两部分：「用户空间」和「内核空间」</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a6aaf6064?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="用户空间内核空间"></p>
<h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>上面章节我们已经知道不管是用户空间还是内核空间，使用的地址都是虚拟地址，当需进程要实际访问内存的时候，会由内核的「请求分页机制」产生「缺页异常」调入物理内存页。</p>
<p>把虚拟地址转换成内存的物理地址，这中间涉及利用<code>MMU</code> 内存管理单元（Memory Management Unit ) 对虚拟地址分段和分页（段页式）地址转换，关于分段和分页的具体流程，这里不再赘述，可以参考任何一本计算机组成原理教材描述。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a6abc1636?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="段页式内存管理地址转换"></p>
<p><code>Linux</code> 内核会将物理内存分为3个管理区，分别是：</p>
<h3 id="ZONE-DMA"><a href="#ZONE-DMA" class="headerlink" title="ZONE_DMA"></a>ZONE_DMA</h3><p><code>DMA</code>内存区域。包含0MB~16MB之间的内存页框，可以由老式基于<code>ISA</code>的设备通过<code>DMA</code>使用，直接映射到内核的地址空间。</p>
<h3 id="ZONE-NORMAL"><a href="#ZONE-NORMAL" class="headerlink" title="ZONE_NORMAL"></a>ZONE_NORMAL</h3><p>普通内存区域。包含16MB~896MB之间的内存页框，常规页框，直接映射到内核的地址空间。</p>
<h3 id="ZONE-HIGHMEM"><a href="#ZONE-HIGHMEM" class="headerlink" title="ZONE_HIGHMEM"></a>ZONE_HIGHMEM</h3><p>高端内存区域。包含896MB以上的内存页框，不进行直接映射，可以通过永久映射和临时映射进行这部分内存页框的访问。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a6d1a5191?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="物理内存区划分"></p>
<h2 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h2><p>用户进程能访问的是「用户空间」，每个进程都有自己独立的用户空间，虚拟地址范围从从 <code>0x00000000</code> 至 <code>0xBFFFFFFF</code> 总容量3G 。</p>
<p>用户进程通常只能访问用户空间的虚拟地址，只有在执行内陷操作或系统调用时才能访问内核空间。</p>
<h3 id="进程与内存"><a href="#进程与内存" class="headerlink" title="进程与内存"></a>进程与内存</h3><p>进程（执行的程序）占用的用户空间按照「 访问属性一致的地址空间存放在一起 」的原则，划分成 <code>5</code>个不同的内存区域。 访问属性指的是“可读、可写、可执行等 。</p>
<ul>
<li><p>代码段</p>
<p>代码段是用来存放可执行文件的操作指令，可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，它是不可写的。</p>
</li>
<li><p>数据段</p>
<p>数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量和全局变量。</p>
</li>
<li><p>BSS段</p>
<p><code>BSS</code>段包含了程序中未初始化的全局变量，在内存中 <code>bss</code> 段全部置零。</p>
</li>
<li><p>堆 <code>heap</code></p>
<p>堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p>
</li>
<li><p>栈 <code>stack</code></p>
<p>栈是用户存放程序临时创建的局部变量，也就是函数中定义的变量（但不包括 <code>static</code> 声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p>
</li>
</ul>
<p>上述几种内存区域中数据段、<code>BSS</code> 段、堆通常是被连续存储在内存中，在位置上是连续的，而代码段和栈往往会被独立存放。堆和栈两个区域在 <code>i386</code> 体系结构中栈向下扩展、堆向上扩展，相对而生。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a71e78b4c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="程序内存区域分段"></p>
<p>你也可以再linux下用<code>size</code> 命令查看编译后程序的各个内存区域大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lemon ~]# size &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;sshd</span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line">1924532	  12412	 426896	2363840	 2411c0	&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;sshd</span><br></pre></td></tr></table></figure>

<h2 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h2><p>在 <code>x86 32</code> 位系统里，Linux 内核地址空间是指虚拟地址从 <code>0xC0000000</code> 开始到 <code>0xFFFFFFFF</code> 为止的高端内存地址空间，总计 <code>1G</code> 的容量， 包括了内核镜像、物理页面表、驱动程序等运行在内核空间 。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a958cdbeb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="内核空间细分区域."></p>
<h4 id="直接映射区"><a href="#直接映射区" class="headerlink" title="直接映射区"></a>直接映射区</h4><p>直接映射区 <code>Direct Memory Region</code>：从内核空间起始地址开始，最大<code>896M</code>的内核空间地址区间，为直接内存映射区。</p>
<p>直接映射区的896MB的「线性地址」直接与「物理地址」的前<code>896MB</code>进行映射，也就是说线性地址和分配的物理地址都是连续的。内核地址空间的线性地址<code>0xC0000001</code>所对应的物理地址为<code>0x00000001</code>，它们之间相差一个偏移量<code>PAGE_OFFSET = 0xC0000000</code></p>
<p>该区域的线性地址和物理地址存在线性转换关系「线性地址 = <code>PAGE_OFFSET</code> + 物理地址」也可以用 <code>virt_to_phys()</code>函数将内核虚拟空间中的线性地址转化为物理地址。</p>
<h4 id="高端内存线性地址空间"><a href="#高端内存线性地址空间" class="headerlink" title="高端内存线性地址空间"></a>高端内存线性地址空间</h4><p>内核空间线性地址从 896M 到 1G 的区间，容量 128MB 的地址区间是高端内存线性地址空间，为什么叫高端内存线性地址空间？下面给你解释一下：</p>
<p>前面已经说过，内核空间的总大小 1GB，从内核空间起始地址开始的 896MB 的线性地址可以直接映射到物理地址大小为 896MB 的地址区间。退一万步，即使内核空间的1GB线性地址都映射到物理地址，那也最多只能寻址 1GB 大小的物理内存地址范围。</p>
<p>请问你现在你家的内存条多大？快醒醒都 0202 年了，一般 PC 的内存都大于 1GB 了吧！</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a95ad1545?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>所以，内核空间拿出了最后的 128M 地址区间，划分成下面三个高端内存映射区，以达到对整个物理地址范围的寻址。而在 64 位的系统上就不存在这样的问题了，因为可用的线性地址空间远大于可安装的内存。</p>
<h5 id="动态内存映射区"><a href="#动态内存映射区" class="headerlink" title="动态内存映射区"></a>动态内存映射区</h5><p><code>vmalloc Region</code> 该区域由内核函数<code>vmalloc</code>来分配，特点是：线性空间连续，但是对应的物理地址空间不一定连续。 <code>vmalloc</code> 分配的线性地址所对应的物理页可能处于低端内存，也可能处于高端内存。</p>
<h5 id="永久内存映射区"><a href="#永久内存映射区" class="headerlink" title="永久内存映射区"></a>永久内存映射区</h5><p><code>Persistent Kernel Mapping Region</code> 该区域可访问高端内存。访问方法是使用 <code>alloc_page (_GFP_HIGHMEM)</code> 分配高端内存页或者使用<code>kmap</code>函数将分配到的高端内存映射到该区域。</p>
<h5 id="固定映射区"><a href="#固定映射区" class="headerlink" title="固定映射区"></a>固定映射区</h5><p><code>Fixing kernel Mapping Region</code> 该区域和 4G 的顶端只有 4k 的隔离带，其每个地址项都服务于特定的用途，如 <code>ACPI_BASE</code> 等。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a94f6a870?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p>
<h2 id="回顾一下"><a href="#回顾一下" class="headerlink" title="回顾一下"></a>回顾一下</h2><p>上面讲的有点多，先别着急进入下一节，在这之前我们再来回顾一下上面所讲的内容。如果认真看完上面的章节，我这里再画了一张图，现在你的脑海中应该有这样一个内存管理的全局图。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7a9b3cf2c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="内核空间用户空间全图"></p>
<h2 id="内存数据结构"><a href="#内存数据结构" class="headerlink" title="内存数据结构"></a>内存数据结构</h2><p>要让内核管理系统中的虚拟内存，必然要从中抽象出内存管理数据结构，内存管理操作如「分配、释放等」都基于这些数据结构操作，这里列举两个管理虚拟内存区域的数据结构。</p>
<h3 id="用户空间内存数据结构"><a href="#用户空间内存数据结构" class="headerlink" title="用户空间内存数据结构"></a>用户空间内存数据结构</h3><p>在前面「进程与内存」章节我们提到，Linux进程可以划分为 5 个不同的内存区域，分别是：代码段、数据段、<code>BSS</code>、堆、栈，内核管理这些区域的方式是，将这些内存区域抽象成<code>vm_area_struct</code>的内存管理对象。</p>
<p><code>vm_area_struct</code>是描述进程地址空间的基本管理单元，一个进程往往需要多个<code>vm_area_struct</code>来描述它的用户空间虚拟地址，需要使用「链表」和「红黑树」来组织各个<code>vm_area_struct</code>。</p>
<p>链表用于需要遍历全部节点的时候用，而红黑树适用于在地址空间中定位特定内存区域。内核为了内存区域上的各种不同操作都能获得高性能，所以同时使用了这两种数据结构。</p>
<p>用户空间进程的地址管理模型：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7aae19dce8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="wm_arem_struct"></p>
<h3 id="内核空间动态分配内存数据结构"><a href="#内核空间动态分配内存数据结构" class="headerlink" title="内核空间动态分配内存数据结构"></a>内核空间动态分配内存数据结构</h3><p>在内核空间章节我们提到过「动态内存映射区」，该区域由内核函数<code>vmalloc</code>来分配，特点是：线性空间连续，但是对应的物理地址空间不一定连续。 <code>vmalloc</code> 分配的线性地址所对应的物理页可能处于低端内存，也可能处于高端内存。</p>
<p><code>vmalloc</code> 分配的地址则限于<code>vmalloc_start</code>与<code>vmalloc_end</code>之间。每一块<code>vmalloc</code>分配的内核虚拟内存都对应一个<code>vm_struct</code>结构体，不同的内核空间虚拟地址之间有<code>4k</code>大小的防越界空闲区间隔区。与用户空间的虚拟地址特性一样，这些虚拟地址与物理内存没有简单的映射关系，必须通过内核页表才可转换为物理地址或物理页，它们有可能尚未被映射，当发生缺页时才真正分配物理页面。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/20/17195b7aae171d87?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="动态内存映射"></p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p><code>Linux</code>内存管理是一个非常复杂的系统，本文所述只是冰山一角，从宏观角度给你展现内存管理的全貌，但一般来说，这些知识在你和面试官聊天的时候还是够用的，当然我也希望大家能够通过读书了解更深层次的原理。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/6844904132378116104" target="_blank" rel="noopener">面试问了解Linux内存管理吗？10张图给你安排的明明白白！</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/17/MySQL%E4%B8%ADnull%E5%80%BC%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/17/MySQL%E4%B8%ADnull%E5%80%BC%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">MySQL中null值建立索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-17 12:14:36" itemprop="dateCreated datePublished" datetime="2020-08-17T12:14:36+08:00">2020-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-24 19:42:43" itemprop="dateModified" datetime="2020-08-24T19:42:43+08:00">2020-08-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>不知道从什么时候开始，网上流传着这么一个说法：</p>
<blockquote>
<p>MySQL的WHERE子句中包含 IS NULL、IS NOT NULL、!= 这些条件时便不能使用索引查询，只能使用全表扫描。</p>
</blockquote>
<p>这种说法愈演愈烈，甚至被很多同学奉为真理。咱啥话也不说，举个例子。假如我们有个表<code>s1</code>，结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s1 (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key3 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">KEY</span> idx_key1 (key1),</span><br><span class="line">    <span class="keyword">KEY</span> idx_key2 (key2),</span><br><span class="line">    <span class="keyword">KEY</span> idx_key3 (key3),</span><br><span class="line">    <span class="keyword">KEY</span> idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) <span class="keyword">Engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>这个表里有10000条记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(*) FROM s1;</span><br><span class="line">+----------+</span><br><span class="line">| COUNT(*) |</span><br><span class="line">+----------+</span><br><span class="line">|    10000 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>下边我们直接贴几个图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f089efb9cf6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqmch3p1f881eqmvb29gk1tom6e.png-40.7kB"></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f089f21818c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqmbf5616fb1g0b1trv13elsst61.png-40.7kB"></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f089f885438?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqmarklhku131o18rs15281min5k.png-40.2kB"></p>
<p>上边几个查询语句的<code>WHERE</code>子句中用了<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>!=</code>这些条件，但是从它们的执行计划中可以看出来，这些语句都采用了相应的二级索引执行查询，而不是使用所谓的全表扫描，谣言不攻自破。当然，戳破这些谣言并不是本文的目的，本文来更细致的分析一下这些查询到底是怎么执行的。</p>
<h2 id="NULL值是怎么在记录中存储的"><a href="#NULL值是怎么在记录中存储的" class="headerlink" title="NULL值是怎么在记录中存储的"></a>NULL值是怎么在记录中存储的</h2><p>在MySQL中，每一条记录都有它固定的格式，我们以<code>InnoDB</code>存储引擎的<code>Compact</code>行格式为例，来看一下<code>NULL</code>值是怎样存储的。在<code>Compact</code>行格式下，一条记录是由下边这几个部分构成的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f089fc7cd5e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqmp377ebqgqf15e1tuv1qri6r.png-72.8kB"></p>
<p>为了故事的顺利发展，我们新建一个称之为<code>record_format_demo</code>的表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> record_format_demo (</span><br><span class="line">     c1 <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">     c2 <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">     c3 <span class="built_in">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">     c4 <span class="built_in">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line"> ) <span class="keyword">CHARSET</span>=<span class="keyword">ascii</span> ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>

<p>因为我们的重点是<code>NULL</code>值是如何存储在记录中的，所以重点唠叨一下行格式的<code>NULL值列表</code>部分，其他的部分可以到小册中查看。存储<code>NULL</code>值的过程如下：</p>
<ol>
<li><p>首先统计表中允许存储<code>NULL</code>的列有哪些。</p>
<p>我们前边说过，主键列、被<code>NOT NULL</code>修饰的列都是不可以存储<code>NULL</code>值的，所以在统计的时候不会把这些列算进去。比方说表<code>record_format_demo</code>的3个列<code>c1</code>、<code>c3</code>、<code>c4</code>都是允许存储<code>NULL</code>值的，而<code>c2</code>列是被<code>NOT NULL</code>修饰，不允许存储<code>NULL</code>值。</p>
</li>
<li><p>如果表中没有允许存储<code>NULL</code>的列，则<code>NULL值列表</code>也不存在了，否则将每个允许存储<code>NULL</code>的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：</p>
<ul>
<li>二进制位的值为<code>1</code>时，代表该列的值为<code>NULL</code>。</li>
<li>二进制位的值为<code>0</code>时，代表该列的值不为<code>NULL</code>。</li>
</ul>
<p>因为表<code>record_format_demo</code>有3个值允许为<code>NULL</code>的列，所以这3个列和二进制位的对应关系就是这样：</p>
</li>
</ol>
<p>   <img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f089f7318fb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqn3dt810cpog1l4710q637q78.png-19.3kB"></p>
<p>   再一次强调，二进制位按照列的顺序逆序排列，所以第一个列<code>c1</code>和最后一个二进制位对应。</p>
<ol start="3">
<li><p>设计<code>InnoDB</code>的大叔规定<code>NULL值列表</code>必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。</p>
<p>表<code>record_format_demo</code>只有3个值允许为<code>NULL</code>的列，对应3个二进制位，不足一个字节，所以在字节的高位补0，效果就是这样：</p>
</li>
</ol>
<p>   <img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f08a0464a01?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqn48071s0i104314m31isi1ks97l.png-37.7kB"></p>
<p>   以此类推，如果一个表中有9个允许为<code>NULL</code>，那这个记录的<code>NULL值列表</code>部分就需要2个字节来表示了。</p>
<p>假设我们现在向<code>record_format_demo</code>表中插入一条记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO record_format_demo(c1, c2, c3, c4)</span><br><span class="line">    VALUES(&#39;eeee&#39;, &#39;fff&#39;, NULL, NULL);</span><br></pre></td></tr></table></figure>

<p>这条记录的<code>c1</code>、<code>c3</code>、<code>c4</code>这3个列中<code>c3</code>和<code>c4</code>的值都为<code>NULL</code>，所以这3个列对应的二进制位的情况就是：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f08cbf7699e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqng28g7df1l68r4737p3a882.png-38.6kB"></p>
<p>所以这记录的<code>NULL值列表</code>用十六进制表示就是：<code>0x06</code>。</p>
<h2 id="键值为NULL的记录是怎么在B-树中存放的"><a href="#键值为NULL的记录是怎么在B-树中存放的" class="headerlink" title="键值为NULL的记录是怎么在B+树中存放的"></a>键值为NULL的记录是怎么在B+树中存放的</h2><p>对于InnoDB存储引擎来说，记录都是存储在页面中的（一个页面默认是16KB大小），这些页面可以作为<code>B+</code>树的节点而组成一个索引，类似这种样子（只是用下边的图举个B+树的例子而已，跟我们上边列举的表没关系）：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f08ccc49370?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqnp86e76v16h31l7qk21v458f.png-296kB"></p>
<p>聚簇索引和二级索引都对应着像上图一样的<code>B+</code>树（也就是说有多少个索引就有多少棵对应的<code>B+</code>树），不过：</p>
<ul>
<li>对于聚簇索引索引来说，页面中的记录是按照主键值进行排序的；而对于二级索引来说，页面中的记录是按照给定的索引列的值进行排序的。</li>
<li>对于聚簇索引来说，B+树每一层节点（页面）都是按照页中记录的主键值大小进行排序的；而对于二级索引来说，B+树每一层节点（页面）都是按照页中记录的给定的索引列的值进行排序的。</li>
<li>对于聚簇索引来说，B+树叶子节点对应的页面中存储的是完整的用户记录（就是一条记录中包含我们定义的所有列值，还包含一些InnoDB自己添加的一些隐藏列）；而对于二级索引来说，B+树叶子节点对应的页面中存储的只是<code>索引列的值 + 主键值</code>。</li>
</ul>
<p>按规定，一条记录的主键值不允许存储<code>NULL</code>值，所以下边语句中的WHERE子句结果肯定为<code>FALSE</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE primary_key IS NULL;</span><br></pre></td></tr></table></figure>

<p>像这样的语句优化器自己就能判定出WHERE子句必定为NULL，所以压根儿不会去执行它，不信我们看（Extra信息提示WHERE子句压根儿不成立）：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f08ce14ddc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqofhth2941mtorq72f1nqf8s.png-35.5kB"></p>
<p>对于二级索引来说，索引列的值可能为<code>NULL</code>。那对于索引列值为<code>NULL</code>的二级索引记录来说，它们被放在<code>B+</code>树的哪里呢？答案是：放在B+树的最左边。比方说我们有如下查询语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 IS NULL;</span><br></pre></td></tr></table></figure>

<p>那它的查询示意图就如下所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb6f08d1c53f83?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1dfqqjqnahm6176uta91j7j1q8ram.png-52.9kB"></p>
<p>从图中可以看出，对于<code>s1</code>表的二级索引<code>idx_key1</code>来说，值为<code>NULL</code>的二级索引记录都被放在了<code>B+</code>树的最左边，这是因为设计<code>InnoDB</code>的大叔有这样的规定：</p>
<blockquote>
<p>We define the SQL null to be the smallest possible value of a field.</p>
</blockquote>
<p>也就是说他们把SQL中的<code>NULL</code>值认为是列中最小的值。</p>
<p>在通过二级索引<code>idx_key1</code>对应的<code>B+</code>树快速定位到叶子节点中符合条件的最左边的那条记录后，也就是本例中<code>id</code>值为<code>521</code>的那条记录之后，就可以顺着每条记录都有的<code>next_record</code>属性沿着由记录组成的单向链表去获取记录了，直到某条记录的<code>key1</code>列不为NULL。</p>
<blockquote>
<p>小贴士： 通过B+树快速定位到叶子节点的记录的过程是靠一个所谓的页目录（Page Directory）做到的，不过这不是本文的重点，大家可以到小册中翻看，都有详细解释。</p>
</blockquote>
<h2 id="使不使用索引的依据到底是什么？"><a href="#使不使用索引的依据到底是什么？" class="headerlink" title="使不使用索引的依据到底是什么？"></a>使不使用索引的依据到底是什么？</h2><p>那既然<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>!=</code>这些条件都可能使用到索引，那到底什么时候索引，什么时候采用全表扫描呢？</p>
<p>答案很简单：成本。当然，关于如何定量的计算使用某个索引执行查询的成本比较复杂，我们在小册中花了很大的篇幅来唠叨了。不过因为篇幅有限，我们在这里只准备定性的分析一下。对于使用二级索引进行查询来说，成本组成主要有两个方面：</p>
<ul>
<li>读取二级索引记录的成本</li>
<li>将二级索引记录执行回表操作，也就是到聚簇索引中找到完整的用户记录的操作所付出的成本。</li>
</ul>
<p>很显然，要扫描的二级索引记录条数越多，那么需要执行的回表操作的次数也就越多，达到了某个比例时，使用二级索引执行查询的成本也就超过了全表扫描的成本（举一个极端的例子，比方说要扫描的全部的二级索引记录，那就要对每条记录执行一遍回表操作，自然不如直接扫描聚簇索引来的快）。</p>
<p>所以MySQL优化器在真正执行查询之前，对于每个可能使用到的索引来说，都会预先计算一下需要扫描的二级索引记录的数量，比方说对于下边这个查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 IS NULL;</span><br></pre></td></tr></table></figure>

<p>优化器会分析出此查询只需要查找<code>key1</code>值为<code>NULL</code>的记录，然后访问一下二级索引<code>idx_key1</code>，看一下值为<code>NULL</code>的记录有多少（如果符合条件的二级索引记录数量较少，那么统计结果是精确的，如果太多的话，会采用一定的手段计算一个模糊的值，当然算法也比较麻烦，我们就不展开说了，小册里有说），这种在查询真正执行前优化器就率先访问索引来计算需要扫描的索引记录数量的方式称之为<code>index dive</code>。当然，对于某些查询，比方说WHERE子句中有IN条件，并且IN条件中包含许多参数的话，比方说这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ... , &#39;zzzzzzz&#39;);</span><br></pre></td></tr></table></figure>

<p>这样的话需要统计的<code>key1</code>值所在的区间就太多了，这样就不能采用<code>index dive</code>的方式去真正的访问二级索引<code>idx_key1</code>，而是需要采用之前在背地里产生的一些统计数据去估算匹配的二级索引记录有多少条（很显然根据统计数据去估算记录条数比<code>index dive</code>的方式精确性差了很多）。</p>
<p>反正不论采用<code>index dive</code>还是依据统计数据估算，最终要得到一个需要扫描的二级索引记录条数，如果这个条数占整个记录条数的比例特别大，那么就趋向于使用全表扫描执行查询，否则趋向于使用这个索引执行查询。</p>
<p>理解了这个也就好理解为什么在WHERE子句中出现<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>!=</code>这些条件仍然可以使用索引，本质上都是优化器去计算一下对应的二级索引数量占所有记录数量的比值而已。</p>
<h2 id="不信谣，不传谣"><a href="#不信谣，不传谣" class="headerlink" title="不信谣，不传谣"></a>不信谣，不传谣</h2><p>大家可以看到，MySQL中决定使不使用某个索引执行查询的依据很简单：就是成本够不够小。而不是是否在WHERE子句中用了<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>!=</code>这些条件。大家以后也多多辟谣吧，没那么复杂，只是一个成本而已。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/6844903921450745863" target="_blank" rel="noopener">MySQL中IS NULL、IS NOT NULL、!=不能用索引？胡扯！</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/17/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%AE%A1%E7%AE%97Java%E5%AF%B9%E8%B1%A1%E6%89%80%E5%8D%A0%E5%86%85%E5%AD%98%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/17/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%AE%A1%E7%AE%97Java%E5%AF%B9%E8%B1%A1%E6%89%80%E5%8D%A0%E5%86%85%E5%AD%98%EF%BC%9F/" class="post-title-link" itemprop="url">如何正确计算Java对象所占内存？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-17 11:56:07 / 修改时间：19:57:11" itemprop="dateCreated datePublished" datetime="2020-08-17T11:56:07+08:00">2020-08-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java应用上线前，常常需要估算所需的内存，从而设置正确的内存选项参数。正确计算Java对象所占内存从而估算应用的整体所占内存，就显得很有必要。那么，如何计算Java对象所占的内存呢？</p>
<h3 id="1-Java对象的内存布局"><a href="#1-Java对象的内存布局" class="headerlink" title="1.Java对象的内存布局"></a>1.Java对象的内存布局</h3><p>计算Java对象所占内存，首先需要了解Java对象的内存布局。一个Java对象在内存中可以分为三部分：<strong>对象头、实例数据和对齐填充</strong>。关于对象头的详细介绍可查看<a href="https://www.jianshu.com/p/3d38cba67f8b" target="_blank" rel="noopener">这篇文章</a>；实例数据即Java的成员字段，包括基本类型和对象引用；对齐填充并不必须存在，只用作占位对齐字节。一个对象的内存布局示意如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">|---------------------------|</span>-----------------<span class="params">|---------|</span></span><br><span class="line"><span class="params">|       Object Header       |</span>  Instance Data  <span class="params">| Padding |</span></span><br><span class="line"><span class="params">|-----------|</span>---------------<span class="params">|-----------------|</span>---------<span class="params">|</span></span><br><span class="line"><span class="params">|</span> Mark Word <span class="params">| Klass Pointer |</span> field1<span class="params">|filed2|</span>  <span class="params">| Padding |</span></span><br><span class="line"><span class="params">|-----------|</span>---------------<span class="params">|-----------------|</span>---------<span class="params">|</span></span><br></pre></td></tr></table></figure>

<p>需要注意以下几点：</p>
<ol>
<li>对象默认以8字节对齐，即对象所占空间必须是8的整数倍。默认对齐字节数可以使用选项<em>-XX:ObjectAlignmentInBytes=num</em>设置，最小值为8，最大值为256。</li>
<li>为了避免空间浪费，实例数据会进行重排序，排序的优先级为： long = double  &gt; int = float &gt; char = short &gt; byte &gt; boolean &gt; object reference。</li>
<li>继承体系里不同类的字段<strong>不会混合</strong>在一起，父类成员字段分配之后才会分配子类，每个类里的字段遵循第2条规则。</li>
<li>继承体系里不同类间需要8字节对齐。</li>
<li>在继承体系中，父类层次中有至少4字节的空闲而子类含有4字节及其以下的字段，将按优先级：int = float &gt; char = short &gt; byte &gt; boolean &gt; object reference填充这4字节。<strong>对象头部如果有剩余也会使用该规则填充</strong>。</li>
</ol>
<h3 id="2-内存布局实例研究"><a href="#2-内存布局实例研究" class="headerlink" title="2.内存布局实例研究"></a>2.内存布局实例研究</h3><p>为了方便的研究对象所占的内存，建议使用官方提供的<a href="https://link.jianshu.com?t=http%3A%2F%2Fopenjdk.java.net%2Fprojects%2Fcode-tools%2Fjol%2F" target="_blank" rel="noopener">jol工具</a>，如果使用<code>Maven</code>，只需加入如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后便可以愉快的查看内存布局了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(ClassLayout.parseClass(Object<span class="class">.<span class="keyword">class</span>).<span class="title">toPrintable</span>())</span>;</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(<span class="keyword">new</span> Integer(<span class="number">1</span>)).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码第一行的输出如下（JDK8 64 bit）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object <span class="keyword">object</span> internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>    <span class="number">12</span>        (<span class="keyword">object</span> header)                           N/A</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next <span class="keyword">object</span> alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes <span class="keyword">internal</span> + <span class="number">4</span> bytes <span class="keyword">external</span> = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>

<p>由于目前的计算机基本为64位架构，所以忽略32位JVM，只对64位进行讨论。由于JDK8以后默认开启<code>-XX:CompressedOops</code>选项，所以上述为开启指针压缩的结果。</p>
<h4 id="2-1-int-VS-Integer"><a href="#2-1-int-VS-Integer" class="headerlink" title="2.1 int VS Integer"></a>2.1 int VS Integer</h4><p>Java中，一个int占4个字节，那么<code>Integer</code>对象占多少字节呢？Integer对象中只有一个<code>value</code>字段用于存储实际的整数。不开启指针压缩时，其布局为：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">|-------------------------------------------|</span>----------------<span class="params">|-----------------|</span></span><br><span class="line"><span class="params">|                Object Header              |</span>  Instance Data <span class="params">|      Padding    |</span></span><br><span class="line"><span class="params">|-------------------|</span>-----------------------<span class="params">|----------------|</span>-----------------<span class="params">|</span></span><br><span class="line"><span class="params">|</span> Mark Word(<span class="number">8</span> byte) <span class="params">| Klass Pointer(8 byte) |</span>  value(<span class="number">4</span> byte) <span class="params">| Padding(4 byte) |</span></span><br><span class="line"><span class="params">|-------------------|</span>-----------------------<span class="params">|----------------|</span>-----------------<span class="params">|</span></span><br></pre></td></tr></table></figure>

<p>开启指针压缩时，内存布局为：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">|-------------------------------------------|</span>----------------<span class="params">|</span></span><br><span class="line"><span class="params">|</span>                Object Header              <span class="params">|  Instance Data |</span></span><br><span class="line"><span class="params">|-------------------|</span>-----------------------<span class="params">|----------------|</span></span><br><span class="line"><span class="params">| Mark Word(8 byte) |</span> Klass Pointer(<span class="number">4</span> byte) <span class="params">|  value(4 byte) |</span></span><br><span class="line"><span class="params">|-------------------|</span>-----------------------<span class="params">|----------------|</span></span><br></pre></td></tr></table></figure>

<p>可知如果不开启指针压缩，一个<code>Integer</code>对象需要占用24字节，就算开启指针压缩也需要占用16字节，是<code>int</code>的四倍多。<code>Integer</code>的内存占用超出想象，由此在Java中产生了许多优化方案。考虑Java集合，其中的对象泛型不支持基本数据类型，而只能使用<code>Integer</code>，<code>Long</code>等包装器类，这样将会耗费过多的内存。为了节约内存，一些开源工具支持基本类型的容器，比如：<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fleventov%2FKoloboke" target="_blank" rel="noopener">Koloboke</a>。</p>
<h4 id="2-2-字段重排序"><a href="#2-2-字段重排序" class="headerlink" title="2.2 字段重排序"></a>2.2 字段重排序</h4><p>为了更高效的使用内存，实例数据字段将会重排序。排序的优先级为： long = double  &gt; int = float &gt; char = short &gt; byte &gt; boolean &gt; object reference。如下所示的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FieldTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> a;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">boolean</span> d;</span><br><span class="line">    <span class="keyword">long</span> e;</span><br><span class="line">    Object f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将会重排序为（开启<code>CompressedOops</code>选项）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OFFSET  SIZE               TYPE DESCRIPTION            </span><br><span class="line">    <span class="number">16</span>     <span class="number">8</span>               <span class="keyword">long</span> FieldTest.e            </span><br><span class="line">    <span class="number">24</span>     <span class="number">4</span>                <span class="keyword">int</span> FieldTest.c            </span><br><span class="line">    <span class="number">28</span>     <span class="number">1</span>               <span class="keyword">byte</span> FieldTest.a            </span><br><span class="line">    <span class="number">29</span>     <span class="number">1</span>            <span class="keyword">boolean</span> FieldTest.d            </span><br><span class="line">    <span class="number">30</span>     <span class="number">2</span>              (alignment/padding gap)</span><br><span class="line">    <span class="number">32</span>     <span class="number">8</span>   java.lang.Object FieldTest.f</span><br></pre></td></tr></table></figure>

<h4 id="2-3-继承体系的布局"><a href="#2-3-继承体系的布局" class="headerlink" title="2.3 继承体系的布局"></a>2.3 继承体系的布局</h4><p>继承体系中，类间不混排，而是独立分隔开，但每个类中的字段遵循前述的优先级。如下的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">long</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重排序的结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OFFSET  SIZE   TYPE DESCRIPTION    </span><br><span class="line">    <span class="number">16</span>     <span class="number">8</span>   <span class="keyword">long</span> Father.c       </span><br><span class="line">    <span class="number">24</span>     <span class="number">4</span>    <span class="keyword">int</span> Father.a       </span><br><span class="line">    <span class="number">28</span>     <span class="number">4</span>    <span class="keyword">int</span> Father.b       </span><br><span class="line">    <span class="number">32</span>     <span class="number">8</span>   <span class="keyword">long</span> Child.d</span><br></pre></td></tr></table></figure>

<p>不开启指针压缩时，如果继承体系中的类字段没有占满8字节，将补齐字节对齐8字节。如下的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">byte</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> d;</span><br><span class="line">    <span class="keyword">byte</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重排序的结果为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OFFSET  SIZE   TYPE DESCRIPTION            </span><br><span class="line">    <span class="number">16</span>     <span class="number">8</span>   <span class="keyword">long</span> Father.a               </span><br><span class="line">    <span class="number">24</span>     <span class="number">1</span>   <span class="keyword">byte</span> Father.b               </span><br><span class="line">    <span class="number">25</span>     <span class="number">1</span>   <span class="keyword">byte</span> Father.c               </span><br><span class="line">    <span class="number">26</span>     <span class="number">6</span>        (alignment/padding gap)</span><br><span class="line">    <span class="number">32</span>     <span class="number">8</span>   <span class="keyword">long</span> Child.d                </span><br><span class="line">    <span class="number">40</span>     <span class="number">1</span>   <span class="keyword">byte</span> Child.e                </span><br><span class="line">    <span class="number">41</span>     <span class="number">7</span>        (alignment/padding gap)</span><br></pre></td></tr></table></figure>

<p>开启指针压缩时，情况稍有不同：如果父类层次中有至少4字节的空闲，则子类中如果含有4字节及其以下的字段，将按优先级：int = float &gt; char = short &gt; byte &gt; boolean &gt; object reference填充。开启指针压缩时，由于对象头只有12字节，剩余的4字节也将按这样的规则填充。如下的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">long</span> a;</span><br><span class="line">    <span class="keyword">byte</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> e;</span><br><span class="line">    <span class="keyword">long</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重排序的结果为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                             </span><br><span class="line">    <span class="number">12</span>     <span class="number">1</span>   <span class="keyword">byte</span> Father.b                                </span><br><span class="line">    <span class="number">13</span>     <span class="number">1</span>   <span class="keyword">byte</span> Father.c                                </span><br><span class="line">    <span class="number">14</span>     <span class="number">2</span>        (alignment/padding gap)                 </span><br><span class="line">    <span class="number">16</span>     <span class="number">8</span>   <span class="keyword">long</span> Father.a                                </span><br><span class="line">    <span class="number">24</span>     <span class="number">8</span>   <span class="keyword">long</span> Child.d                                 </span><br><span class="line">    <span class="number">32</span>     <span class="number">1</span>   <span class="keyword">byte</span> Child.e                                 </span><br><span class="line">    <span class="number">33</span>     <span class="number">7</span>        (alignment)</span><br></pre></td></tr></table></figure>

<h4 id="2-4-非静态内部类"><a href="#2-4-非静态内部类" class="headerlink" title="2.4 非静态内部类"></a>2.4 非静态内部类</h4><p>非静态内部类隐含一个指向外部类对象的引用，如下的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    Inner i;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>Inner</code>的字段排序结果为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OFFSET  SIZE    TYPE DESCRIPTION      </span><br><span class="line">    <span class="number">0</span>    <span class="number">12</span>         (<span class="keyword">object</span> header)        </span><br><span class="line">    <span class="number">12</span>     <span class="number">4</span>     <span class="keyword">int</span> Inner.b                                  </span><br><span class="line">    <span class="number">16</span>     <span class="number">4</span>   Outer Inner.<span class="keyword">this</span>$<span class="number">0</span>                             </span><br><span class="line">    <span class="number">20</span>     <span class="number">4</span>         (loss due to the next <span class="keyword">object</span> alignment)</span><br></pre></td></tr></table></figure>

<p>可见其中的隐含引用，这也就是能使用<code>Inner.this</code>引用外部对象的原因。</p>
<h3 id="3-估算应用所占内存"><a href="#3-估算应用所占内存" class="headerlink" title="3.估算应用所占内存"></a>3.估算应用所占内存</h3><p>明白了这些，那么估算应用所占内存便成为可能。一个应用使用如下的数据结构存储数据：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, <span class="built_in">String</span>&gt; cache = <span class="keyword">new</span> HashMap&lt;Integer, <span class="built_in">String</span>&gt;();</span><br></pre></td></tr></table></figure>

<p>该应用有约100万数据，其中每个<code>String</code>的长度约为50，该应用大约占用多少内存呢？假设该应用运行在64位JVM上，开启<code>CompressedOops</code>选项。</p>
<p>由前述分析知：一个<code>Integer</code>占用16字节。那么长度为50的字符串占用多少字节呢？<code>String</code>的数据结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中含有一个int值和字符数组，而数组的对象头中含有一个4字节的长度字段，故对象头部为16字节。该<code>String</code>对象的内存布局示意如下：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3288959-61048da22e79d2c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/444/format/webp" alt="img"></p>
<p>字符串内存布局示意</p>
<p> 可知，长度为50的字符串占用24+120=144字节的空间。<br> 估计HashMap大小的关键是估算<code>Entry</code>的大小，它的数据结构如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;    <span class="comment">// 引用</span></span><br><span class="line">    V value;    <span class="comment">// 引用</span></span><br><span class="line">    Entry&lt;K,V&gt; next; <span class="comment">// 引用</span></span><br><span class="line">    <span class="built_in">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知一个<code>Entry</code>所占内存为：12B对象头+16B实例数据+4B对齐填充，共占用32字节。由于含有100万条数据，故将创建100万个<code>Entry</code>。由此可估算所占内存为：100万<code>Integer</code>、100万<code>String</code>和100万<code>Entry</code>，忽略HashMap的其他小额占用，最终占用内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(16 + 144 + 32) * 1 000 000 ≈ 192 MB</span><br></pre></td></tr></table></figure>

<p>使用visual vm工具进行监控的实际数据如下：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3288959-cae5db9293f51779.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/916/format/webp" alt="img"></p>
<p>应用所占内存示意</p>
<p>附相关资料：</p>
<p><a href="https://link.jianshu.com?t=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000004574249" target="_blank" rel="noopener">Java对象结构及大小计算</a><br> <a href="https://link.jianshu.com?t=https%3A%2F%2Fawaiswaheed.wordpress.com%2Fcategory%2Fjava-learning%2Fjava-core%2Fjava-object-memory-structure%2F" target="_blank" rel="noopener">Java Object Memory Structure</a><br> <a href="https://link.jianshu.com?t=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Ftopic%2F41307" target="_blank" rel="noopener">Java数据对齐讨论</a><br> <a href="https://link.jianshu.com?t=http%3A%2F%2Fopenjdk.java.net%2Fprojects%2Fcode-tools%2Fjol%2F" target="_blank" rel="noopener">jdk jol工具</a></p>
<hr>
<p>本文整理自</p>
<p><a href="https://www.jianshu.com/p/ad505f9163b2" target="_blank" rel="noopener">如何正确计算Java对象所占内存？</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/17/Java%E5%8E%8B%E7%BC%A9%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/17/Java%E5%8E%8B%E7%BC%A9%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">Java压缩指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-17 11:54:29 / 修改时间：19:55:52" itemprop="dateCreated datePublished" datetime="2020-08-17T11:54:29+08:00">2020-08-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>Java虚拟机中每个Java对象都有一个对象头，对象头由标记字段和类型指针构成。其中标记字段用以存储Java虚拟机有关对象的运行数据，如哈希码、GC信息及锁信息，而指针类型指向该对象的类。</p>
<h2 id="压缩指针"><a href="#压缩指针" class="headerlink" title="压缩指针"></a>压缩指针</h2><p>在64位的虚拟机中，对象头的标记字段占64位，而类型指针又占64位。也就是说一个对象额外占用的字节就是16个字节。以Integer对象为例，它仅有一个int类型的私有字段，占4个字节。因此，每个Integer的额外开销至少400%，这也就是Java为什么要引入基本数据类型的原因之一。为了减少内存开销，64位Java虚拟机引入了压缩指针概念（对应虚拟机选项 -XX:+UseCompressedOops，默认开启），将堆中原本64位的Java对象指针压缩成32位的。<br> 这样一来，对象头的类型指针也会被压缩成32位，使得对象头大小从16字节降低为12字节。压缩指针不仅可以作用对象头的类型指针，还可以作用引用类型的字段，引用类型的数组。</p>
<h2 id="压缩指针原理"><a href="#压缩指针原理" class="headerlink" title="压缩指针原理"></a>压缩指针原理</h2><p>默认情况下，Java虚拟机中对象的起始地址需要对齐至8的倍数（这个概念我们称之为内存对齐（对应虚拟机选项 -XX:ObjectAlignmentInBytes，默认值为 8）。如果一个对象用不到8N字节，那么空白的那部分空间就白白浪费掉了。这些浪费掉的空间我们称之为对象之间的填充。默认情况下，Java虚拟机中32位的指针可以寻址到2的35次方，也就是32GB的内存空间（超过32位会关闭压缩指针）。在对压缩指针解引用时，我们需要将其左移3位，再加上一个固定的偏移量，便可以寻址到32GB地址空间伪64位指针了。</p>
<p>此外，我们可以配置刚刚提到的内存对齐选项（-XX:ObjectAlignmentInBytes）来进一步提升内存寻址范围。但是，这也可能增加对象填充，导致压缩指针没有打到节省空间效果。</p>
<h2 id="关闭压缩指针"><a href="#关闭压缩指针" class="headerlink" title="关闭压缩指针"></a>关闭压缩指针</h2><p>就算关闭了压缩指针，Java虚拟机也会进行内存对齐。内存对齐不仅在于对象和对象之间，也存在于对象的各个字段之间。比如说，Java虚拟机中的long字段、double字段，以及非压缩指针状态下的引用字段为8的倍数。</p>
<h2 id="内存对齐原因"><a href="#内存对齐原因" class="headerlink" title="内存对齐原因"></a>内存对齐原因</h2><p>内存对齐的一个原因是让字段出现在同一CPU的缓存中。如果字段不对齐，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取的读取可能需要跨两个缓存行，而改字段的存储也可能同时污染两个缓存行。这种情况对程序的执行效率是不利的。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://www.jianshu.com/p/017467692a92" target="_blank" rel="noopener">压缩指针</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/10/kafka%E4%B8%ADpartition%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/kafka%E4%B8%ADpartition%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/" class="post-title-link" itemprop="url">kafka中partition和消费者对应关系</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-10 12:07:35 / 修改时间：20:09:26" itemprop="dateCreated datePublished" datetime="2020-08-10T12:07:35+08:00">2020-08-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>1个partition只能被同组的一个consumer消费，同组的consumer则起到均衡效果</strong></p>
<h2 id="消费者多于partition"><a href="#消费者多于partition" class="headerlink" title="消费者多于partition"></a>消费者多于partition</h2><p>topic： test 只有一个partition<br> 创建一个topic——test，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>在g2组中启动两个consumer，</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> bin/kafka-<span class="built_in">console</span>-consumer.sh --bootstrap-server localhost:<span class="number">9092</span> --topic test --<span class="keyword">from</span>-beginning --consumer.config config/consumer_g2.properties</span><br><span class="line"><span class="number">2.</span> bin/kafka-<span class="built_in">console</span>-consumer.sh --bootstrap-server localhost:<span class="number">9092</span> --topic test --<span class="keyword">from</span>-beginning --consumer.config config/consumer_g2.properties</span><br></pre></td></tr></table></figure>

<p>消费者数量为2大于partition数量1，此时partition和消费者进程对应关系如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-consumer-groups.sh --bootstrap-server localhost:<span class="number">9092</span> --describe --<span class="keyword">group</span> g2</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TOPIC PARTITION CURRENT-OFFSET LOG-END-OFFSET LAG CONSUMER-ID HOST CLIENT-ID</span><br><span class="line"><span class="built_in">test</span> 0 9 9 0 consumer-1-4a2a4aa8-32f4-4904-9c16-1c0bdf7128a2 /127.0.0.1 consumer-1</span><br><span class="line">- - - - - consumer-1-fd7b120f-fd21-4e07-8c23-87b71c1ee8a5 /127.0.0.1 consumer-1</span><br></pre></td></tr></table></figure>

<p>消费者consumer-1-fd7b120f-fd21-4e07-8c23-87b71c1ee8a5无对应的partition。<br> 用图表示为</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2414051-4c77d6b4a8d3ae9a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/339/format/webp" alt="img"></p>
<p>生产者消费者对应关系1.jpg</p>
<p> 如上图，向test发送消息：1，2， 3，4，5，6，7，8，9<br> 只有C1能接收到消息，C2则不能接收到消息，<strong>即同一个partition内的消息只能被同一个组中的一个consumer消费。当消费者数量多于partition的数量时，多余的消费者空闲。</strong><br><strong>也就是说如果只有一个partition你在同一组启动多少个consumer都没用，partition的数量决定了此topic在同一组中被可被均衡的程度，例如partition=4，则可在同一组中被最多4个consumer均衡消费。</strong></p>
<h2 id="消费者少于和等于partition"><a href="#消费者少于和等于partition" class="headerlink" title="消费者少于和等于partition"></a>消费者少于和等于partition</h2><p>topic：test2包含3个partition</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 3 --topic test2</span><br></pre></td></tr></table></figure>

<p>开始时，在g3组中启动2个consumer,</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>bin/kafka-<span class="built_in">console</span>-consumer.sh --bootstrap-server localhost:<span class="number">9092</span> --topic test2 --<span class="keyword">from</span>-beginning --consumer.config config/consumer_g3.properties</span><br><span class="line"><span class="number">2.</span>bin/kafka-<span class="built_in">console</span>-consumer.sh --bootstrap-server localhost:<span class="number">9092</span> --topic test2 --<span class="keyword">from</span>-beginning --consumer.config config/consumer_g3.properties</span><br></pre></td></tr></table></figure>

<p>则对应关系如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TOPIC PARTITION CURRENT-OFFSET LOG-END-OFFSET LAG CONSUMER-ID HOST <span class="built_in">CLIENT</span>-ID</span><br><span class="line">test2 <span class="number">0</span> <span class="number">8</span> <span class="number">8</span> <span class="number">0</span> consumer<span class="number">-1</span><span class="number">-8</span>b872ef7-a2f0<span class="number">-4</span>bd3-b2a8<span class="number">-7</span>b26e4d8ab2c /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br><span class="line">test2 <span class="number">1</span> <span class="number">7</span> <span class="number">7</span> <span class="number">0</span> consumer<span class="number">-1</span><span class="number">-8</span>b872ef7-a2f0<span class="number">-4</span>bd3-b2a8<span class="number">-7</span>b26e4d8ab2c /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br><span class="line">test2 <span class="number">2</span> <span class="number">8</span> <span class="number">8</span> <span class="number">0</span> consumer<span class="number">-1</span>-f362847d<span class="number">-1094</span><span class="number">-4895</span>-ad8b<span class="number">-1e1</span>f1c88936c /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>其中，consumer-1-8b872ef7-a2f0-4bd3-b2a8-7b26e4d8ab2c对应了2个partition<br> 用图表示为：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2414051-dd61642376e23f15.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/343/format/webp" alt="img"></p>
<p>生产者消费者对应关系2.jpg</p>
<p> 消费者数量2小于partition的数量3，此时，向test2发送消息1，2，3，4，5，6，7，8，9<br> C1接收到1，3，4，6，7，9<br> C2接收到2，5，8<br><strong>此时P1、P2对对应C1，即多个partition对应一个消费者，C1接收到消息量是C2的两倍</strong><br> 然后，在g3组中再启动一个消费者，使得消费者数量为3等于topic2中partition的数量</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span>bin/kafka-<span class="built_in">console</span>-consumer.sh --bootstrap-server localhost:<span class="number">9092</span> --topic test2 --<span class="keyword">from</span>-beginning --consumer.config config/consumer_g3.properties</span><br></pre></td></tr></table></figure>

<p>对应关系如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TOPIC PARTITION CURRENT-OFFSET LOG-END-OFFSET LAG CONSUMER-ID HOST <span class="built_in">CLIENT</span>-ID</span><br><span class="line">test2 <span class="number">0</span> <span class="number">8</span> <span class="number">8</span> <span class="number">0</span> consumer<span class="number">-1</span><span class="number">-8</span>b872ef7-a2f0<span class="number">-4</span>bd3-b2a8<span class="number">-7</span>b26e4d8ab2c /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br><span class="line">test2 <span class="number">1</span> <span class="number">7</span> <span class="number">7</span> <span class="number">0</span> consumer<span class="number">-1</span>-ab472ed5-de11<span class="number">-4e56</span><span class="number">-863</span>a<span class="number">-67</span>bf3a3cc36a /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br><span class="line">test2 <span class="number">2</span> <span class="number">8</span> <span class="number">8</span> <span class="number">0</span> consumer<span class="number">-1</span>-f362847d<span class="number">-1094</span><span class="number">-4895</span>-ad8b<span class="number">-1e1</span>f1c88936c /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>此时，partition和消费者是一对一关系，向test2发送消息1，2，3，4，5，6，7，8，9<br> C1接收到了：2，5，8<br> C2接收到了：3，6，9<br> C3接收到了：1，4，7<br> C1，C2，C3均分了test2的所有消息，即<strong>消息在同一个组之间的消费者之间均分了!</strong></p>
<h2 id="多个消费者组"><a href="#多个消费者组" class="headerlink" title="多个消费者组"></a>多个消费者组</h2><p>启动g4组，仅包含一个消费者C1，消费topic2的消息，此时消费端有两个消费者组</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-<span class="built_in">console</span>-consumer.sh --bootstrap-server localhost:<span class="number">9092</span> --topic test2 --<span class="keyword">from</span>-beginning --consumer.config config/consumer_g4.properties --<span class="keyword">delete</span>-consumer-offsets</span><br></pre></td></tr></table></figure>

<p>g4组的C1的对应了test2的所有partition:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-consumer-groups.sh --bootstrap-server localhost:<span class="number">9092</span> --describe --<span class="keyword">group</span> g4</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TOPIC PARTITION CURRENT-OFFSET LOG-END-OFFSET LAG CONSUMER-ID HOST <span class="built_in">CLIENT</span>-ID</span><br><span class="line">test2 <span class="number">0</span> <span class="number">36</span> <span class="number">36</span> <span class="number">0</span> consumer<span class="number">-1</span>-befc9234<span class="number">-260</span>d<span class="number">-4</span>ad3-b283-b67a2bf446ca /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br><span class="line">test2 <span class="number">1</span> <span class="number">35</span> <span class="number">35</span> <span class="number">0</span> consumer<span class="number">-1</span>-befc9234<span class="number">-260</span>d<span class="number">-4</span>ad3-b283-b67a2bf446ca /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br><span class="line">test2 <span class="number">2</span> <span class="number">36</span> <span class="number">36</span> <span class="number">0</span> consumer<span class="number">-1</span>-befc9234<span class="number">-260</span>d<span class="number">-4</span>ad3-b283-b67a2bf446ca /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> consumer<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>用图表示为</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2414051-834521901c8940b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/336/format/webp" alt="img"></p>
<p>生产者消费者对应关系3.jpg</p>
<p> 如上图，向test2发送消息1，2，3，4，5，6，7，8，9<br> 那么g3组各个消费者及g4组的消费者接收到的消息是怎样地呢？欢迎思考！！<br> 答案：<br> 消息被g3组的消费者均分，g4组的消费者在接收到了所有的消息。<br> g3组：<br> C1接收到了：2，5，8<br> C2接收到了：3，6，9<br> C3接收到了：1，4，7<br> g4组：<br> C1接收到了：1，2，3，4，5，6，7，8，9<br><strong>启动多个组，则会使同一个消息被消费多次</strong></p>
<hr>
<p>本文整理自</p>
<p><a href="https://www.jianshu.com/p/6233d5341dfe" target="_blank" rel="noopener">kafka中partition和消费者对应关系</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/10/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Spring事务传播行为详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-10 11:12:34 / 修改时间：19:14:04" itemprop="dateCreated datePublished" datetime="2020-08-10T11:12:34+08:00">2020-08-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。这是Spring为我们提供的强大的工具箱，使用事务传播行可以为我们的开发工作提供许多便利。但是人们对他的误解也颇多，你一定也听过“service方法事务最好不要嵌套”的传言。要想正确的使用工具首先需要了解工具。本文对七种事务传播行为做详细介绍，内容主要代码示例的方式呈现。</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="1-什么是事务传播行为？"><a href="#1-什么是事务传播行为？" class="headerlink" title="1. 什么是事务传播行为？"></a>1. 什么是事务传播行为？</h2><p>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。</p>
<p>用伪代码说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void methodA()&#123;</span><br><span class="line">   methodB();</span><br><span class="line">   &#x2F;&#x2F;doSomething</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transaction(Propagation&#x3D;XXX)</span><br><span class="line">public void methodB()&#123;</span><br><span class="line">   &#x2F;&#x2F;doSomething</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中<code>methodA()</code>方法嵌套调用了<code>methodB()</code>方法，<code>methodB()</code>的事务传播行为由<code>@Transaction(Propagation=XXX)</code>设置决定。这里需要注意的是<code>methodA()</code>并没有开启事务，某一个事务传播行为修饰的方法并不是必须要在开启事务的外围方法中调用。</p>
<h2 id="2-Spring中七种事务传播行为"><a href="#2-Spring中七种事务传播行为" class="headerlink" title="2. Spring中七种事务传播行为"></a>2. Spring中七种事务传播行为</h2><table>
<thead>
<tr>
<th>事务传播行为类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>使用当前的事务，如果当前没有事务，就抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>新建事务，如果当前存在事务，把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>以非事务方式执行，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody></table>
<p>定义非常简单，也很好理解，下面我们就进入代码测试部分，验证我们的理解是否正确。</p>
<h1 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h1><p>文中代码以传统三层结构中两层呈现，即Service和Dao层，由Spring负责依赖注入和注解式事务管理，DAO层由Mybatis实现，你也可以使用任何喜欢的方式，例如，Hibernate,JPA,JDBCTemplate等。数据库使用的是MySQL数据库，你也可以使用任何支持事务的数据库，并不会影响验证结果。</p>
<p>首先我们在数据库中创建两张表：</p>
<p><strong>user1</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;user1&#96; (</span><br><span class="line">  &#96;id&#96; INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; VARCHAR(45) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">  PRIMARY KEY(&#96;id&#96;)</span><br><span class="line">)</span><br><span class="line">ENGINE &#x3D; InnoDB;</span><br></pre></td></tr></table></figure>

<p><strong>user2</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;user2&#96; (</span><br><span class="line">  &#96;id&#96; INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; VARCHAR(45) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">  PRIMARY KEY(&#96;id&#96;)</span><br><span class="line">)</span><br><span class="line">ENGINE &#x3D; InnoDB;</span><br></pre></td></tr></table></figure>

<p>然后编写相应的Bean和DAO层代码：</p>
<p><strong>User1</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class User1 &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">   &#x2F;&#x2F;get和set方法省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User2</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class User2 &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">   &#x2F;&#x2F;get和set方法省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User1Mapper</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface User1Mapper &#123;</span><br><span class="line">    int insert(User1 record);</span><br><span class="line">    User1 selectByPrimaryKey(Integer id);</span><br><span class="line">    &#x2F;&#x2F;其他方法省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User2Mapper</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface User2Mapper &#123;</span><br><span class="line">    int insert(User2 record);</span><br><span class="line">    User2 selectByPrimaryKey(Integer id);</span><br><span class="line">    &#x2F;&#x2F;其他方法省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后也是具体验证的代码由service层实现，下面我们分情况列举。</p>
<h2 id="1-PROPAGATION-REQUIRED"><a href="#1-PROPAGATION-REQUIRED" class="headerlink" title="1.PROPAGATION_REQUIRED"></a>1.PROPAGATION_REQUIRED</h2><p>我们为User1Service和User2Service相应方法加上<code>Propagation.REQUIRED</code>属性。</p>
<p><strong>User1Service方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User1ServiceImpl implements User1Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">    public void addRequired(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User2Service方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User2ServiceImpl implements User2Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">    public void addRequired(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">    public void addRequiredException(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-场景一"><a href="#1-1-场景一" class="headerlink" title="1.1 场景一"></a>1.1 场景一</h3><p>此场景外围方法没有开启事务。</p>
<p><strong>验证方法1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_exception_required_required()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequired(user2);</span><br><span class="line">    </span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_required_required_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiredException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别执行验证方法，结果：</p>
<table>
<thead>
<tr>
<th>验证方法序号</th>
<th>数据库结果</th>
<th>结果分析</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>“张三”、“李四”均插入。</td>
<td>外围方法未开启事务，插入“张三”、“李四”方法在自己的事务中独立运行，外围方法异常不影响内部插入“张三”、“李四”方法独立的事务。</td>
</tr>
<tr>
<td>2</td>
<td>“张三”插入，“李四”未插入。</td>
<td>外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,所以插入“李四”方法抛出异常只会回滚插入“李四”方法，插入“张三”方法不受影响。</td>
</tr>
</tbody></table>
<p><strong>结论：通过这两个方法我们证明了在外围方法未开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong></p>
<h3 id="1-2-场景二"><a href="#1-2-场景二" class="headerlink" title="1.2 场景二"></a>1.2 场景二</h3><p>外围方法开启事务，这个是使用率比较高的场景。</p>
<p><strong>验证方法1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> @Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line"> public void transaction_exception_required_required()&#123;</span><br><span class="line">     User1 user1&#x3D;new User1();</span><br><span class="line">     user1.setName(&quot;张三&quot;);</span><br><span class="line">     user1Service.addRequired(user1);</span><br><span class="line">     </span><br><span class="line">     User2 user2&#x3D;new User2();</span><br><span class="line">     user2.setName(&quot;李四&quot;);</span><br><span class="line">     user2Service.addRequired(user2);</span><br><span class="line">     </span><br><span class="line">     throw new RuntimeException();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void transaction_required_required_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiredException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_required_required_exception_try()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        user2Service.addRequiredException(user2);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        System.out.println(&quot;方法回滚&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别执行验证方法，结果：</p>
<table>
<thead>
<tr>
<th>验证方法序号</th>
<th>数据库结果</th>
<th>结果分析</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>“张三”、“李四”均未插入。</td>
<td>外围方法开启事务，内部方法加入外围方法事务，外围方法回滚，内部方法也要回滚。</td>
</tr>
<tr>
<td>2</td>
<td>“张三”、“李四”均未插入。</td>
<td>外围方法开启事务，内部方法加入外围方法事务，内部方法抛出异常回滚，外围方法感知异常致使整体事务回滚。</td>
</tr>
<tr>
<td>3</td>
<td>“张三”、“李四”均未插入。</td>
<td>外围方法开启事务，内部方法加入外围方法事务，内部方法抛出异常回滚，即使方法被catch不被外围方法感知，整个事务依然回滚。</td>
</tr>
</tbody></table>
<p><strong>结论：以上试验结果我们证明在外围方法开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会加入到外围方法的事务中，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</strong></p>
<h2 id="2-PROPAGATION-REQUIRES-NEW"><a href="#2-PROPAGATION-REQUIRES-NEW" class="headerlink" title="2.PROPAGATION_REQUIRES_NEW"></a>2.PROPAGATION_REQUIRES_NEW</h2><p>我们为User1Service和User2Service相应方法加上<code>Propagation.REQUIRES_NEW</code>属性。<br><strong>User1Service方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User1ServiceImpl implements User1Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</span><br><span class="line">    public void addRequiresNew(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">    public void addRequired(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User2Service方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User2ServiceImpl implements User2Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</span><br><span class="line">    public void addRequiresNew(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</span><br><span class="line">    public void addRequiresNewException(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-场景一"><a href="#2-1-场景一" class="headerlink" title="2.1 场景一"></a>2.1 场景一</h3><p>外围方法没有开启事务。</p>
<p><strong>验证方法1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_exception_requiresNew_requiresNew()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequiresNew(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_requiresNew_requiresNew_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequiresNew(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNewException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别执行验证方法，结果：</p>
<table>
<thead>
<tr>
<th>验证方法序号</th>
<th>数据库结果</th>
<th>结果分析</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>“张三”插入，“李四”插入。</td>
<td>外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,外围方法抛出异常回滚不会影响内部方法。</td>
</tr>
<tr>
<td>2</td>
<td>“张三”插入，“李四”未插入</td>
<td>外围方法没有开启事务，插入“张三”方法和插入“李四”方法分别开启自己的事务，插入“李四”方法抛出异常回滚，其他事务不受影响。</td>
</tr>
</tbody></table>
<p><strong>结论：通过这两个方法我们证明了在外围方法未开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong></p>
<h3 id="2-2-场景二"><a href="#2-2-场景二" class="headerlink" title="2.2 场景二"></a>2.2 场景二</h3><p>外围方法开启事务。</p>
<p><strong>验证方法1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void transaction_exception_required_requiresNew_requiresNew()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    </span><br><span class="line">    User2 user3&#x3D;new User2();</span><br><span class="line">    user3.setName(&quot;王五&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user3);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void transaction_required_requiresNew_requiresNew_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    </span><br><span class="line">    User2 user3&#x3D;new User2();</span><br><span class="line">    user3.setName(&quot;王五&quot;);</span><br><span class="line">    user2Service.addRequiresNewException(user3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void transaction_required_requiresNew_requiresNew_exception_try()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    User2 user3&#x3D;new User2();</span><br><span class="line">    user3.setName(&quot;王五&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        user2Service.addRequiresNewException(user3);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        System.out.println(&quot;回滚&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别执行验证方法，结果：</p>
<table>
<thead>
<tr>
<th>验证方法序号</th>
<th>数据库结果</th>
<th>结果分析</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>“张三”未插入，“李四”插入，“王五”插入。</td>
<td>外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中，外围方法抛出异常只回滚和外围方法同一事务的方法，故插入“张三”的方法回滚。</td>
</tr>
<tr>
<td>2</td>
<td>“张三”未插入，“李四”插入，“王五”未插入。</td>
<td>外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中。插入“王五”方法抛出异常，首先插入 “王五”方法的事务被回滚，异常继续抛出被外围方法感知，外围方法事务亦被回滚，故插入“张三”方法也被回滚。</td>
</tr>
<tr>
<td>3</td>
<td>“张三”插入，“李四”插入，“王五”未插入。</td>
<td>外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中。插入“王五”方法抛出异常，首先插入“王五”方法的事务被回滚，异常被catch不会被外围方法感知，外围方法事务不回滚，故插入“张三”方法插入成功。</td>
</tr>
</tbody></table>
<p><strong>结论：在外围方法开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰。</strong></p>
<h2 id="3-PROPAGATION-NESTED"><a href="#3-PROPAGATION-NESTED" class="headerlink" title="3.PROPAGATION_NESTED"></a>3.PROPAGATION_NESTED</h2><p>我们为User1Service和User2Service相应方法加上<code>Propagation.NESTED</code>属性。<br><strong>User1Service方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User1ServiceImpl implements User1Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.NESTED)</span><br><span class="line">    public void addNested(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User2Service方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User2ServiceImpl implements User2Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.NESTED)</span><br><span class="line">    public void addNested(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.NESTED)</span><br><span class="line">    public void addNestedException(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-场景一"><a href="#3-1-场景一" class="headerlink" title="3.1 场景一"></a>3.1 场景一</h3><p>此场景外围方法没有开启事务。</p>
<p><strong>验证方法1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_exception_nested_nested()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNested(user2);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_nested_nested_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNestedException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别执行验证方法，结果：</p>
<table>
<thead>
<tr>
<th>验证方法序号</th>
<th>数据库结果</th>
<th>结果分析</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>“张三”、“李四”均插入。</td>
<td>外围方法未开启事务，插入“张三”、“李四”方法在自己的事务中独立运行，外围方法异常不影响内部插入“张三”、“李四”方法独立的事务。</td>
</tr>
<tr>
<td>2</td>
<td>“张三”插入，“李四”未插入。</td>
<td>外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,所以插入“李四”方法抛出异常只会回滚插入“李四”方法，插入“张三”方法不受影响。</td>
</tr>
</tbody></table>
<p><strong>结论：通过这两个方法我们证明了在外围方法未开启事务的情况下<code>Propagation.NESTED</code>和<code>Propagation.REQUIRED</code>作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong></p>
<h3 id="3-2-场景二"><a href="#3-2-场景二" class="headerlink" title="3.2 场景二"></a>3.2 场景二</h3><p>外围方法开启事务。</p>
<p><strong>验证方法1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_exception_nested_nested()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNested(user2);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_nested_nested_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNestedException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证方法3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_nested_nested_exception_try()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        user2Service.addNestedException(user2);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        System.out.println(&quot;方法回滚&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别执行验证方法，结果：</p>
<table>
<thead>
<tr>
<th>验证方法序号</th>
<th>数据库结果</th>
<th>结果分析</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>“张三”、“李四”均未插入。</td>
<td>外围方法开启事务，内部事务为外围事务的子事务，外围方法回滚，内部方法也要回滚。</td>
</tr>
<tr>
<td>2</td>
<td>“张三”、“李四”均未插入。</td>
<td>外围方法开启事务，内部事务为外围事务的子事务，内部方法抛出异常回滚，且外围方法感知异常致使整体事务回滚。</td>
</tr>
<tr>
<td>3</td>
<td>“张三”插入、“李四”未插入。</td>
<td>外围方法开启事务，内部事务为外围事务的子事务，插入“李四”内部方法抛出异常，可以单独对子事务回滚。</td>
</tr>
</tbody></table>
<p><strong>结论：以上试验结果我们证明在外围方法开启事务的情况下<code>Propagation.NESTED</code>修饰的内部方法属于外部事务的子事务，外围主事务回滚，子事务一定回滚，而内部子事务可以单独回滚而不影响外围主事务和其他子事务</strong></p>
<h2 id="4-REQUIRED-REQUIRES-NEW-NESTED异同"><a href="#4-REQUIRED-REQUIRES-NEW-NESTED异同" class="headerlink" title="4. REQUIRED,REQUIRES_NEW,NESTED异同"></a>4. REQUIRED,REQUIRES_NEW,NESTED异同</h2><p>由“1.2 场景二”和“3.2 场景二”对比，我们可知：<br><strong>NESTED和REQUIRED修饰的内部方法都属于外围方法事务，如果外围方法抛出异常，这两种方法的事务都会被回滚。但是REQUIRED是加入外围方法事务，所以和外围事务同属于一个事务，一旦REQUIRED事务抛出异常被回滚，外围方法事务也将被回滚。而NESTED是外围方法的子事务，有单独的保存点，所以NESTED方法抛出异常被回滚，不会影响到外围方法的事务。</strong></p>
<p>由“2.2 场景二”和“3.2 场景二”对比，我们可知：<br><strong>NESTED和REQUIRES_NEW都可以做到内部方法事务回滚而不影响外围方法事务。但是因为NESTED是嵌套事务，所以外围方法回滚之后，作为外围方法事务的子事务也会被回滚。而REQUIRES_NEW是通过开启新的事务实现的，内部事务和外围事务是两个事务，外围事务回滚不会影响内部事务。</strong></p>
<h2 id="5-其他事务传播行为"><a href="#5-其他事务传播行为" class="headerlink" title="5. 其他事务传播行为"></a>5. 其他事务传播行为</h2><p>鉴于文章篇幅问题，其他事务传播行为的测试就不在此一一描述了，感兴趣的读者可以去源码中自己寻找相应测试代码和结果解释。传送门：<a href="https://github.com/TmTse/transaction-test" target="_blank" rel="noopener">https://github.com/TmTse/tran…</a></p>
<h1 id="模拟用例"><a href="#模拟用例" class="headerlink" title="模拟用例"></a>模拟用例</h1><p>介绍了这么多事务传播行为，我们在实际工作中如何应用呢？下面我来举一个示例：</p>
<p>假设我们有一个注册的方法，方法中调用添加积分的方法，如果我们希望添加积分不会影响注册流程（即添加积分执行失败回滚不能使注册方法也回滚），我们会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">     </span><br><span class="line">     @Transactional</span><br><span class="line">     public void register(User user)&#123;</span><br><span class="line">                </span><br><span class="line">         try &#123;</span><br><span class="line">             membershipPointService.addPoint(Point point);</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F;省略...</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F;省略...</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还规定注册失败要影响<code>addPoint()</code>方法（注册方法回滚添加积分方法也需要回滚），那么<code>addPoint()</code>方法就需要这样实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MembershipPointServiceImpl implements MembershipPointService&#123;</span><br><span class="line">     </span><br><span class="line">     @Transactional(propagation &#x3D; Propagation.NESTED)</span><br><span class="line">     public void addPoint(Point point)&#123;</span><br><span class="line">                </span><br><span class="line">         try &#123;</span><br><span class="line">             recordService.addRecord(Record record);</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F;省略...</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F;省略...</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到了在<code>addPoint()</code>中还调用了<code>addRecord()</code>方法，这个方法用来记录日志。他的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class RecordServiceImpl implements RecordService&#123;</span><br><span class="line">     </span><br><span class="line">     @Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)</span><br><span class="line">     public void addRecord(Record record)&#123;</span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line">         &#x2F;&#x2F;省略...</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到<code>addRecord()</code>方法中<code>propagation = Propagation.NOT_SUPPORTED</code>，因为对于日志无所谓精确，可以多一条也可以少一条，所以<code>addRecord()</code>方法本身和外围<code>addPoint()</code>方法抛出异常都不会使<code>addRecord()</code>方法回滚，并且<code>addRecord()</code>方法抛出异常也不会影响外围<code>addPoint()</code>方法的执行。</p>
<p>通过这个例子相信大家对事务传播行为的使用有了更加直观的认识，通过各种属性的组合确实能让我们的业务实现更加灵活多样。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://segmentfault.com/a/1190000013341344" target="_blank" rel="noopener">Spring事务传播行为详解</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EricMa"
      src="/images/eric.png">
  <p class="site-author-name" itemprop="name">EricMa</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">229</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Eric-Ma-C" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Eric-Ma-C" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chaoma@zju.edu.cn" title="E-Mail → mailto:chaoma@zju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EricMa</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">864k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
