<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux文件和目录总结</title>
    <url>/2019/11/02/Linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="目录分类"><a href="#目录分类" class="headerlink" title="目录分类"></a>目录分类</h2><p><strong>/usr</strong>    系统软件资源目录<br><strong>/bin    /usr/bin</strong>    系统命令,所有用户可执行<br><strong>/sbin    /usr/sbin</strong>    系统命令,仅root可执行<br><strong>/boot</strong>    系统启动数据<br><strong>/etc</strong>    系统默认配置文件<br><strong>/dev</strong>    硬件设备文件<br><strong>/lib</strong>    系统功能函数库,so文件<br><strong>/sys    /proc</strong>    内存挂载点,直接写入内存,不能动<br><strong>/var</strong>    系统可变文档目录</p>
<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>    <span class="comment"># 等同于 cd ~ 回家</span></span><br><span class="line"><span class="built_in">cd</span> -  <span class="comment"># 上次目录 </span></span><br><span class="line">ls  -lh  <span class="comment"># --long   --human人性化显示大小   -i查看文件inode号</span></span><br><span class="line">ll    <span class="comment"># ls -l</span></span><br><span class="line"><span class="built_in">pwd</span>   <span class="comment"># print working dir</span></span><br><span class="line">mkdir -p xxxx <span class="comment"># -p 递归创建</span></span><br><span class="line">rm -r xxxx    <span class="comment">#删除目录</span></span><br><span class="line">cp -r src dst	<span class="comment"># -r复制目录 -p同时复制文件属性(如修改时间) -d若为链接文件,则复制链接属性</span></span><br><span class="line">cp -a src dst	<span class="comment"># --all相当于 cp -rpd  </span></span><br><span class="line">mv src dst	<span class="comment">#剪切文件和目录,重命名  目录不需要-r</span></span><br></pre></td></tr></table></figure>

<h2 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h2><ul>
<li><code>硬链接</code>    文件索引表中拥有<strong>相同的inode号和存储block块</strong>,看做同一个文件<br>创建后文件引用计数加1<br>不能跨分区创建硬链接;目录不能创建硬链接.<br>有限制,易混淆,平时不建议用</li>
<li><code>软链接</code>    有<strong>自己的inode号和block块</strong>,但数据块中只保存<strong>原文件的文件名和inode号</strong><br>类似win快捷方式,删除原文件,软链接不可用<br>block中文件名(路径)和inode号都符合才找得到<br><strong>软链接文件权限都为rwxrwxrwx</strong>,是否可以访问要看原文件的权限</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s src dis  # link  -s 软链接  src要写绝对路径!除非src和dst在同一目录</span><br></pre></td></tr></table></figure>

<h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><h3 id="locate-文件名"><a href="#locate-文件名" class="headerlink" title="locate 文件名"></a><code>locate 文件名</code></h3><p>速度快,在数据库(索引)中<strong>按文件名</strong>查找文件,数据库在<code>/var/lib/mlocate</code>一般一天一更新,<code>updatedb</code>立即更新.<br>搜索时的排除项(不搜索的内容)配置在<code>/etc/updatedb.conf</code>,如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PRUNE_BIND_MOUNTS="yes"</span><br><span class="line"><span class="meta">#</span><span class="bash"> PRUNENAMES=<span class="string">".git .bzr .hg .svn"</span></span></span><br><span class="line">PRUNEPATHS="/tmp /var/spool /media /home/.ecryptfs /var/lib/schroot"</span><br><span class="line">PRUNEFS="NFS nfs nfs4 rpc_pipefs afs binfmt_misc proc smbfs autofs iso9660 ncpfs coda devpts ftpfs devfs mfs shfs sysfs cifs lustre tmpfs usbfs udf fuse.glusterfs fuse.sshfs curlftpfs ecryptfs fusesmb devtmpfs"</span><br></pre></td></tr></table></figure>

<h3 id="whereis-命令名"><a href="#whereis-命令名" class="headerlink" title="whereis 命令名"></a><code>whereis 命令名</code></h3><p>搜索(外部)<strong>命令,配置及其帮助文档</strong>所在位置,-b仅可执行文件,-m仅帮助文档.<br>有些命令找不到,如cd,因为它是shell的内置命令.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whereis ls</span><br><span class="line">ls: /bin/ls /usr/share/man/man1/ls.1.gz</span><br></pre></td></tr></table></figure>

<h3 id="which-命令名"><a href="#which-命令名" class="headerlink" title="which 命令名"></a><code>which 命令名</code></h3><p>类似whereis,搜索(外部)<strong>命令</strong>所在位置及其别名.</p>
<h3 id="echo-PATH"><a href="#echo-PATH" class="headerlink" title="echo $PATH"></a><code>echo $PATH</code></h3><p>PATH环境变量定义的是系统搜索路径.</p>
<h3 id="find-范围-选项"><a href="#find-范围-选项" class="headerlink" title="find [范围] [选项]"></a><code>find [范围] [选项]</code></h3><p>功能非常强大,可能较慢.<br><code>find / -name 文件名</code><br>文件名需<strong>完全匹配</strong>,部分匹配用通配符:</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配任意字符</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td>[ ]</td>
<td>匹配任意一个中括号内的字符</td>
</tr>
</tbody></table>
<p><code>find / -iname 文件名</code>    不区分大小写<br><code>find / -user 用户名</code>    查找某用户的文件<br><code>find / -nouser</code>    查找没有所有者的文件,比如内核创建的文件,外来文件等<br><code>find /var/log/ -mtime +10</code>查找10天前修改的文件,一般是日志文件.单位也支持分钟.</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-atime</td>
<td>文件访问时间</td>
<td>-10</td>
<td>10天内</td>
</tr>
<tr>
<td>-ctime</td>
<td>文件属性修改时间</td>
<td>10</td>
<td>第10天</td>
</tr>
<tr>
<td>-mtime</td>
<td>文件修改时间</td>
<td>+10</td>
<td>10天前</td>
</tr>
</tbody></table>
<p> <code>find . -size 25k</code><br>查找当前目录下大小为25k的文件<br>注意大小写:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-25k</td>
<td>小于25kb</td>
<td>-4M</td>
<td>小于4Mb</td>
</tr>
<tr>
<td>25k</td>
<td>等于25kb</td>
<td>4M</td>
<td>等于4Mb</td>
</tr>
<tr>
<td>+25k</td>
<td>大于25kb</td>
<td>+4M</td>
<td>大于4Mb</td>
</tr>
</tbody></table>
<p> <code>find /root -inum 25225</code><br>查找inode节点为25225的文件<br> <code>find /etc -size +20k -a -size -50k</code><br>多条件查询,在/etc下找大于20kb小于50kb的文件,<code>-a(and) -o(or)</code><br> <code>find /etc -size +20k -a -size -50k -exec ls -lh {} \;</code><br>显示查找结果的详细信息,多执行了<code>ls -lh</code><br>对find结果执行操作:<code>-exec/-ok 增加的命令 {} \ ;</code></p>
<h3 id="grep-选项-quot-字符串-quot-文件名"><a href="#grep-选项-quot-字符串-quot-文件名" class="headerlink" title="grep [选项] &quot;字符串&quot; 文件名"></a><code>grep [选项] &quot;字符串&quot; 文件名</code></h3><p>在文件当中<strong>包含</strong>匹配符合条件的<strong>行</strong>,是部分匹配, -i忽略大小写  -v 排除指定字符串</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>JavaIO分类</title>
    <url>/2020/03/03/JavaIO%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="BIO-阻塞IO"><a href="#BIO-阻塞IO" class="headerlink" title="BIO (阻塞IO)"></a>BIO (阻塞IO)</h2><p>服务器程序一个线程负责一个连接，进行请求的处理和响应。当客户端比较多的时候，服务端的线程可能就不够了，这时候对应的请求就没法及时处理了。</p>
<h2 id="伪异步IO（BIO增加线程池）"><a href="#伪异步IO（BIO增加线程池）" class="headerlink" title="伪异步IO（BIO增加线程池）"></a>伪异步IO（BIO增加线程池）</h2><p>服务端会维护一个线程池来处理请求端的请求,<strong>减少了线程创建销毁开销</strong>。当客户端的请求比较多的时候，线程池的线程也是不够的，此时也会出现请求处理阻塞的情况。</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>同步非阻塞IO方式，服务端通过<strong>缓存区</strong>、<strong>通道</strong>、<strong>多路复用</strong>等技术，允许客户端的请求成千上万。读写都首先通过缓冲区来承接，然后通过通道（双向，区别于需要两个<code>InputStream</code>和<code>OutputStream</code>）来传输信息。通过多路复用器轮询通道(<code>select/poll,epoll</code>)，看看是否存在读或者写时间，然后再进行处理，大大提升了IO处理的性能和稳定性.<strong>由于操作复杂，Netty横空出世。</strong></p>
<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>AIO又称为NIO2.0，在JDK7才开始支持<strong>(但Linux平台下没有真正的异步IO实现,如windows下的IOCP技术,只能用epoll模拟异步IO)</strong>。真正的异步IO，简化了NIO的通信模型。它是连接注册读写事件和回调函数，读写方法异步，同时它是主动通知程序。<br>AIO异步通信提供了两种方式获取操作结果：第一种方式是通过<code>java.util.concurrent</code>的<code>Future</code>类来表示异步操作的结果；第二种方式是在执行异步操作的时候传入一个<code>java.nio.channels.CompletionHandler</code>接口的实现类作为操作完成回调。<br>AIO的异步套接字回调，是真正的异步非阻塞IO, .对应于Unix网络编程中的事件驱动IO，不需要通过多路复用器对被注册的通道进行轮询操作即可实现异步读写，从而简化NIO的编程模型。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table>
<thead>
<tr>
<th>IO通信方式</th>
<th>客户端:处理线程</th>
<th>IO类型</th>
<th>可靠性</th>
<th>调试难度</th>
<th>吞吐量</th>
</tr>
</thead>
<tbody><tr>
<td>BIO</td>
<td>M:M</td>
<td>同步阻塞</td>
<td>差</td>
<td>简单</td>
<td>低</td>
</tr>
<tr>
<td>伪异步IO(线程池)</td>
<td>M:N (N&lt;M)</td>
<td>同步阻塞</td>
<td>比较差</td>
<td>简单</td>
<td>中</td>
</tr>
<tr>
<td>NIO</td>
<td>M:1</td>
<td>同步非阻塞</td>
<td>比较高</td>
<td>复杂</td>
<td>高</td>
</tr>
<tr>
<td>AIO(异步NIO)</td>
<td>M:0</td>
<td>异步非阻塞</td>
<td>比较高</td>
<td>比较复杂</td>
<td>高</td>
</tr>
</tbody></table>
<p>阻塞式的I/O模型需要每个链接开一个线程（或进程），当线程数达到10k级别时，<strong>内存占用</strong>和<strong>上下文切换</strong>（context switch）导致系统的开销很大。</p>
<h2 id="为什么Netty使用NIO而不是AIO？"><a href="#为什么Netty使用NIO而不是AIO？" class="headerlink" title="为什么Netty使用NIO而不是AIO？"></a>为什么Netty使用NIO而不是AIO？</h2><p><a href="https://www.jianshu.com/p/df1d6d8c3f9d" target="_blank" rel="noopener">参考链接</a></p>
<ul>
<li>Netty不看重Windows上的使用，<strong>在Linux系统上，AIO的底层实现仍使用EPOLL，没有很好实现AIO</strong>，因此在性能上没有明显的优势，而且被JDK封装了一层不容易深度优化</li>
<li>Netty整体架构是reactor模型, 而AIO是proactor模型, 混合在一起会非常混乱,把AIO也改造成reactor模型看起来是把epoll绕个弯(Linux用epoll实现AIO)又绕回来</li>
<li>AIO还有个缺点是接收数据需要预先分配缓存, 而不是NIO那种需要接收时才需要分配缓存.所以对连接数量非常大但流量小的情况, AIO内存浪费很多</li>
<li>Linux上AIO不够成熟，处理回调结果速度跟不到处理需求，比如外卖员太少，顾客太多，供不应求，造成处理速度有瓶颈.</li>
<li>Netty作者原话：<br>Not faster than NIO (epoll) on unix systems (which is true).<br>There is no daragram suppport.<br>Unnecessary threading model (too much abstraction without usage).</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>I/O流的总结-字符流</title>
    <url>/2019/10/23/I-O%E6%B5%81%E7%9A%84%E6%80%BB%E7%BB%93-%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
    <content><![CDATA[<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>java的文本<code>(char)</code>是16位无符号整数，是字符的unicode编码（双字节编码).<br>文件是byte byte byte …的数据序列,文本文件是文本<code>(char)</code>序列按照某种编码方案<code>(utf-8,utf-16be,gbk)</code>序列化为byte的存储结果.</p>
<p>字符流(Reader Writer)—-&gt;操作的是文本文件<br>字符的处理，一次处理一个字符<br>字符的底层任然是基本的字节序列</p>
<h3 id="字符流的基本实现"><a href="#字符流的基本实现" class="headerlink" title="字符流的基本实现"></a>字符流的基本实现</h3><p> <code>InputStreamReader</code>完成byte流到char流,按照编码规则解析<br> <code>OutputStreamWriter</code>完成char流到byte流,按照编码规则转化 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"e:\\javaio\\utf8.txt"</span>);</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in,<span class="string">"utf-8"</span>);<span class="comment">//默认项目的编码,操作的时候，要写文件本身的编码格式</span></span><br><span class="line">	</span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"e:\\javaio\\utf81.txt"</span>);</span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(out,<span class="string">"utf-8"</span>);</span><br><span class="line"><span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="comment">/*批量读取，放入buffer这个字符数组，从第0个位置开始放置，最多放buffer.length个</span></span><br><span class="line"><span class="comment">  返回的是读到的字符的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span>(( c = isr.read(buffer,<span class="number">0</span>,buffer.length))!=-<span class="number">1</span>)&#123;</span><br><span class="line">	String s = <span class="keyword">new</span> String(buffer,<span class="number">0</span>,c);</span><br><span class="line">	System.out.print(s);</span><br><span class="line">	osw.write(buffer,<span class="number">0</span>,c);</span><br><span class="line">	osw.flush();</span><br><span class="line">&#125;</span><br><span class="line">isr.close();</span><br><span class="line">osw.close();</span><br></pre></td></tr></table></figure>
<h3 id="FileReader-FileWriter"><a href="#FileReader-FileWriter" class="headerlink" title="FileReader/FileWriter"></a>FileReader/FileWriter</h3><p>进一步封装了文件字符流的读写,使用更方便:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"e:\\javaio\\demo.txt"</span>);</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"e:\\javaio\\demo2.txt"</span>);</span><br><span class="line"><span class="comment">//FileWriter fw = new FileWriter("e:\\javaio\\demo2.txt",true);</span></span><br><span class="line"><span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2056</span>];</span><br><span class="line"><span class="keyword">int</span> c ;</span><br><span class="line"><span class="keyword">while</span>((c = fr.read(buffer,<span class="number">0</span>,buffer.length))!=-<span class="number">1</span>)&#123;</span><br><span class="line">	fw.write(buffer,<span class="number">0</span>,c);</span><br><span class="line">	fw.flush();</span><br><span class="line">&#125;</span><br><span class="line">fr.close();</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>


<h3 id="字符流的过滤器"><a href="#字符流的过滤器" class="headerlink" title="字符流的过滤器"></a>字符流的过滤器</h3><p><code>PrintWriter</code>比<code>BufferedWriter</code>使用更方便.<br><code>BufferedReader.readLine()</code>一次读一行<br><code>BufferedWriter/PrintWriter</code>一次写一行    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//对文件进行读写操作 </span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">		<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">				<span class="keyword">new</span> FileInputStream(<span class="string">"e:\\javaio\\imooc.txt"</span>)));</span><br><span class="line"><span class="comment">/*BufferedWriter bw = new BufferedWriter(</span></span><br><span class="line"><span class="comment">		new OutputStreamWriter(</span></span><br><span class="line"><span class="comment">				new FileOutputStream("e:\\javaio\\imooc3.txt")));*/</span></span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="string">"e:\\javaio\\imooc4.txt"</span>);</span><br><span class="line"><span class="comment">//PrintWriter pw1 = new PrintWriter(outputStream,boolean autoFlush);</span></span><br><span class="line">String line ;</span><br><span class="line"><span class="keyword">while</span>((line = br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	System.out.println(line);<span class="comment">//一次读一行，并不能识别换行</span></span><br><span class="line">	<span class="comment">/*bw.write(line);</span></span><br><span class="line"><span class="comment">	//单独写出换行操作</span></span><br><span class="line"><span class="comment">	bw.newLine();//换行操作</span></span><br><span class="line"><span class="comment">	bw.flush();*/</span></span><br><span class="line">	pw.println(line);</span><br><span class="line">	pw.flush();</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br><span class="line"><span class="comment">//bw.close();</span></span><br><span class="line">pw.close();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>I/O流的总结-字节流</title>
    <url>/2019/10/17/I-O%E6%B5%81%E7%9A%84%E6%80%BB%E7%BB%93-%E5%AD%97%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="IO流-输入流-输出流"><a href="#IO流-输入流-输出流" class="headerlink" title="IO流(输入流,输出流)"></a>IO流(输入流,输出流)</h2><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p>读一字节填充到int低8位:<br><code>int b = in.read();</code><br>读数据填充到字节数组:<br><code>in.read(byte[] buf);</code><br><code>in.read(byte[] buf,int start,int size);</code></p>
<h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><p>写int的低8位写入到流:<br><code>out.write(int b)</code><br>将字节数组写入到流:<br><code>out.write(byte[] buf);</code><br><code>out.write(byte[] buf,int start,int size);</code></p>
<h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>FileInputStream是InputStream的子类<br>把文件作为字节流进行读操作<br>读取指定文件内容，按照16进制输出到控制台<br>每输出10个byte换行<br><strong>单字节读取不适合大文件，大文件效率很低</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line"><span class="keyword">int</span> b ;<span class="comment">//存储每次读到的一个字节</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((b = in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(b &lt;= <span class="number">0xf</span>)&#123;</span><br><span class="line">		<span class="comment">//单位数前面补0</span></span><br><span class="line">		System.out.print(<span class="string">"0"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.print(Integer.toHexString(b)+<span class="string">"  "</span>);</span><br><span class="line">	<span class="keyword">if</span>(i++%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>

<p>批量读取文件并输出,对大文件而言效率高:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   FileInputStream in = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span> * <span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> bytes = <span class="number">0</span>;<span class="comment">//读到的字节的个数</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//一次可能读不满,只要读到数据,bytes就不可能是-1</span></span><br><span class="line"><span class="keyword">while</span>((bytes = in.read(buf,<span class="number">0</span>,buf.length))!=-<span class="number">1</span>)&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; bytes;i++)&#123;</span><br><span class="line">  System.out.print(Integer.toHexString(buf[i] &amp; <span class="number">0xff</span>)+<span class="string">"  "</span>);</span><br><span class="line">  <span class="keyword">if</span>(j++%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">	  System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>
<h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p>FileOutputStream是OutputStream的子类<br>将字节流写入文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果该文件不存在，则直接创建，如果存在，删除后创建</span></span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"demo/out.dat"</span>);</span><br><span class="line">out.write(<span class="string">'A'</span>);<span class="comment">//写出了'A'的低八位</span></span><br><span class="line">out.write(<span class="string">'B'</span>);<span class="comment">//写出了'B'的低八位</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//write只能写八位,那么写一个int需要些4次每次8位</span></span><br><span class="line">out.write(a &gt;&gt;&gt; <span class="number">24</span>);</span><br><span class="line">out.write(a &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">out.write(a &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">out.write(a);</span><br><span class="line"><span class="keyword">byte</span>[] gbk = <span class="string">"中国"</span>.getBytes(<span class="string">"gbk"</span>);</span><br><span class="line">out.write(gbk);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">IOUtil.printHex(<span class="string">"demo/out.dat"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h3><p>对”流”功能的拓展,可以更方便地写<code>int,long,double,char</code>等,常见用法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String file = <span class="string">"demo/dos.dat"</span>;</span><br><span class="line">DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">		         <span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">dos.writeInt(<span class="number">10</span>);</span><br><span class="line">dos.writeInt(-<span class="number">10</span>);</span><br><span class="line">dos.writeLong(<span class="number">10l</span>);</span><br><span class="line">dos.writeDouble(<span class="number">10.5</span>);</span><br><span class="line"><span class="comment">//采用utf-8编码写出</span></span><br><span class="line">dos.writeUTF(<span class="string">"中国"</span>);</span><br><span class="line"><span class="comment">//采用utf-16be编码写出</span></span><br><span class="line">dos.writeChars(<span class="string">"中国"</span>);</span><br><span class="line">dos.close();</span><br><span class="line">IOUtil.printHex(file);</span><br></pre></td></tr></table></figure>
<h3 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h3><p>常见用法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   String file = <span class="string">"demo/dos.dat"</span>;</span><br><span class="line">IOUtil.printHex(file);</span><br><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">  <span class="keyword">new</span> FileInputStream(file));</span><br><span class="line"><span class="keyword">int</span> i = dis.readInt();</span><br><span class="line">System.out.println(i);</span><br><span class="line">i = dis.readInt();</span><br><span class="line">System.out.println(i);</span><br><span class="line"><span class="keyword">long</span> l = dis.readLong();</span><br><span class="line">System.out.println(l);</span><br><span class="line"><span class="keyword">double</span> d = dis.readDouble();</span><br><span class="line">System.out.println(d);</span><br><span class="line">String s = dis.readUTF();</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line">   dis.close();</span><br></pre></td></tr></table></figure>
<h3 id="BufferedInputStream-amp-BufferedOutputStream"><a href="#BufferedInputStream-amp-BufferedOutputStream" class="headerlink" title="BufferedInputStream &amp; BufferedOutputStream"></a>BufferedInputStream &amp; BufferedOutputStream</h3><p> 这两个流类位IO提供了带缓冲区的操作，一般打开文件进行写入或读取操作时，都会加上缓冲，这种流模式提高了IO的性能.<br> 从应用程序中把输入放入文件，相当于将一缸水倒入到另一个缸中:<br><code>FileOutputStream.write()</code>方法相当于一滴一滴地把水“转移”过去.<br><code>DataOutputStream.writeXxx()</code>方法会方便一些，相当于一瓢一瓢把水“转移”过去.<br> <code>BufferedOutputStream.write()</code>方法更方便，相当于一瓢一瓢先放入桶中，再从桶中倒入到另一个缸中，性能提高了.<br>利用带缓冲的字节流, 进行文件的拷贝:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFileByBuffer</span><span class="params">(File srcFile,File destFile)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!srcFile.exists())&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"文件:"</span>+srcFile+<span class="string">"不存在"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!srcFile.isFile())&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(srcFile+<span class="string">"不是文件"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">				<span class="keyword">new</span> FileInputStream(srcFile));</span><br><span class="line">		BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">				<span class="keyword">new</span> FileOutputStream(destFile));</span><br><span class="line">		<span class="keyword">int</span> c ;</span><br><span class="line">		<span class="keyword">while</span>((c = bis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			bos.write(c);</span><br><span class="line">			bos.flush();<span class="comment">//刷新缓冲区</span></span><br><span class="line">		&#125;</span><br><span class="line">		bis.close();</span><br><span class="line">		bos.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java关于反射的总结</title>
    <url>/2019/10/21/Java%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="获取Class-Type的三种方式"><a href="#获取Class-Type的三种方式" class="headerlink" title="获取Class Type的三种方式"></a>获取Class Type的三种方式</h1><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><ol>
<li><code>Class c1 = Foo.class;</code></li>
<li><code>Class c2 = foo.getClass();</code><br>c1 == c2  -&gt;  true  类对象唯一</li>
<li><code>Class c3 = Class.forName(&quot;com.xxx.Foo&quot;);</code><br>推荐使用该方式，最快，但会抛异常，要try-catch</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo foo = (Foo)c1.newInstance();<span class="comment">//Foo需要有无参构造函数</span></span><br></pre></td></tr></table></figure>

<h1 id="动态加载类"><a href="#动态加载类" class="headerlink" title="动态加载类"></a>动态加载类</h1><p><strong>使用new创建对象，是静态加载类，在编译时刻就需要加载所有可能用到的类。</strong> 如果项目中大部分类暂时用不到（比如用于解决特例情况），或者为了避免因一个（模块）类的失效导致整个系统的不可用，我们可以使用动态（运行时）加载类。<br>如：<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Excel</span> <span class="keyword">implements</span> <span class="title">OfficeAble</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Excel starting..."</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span> <span class="keyword">implements</span> <span class="title">OfficeAble</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Word starting..."</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Office</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//动态加载类，在运行时刻加载</span></span><br><span class="line">			Class <span class="class"><span class="keyword">class</span> </span>= Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">			<span class="comment">//Foo需要有无参构造函数</span></span><br><span class="line">			OfficeAble oa = (OfficeAble)<span class="class"><span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br><span class="line">			oa.start();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 编译好发布以后，后期软件更新，新的模块（如ppt）只需要实现OfficeAble接口即可。</p>
<h1 id="获取Class-Type信息"><a href="#获取Class-Type信息" class="headerlink" title="获取Class Type信息"></a>获取Class Type信息</h1><p>我们可以通过以下代码简单地获取一个类的<strong>成员函数</strong>，<strong>成员变量</strong>和<strong>构造函数</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtil</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 打印类的信息，包括类的成员函数、成员变量</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> obj 该类的一个对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassMethodMessage</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="comment">//要获取类的信息  首先要获取类的类类型</span></span><br><span class="line">		Class c = obj.getClass();<span class="comment">//传递的是哪个子类的对象  c就是该子类的类类型</span></span><br><span class="line">		<span class="comment">//获取类的名称</span></span><br><span class="line">		System.out.println(<span class="string">"类的名称是:"</span>+c.getName());</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Method类，方法对象</span></span><br><span class="line"><span class="comment">		 * 一个成员方法就是一个Method对象</span></span><br><span class="line"><span class="comment">		 * getMethods()方法获取的是所有的public的函数，包括父类继承而来的</span></span><br><span class="line"><span class="comment">		 * getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Method[] ms = c.getMethods();<span class="comment">//c.getDeclaredMethods()</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ms.length;i++)&#123;</span><br><span class="line">			<span class="comment">//得到方法的返回值类型的类类型</span></span><br><span class="line">			Class returnType = ms[i].getReturnType();</span><br><span class="line">			System.out.print(returnType.getName()+<span class="string">" "</span>);</span><br><span class="line">			<span class="comment">//得到方法的名称</span></span><br><span class="line">			System.out.print(ms[i].getName()+<span class="string">"("</span>);</span><br><span class="line">			<span class="comment">//获取参数类型---&gt;得到的是参数列表的类型的类类型</span></span><br><span class="line">			Class[] paramTypes = ms[i].getParameterTypes();</span><br><span class="line">			<span class="keyword">for</span> (Class class1 : paramTypes) &#123;</span><br><span class="line">				System.out.print(class1.getName()+<span class="string">","</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">")"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取成员变量的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFieldMessage</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		Class c = obj.getClass();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 成员变量也是对象</span></span><br><span class="line"><span class="comment">		 * java.lang.reflect.Field</span></span><br><span class="line"><span class="comment">		 * Field类封装了关于成员变量的操作</span></span><br><span class="line"><span class="comment">		 * getFields()方法获取的是所有的public的成员变量的信息</span></span><br><span class="line"><span class="comment">		 * getDeclaredFields获取的是该类自己声明的成员变量的信息</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//Field[] fs = c.getFields();</span></span><br><span class="line">		Field[] fs = c.getDeclaredFields();</span><br><span class="line">		<span class="keyword">for</span> (Field field : fs) &#123;</span><br><span class="line">			<span class="comment">//得到成员变量的类型的类类型</span></span><br><span class="line">			Class fieldType = field.getType();</span><br><span class="line">			String typeName = fieldType.getName();</span><br><span class="line">			<span class="comment">//得到成员变量的名称</span></span><br><span class="line">			String fieldName = field.getName();</span><br><span class="line">			System.out.println(typeName+<span class="string">" "</span>+fieldName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 打印对象的构造函数的信息</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConMessage</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		Class c = obj.getClass();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 构造函数也是对象</span></span><br><span class="line"><span class="comment">		 * java.lang. Constructor中封装了构造函数的信息</span></span><br><span class="line"><span class="comment">		 * getConstructors获取所有的public的构造函数</span></span><br><span class="line"><span class="comment">		 * getDeclaredConstructors得到所有的构造函数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//Constructor[] cs = c.getConstructors();</span></span><br><span class="line">		Constructor[] cs = c.getDeclaredConstructors();</span><br><span class="line">		<span class="keyword">for</span> (Constructor constructor : cs) &#123;</span><br><span class="line">			System.out.print(constructor.getName()+<span class="string">"("</span>);</span><br><span class="line">			<span class="comment">//获取构造函数的参数列表---&gt;得到的是参数列表的类类型</span></span><br><span class="line">			Class[] paramTypes = constructor.getParameterTypes();</span><br><span class="line">			<span class="keyword">for</span> (Class class1 : paramTypes) &#123;</span><br><span class="line">				System.out.print(class1.getName()+<span class="string">","</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">")"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="方法的反射"><a href="#方法的反射" class="headerlink" title="方法的反射"></a>方法的反射</h1><p><strong>方法名称+参数列表</strong> 确定一个方法<br>通过<code>method.invoke();</code>实现反射调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	   <span class="comment">//要获取print(int ,int )方法  1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型</span></span><br><span class="line">		A a1 = <span class="keyword">new</span> A();</span><br><span class="line">		Class c = a1.getClass();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * getMethod获取的是public的方法</span></span><br><span class="line"><span class="comment">		 * getDelcaredMethod自己声明的方法</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Method m =  c.getMethod("print", new Class[]&#123;int.class,int.class&#125;);</span></span><br><span class="line">	    	Method m = c.getMethod(<span class="string">"print"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">	    	</span><br><span class="line">	    	<span class="comment">// 方法的反射操作  </span></span><br><span class="line">	    	<span class="comment">// a1.print(10, 20);方法的反射操作是用m对象来进行方法调用 和a1.print调用的效果完全相同</span></span><br><span class="line">	        <span class="comment">// 方法如果没有返回值返回null,有返回值返回具体的返回值</span></span><br><span class="line">	    	<span class="comment">// Object o = m.invoke(a1,new Object[]&#123;10,20&#125;);</span></span><br><span class="line">	    	Object o = m.invoke(a1, <span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">	    	System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">	    	<span class="comment">// 获取方法print(String,String)</span></span><br><span class="line">             Method m1 = c.getMethod(<span class="string">"print"</span>,String<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">             <span class="comment">// 用方法进行反射操作</span></span><br><span class="line">             <span class="comment">// a1.print("hello", "WORLD");</span></span><br><span class="line">             o = m1.invoke(a1, <span class="string">"hello"</span>,<span class="string">"WORLD"</span>);</span><br><span class="line">             System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">             <span class="comment">// Method m2 = c.getMethod("print", new Class[]&#123;&#125;);</span></span><br><span class="line">                Method m2 = c.getMethod(<span class="string">"print"</span>);</span><br><span class="line">               <span class="comment">// m2.invoke(a1, new Object[]&#123;&#125;);</span></span><br><span class="line">                m2.invoke(a1);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"helloworld"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		System.out.println(a+b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String a,String b)</span></span>&#123;</span><br><span class="line">		System.out.println(a.toUpperCase()+<span class="string">","</span>+b.toLowerCase());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="帮助理解泛型的本质"><a href="#帮助理解泛型的本质" class="headerlink" title="帮助理解泛型的本质"></a>帮助理解泛型的本质</h1><p>Java中集合的泛型，定义的模板是防止错误输入的，只在编译阶段有效，编译阶段以后就无效了，我们可以通过方法的反射来操作，绕过泛型模板的限制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		</span><br><span class="line">		ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		list1.add(<span class="string">"hello"</span>);</span><br><span class="line">		<span class="comment">//list1.add(20);错误的</span></span><br><span class="line">		Class c1 = list.getClass();</span><br><span class="line">		Class c2 = list1.getClass();</span><br><span class="line">		System.out.println(c1 == c2);</span><br><span class="line">		<span class="comment">//反射的操作都是编译之后的操作,c1==c2结果返回true说明编译之后集合的泛型是去泛型化的， 验证：我们可以通过方法的反射来操作，绕过编译</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Method m = c2.getMethod(<span class="string">"add"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			m.invoke(list1, <span class="number">20</span>);<span class="comment">//绕过编译操作就绕过了泛型</span></span><br><span class="line">			System.out.println(list1.size());</span><br><span class="line">			System.out.println(list1);</span><br><span class="line">			<span class="comment">/*for (String string : list1) &#123;</span></span><br><span class="line"><span class="comment">				System.out.println(string);</span></span><br><span class="line"><span class="comment">			&#125;*/</span><span class="comment">//现在不能这样遍历</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		  e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Linux关机与重启</title>
    <url>/2019/10/09/Linux%E5%85%B3%E6%9C%BA%E4%B8%8E%E9%87%8D%E5%90%AF/</url>
    <content><![CDATA[<h2 id="关机与重启"><a href="#关机与重启" class="headerlink" title="关机与重启"></a>关机与重启</h2><h4 id="shutdown命令"><a href="#shutdown命令" class="headerlink" title="shutdown命令"></a>shutdown命令</h4><p>安全的关机命令<code>shutdown [选项] 时间</code><br>关机时会自动保存运行数据<br>时间为<code>now</code>则立即执行,或<code>23:30</code>定时关机</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>取消前一个关机命令</td>
</tr>
<tr>
<td>-h</td>
<td>关机</td>
</tr>
<tr>
<td>-r</td>
<td>重启</td>
</tr>
</tbody></table>
<p>不安全的关机:<code>halt, poweroff, init 0</code>等,尽量不用<br>重启:<code>reboot</code>可用,较安全,<code>init 6</code>尽量不用</p>
<h4 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h4><p><code>runlevel</code>可查看系统运行级别</p>
<table>
<thead>
<tr>
<th>系统运行级别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>关机</td>
</tr>
<tr>
<td>1</td>
<td>单用户(类似win安全模式)</td>
</tr>
<tr>
<td>2</td>
<td>不完全多用户,不含NFS(文件共享)服务</td>
</tr>
<tr>
<td>3</td>
<td>完全多用户   常用</td>
</tr>
<tr>
<td>4</td>
<td>未分配</td>
</tr>
<tr>
<td>5</td>
<td>图形界面</td>
</tr>
<tr>
<td>6</td>
<td>重启</td>
</tr>
</tbody></table>
<p>CentOS系统启动的默认运行级别<code>initdefault</code>的设置在<code>/etc/inittab</code>中,<code>initdefault</code>不能改为0或6,否则无法开机!</p>
<h4 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h4><p><code>logout</code><br>linux默认最多允许256个用户同时登录<br>winXP默认最多允许1个用户同时登录<br>winSever 2003默认最多允许2个用户同时登录<br>winSever 2008默认最多允许4-8个用户同时登录<br>直接关闭终端窗口并不能退出用户,终端号没有释放,一定要手动<code>logout</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux帮助命令</title>
    <url>/2019/11/03/Linux%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="man-命令"><a href="#man-命令" class="headerlink" title="man 命令"></a>man 命令</h1><h2 id="man-命令名"><a href="#man-命令名" class="headerlink" title="man 命令名"></a><code>man 命令名</code></h2><p>man是manual的简写<br>如<code>man ls</code></p>
<h2 id="man-f-命令名"><a href="#man-f-命令名" class="headerlink" title="man -f 命令名"></a><code>man -f 命令名</code></h2><p>man帮助文档,可以按级别查看:<br><code>man -f 命令名</code>相当于<code>whatis 命令名</code><br>举例:<br><code>shell
man -5 passwd  #系统所有用户信息
man -4 null  #系统黑洞
man -8 ifconfig</code><br>如果只有一种等级的帮助文档,直接<code>man 命令名</code>即可<br><img src="https://img-blog.csdnimg.cn/20191208165450164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="man-k-命令名"><a href="#man-k-命令名" class="headerlink" title="man -k 命令名"></a><code>man -k 命令名</code></h2><p>man查看和命令相关的所有帮助:<br><code>man -k 命令名</code>相当于<code>apropos 命令名</code><br>如:<code>apropos passwd</code><br><br></p>
<h1 id="help-选项帮助"><a href="#help-选项帮助" class="headerlink" title="--help 选项帮助"></a>--help 选项帮助</h1><p>比较常用,通过命令选项获取帮助,如<code>ls --help</code><br><br></p>
<h1 id="help获取shell内部命令的帮助"><a href="#help获取shell内部命令的帮助" class="headerlink" title="help获取shell内部命令的帮助"></a>help获取shell内部命令的帮助</h1><p><code>help shell内部命令</code>获取shell内部命令的帮助<br>如<br><code>shell
whereis cd    #检查是否是shell内部命令,whereis只能找到外部命令的可执行文件位置
help cd        #获取帮助
help ls      #ls不是内部命令,所以找不到帮助文件</code><br>shell内部命令是最基本的命令<br><br></p>
<h1 id="info详细命令帮助"><a href="#info详细命令帮助" class="headerlink" title="info详细命令帮助"></a>info详细命令帮助</h1><p><code>info 命令名</code>帮助文档,很详细,用得少.<br><img src="https://img-blog.csdnimg.cn/20191208172719768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>TopK词频统计</title>
    <url>/2019/10/24/TopK%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="查询所有记录中搜索频次最高的30个关键词"><a href="#查询所有记录中搜索频次最高的30个关键词" class="headerlink" title="查询所有记录中搜索频次最高的30个关键词"></a>查询所有记录中搜索频次最高的30个关键词</h2><p>主要分两个步骤，首先多个mapper分别处理所有数据中的一部分关键词数据，然后汇总到reducer做词频统计。</p>
<h2 id="CountWordMapper"><a href="#CountWordMapper" class="headerlink" title="CountWordMapper"></a>CountWordMapper</h2><p>在Mapper中处理每一小块数据，使用HashMap存储关键字及其频次，可以节省时间，key为查询的关键字。Mapper返回一个<code>&lt;Text , LongWritable&gt;</code>的列表，存储当前文件块中的关键字及其频次，传给reducer作统计。</p>
<h2 id="CountWordReducer"><a href="#CountWordReducer" class="headerlink" title="CountWordReducer"></a>CountWordReducer</h2><p>Reducer将所有mapper得到的关键字及频次汇总，不同mapper下的相同关键字在此合并，可得到当前关键字的总频次。为了得到TopK数据，在reducer维护一个大小为K的小顶堆，每次得到一个关键词的搜索总频次即向堆中插入一个<code>Pair&lt;String, Long&gt;</code>，堆中元素排序自定义为关键词频次Long。当堆元素大于K时，将堆顶元素（即当前最小元素）删去。最后reducer可得到访问频次最大的TopK关键词。输出前将堆中元素按频次排序即可。</p>
<p>词频统计完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        countWords();    <span class="comment">//统计词频前30的搜索关键词</span></span><br><span class="line">        countUrls();   <span class="comment">//被访问次数前10的网址及其次数占比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countWords</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String input_dir = <span class="string">"./data/sogou.full.utf8"</span>;<span class="comment">//input</span></span><br><span class="line">        String outputDir = <span class="string">"./result/words"</span>;<span class="comment">//output</span></span><br><span class="line"></span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        FileSystem fs = FileSystem.get(conf);</span><br><span class="line">        fs.deleteOnExit(<span class="keyword">new</span> Path(outputDir));</span><br><span class="line">        fs.close();</span><br><span class="line"></span><br><span class="line">        Job job = <span class="keyword">new</span> Job(conf, <span class="string">"CountWords"</span>);</span><br><span class="line">        job.setMapperClass(CountWordMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(CountWordReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       </span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(LongWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(LongWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        job.setInputFormatClass(TextInputFormat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        TextInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(input_dir));</span><br><span class="line"></span><br><span class="line">        job.setOutputFormatClass(TextOutputFormat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        TextOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(outputDir));</span><br><span class="line">        job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CountWordMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountWordMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//使用hash表存储关键词和该词的频次</span></span><br><span class="line">    HashMap&lt;String, Long&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分离各项数据，以‘\t’为间隔标志</span></span><br><span class="line">        String fields[] = value.toString().split(<span class="string">"\t"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fields.length != <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String keyWord = fields[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> count=map.getOrDefault(keyWord,-<span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">if</span> (count==-<span class="number">1L</span>)<span class="comment">//判断该词是否已存在于hash表中</span></span><br><span class="line">            map.put(keyWord,<span class="number">1L</span>);<span class="comment">//不存在，加入新词</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            map.replace(keyWord,count+<span class="number">1</span>);<span class="comment">//存在，词频加一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(Mapper&lt;LongWritable, Text,  Text , LongWritable&gt;.Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//将当前文件块内关键词的频度输出给reducer</span></span><br><span class="line">        <span class="keyword">for</span> (String keyWord : map.keySet()) &#123;</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(keyWord), <span class="keyword">new</span> LongWritable(map.get(keyWord)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//CountWordReducer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountWordReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> K = <span class="number">30</span>;<span class="comment">//选出频次最大的K条关键词</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//小顶堆，容量K，用于快速删除词频最小的元素</span></span><br><span class="line">    PriorityQueue&lt;Pair&lt;String, Long&gt;&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((p1, p2) -&gt; (<span class="keyword">int</span>) (p1.getValue() - p2.getValue()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次传入的参数为key相同的values的集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (LongWritable count : values) &#123;</span><br><span class="line">            <span class="comment">//依次取出每个mapper统计的关键词key的频次，加起来</span></span><br><span class="line">            total += count.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pair&lt;String, Long&gt; tmp = <span class="keyword">new</span> Pair&lt;&gt;(key.toString(), total);</span><br><span class="line">        minHeap.add(tmp);<span class="comment">//向小顶堆插入新的关键词词频</span></span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() &gt; K)<span class="comment">//若小顶堆容量达到要求的上限</span></span><br><span class="line">            minHeap.poll();<span class="comment">//删除堆顶最小的元素，保持TopK</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        List&lt;Pair&lt;String, Long&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//从小顶堆中取出数据，便于排序</span></span><br><span class="line">        <span class="keyword">for</span> (Pair&lt;String, Long&gt; p : minHeap)</span><br><span class="line">            list.add(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对搜索词频前K个元素排序</span></span><br><span class="line">        Collections.sort(list, ((p1, p2) -&gt; (<span class="keyword">int</span>) (p2.getValue() - p1.getValue())));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//reducer的输出，按搜索词频排好序的TopK关键词</span></span><br><span class="line">        <span class="keyword">for</span> (Pair&lt;String, Long&gt; t : list)</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(t.getKey()), <span class="keyword">new</span> LongWritable(t.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MapReduce</category>
      </categories>
  </entry>
  <entry>
    <title>java关于多线程的总结</title>
    <url>/2019/10/15/java%E5%85%B3%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>进程是==程序的执行过程==（动态性），持有<strong>资源</strong>（共享内存、共享文件）和<strong>线程</strong>（是资源和线程的载体）</p>
</li>
<li><p><strong>线程</strong>是系统中==最小的执行单元==</p>
<h2 id="线程间交互"><a href="#线程间交互" class="headerlink" title="线程间交互"></a>线程间交互</h2></li>
</ul>
<ol>
<li><p><strong>互斥</strong> 资源有限，需抢占</p>
</li>
<li><p><strong>同步</strong> 协作完成一项任务，有先后顺序</p>
<h1 id="java线程初探"><a href="#java线程初探" class="headerlink" title="java线程初探"></a>java线程初探</h1><h2 id="java对线程的支持"><a href="#java对线程的支持" class="headerlink" title="java对线程的支持"></a>java对线程的支持</h2><p><code>Thread</code>类和<code>Runnable</code>接口，以及共同的<code>run()</code>方法。<br><img src="https://img-blog.csdnimg.cn/20191203220122134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="java对线程的支持"></p>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p><code>join()</code>使当前运行线程<strong>等待调用线程的终止</strong>，再继续运行<br><code>yield()</code>使当前运行线程<strong>释放处理器资源</strong><br>停止线程的错误方法 1.<del>stop()</del>         2.<del>interrupt()</del><br>使用退出标志（<code>volatile bool keepRunning</code>）停止线程循环<br><img src="https://img-blog.csdnimg.cn/20191203221138225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Thread和Runnable示例"><a href="#Thread和Runnable示例" class="headerlink" title="Thread和Runnable示例"></a>Thread和Runnable示例</h2><p>Thread和Runnable各自每运行10次暂停1s，交替运行。一个.java文件可有多个类（不包括内部类），但只能有一个public类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Actor</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(getName()+<span class="string">"是一个演员！"</span>);</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">boolean</span> keepRunning = <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span>(keepRunning)&#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">"登台演出："</span>+ (++count));</span><br><span class="line">			<span class="keyword">if</span>(count == <span class="number">100</span>)&#123;</span><br><span class="line">				keepRunning = <span class="keyword">false</span>;</span><br><span class="line">			&#125;	</span><br><span class="line">			<span class="keyword">if</span>(count%<span class="number">10</span>== <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(getName()+<span class="string">"的演出结束了！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Thread actor = <span class="keyword">new</span> Actor();</span><br><span class="line">		actor.setName(<span class="string">"Mr. Thread"</span>);</span><br><span class="line">		actor.start();</span><br><span class="line">		Thread actressThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Actress(),<span class="string">"Ms. Runnable"</span>);</span><br><span class="line">		actressThread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actress</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">"是一个演员！"</span>);</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">boolean</span> keepRunning = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span>(keepRunning)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"登台演出："</span>+ (++count));	</span><br><span class="line">			<span class="keyword">if</span>(count == <span class="number">100</span>)&#123;</span><br><span class="line">				keepRunning = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(count%<span class="number">10</span>== <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"的演出结束了！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下:<br><img src="https://img-blog.csdnimg.cn/2019120513395094.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191205134111771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p><img src="https://img-blog.csdnimg.cn/20191205140153638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>阻塞事件:如<code>sleep(),wait(),join()</code>方法被调用</p>
<h1 id="java守护线程"><a href="#java守护线程" class="headerlink" title="java守护线程"></a>java守护线程</h1><p>java线程分两类:<br>1.用户线程<br>2.守护线程   一旦所有用户线程都结束了,守护线程也就结束了<br><img src="https://img-blog.csdnimg.cn/20191205140656498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191205140834109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191205140852906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191205140938132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="jstack生成线程快照"><a href="#jstack生成线程快照" class="headerlink" title="jstack生成线程快照"></a>jstack生成线程快照</h1><p><img src="https://img-blog.csdnimg.cn/20191205142146779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191205142411386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>java关于文件操作的总结</title>
    <url>/2019/10/19/java%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="文件的编码"><a href="#文件的编码" class="headerlink" title="文件的编码"></a>文件的编码</h1><p>文本文件就是字符(字节)序列,是原始字符串按照某种编码方式编码而成的字节序列.常见编码有</p>
<ul>
<li>utf-8   中文3字节  英文1字节</li>
<li>ansi   扩展的ASCII编码 中文2字节  英文1字节</li>
<li>GBK  中文系统下,ansi即GBK,是基于GB2312的扩展 中文2字节  英文1字节 </li>
<li>utf-16be  java双字节编码  中文2字节  英文2字节</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">"中文abc"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes=s.getBytes(<span class="string">"gbk"</span>);</span><br><span class="line"><span class="comment">//byte[] bytes=s.getBytes("utf-8");</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">byte</span> b:bytes)&#123;<span class="comment">//int 4 byte</span></span><br><span class="line">    System.out..println(Integer.toHexString(b &amp; <span class="number">0xff</span>) + <span class="string">" "</span>);					</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String str=<span class="keyword">new</span> String(bytes,<span class="string">"utf-8"</span>);</span><br><span class="line">System.out..println(str);<span class="comment">//输出乱码,因为bytes是按gbk编码的</span></span><br><span class="line"><span class="comment">//String str=new String(bytes,"gbk");</span></span><br></pre></td></tr></table></figure>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p>java.io.File类用于表示文件和目录,但不能访问文件的内容,用法示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">file.getAbsolutePath();</span><br><span class="line">file.getName();</span><br><span class="line">file.getParent();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 了解构造函数的情况  查帮助</span></span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"E:\\javaio\\imooc"</span>);</span><br><span class="line">		<span class="comment">//System.out.println(file.exists());</span></span><br><span class="line">		<span class="keyword">if</span>(!file.exists())</span><br><span class="line">			file.mkdir(); <span class="comment">//file.mkdirs()多级目录</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			file.delete();</span><br><span class="line">		<span class="comment">//是否是一个目录  如果是目录返回true,如果不是目录or目录不存在返回的是false</span></span><br><span class="line">		System.out.println(file.isDirectory());</span><br><span class="line">		<span class="comment">//是否是一个文件</span></span><br><span class="line">		System.out.println(file.isFile());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//File file2 = new File("e:\\javaio\\日记1.txt");</span></span><br><span class="line">		File file2 = <span class="keyword">new</span> File(<span class="string">"e:\\javaio"</span>,<span class="string">"日记1.txt"</span>);</span><br><span class="line">		<span class="keyword">if</span>(!file2.exists())</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				file2.createNewFile();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			file2.delete();</span><br><span class="line">         <span class="comment">//常用的File对象的API</span></span><br><span class="line">		System.out.println(file);<span class="comment">//file.toString()的内容</span></span><br><span class="line">	    System.out.println(file.getParentFile().getAbsolutePath());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h1><p>提供对文件内容的访问,支持随机读写文件.文件读写完毕应关闭<code>close()</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;writeInt()&#96;&#96;&#96;写int 4个字节</span><br><span class="line">&#96;&#96;&#96;read()&#96;&#96;&#96;一次只读一个字节</span><br><span class="line">&#96;&#96;&#96;getFilePointer()&#96;&#96;&#96;获取文件指针</span><br><span class="line">&#96;&#96;&#96;seek()&#96;&#96;&#96;移动文件指针</span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public class RandomAccessFileSeriaDemo &#123;</span><br><span class="line">	public static void main(String[] args)throws IOException &#123;</span><br><span class="line">        File demo &#x3D; new File(&quot;demo1&quot;);</span><br><span class="line">        if (!demo.exists()) demo.mkdir();</span><br><span class="line">        File file &#x3D; new File(demo, &quot;raf.dat&quot;);</span><br><span class="line">        if (!file.exists())</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#x2F;&#x2F;打开文件，进行随机读写</span><br><span class="line">        RandomAccessFile raf &#x3D; new RandomAccessFile(file, &quot;rw&quot;);</span><br><span class="line">        &#x2F;*序列化*&#x2F;</span><br><span class="line">        &#x2F;&#x2F;写int 4 byte</span><br><span class="line">        int i &#x3D; 0x7ffffff;</span><br><span class="line">        raf.write(i &gt;&gt;&gt; 24);&#x2F;&#x2F;右移24位 写高8位</span><br><span class="line">        raf.write(i &gt;&gt;&gt; 16);</span><br><span class="line">        raf.write(i &gt;&gt;&gt; 8);</span><br><span class="line">        raf.write(i);</span><br><span class="line">&#x2F;&#x2F;        raf.writeInt(i);</span><br><span class="line">        System.out.println(raf.getFilePointer());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Linux压缩与解压</title>
    <url>/2019/11/03/Linux%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/</url>
    <content><![CDATA[<h2 id="zip格式"><a href="#zip格式" class="headerlink" title=".zip格式"></a>.zip格式</h2><h4 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h4><p><code>zip 文件.zip 源文件</code></p>
<h4 id="压缩文件夹"><a href="#压缩文件夹" class="headerlink" title="压缩文件夹"></a>压缩文件夹</h4><p><code>zip -r 文件夹.zip 源目录</code></p>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p><code>unzip 文件.zip</code></p>
<h2 id="gz格式"><a href="#gz格式" class="headerlink" title=".gz格式"></a>.gz格式</h2><h4 id="压缩文件-1"><a href="#压缩文件-1" class="headerlink" title="压缩文件"></a>压缩文件</h4><p><code>gzip 源文件</code><br>压缩为.gz格式,且源文件会消失<br><code>gzip -c 源文件 &gt; 源文件.gz</code><br>压缩为.gz格式,保留源文件,不常用,”-c”表示把压缩文件输出到屏幕,”&gt;”表示输出重定向</p>
<h4 id="压缩目录-下的所有子文件"><a href="#压缩目录-下的所有子文件" class="headerlink" title="压缩目录(下的所有子文件)"></a>压缩目录(下的所有子文件)</h4><p><code>gzip -r 目录</code><br>压缩目录下的所有子文件,但是不能压缩目录.(很不方便,不常用)</p>
<h4 id="解压-1"><a href="#解压-1" class="headerlink" title="解压"></a>解压</h4><p><code>gzip -d 压缩文件</code>或<code>gunzip 压缩文件</code></p>
<h5 id="解压目录-下的所有子文件"><a href="#解压目录-下的所有子文件" class="headerlink" title="解压目录(下的所有子文件)"></a>解压目录(下的所有子文件)</h5><p><code>gunzip -r 目录</code></p>
<h2 id="bz2格式"><a href="#bz2格式" class="headerlink" title=".bz2格式"></a>.bz2格式</h2><h4 id="压缩文件-2"><a href="#压缩文件-2" class="headerlink" title="压缩文件"></a>压缩文件</h4><p><code>bzip2 源文件</code><br>不保留源文件<br><code>bzip2 -k 源文件</code><br>保留源文件</p>
<p><strong>bzip2命令不能压缩目录!</strong></p>
<h4 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h4><p><code>bzip2 -d 源文件</code>或<code>bunzip2 源文件</code><br>-k保留压缩文件<br><br></p>
<p><strong>.gz和.bz2对目录的处理不太友好,下面介绍tar打包命令</strong></p>
<h2 id="tar打包命令"><a href="#tar打包命令" class="headerlink" title="tar打包命令"></a>tar打包命令</h2><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><h6 id="tar-cvf-打包名-源文件"><a href="#tar-cvf-打包名-源文件" class="headerlink" title="tar -cvf 打包名 源文件"></a><code>tar -cvf 打包名 源文件</code></h6><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>打包</td>
</tr>
<tr>
<td>-v</td>
<td>显示过程</td>
</tr>
<tr>
<td>-f</td>
<td>指定打包后的文件名</td>
</tr>
</tbody></table>
<p>如<code>tar -cvf xxx.tar xxx</code></p>
<h4 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h4><h6 id="tar-xvf-打包名"><a href="#tar-xvf-打包名" class="headerlink" title="tar -xvf 打包名"></a><code>tar -xvf 打包名</code></h6><p>如<code>tar -xvf xxx.tar</code></p>
<h4 id="打包-压缩为-gz"><a href="#打包-压缩为-gz" class="headerlink" title="打包+压缩为.gz"></a>打包+压缩为.gz</h4><h6 id="tar-zcvf-打包名-tar-gz-源文件-源文件2-源文件3"><a href="#tar-zcvf-打包名-tar-gz-源文件-源文件2-源文件3" class="headerlink" title="tar -zcvf 打包名.tar.gz 源文件 [源文件2] [源文件3]..."></a><code>tar -zcvf 打包名.tar.gz 源文件 [源文件2] [源文件3]...</code></h6><p><code>-z</code>代表.gz,可以有多个源文件,空格隔开</p>
<h4 id="解压缩-tar-gz"><a href="#解压缩-tar-gz" class="headerlink" title="解压缩.tar.gz"></a>解压缩.tar.gz</h4><h6 id="tar-zxvf-打包名-tar-gz-C-新位置"><a href="#tar-zxvf-打包名-tar-gz-C-新位置" class="headerlink" title="tar -zxvf 打包名.tar.gz [-C 新位置]"></a><code>tar -zxvf 打包名.tar.gz [-C 新位置]</code></h6><p><code>-z</code>代表.gz</p>
<h4 id="打包-压缩为-bz2"><a href="#打包-压缩为-bz2" class="headerlink" title="打包+压缩为.bz2"></a>打包+压缩为.bz2</h4><h6 id="tar-jcvf-打包名-tar-bz2-源文件"><a href="#tar-jcvf-打包名-tar-bz2-源文件" class="headerlink" title="tar -jcvf 打包名.tar.bz2 源文件"></a><code>tar -jcvf 打包名.tar.bz2 源文件</code></h6><p><code>-j</code>代表.bz2,,可以有多个源文件,空格隔开</p>
<h4 id="解压缩-tar-bz2"><a href="#解压缩-tar-bz2" class="headerlink" title="解压缩.tar.bz2"></a>解压缩.tar.bz2</h4><h6 id="tar-jxvf-打包名-tar-bz2-C-新位置"><a href="#tar-jxvf-打包名-tar-bz2-C-新位置" class="headerlink" title="tar -jxvf 打包名.tar.bz2 [-C 新位置]"></a><code>tar -jxvf 打包名.tar.bz2 [-C 新位置]</code></h6><p><code>-j</code>代表.bz2</p>
<h4 id="查看压缩包-不解压"><a href="#查看压缩包-不解压" class="headerlink" title="查看压缩包,不解压"></a>查看压缩包,不解压</h4><h6 id="tar-ztvf-打包名-tar-gz"><a href="#tar-ztvf-打包名-tar-gz" class="headerlink" title="tar -ztvf 打包名.tar.gz"></a><code>tar -ztvf 打包名.tar.gz</code></h6><h6 id="tar-jtvf-打包名-tar-bz2"><a href="#tar-jtvf-打包名-tar-bz2" class="headerlink" title="tar -jtvf 打包名.tar.bz2"></a><code>tar -jtvf 打包名.tar.bz2</code></h6><p><code>-t</code>代表test,查看文件内容.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>java关于对象序列化的总结</title>
    <url>/2019/10/13/java%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对象序列化，就是<strong>将Object转换成byte序列</strong>，反之叫对象的反序列化.</p>
<ul>
<li>序列化流(<code>ObjectOutputStream</code>),是过滤流—-writeObject</li>
<li>反序列化流(<code>ObjectInputStream</code>)—-readObject</li>
</ul>
<h3 id="序列化接口-Serializable"><a href="#序列化接口-Serializable" class="headerlink" title="序列化接口(Serializable)"></a>序列化接口(Serializable)</h3><p>   对象必须实现序列化接口 ，才能进行序列化，否则将出现异常<br>   这个接口，没有任何方法，只是一个标准.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String file = <span class="string">"demo/obj.dat"</span>;</span><br><span class="line">		<span class="comment">//1.对象的序列化</span></span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">				<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">		Student stu = <span class="keyword">new</span> Student(<span class="string">"10001"</span>, <span class="string">"张三"</span>, <span class="number">20</span>);</span><br><span class="line">		oos.writeObject(stu);</span><br><span class="line">		oos.flush();</span><br><span class="line">		oos.close();</span><br><span class="line">		<span class="comment">//2.对象的反序列化</span></span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">				<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">		Student stu = (Student)ois.readObject();</span><br><span class="line">		System.out.println(stu);</span><br><span class="line">		ois.close();</span><br></pre></td></tr></table></figure>

<h3 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h3><p><code>transient</code>修饰的变量不会进行jvm默认的序列化,但可以自己完成这个元素的序列化.即覆写:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">		        <span class="keyword">throws</span> java.io.IOException</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">		        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String stuno;</span><br><span class="line">	<span class="keyword">private</span> String stuname;</span><br><span class="line">	<span class="comment">//该元素不会进行jvm默认的序列化,也可以自己完成这个元素的序列化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> stuage;  </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String stuno, String stuname, <span class="keyword">int</span> stuage)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.stuno = stuno;</span><br><span class="line">		<span class="keyword">this</span>.stuname = stuname;</span><br><span class="line">		<span class="keyword">this</span>.stuage = stuage;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getStuno</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stuno;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuno</span><span class="params">(String stuno)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.stuno = stuno;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getStuname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stuname;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuname</span><span class="params">(String stuname)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.stuname = stuname;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStuage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stuage;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuage</span><span class="params">(<span class="keyword">int</span> stuage)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.stuage = stuage;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Student [stuno="</span> + stuno + <span class="string">", stuname="</span> + stuname + <span class="string">", stuage="</span></span><br><span class="line">				+ stuage + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">		        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">		 s.defaultWriteObject();<span class="comment">//把jvm能默认序列化的元素进行序列化操作</span></span><br><span class="line">		 s.writeInt(stuage);<span class="comment">//自己完成stuage的序列化</span></span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">		        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">		  s.defaultReadObject();<span class="comment">//把jvm能默认反序列化的元素进行反序列化操作</span></span><br><span class="line">		  <span class="keyword">this</span>.stuage = s.readInt();<span class="comment">//自己完成stuage的反序列化操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 如<code>ArrayList</code>源码中对<code>elementData</code>数组序列化和反序列化的处理,因为<code>elementData</code>数组中不是所有元素都是有效元素,所以只序列化了<code>size</code>个有效元素.<br> <img src="https://img-blog.csdnimg.cn/20191206205124318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191206205301628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="序列化中-子父类构造函数的调用问题"><a href="#序列化中-子父类构造函数的调用问题" class="headerlink" title="序列化中 子父类构造函数的调用问题"></a>序列化中 子父类构造函数的调用问题</h3><p>一个类实现了序列化接口，那么其<strong>子类</strong>都可以进行序列化.<br>对<strong>子类</strong>对象进行反序列化操作时,如果其<strong>父类</strong>没有实现序列化接口,那么其<strong>父类的构造函数</strong>会被调用.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSeriaDemo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//序列化Foo2</span></span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">				<span class="keyword">new</span> FileOutputStream(<span class="string">"demo/obj1.dat"</span>));</span><br><span class="line">		Foo2 foo2 = <span class="keyword">new</span> Foo2();</span><br><span class="line">		oos.writeObject(foo2);</span><br><span class="line">		oos.flush();</span><br><span class="line">		oos.close();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//反序列化Foo2是否递归调用父类的构造函数?不会调用Foo1(),Foo()</span></span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">				<span class="keyword">new</span> FileInputStream(<span class="string">"demo/obj1.dat"</span>));</span><br><span class="line">		Foo2 foo2 = (Foo2)ois.readObject();</span><br><span class="line">		System.out.println(foo2);</span><br><span class="line">		ois.close();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//序列化Bar2</span></span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">				<span class="keyword">new</span> FileOutputStream(<span class="string">"demo/obj1.dat"</span>));</span><br><span class="line">		Bar2 bar2 = <span class="keyword">new</span> Bar2();</span><br><span class="line">		oos.writeObject(bar2);</span><br><span class="line">		oos.flush();</span><br><span class="line">		oos.close();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//反序列化Bar2是否递归调用父类的构造函数?会调用Bar1(),Bar()</span></span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">				<span class="keyword">new</span> FileInputStream(<span class="string">"demo/obj1.dat"</span>));</span><br><span class="line">		Bar2 bar2 = (Bar2)ois.readObject();</span><br><span class="line">		System.out.println(bar2);</span><br><span class="line">		ois.close();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 对子类对象进行反序列化操作时，</span></span><br><span class="line"><span class="comment">		 * 如果其父类没有实现序列化接口</span></span><br><span class="line"><span class="comment">		 * 那么其父类的构造函数会被调用</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   一个类实现了序列化接口，那么其子类都可以进行序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"foo..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo1</span> <span class="keyword">extends</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Foo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"foo1..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span> <span class="keyword">extends</span> <span class="title">Foo1</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Foo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"foo2..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"bar"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar1</span> <span class="keyword">extends</span> <span class="title">Bar</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bar1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"bar1.."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar2</span> <span class="keyword">extends</span> <span class="title">Bar1</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bar2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"bar2..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>shell备忘录</title>
    <url>/2019/10/07/shell%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<h2 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@主机名 ~] # root(超级)用户</span><br><span class="line">[xxxx@主机名 ~] $ 普通用户</span><br></pre></td></tr></table></figure>
<h2 id="切换默认shell"><a href="#切换默认shell" class="headerlink" title="切换默认shell"></a>切换默认shell</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chsh -s /usr/bin/fish</span><br><span class="line">grep root /etc/passwd</span><br></pre></td></tr></table></figure>
<h2 id="快速删除-移动光标"><a href="#快速删除-移动光标" class="headerlink" title="快速删除,移动光标"></a>快速删除,移动光标</h2><p>键盘快捷键:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl + w 往回删除一个单词，光标放在最末尾</span><br><span class="line">ctrl + u 删除光标以前的字符</span><br><span class="line">ctrl + k 删除光标以后的字符</span><br><span class="line">ctrl + a 移动光标至的字符头</span><br><span class="line">ctrl + e 移动光标至的字符尾</span><br><span class="line">ctrl + l 清屏</span><br></pre></td></tr></table></figure>

<h2 id="已知进程pid获取其父进程pid"><a href="#已知进程pid获取其父进程pid" class="headerlink" title="已知进程pid获取其父进程pid"></a>已知进程pid获取其父进程pid</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef  #查看所有用户进程</span><br><span class="line">ps -ef|awk '$2 ~ /pid/&#123;print $3&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tar打包解包"><a href="#tar打包解包" class="headerlink" title="tar打包解包"></a>tar打包解包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zcvf xx.tar.gz xx  </span><br><span class="line">tar -zxvf xx.tar.gz xx</span><br></pre></td></tr></table></figure>
<h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><p>用于查看纯文本文档的后N行或持续刷新内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail [选项] [文件]</span><br></pre></td></tr></table></figure>
<h2 id="判断字符串长度"><a href="#判断字符串长度" class="headerlink" title="判断字符串长度"></a>判断字符串长度</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ID=12345</span><br><span class="line">if [ $&#123;#ID&#125; -eq 5 ];then</span><br><span class="line">    echo "5"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="将命令的输出结果赋值给变量"><a href="#将命令的输出结果赋值给变量" class="headerlink" title="将命令的输出结果赋值给变量"></a>将命令的输出结果赋值给变量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">begin_time=`date`    #开始时间，使用``替换</span><br><span class="line">sleep 20s            #休眠20秒</span><br><span class="line">finish_time=$(date)  #结束时间，使用$()替换</span><br><span class="line">echo "Begin time: $begin_time"</span><br><span class="line">echo "Finish time: $finish_time"</span><br></pre></td></tr></table></figure>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls  -lh  # --long   --human人性化显示大小</span><br><span class="line">ll    # ls -l</span><br><span class="line">drwx------ 2 root root 4096 Nov  3 10:13 Downloads </span><br><span class="line">        引用计数</span><br></pre></td></tr></table></figure>
<p>linux中有6中文件类型,常用的三种为:<br>-普通文件 d目录 l软连接<br><img src="https://img-blog.csdnimg.cn/2019120811435069.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191208115535623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Netty介绍</title>
    <url>/2020/05/03/Netty%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Java原生NIO的缺陷"><a href="#Java原生NIO的缺陷" class="headerlink" title="Java原生NIO的缺陷"></a>Java原生NIO的缺陷</h1><ul>
<li>类库和API繁杂</li>
<li>入门门槛高，需要其他额外的知识做铺垫</li>
<li>工作量和难度大，客户端会面临断开，重连，网络闪断，失败缓存，网络拥堵等问题</li>
<li>JDK NIO存在臭名昭著的epoll bug，导致Selector空轮询：这个bug会导致linux上cpu 100%</li>
</ul>
<h1 id="Netty的优势"><a href="#Netty的优势" class="headerlink" title="Netty的优势"></a>Netty的优势</h1><ul>
<li>业界流行的NIO框架之一，健壮性，功能，可定制性，可扩展性都比较好，得到了业界的认可与证明。比如在dubbo框架中的底层应用</li>
<li>API使用简单，定制能力强，可以灵活扩展</li>
<li>入门门槛低，易学，功能强大，预置了多种编解码功能，支持多种主流通信协议（http,tpc,udp,socket）</li>
<li>性能高，成熟，稳定</li>
</ul>
<h1 id="Netty介绍"><a href="#Netty介绍" class="headerlink" title="Netty介绍"></a>Netty介绍</h1><p><strong>Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients.</strong>It greatly simplifies and streamlines network programming such as TCP and UDP socket server.<br><img src="https://netty.io/images/components.png" alt="Netty框架"><br><img src="https://user-gold-cdn.xitu.io/2018/11/1/166ccbbdc8614c8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h1 id="Netty使用场景"><a href="#Netty使用场景" class="headerlink" title="Netty使用场景"></a>Netty使用场景</h1><p>Netty常见的使用场景如下：</p>
<h2 id="互联网行业"><a href="#互联网行业" class="headerlink" title="互联网行业"></a>互联网行业</h2><p>在分布式系统中，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高新能的通信框架,往往作为基础通信组件被这些RPC框架使用。<br>典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</p>
<h2 id="游戏行业"><a href="#游戏行业" class="headerlink" title="游戏行业"></a>游戏行业</h2><p>无论是手游服务端还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈。<br>非常方便定制和开发私有协议栈，账号登录服务器，地图服务器之间可以方便的通过Netty进行高性能的通信</p>
<h2 id="大数据领域"><a href="#大数据领域" class="headerlink" title="大数据领域"></a>大数据领域</h2><p>经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨界点通信，它的Netty Service基于Netty框架二次封装实现</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty介绍</title>
    <url>/2020/05/03/Netty%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="Java原生NIO的缺陷"><a href="#Java原生NIO的缺陷" class="headerlink" title="Java原生NIO的缺陷"></a>Java原生NIO的缺陷</h1><ul>
<li>类库和API繁杂</li>
<li>入门门槛高，需要其他额外的知识做铺垫</li>
<li>工作量和难度大，客户端会面临断开，重连，网络闪断，失败缓存，网络拥堵等问题</li>
<li>JDK NIO存在臭名昭著的epoll bug，导致Selector空轮询：这个bug会导致linux上cpu 100%</li>
</ul>
<h1 id="Netty的优势"><a href="#Netty的优势" class="headerlink" title="Netty的优势"></a>Netty的优势</h1><ul>
<li>业界流行的NIO框架之一，健壮性，功能，可定制性，可扩展性都比较好，得到了业界的认可与证明。比如在dubbo框架中的底层应用</li>
<li>API使用简单，定制能力强，可以灵活扩展</li>
<li>入门门槛低，易学，功能强大，预置了多种编解码功能，支持多种主流通信协议（http,tpc,udp,socket）</li>
<li>性能高，成熟，稳定</li>
</ul>
<h1 id="Netty介绍"><a href="#Netty介绍" class="headerlink" title="Netty介绍"></a>Netty介绍</h1><p><strong>Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients.</strong>It greatly simplifies and streamlines network programming such as TCP and UDP socket server.<br><img src="https://netty.io/images/components.png" alt="Netty框架"></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/1/166ccbbdc8614c8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h1 id="Netty使用场景"><a href="#Netty使用场景" class="headerlink" title="Netty使用场景"></a>Netty使用场景</h1><p>Netty常见的使用场景如下：</p>
<h2 id="互联网行业"><a href="#互联网行业" class="headerlink" title="互联网行业"></a>互联网行业</h2><p>在分布式系统中，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高新能的通信框架,往往作为基础通信组件被这些RPC框架使用。<br>典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</p>
<h2 id="游戏行业"><a href="#游戏行业" class="headerlink" title="游戏行业"></a>游戏行业</h2><p>无论是手游服务端还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈。<br>非常方便定制和开发私有协议栈，账号登录服务器，地图服务器之间可以方便的通过Netty进行高性能的通信</p>
<h2 id="大数据领域"><a href="#大数据领域" class="headerlink" title="大数据领域"></a>大数据领域</h2><p>经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨界点通信，它的Netty Service基于Netty框架二次封装实现</p>
]]></content>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket简介</title>
    <url>/2020/05/02/WebSocket%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="为什么需要-WebSocket？"><a href="#为什么需要-WebSocket？" class="headerlink" title="为什么需要 WebSocket？"></a>为什么需要 WebSocket？</h2><p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP协议做不到服务器主动向客户端推送信息。<br>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用<strong>轮询</strong>：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。<br>轮询的效率低，非常浪费资源（因为必须不停连接，或者HTTP连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017051502.png" alt=""><br>websocket是HTML5的一个新协议，它允许服务端向客户端传递信息，实现浏览器和客户端双工通信。WebSocket协议在2008年诞生，2011年成为国际标准，所有浏览器都已经支持了。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p>
<p>##WebSocket特点</p>
<p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p>
<p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p>
<p>（3）数据格式比较轻量，性能开销小，通信高效。</p>
<p>（4）可以发送文本，也可以发送二进制数据。</p>
<p>（5）没有同源限制，客户端可以与任意服务器通信。</p>
<p>（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017051503.jpg" alt=""></p>
<h2 id="WebSocket生命周期"><a href="#WebSocket生命周期" class="headerlink" title="WebSocket生命周期"></a>WebSocket生命周期</h2><h3 id="打开事件"><a href="#打开事件" class="headerlink" title="打开事件"></a>打开事件</h3><p>端点上建立新链接时，该事件是先于其他任何事件发生之前。该事件发生会产生三部分信息。</p>
<ul>
<li>创建WebSocket Session对象: 用于表示已经建立好的链接</li>
<li>配置对象: 包含配置端点的信息。</li>
<li>一组路径参数: 用于打开节点握手时，WebSocket端入栈匹配的URI</li>
</ul>
<h3 id="消息事件"><a href="#消息事件" class="headerlink" title="消息事件"></a>消息事件</h3><p>主要是接收WebSocket对话中，另一端发送的消息。链接上的消息将会有三种形式抵达客户端。</p>
<ul>
<li><p>文本消息 用String处理</p>
</li>
<li><p>二进制消息 用byteBuffer或者byte[]处理</p>
</li>
<li><p>pong消息 用Java WebSocket API中的pong.message接口的实例来处理</p>
</li>
</ul>
<h3 id="错误事件"><a href="#错误事件" class="headerlink" title="错误事件"></a>错误事件</h3><p>WebSocket链接或者端点发生错误时产生。可以处理入栈消息时发生的各种异常。入栈消息可能产生的三种异常。</p>
<ul>
<li>WebSocket建立链接时发生错误 SessionException类型</li>
<li>WebSocket试图将入栈消息解码成开发人员使用的对象时 EncodeException类型</li>
<li>WebSocket端点的其他方法运行时产生的错误，WebSocket实现将记录端点操作过程中产生的任何运行时异常</li>
</ul>
<h3 id="关闭事件"><a href="#关闭事件" class="headerlink" title="关闭事件"></a>关闭事件</h3><p>WebSocket链接端点关闭，做一些清理工作，可以由参与连接的任意一个端点发出。</p>
<ul>
<li>服务器关闭底层TCP连接</li>
<li>客户端发起TCP Close</li>
</ul>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>常见电商种类</title>
    <url>/2020/05/11/%E5%B8%B8%E8%A7%81%E7%94%B5%E5%95%86%E7%A7%8D%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="B2B"><a href="#B2B" class="headerlink" title="B2B"></a>B2B</h1><p>B2B = Business to Business<br>商家（泛指企业）对商家的电子商务，即企业与企业之间通过互联网进行产品、服务及信息的交换。通俗的说法是指进行电子商务交易的供需双方都是商家（或企业、公司），他们使用 Internet 的技术或各种商务网络平台（如拓商网），完成商务交易的过程。这些过程包括：发布供求信息，订货及确认订货，支付过程，票据的签发、传送和接收，确定配送方案并监控配送过程等。如<strong>阿里巴巴，慧聪网</strong>。</p>
<h1 id="B2C"><a href="#B2C" class="headerlink" title="B2C"></a>B2C</h1><p>B2C = Business to Customer<br>B2C 模式是中国最早产生的电子商务模式，如今的 B2C 电子商务网站非常的多，比较大型的有<strong>唯品会、一号店、亚马逊、苏宁易购、国美在线</strong>等。</p>
<h1 id="B2B2C"><a href="#B2B2C" class="headerlink" title="B2B2C"></a>B2B2C</h1><p>B2B2C = Business To Business To Customers<br>所谓 B2B2C 是一种新的网络通信销售方式。第一个 B 指广义的卖方（即成品、半成品、材料提供商等），第二个 B 指交易平台，即提供卖方与买方的联系平台，同时提供优质的附加服务，C 即指买方。卖方可以是公司，也可以是个人，即一种逻辑上的买卖关系中的卖方。如<strong>天猫商城、京东商城</strong>。</p>
<h1 id="C2C"><a href="#C2C" class="headerlink" title="C2C"></a>C2C</h1><p>C2C = Consumer to Consumer<br>C2C 同 B2B、B2C 一样，都是电子商务的几种模式之一。不同的是 C2C 是用户对用户的模式，C2C 商务平台就是通过为买卖双方提供一个在线交易平台，使卖方可以主动提供商品上网拍卖，而买方可以自行选择商品进行竞价。如<strong>淘宝，易趣，瓜子二手车</strong>等</p>
<h1 id="O2O"><a href="#O2O" class="headerlink" title="O2O"></a>O2O</h1><p>O2O = Online to Offline<br>O2O 是新兴起的一种电子商务新商业模式，即将线下商务的机会与互联网结合在了一起，让互联网成为线下交易的前台。这样线下服务就可以用线上来揽客，消费者可以用线上来筛选服务，还有成交可以在线结算，很快达到规模。该模式最重要的特点是：推广效果可查，每笔交易可跟踪。如<strong>美团，饿了么</strong>。</p>
<h1 id="C2B"><a href="#C2B" class="headerlink" title="C2B"></a>C2B</h1><p>C2B = Customer to Business<br>C2B 是电子商务模式的一种，即消费者对企业。最先由美国流行起来的 C2B 模式也许是一个值得关注的尝试。C2B 模式的核心，是通过聚合分散分布但数量庞大的用户形成一个强大的采购集团，以此来改变 B2C 模式中用户一对一出价的弱势地位，使之享受到以大批发商的价格买单件商品的利益。如<strong>海尔商城，尚品宅配，某些装修类电商平台</strong>，注重个性化服务。</p>
<h1 id="F2C"><a href="#F2C" class="headerlink" title="F2C"></a>F2C</h1><p>F2C = Factory to customer<br>即从厂商到消费者的电子商务模式，如<strong>拼多多</strong>。</p>
]]></content>
      <categories>
        <category>业务</category>
      </categories>
  </entry>
  <entry>
    <title>Notes</title>
    <url>/2020/05/03/Notes/</url>
    <content><![CDATA[<h1 id="公钥与私钥"><a href="#公钥与私钥" class="headerlink" title="公钥与私钥"></a>公钥与私钥</h1><h2 id="公钥本来就是公开的，那岂不是私钥加密的数据根本没有安全性可言？"><a href="#公钥本来就是公开的，那岂不是私钥加密的数据根本没有安全性可言？" class="headerlink" title="公钥本来就是公开的，那岂不是私钥加密的数据根本没有安全性可言？"></a>公钥本来就是公开的，那岂不是私钥加密的数据根本没有安全性可言？</h2><p>私钥加密的数据确实没有安全性可言，因为用私钥加密数据根本就不是为了安全性，而是作为一种验证身份的手段。<br>因为私钥是唯一的，一旦使用公钥对私钥加密的数据解密成功，服务端S就可以完全确定这条消息是由拥有对应私钥的客户端C发出的，而不是第三方伪装者发出的。<br>所以，<strong>公钥加密私钥解密，是为了数据的安全性，而私钥加密公钥解密，则是为了验证数据发送者的身份</strong>。</p>
]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>InterruptedException异常处理</title>
    <url>/2020/05/05/InterruptedException%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p><strong>当阻塞方法(如<code>sleep()</code>)收到中断请求的时候就会抛出InterruptedException异常</strong></p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>线程在一定的条件下会发生状态的改变，下面是线程的一些状态</p>
<p><img src="https://img-blog.csdnimg.cn/20181120173640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li><p>初始(NEW)：新建一个线程的对象，还未调用start方法</p>
</li>
<li><p>运行(RUNNABLE)：java线程中将已经准备就绪(Ready)和正在运行中(Running)的两种状态都统称为“Runnable”。准备就绪的线程会被放在线程池中等待被调用</p>
</li>
<li><p>阻塞(BLOCKED)：是因为某种的原因而放弃了CPU的使用权，暂时的停止了运行。直到线程进入准备就绪(Ready)状态才会有机会转到运行状态</p>
</li>
<li><p>等待(WAITING)：该状态的线程需要等待其他线程做出一些特定的动作（通知或者是中断）</p>
</li>
<li><p>超时等待(TIME_WAITING)：该状态和上面的等待不同，他可以在指定的时间内自行返回</p>
</li>
<li><p>终止(TERMINATED)：线程任务执行完毕</p>
</li>
</ul>
<h2 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h2><p>线程阻塞通常是指一个线程在执行过程中暂停，以<strong>等待某个条件的触发</strong>。而什么情况才会使得线程进入阻塞的状态呢？</p>
<ul>
<li><strong>等待阻塞</strong>：运行的线程执行<strong>wait()方法</strong>，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒</li>
<li><strong>同步阻塞</strong>：运行的线程在获取对象的<strong>同步锁</strong>时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中</li>
<li><strong>其他阻塞</strong>：运行的线程执行<strong>sleep()或join()方法</strong>，或者发出了<strong>I/O请求</strong>时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态</li>
</ul>
<h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>每一个线程都有一个boolean类型的标志，此标志意思是当前的请求<strong>是否请求中断</strong>，默认为false。当一个线程A调用了线程B的interrupt方法时，那么线程B的是否请求的中断标志变为true。而线程B可以调用方法检测到此标志的变化。</p>
<ol>
<li>阻塞方法：如果线程B调用了造成阻塞的方法，如果是否请求中断标志变为了true，那么它会抛出<code>InterruptedException</code>异常。<strong>抛出异常的同时它会将线程B的是否请求中断标志置为false</strong></li>
<li>非阻塞方法：可以通过线程B的<code>isInterrupted()</code>方法进行检测是否请求中断标志为true还是false，另外还有一个静态的方法interrupted方法也可以检测标志。<strong>但是这个静态方法检测完以后会自动的将是否请求中断标志位置为false</strong>。例如线程A调用了线程B的interrupt的方法，那么如果此时线程B中用静态interrupted方法进行检测标志位的变化的话，那么第一次为true，第二次就为false。</li>
</ol>
<p>线程可以检测到自身的标志位的变化，但是他只是一个标志，如果线程本身不处理的话，那么程序还是会执行下去。<strong><code>interrupt()</code> 方法并不能立即中断线程</strong>，该方法仅仅告诉线程外部已经有中断请求，至于是否中断还取决于线程自己。</p>
<h2 id="正确处理InterruptedException"><a href="#正确处理InterruptedException" class="headerlink" title="正确处理InterruptedException"></a>正确处理<code>InterruptedException</code></h2><p>有时候阻塞的方法抛出(<code>throw</code>)<code>InterruptedException</code>异常并不合适，例如在Runnable中调用了可中断的方法，因为你的程序是实现了Runnable接口，然后在重写Runnable接口的run方法的时候，那么子类抛出的异常要小于等于父类的异常。而<strong>在Runnable中run方法是没有抛异常的,所以此时不能抛出<code>InterruptedException</code>异常</strong>。如果此时你只是记录日志的话，那么就是一个不负责任的做法，因为<strong>在捕获InterruptedException异常的时候自动的将是否请求中断标志置为了false</strong>。至少在捕获了InterruptedException异常之后，如果你什么也不想做，那么就<strong>将标志重新置为true，以便栈中更高层的代码能知道中断，并且对中断作出响应</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Task&gt; queue;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskRunner</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.queue = queue; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                 Task task = queue.take(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                 task.execute();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">             <span class="comment">// Restore the interrupted status</span></span><br><span class="line">             Thread.currentThread().interrupt();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode173</title>
    <url>/2020/05/14/LeetCode173/</url>
    <content><![CDATA[<p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p>
<p>调用 next() 将返回二叉搜索树中的下一个最小的数。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BSTIterator iterator &#x3D; new BSTIterator(root);</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 3</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 7</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 9</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 15</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 20</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure>

<p>提示：<br>next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。<br>你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">         Stack&lt;TreeNode&gt; iter;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">                       iter=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">           pushStack(root);</span><br><span class="line">          </span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushStack</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">           TreeNode tmp=node;</span><br><span class="line">           <span class="keyword">while</span> (tmp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               iter.push(tmp);</span><br><span class="line">               tmp=tmp.left;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!iter.isEmpty())&#123;</span><br><span class="line">               TreeNode ans=iter.pop();</span><br><span class="line">               <span class="keyword">if</span> (ans.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   pushStack(ans.right);</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">return</span> ans.val;</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> !iter.isEmpty();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>RESTful架构-转载</title>
    <url>/2020/05/15/RESTful%E6%9E%B6%E6%9E%84-%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<p>越来越多的人开始意识到，<strong>网站即软件</strong>，而且是一种新型的软件。</p>
<p>这种”互联网软件”采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。</p>
<p>网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，<strong>现在我们必须考虑，如何开发在互联网环境中使用的软件。</strong></p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201109/bg2011091202.jpg" alt="img"></p>
<p>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p>
<p>但是，到底什么是RESTful架构，并不是一个容易说清楚的问题。下面，我就谈谈我理解的RESTful架构。</p>
<p><strong>一、起源</strong></p>
<p>REST这个词，是<a href="http://en.wikipedia.org/wiki/Roy_Fielding" target="_blank" rel="noopener">Roy Thomas Fielding</a>在他2000年的<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="noopener">博士论文</a>中提出的。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201109/bg2011091201.jpg" alt="img"></p>
<p>Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。</p>
<p>他这样介绍论文的写作目的：</p>
<blockquote>
<p>“本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。<strong>我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。</strong>“</p>
<p>(This dissertation explores a junction on the frontiers of two research disciplines in computer science: software and networking. Software research has long been concerned with the categorization of software designs and the development of design methodologies, but has rarely been able to objectively evaluate the impact of various design choices on system behavior. Networking research, in contrast, is focused on the details of generic communication behavior between systems and improving the performance of particular communication techniques, often ignoring the fact that changing the interaction style of an application can have more impact on performance than the communication protocols used for that interaction. My work is motivated by the desire to understand and evaluate the architectural design of network-based application software through principled use of architectural constraints, thereby obtaining the functional, performance, and social properties desired of an architecture. )</p>
</blockquote>
<p><strong>二、名称</strong></p>
<p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。</p>
<p>如果一个架构符合REST原则，就称它为RESTful架构。</p>
<p><strong>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。</strong>如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p>
<p><strong>三、资源（Resources）</strong></p>
<p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>
<p><strong>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。</strong>它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>
<p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p>
<p><strong>四、表现层（Representation）</strong></p>
<p>“资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</strong></p>
<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>
<p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p>
<p><strong>五、状态转化（State Transfer）</strong></p>
<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
<p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</strong></p>
<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></p>
<p><strong>六、综述</strong></p>
<p>综合上面的解释，我们总结一下什么是RESTful架构：</p>
<p>　　（1）每一个URI代表一种资源；</p>
<p>　　（2）客户端和服务器之间，传递这种资源的某种表现层；</p>
<p>　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>
<p><strong>七、误区</strong></p>
<p>RESTful架构有一些典型的设计误区。</p>
<p><strong>最常见的一种设计错误，就是URI包含动词。</strong>因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p>
<p>举例来说，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。</p>
<p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：</p>
<blockquote>
<p>　　POST /accounts/1/transfer/500/to/2</p>
</blockquote>
<p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：</p>
<blockquote>
<p>　　POST /transaction HTTP/1.1<br>　　Host: 127.0.0.1<br>　　<br>　　from=1&amp;to=2&amp;amount=500.00</p>
</blockquote>
<p><strong>另一个设计误区，就是在URI中加入版本号</strong>：</p>
<blockquote>
<p>　　<a href="http://www.example.com/app/1.0/foo" target="_blank" rel="noopener">http://www.example.com/app/1.0/foo</a></p>
<p>　　<a href="http://www.example.com/app/1.1/foo" target="_blank" rel="noopener">http://www.example.com/app/1.1/foo</a></p>
<p>　　<a href="http://www.example.com/app/2.0/foo" target="_blank" rel="noopener">http://www.example.com/app/2.0/foo</a></p>
</blockquote>
<p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见<a href="http://www.informit.com/articles/article.aspx?p=1566460" target="_blank" rel="noopener">Versioning REST Services</a>）：</p>
<blockquote>
<p>　　Accept: vnd.example-com.foo+json; version=1.0</p>
<p>　　Accept: vnd.example-com.foo+json; version=1.1</p>
<p>　　Accept: vnd.example-com.foo+json; version=2.0</p>
</blockquote>
<p>作者： <a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰</a></p>
<p>日期： <a href="http://www.ruanyifeng.com/blog/2011/09/" target="_blank" rel="noopener">2011年9月12日</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>分布式ID生成方案</title>
    <url>/2020/05/15/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><img src="C:%5CUsers%5Ceric3%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200515201720558.png" alt="image-20200515201720558"></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode70</title>
    <url>/2020/05/16/LeetCode70/</url>
    <content><![CDATA[<h1 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h1><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<p>这是一道典型的的规划问题,写出状态转移方程:<strong>dp[n]=dp[n-1]+dp[n-2]</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">3</span>)&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            dp[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode226</title>
    <url>/2020/05/16/LeetCode226/</url>
    <content><![CDATA[<p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<p>备注:<br>这个问题是受到 Max Howell 的 原问题 启发的 ：</p>
<blockquote>
<p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p>
</blockquote>
<p>递归求解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      TreeNode left;</span><br><span class="line">      TreeNode right;</span><br><span class="line">      TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>||(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode tmp=root.left;</span><br><span class="line">        root.left=root.right;</span><br><span class="line">        root.right=tmp;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>UNIX下的I/O模型</title>
    <url>/2020/05/16/UNIX%E4%B8%8B%E7%9A%84IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>RPC 中很重要的部分就是网络通信，因此这篇叙述一下 Unix 下为解决不同 I/O 问题所设计的 I/O 模型。首先要说明的是，I/O 是个很宽泛的概念，常见的有网络 I/O、磁盘 I/O、内存 I/O 等。</p>
<p>在 Unix 系统下，不论是标准输入还是借助套接字接受网络输入，其实都会有两个步骤，很多文章都提到：</p>
<ol>
<li>等待数据准备好（Waiting for the data to be ready）</li>
<li>从内核向进程复制数据（Copying the data from the kernel to the process）</li>
</ol>
<p><img src="https://pic4.zhimg.com/80/v2-89272a2047be6b90fff1893615a22a99_hd.jpg" alt="img"></p>
<p>这两个阶段涉及到用户空间和内核空间</p>
<h2 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h2><p>对 32 位 OS 而言，它的寻址空间（虚拟存储空间）为 4G。OS 的核心是内核，可以访问底层硬件设备，为了保证用户进程不能直接操作内核从而保证内核的安全，OS 将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</p>
<p>内核空间中存放的是内核代码和数据，例如 Linux 的 OS 和驱动便运行在内核空间，可以操作底层硬件，如果从磁盘读取数据，那么数据会被先载入内核空间的缓冲区中；而进程的用户空间中存放的是用户程序的代码和数据，通常来讲就是应用程序常驻的区域。</p>
<p>因此整个 Linux 内部结构可以分为三部分，从最底层到最上层依次是：硬件、内核空间、用户空间。如下图：</p>
<p><img src="https://pic4.zhimg.com/80/v2-0800f36d38f800111c76f362ea30daf2_hd.jpg" alt="img"></p>
<p>二者间无法直接通信，必须通过系统调用，一般来说系统调用的成本很高。</p>
<h2 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h2><ul>
<li>当一个进程经过系统调用而陷入内核代码中执行时，称进程处于内核运行态，简称内核态</li>
<li>当进程在执行用户自己的代码时，则称其处于用户运行态，简称用户态</li>
</ul>
<h2 id="高性能的Server有什么特点"><a href="#高性能的Server有什么特点" class="headerlink" title="高性能的Server有什么特点"></a>高性能的Server有什么特点</h2><p>说完上面的之后，你可能疑惑这和 RPC 的通信设计有什么关系呢？其实正是由于这种内存空间的划分，所以 I/O 一般会在两个地方阻塞，一个是等待数据报到达时，一个是从内核空间拷贝到用户空间时，而阻塞多数情况下我们是无法接受的，因为其损耗性能，而高性能的 server 到底在关注什么？一句话总结：用尽可能少的系统开销处理尽可能多的连接请求。因此诞生了不同的 I/O 模型，它们的不同点总结起来就是对这两个阻塞阶段的处理方式不同</p>
<h2 id="Unix-下的-I-O-模型"><a href="#Unix-下的-I-O-模型" class="headerlink" title="Unix 下的 I/O 模型"></a>Unix 下的 I/O 模型</h2><p>Unix 下存在五种 I/O 模型：</p>
<ol>
<li>阻塞 I/O</li>
<li>非阻塞 I/O</li>
<li>I/O 复用（select和poll）</li>
<li>信号驱动 I/O（SIGIO）</li>
<li>异步 I/O</li>
</ol>
<p>以下的例子，我们以 UDP 套接字中的 recvfrom 函数作为系统调用来说明I/O模型。recvfrom 函数类似于标准的 read 函数，它的作用是从指定的套接字中读取数据报。</p>
<h3 id="1-、阻塞-I-O"><a href="#1-、阻塞-I-O" class="headerlink" title="1 、阻塞 I/O"></a>1 、阻塞 I/O</h3><p><img src="https://pic4.zhimg.com/80/v2-a2576248ff4c0a7b6bfeb00cd34f6619_hd.jpg" alt="img"></p>
<p>可以看到阻塞 I/O 在两个步骤阶段都是阻塞的，等到数据报准备好和数据报从内核空间拷贝到用户空间之后，才会向用户侧的进程返回结果，此时用户侧的进程才能继续工作。</p>
<h3 id="2-、非阻塞-I-O"><a href="#2-、非阻塞-I-O" class="headerlink" title="2 、非阻塞 I/O"></a>2 、非阻塞 I/O</h3><p><img src="https://pic4.zhimg.com/80/v2-00e47334a74e9ad8eb66a5ca36181289_hd.jpg" alt="img"></p>
<p>非阻塞 I/O 的优化点在于第一阶段不是阻塞的，而是采取轮询的形式，如果数据报没有准备好，立刻返回一个错误 EWOULDBLOCK，此时用户侧进程不需要等待而是立刻得知此次询问的结果，然后进行重试直到数据报准备好再开始，但是再第二阶段拷贝数据报的时候依旧是阻塞的。</p>
<h3 id="3、-I-O-复用"><a href="#3、-I-O-复用" class="headerlink" title="3、 I/O 复用"></a>3、 I/O 复用</h3><p><img src="https://pic3.zhimg.com/80/v2-50bc7968407818f78ab3baab5b29b102_hd.jpg" alt="img"></p>
<p>本质上 I/O 复用的优化点在于让内核来负责非阻塞 I/O 时用户侧进程进行的反复重试操作，当内核发现某个套接字的数据报已经就绪时就通知进程。但是这里细心的你会发现，有两个系统调用，select 和 revfrom，但是由于 I/O 复用可以处理多个连接，性能还是有提升。</p>
<h2 id="4-、信号驱动-I-O"><a href="#4-、信号驱动-I-O" class="headerlink" title="4 、信号驱动 I/O"></a>4 、信号驱动 I/O</h2><p><img src="https://pic4.zhimg.com/80/v2-fd31b6ac102826ce9ac6cb6e629a24a0_hd.jpg" alt="img"></p>
<p>进程先创建一个信号处理 handler，然后内核立刻返回，进程可以去处理其他事情，等到数据报就绪，内核通过发送信号给之前的 handler 通知进程，然后进程在拷贝数据报期间阻塞。</p>
<h3 id="5-、异步-I-O"><a href="#5-、异步-I-O" class="headerlink" title="5 、异步 I/O"></a>5 、异步 I/O</h3><p><img src="https://pic1.zhimg.com/80/v2-1092eeaa0f367bb4bc0d4fd9c3b52e7a_hd.jpg" alt="img"></p>
<p>调用 aio_read 函数发起读取操作时其实是告诉内核 “当整个I/O操作完成后通知我们”。该系统调用会立即返回，进程不会被阻塞。当 I/O 阶段两个步骤完成后，内核会产生一个信号通知应用进程对数据报进行处理。</p>
<p>跟信号驱动 I/O 相比是告知进程何时进行数据拷贝操作，而异步 I/O 则是通知进程何时整个 I/O 操作完毕。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.tianshouzhi.com/api/tutorials/netty/221" target="_blank" rel="noopener">Unix五种IO模型</a></li>
<li><a href="http://www.rowkey.me/blog/2016/01/18/io-model/" target="_blank" rel="noopener">也谈IO模型</a></li>
<li><a href="https://blog.csdn.net/lihao21/article/details/51620374" target="_blank" rel="noopener">图解UNIX的I/O模型</a></li>
</ol>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><ul>
<li>本文遵守创作共享 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener"><strong>CC BY-NC-SA 3.0协议</strong></a></li>
</ul>
<p><a href="https://chenjiayang.me/2018/10/01/unix-io-model/" target="_blank" rel="noopener">原文链接</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode617</title>
    <url>/2020/05/17/LeetCode617/</url>
    <content><![CDATA[<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<p>输入:<br>    Tree 1                  Tree 2<br>         1                         2<br>         / \                       / \<br>        3   2                  1   3<br>       /                           \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>        3<br>        / <br>      4   5<br>      / \     \<br>     5   4    7<br>注意: 合并必须从两个树的根节点开始。</p>
<p>递归遍历:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (t1==<span class="keyword">null</span>&amp;&amp;t2==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t1!=<span class="keyword">null</span>&amp;&amp;t2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                TreeNode node=<span class="keyword">new</span> TreeNode(t1.val+t2.val);</span><br><span class="line">                node.left=mergeTrees(t1.left,t2.left);</span><br><span class="line">                node.right=mergeTrees(t1.right,t2.right);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                TreeNode node=<span class="keyword">new</span> TreeNode(t1.val);</span><br><span class="line">                node.left=mergeTrees(t1.left,<span class="keyword">null</span>);</span><br><span class="line">                node.right=mergeTrees(t1.right,<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                if (t2!=null)</span></span><br><span class="line">                TreeNode node=<span class="keyword">new</span> TreeNode(t2.val);</span><br><span class="line">                node.left=mergeTrees(<span class="keyword">null</span>,t2.left);</span><br><span class="line">                node.right=mergeTrees(<span class="keyword">null</span>,t2.right);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode654</title>
    <url>/2020/05/17/LeetCode654/</url>
    <content><![CDATA[<p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<p>二叉树的根是数组中的最大元素。<br>左子树是通过数组中最大值左边部分构造出的最大二叉树。<br>右子树是通过数组中最大值右边部分构造出的最大二叉树。<br>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
<p>示例 ：</p>
<p>输入：[3,2,1,6,0,5]<br>输出：返回下面这棵树的根节点：</p>
<pre><code>   6
 /   \   
3     5
 \    / 
  2  0   
    \
      1</code></pre><p>提示：</p>
<p>给定的数组的大小在 [1, 1000] 之间。</p>
<p>递归建树.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxId = getMaxId(nums);</span><br><span class="line">        <span class="keyword">int</span> max = nums[maxId];</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(max);</span><br><span class="line">        <span class="keyword">if</span> (maxId - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, <span class="number">0</span>, maxId));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxId + <span class="number">1</span> &lt; nums.length) &#123;</span><br><span class="line">            node.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxId + <span class="number">1</span>, nums.length));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxId</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxId = <span class="number">0</span>, max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max) &#123;</span><br><span class="line">                maxId = i;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode655</title>
    <url>/2020/05/19/LeetCode655/</url>
    <content><![CDATA[<p>在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：</p>
<ol>
<li><p>行数 m 应当等于给定二叉树的高度。</p>
</li>
<li><p>列数 n 应当总是奇数。</p>
</li>
<li><p>根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。</p>
</li>
<li><p>每个未使用的空间应包含一个空的字符串””。</p>
</li>
<li><p>使用相同的规则输出子树。</p>
</li>
</ol>
<p>   示例 1:</p>
<p>输入:<br>     1<br>    /<br>   2<br>输出:<br>[[“”, “1”, “”],<br> [“2”, “”, “”]]<br>示例 2:</p>
<p>输入:<br>     1<br>    / <br>   2   3<br>    <br>     4```<br>输出:<br>[[“”, “”, “”, “1”, “”, “”, “”],<br> [“”, “2”, “”, “”, “”, “3”, “”],<br> [“”, “”, “4”, “”, “”, “”, “”]]<br>示例 3:</p>
<p>输入:<br>      1<br>     / <br>    2   5<br>   /<br>  3<br> /<br>4<br>输出:<br>[[“”,  “”,  “”, “”,  “”, “”, “”, “1”, “”,  “”,  “”,  “”,  “”, “”, “”]<br> [“”,  “”,  “”, “2”, “”, “”, “”, “”,  “”,  “”,  “”,  “5”, “”, “”, “”]<br> [“”,  “3”, “”, “”,  “”, “”, “”, “”,  “”,  “”,  “”,  “”,  “”, “”, “”]<br> [“4”, “”,  “”, “”,  “”, “”, “”, “”,  “”,  “”,  “”,  “”,  “”, “”, “”]]<br>注意: 二叉树的高度在范围 [1, 10] 中。</p>
<p>先递归求出树的高度,生成矩阵框架,再递归填充节点值.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; printTree(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> height = getHeight(root);</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, height) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** 生成矩阵 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                ans.get(i).add(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printNode(root, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> level, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = (begin + end) / <span class="number">2</span>;</span><br><span class="line">        ans.get(level).set(index, root.val + <span class="string">""</span>);</span><br><span class="line">        printNode(root.left, level + <span class="number">1</span>, begin, index - <span class="number">1</span>);</span><br><span class="line">        printNode(root.right, level + <span class="number">1</span>, index + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 树的高度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftH = getHeight(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightH = getHeight(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftH, rightH) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>Python Web开发入门</title>
    <url>/2020/05/19/Python%20Web%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>本文内容为慕课网Python全栈案例入门课程笔记,<a href="https://www.imooc.com/learn/864" target="_blank" rel="noopener">点击跳转课程页面</a></p>
<h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><h4 id="Python-web框架"><a href="#Python-web框架" class="headerlink" title="Python web框架"></a>Python web框架</h4><ul>
<li>flask    简单轻量,灵活性大,创建于2010</li>
<li>django 简单,比flask重,灵活性不如flask,创建于2006</li>
<li>web.py 简单轻量,不再维护,创建于2008</li>
</ul>
<h1 id="web应用开发流程"><a href="#web应用开发流程" class="headerlink" title="web应用开发流程"></a>web应用开发流程</h1><ol>
<li>产品分析: 用户需求,市场调研</li>
<li>技术选型: 前端,后端,数据库,业务框架(大数据,直播)</li>
<li>开发实现: 前后端开发,测试</li>
<li>生产上线: 部署,升级,峰值处理,成本优化,警报处理<h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><h4 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h4></li>
</ol>
<ul>
<li>字符串:<code>str,unicode</code><br>python3.x只有str</li>
<li>列表:<code>list 可变列表, tuple 不可变列表, set 唯一列表</code><br>tuple内的元素是不变的</li>
<li>字典:<code>dict</code><br>key —&gt; value映射,数据量大可用redis数据库</li>
</ul>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>generator</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一次性产生10个元素的数组,占内存</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">print</span> i</span><br><span class="line">	</span><br><span class="line"><span class="comment">#xrange() 函数用法与 range 完全相同，所不同的是生成的不是一个数组，而是一个生成器,依次产生1,2,3...节省内存</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>) <span class="comment">#</span></span><br><span class="line">	<span class="keyword">print</span> i</span><br></pre></td></tr></table></figure>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。<br>迭代器有两个基本的方法：<code>iter()</code>和 <code>next()</code>。<br>字符串<code>str</code>，列表<code>list</code>或元组<code>tuple</code>对象都可用于创建迭代器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (next(it))   <span class="comment"># 输出迭代器的下一个元素</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (next(it))</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment"># 可以使用常规for语句进行遍历：</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="keyword">print</span> (x, end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure>

<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = range(<span class="number">10</span>)</span><br><span class="line">&gt;&gt;&gt;&gt; list</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list[<span class="number">5</span> : <span class="number">7</span>]    <span class="comment"># 切片,第5-6个位置</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list[<span class="number">-2</span> : ]    <span class="comment"># 倒数第二个位置到最后</span></span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul>
<li>def 自定义函数</li>
<li>lambda 匿名函数<figure class="highlight plain"><figcaption><span>[arg1 [,arg2,.....argn]]:expression```</span></figcaption><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;python</span><br><span class="line"> &gt;&gt;&gt; sum &#x3D; lambda arg1, arg2: arg1 + arg2</span><br><span class="line"> &gt;&gt;&gt; print (&quot;相加后的值为 : &quot;, sum( 10, 20 ))</span><br><span class="line">	相加后的值为 :  30</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>functools.partial 函数封装</li>
<li>functools.wraps 装饰器</li>
</ul>
<p>python中函数像变量一样,可作为参数传入另一个函数:<br><img src="https://img-blog.csdnimg.cn/20191210100759984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="列表-字典推导式"><a href="#列表-字典推导式" class="headerlink" title="列表 / 字典推导式"></a>列表 / 字典推导式</h4><ul>
<li><strong>列表推导式</strong>可以方便地由<code>a_list</code>生成新的列表<code>b_list</code></li>
<li><strong>字典推导式</strong>可以方便地由列表<code>a_list</code>和<code>string.letters</code>生成新的字典<code>b_dict</code><br><img src="https://img-blog.csdnimg.cn/20191210100255508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h4 id="列表-字典解析式"><a href="#列表-字典解析式" class="headerlink" title="列表 / 字典解析式"></a>列表 / 字典解析式</h4></li>
<li>使用<code>enumerate</code>可以在遍历时方便地获取<strong>列表</strong>下标<code>index</code></li>
<li>使用<code>iteritems()</code>迭代器可以方便地遍历<strong>字典</strong><code>(key,value)</code>,快速又省内存<br><img src="https://img-blog.csdnimg.cn/20191210100351382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h1 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h1><h3 id="最简单的web-app"><a href="#最简单的web-app" class="headerlink" title="最简单的web app"></a>最简单的web app</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__) <span class="comment">### 生成一个web app对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')  ### 注册一个url,当请求url+'/'这个网址时,执行hello_world函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, World!'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	app.run()     <span class="comment">### run(host=None, port=None, debug=None, **options)</span></span><br><span class="line">				  <span class="comment">### 默认host: 127.0.0.1</span></span><br><span class="line">				  <span class="comment">### 默认port: 5000</span></span><br></pre></td></tr></table></figure>
<h3 id="调试flask应用"><a href="#调试flask应用" class="headerlink" title="调试flask应用"></a>调试flask应用</h3></li>
<li>设置app.run(debug=True)</li>
<li>Python打印log,前端页面打印log(开发者模式)</li>
<li>本地开发可以使用断点调试<h3 id="图书馆管理系统"><a href="#图书馆管理系统" class="headerlink" title="图书馆管理系统"></a>图书馆管理系统</h3><img src="https://img-blog.csdnimg.cn/20191209194815498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191209195033835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h4 id="项目文件"><a href="#项目文件" class="headerlink" title="项目文件"></a>项目文件</h4></li>
</ul>
<p><strong>接口与逻辑分开设计</strong></p>
<ul>
<li>views.py: url接口逻辑<br><img src="https://img-blog.csdnimg.cn/20191209195357219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>logic.py: 逻辑处理<br><img src="https://img-blog.csdnimg.cn/20191209200108740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>run.py: 应用发布<br><img src="https://img-blog.csdnimg.cn/20191209200429598.png" alt="在这里插入图片描述"></li>
</ul>
<h1 id="实践-DashBoard可视化"><a href="#实践-DashBoard可视化" class="headerlink" title="实践:DashBoard可视化"></a>实践:DashBoard可视化</h1><p><a href="https://github.com/litaotao/IPython-Dashboard" target="_blank" rel="noopener">点击获取项目源码</a></p>
<h2 id="应用设计"><a href="#应用设计" class="headerlink" title="应用设计"></a>应用设计</h2><p><img src="https://img-blog.csdnimg.cn/20191209220402880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191209220500455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>项目文件结构:<br><img src="https://img-blog.csdnimg.cn/20191209222556417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="python应用发布工具"><a href="#python应用发布工具" class="headerlink" title="python应用发布工具"></a>python应用发布工具</h2><p>CI / CD  持续集成,持续部署</p>
<ol>
<li>setup.py打包至pip公共仓库, 通过pip安装 / 卸载</li>
<li>github hooks,  travis 轻量,适合中小型项目</li>
<li>jenkins 较重,适合中大型项目</li>
</ol>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>Web前端入门</title>
    <url>/2020/05/19/Web%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>前端开发三把瑞士军刀:</p>
<ul>
<li><strong>HTML 超文本标记语言</strong> <code>HyperText Markup Language</code><br>一种标记语言,用标记标签描述网页(静态网页)</li>
<li><strong>CSS 层叠样式表</strong> <code>Cascading Style Sheets</code><br>样式定义如何显示HTML元素,大小,形状等<br>样式表可内置于HTML文件中,但专业的做法是独立存放</li>
<li><strong>JS JavaScript</strong><br>一种轻量级的高级编程语言<br>服务于网页交互,生成动态网页<br>同CSS一样,JS可嵌入在HTML文件中,但专业的做法是单独存放</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20191209164927586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>补充</p>
<ul>
<li><strong>jQuery</strong><br>jQuery是一个轻量级的”写的少，做的多”的<strong>JavaScript库</strong>。是目前最流行的 JS 框架，而且提供了大量的扩展。jQuery <strong>极大地简化了 JavaScript 编程</strong>.</li>
<li><strong>bootstrap</strong><br>Bootstrap来自 Twitter,是基于HTML5和CSS3开发的<strong>CSS框架</strong>，它在jQuery的基础上进行了更为个性化的完善，形成一套自己独有的网站风格，并兼容大部分jQuery插件,可以<strong>方便地使用预定义的各种CSS元素和样式</strong>。</li>
</ul>
<br>

<ul>
<li><p><strong>JSP java服务器页面</strong> <code>Java Server Pages</code><br>JSP是为了简化Servlet的工作出现的替代品，Servlet输出HTML非常困难(需要一行一行print)，JSP就是替代Servlet输出HTML的。jsp更注重前端显示，servlet更注重模型和业务逻辑.简单地说,jsp就是在html里面写java代码，servlet就是在java里面写html代码,其实jsp经过容器解释之后就是servlet.<br>MVC模式在Web开发中的好处是非常明显，它规避了JSP与Servlet各自的短板，Servlet只负责业务逻辑而不会通过out.append()动态生成HTML代码；JSP中也不会充斥着大量的业务代码。这大大提高了代码的可读性和可维护性。</p>
</li>
<li><p><strong>Ajax  Asynchronous JavaScript + XML</strong><br>异步JavaScript和XML,Ajax是一种技术方案，但并不是一种新技术。它依赖现有的CSS/HTML/JavaScript，而其中最核心的依赖是浏览器提供的<strong>XMLHttpRequest对象</strong>，是这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。实现了<strong>在页面不刷新个情况下和服务器进行数据交互</strong>。</p>
</li>
<li><p><strong>Grunt</strong><br>是一个前端自动化工具,提高工作效率.Grunt可以帮助你处理需要重复执行的压缩，编译，单元测试，代码检查以及打包发布等任务.</p>
</li>
<li><p><strong>Node.js</strong><br>是一种通过JavaScript语言开发web服务端应用的框架,简单地说就是运行在服务端的 JavaScript。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。<br>如果你是一个前端程序员，你不懂得像PHP、Python或Ruby等动态编程语言，然后你想创建自己的服务，那么Node.js是一个非常好的选择。当然，如果你是后端程序员，想部署一些高性能的服务，那么学习Node.js也是一个非常好的选择。</p>
</li>
</ul>
<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>显示当前时间,刷新页面更新时间<br><img src="https://img-blog.csdnimg.cn/20191209201144526.png" alt="在这里插入图片描述"><br>对应的.html文件<br><img src="https://img-blog.csdnimg.cn/2019120920150448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&lt;head&gt;定义了当前网页在浏览器标签栏的标题,编码格式,当前页面css,js资源下载链接<br>&lt;body&gt;定义了网页中显示的元素<br>&lt;script&gt;js脚本,定义动态内容,这里每刷新一次更新一次显示时间</p>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>chrome –&gt; F12 –&gt; Console<br>输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = document.getElementById(<span class="string">"time"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.textContent = <span class="string">" hello world "</span></span><br><span class="line"> <span class="string">" hello world "</span></span><br></pre></td></tr></table></figure>
<p>网页内容会跟着改变</p>
<h4 id="复杂一点的例子"><a href="#复杂一点的例子" class="headerlink" title="复杂一点的例子"></a>复杂一点的例子</h4><p>点击开始显示当前实时时间,点击停止时间暂停更新<br>颜色,布局:居中显示,设置字体颜色<br><img src="https://img-blog.csdnimg.cn/20191209212141134.png" alt="在这里插入图片描述"></p>
<ul>
<li>.html文件<br>&lt;head&gt;下新定义了.css和.js文件位置<br>&lt;button&gt;新定义了点击事件<br><img src="https://img-blog.csdnimg.cn/20191209213114526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>.css文件<br>id选择器:#id { 属性 }<br><img src="https://img-blog.csdnimg.cn/20191209213510444.png" alt="在这里插入图片描述"></li>
<li>.js文件<br>业务逻辑<br><img src="https://img-blog.csdnimg.cn/20191209213633443.png" alt="在这里插入图片描述"></li>
</ul>
<h1 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h1><p>职责分离,架构分离<br>前后端分开开发,各自持续集成,分离上线<br>前后端协作依靠配置文件<br>注意区别<strong>全栈工程师</strong>和<strong>前后端分离前的web工程师</strong></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>旋转数组的最小数字</title>
    <url>/2020/05/21/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>O(n)的复杂度,不够好,应该参考二分查找的实现.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i - <span class="number">1</span>] &gt; array[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进版,要考虑到<code>1,1,0,1,1,1,1</code>等情况.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = array.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">/** 答案一定在start,mid,end的最大值和最小值之间 */</span></span><br><span class="line"><span class="keyword">for</span> (; array[start] &gt;= array[end] &amp;&amp; end - start &gt;= <span class="number">2</span>; mid = (start + end) / <span class="number">2</span>) &#123;<span class="comment">//说明有接头处</span></span><br><span class="line">    <span class="keyword">if</span> (array[mid] &lt; array[start] || array[mid] &lt; array[end]) &#123;</span><br><span class="line">        end = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; array[start] || array[mid] &gt; array[end]) &#123;</span><br><span class="line">        start = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//start,mid,end相等的特殊情况</span></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; min) &#123;</span><br><span class="line">                min = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Math.min(array[start], array[end]);</span><br></pre></td></tr></table></figure>

<h1 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h1><p>链接：<a href="https://www.nowcoder.com/questionTerminal/9f3231a991af4f55b95579b44b7a01ba?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/9f3231a991af4f55b95579b44b7a01ba?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<p>直接进行顺序的查找,复杂度为O(n).<br>但是我们看到题中是给出的有序的旋转数组,我们可以采用二分法来进行求解,其复杂度为O(logn).<br>这里我们需要利用带有条件的二分法来进行求解:</p>
<p>第一步我们可以将这个旋转的数组看作是前后两个有序的子数组,然后设定我们的中间值 mid = (start + end) // 2.</p>
<p>第二步我们能够看到,当我们选取的中间值 mid 所对应的值大于 start 所对应的值时,说明此时 mid 还在第一有序的数组中,而我们所要求解的最小值是在第二个有序数组的第一个位置,此时也就是在 mid   的后面,我们就将 start 移到 mid 所在的位置.</p>
<p>第三步,当我们的 end 所对应的值大于 mid 所对应的值时,说明最小值可能是 mid 所对应的值或者在 mid 的前面,我们将 end 移到 mid 所在的位置.</p>
<p>第四步,最后我们的 end 所在的位置就是最小值的位置,直接返回即可.</p>
<p>我说下,在牛客的这道题目中,以上的方法就可以提交完成,但是当我们看剑指offer的书时,有这样的特例 比如数组 10111 , 这是会出现当 start mid end 所对应位置的值相等,这时候我们的程序就不能找到最小值,当出现这样的情况时,我们采用将 start 和 end 区间里面的值进行顺序查找来找出最小值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> rotateArray[<span class="number">0</span>]</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = len(rotateArray)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> rotateArray[start] &gt;= rotateArray[end]:</span><br><span class="line">            <span class="keyword">if</span> end - start == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            mid = (start + end) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[start] == rotateArray[mid] <span class="keyword">and</span> rotateArray[end] == rotateArray[mid]:</span><br><span class="line">                <span class="comment">#进行顺序查找</span></span><br><span class="line">                temp = rotateArray[start]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(start,end + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> temp &lt; rotateArray[i]:</span><br><span class="line">                        temp = rotateArray[i]</span><br><span class="line">                <span class="keyword">return</span> temp</span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid] &gt;= rotateArray[start]:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">elif</span> rotateArray[end] &gt;= rotateArray[mid]:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">return</span> rotateArray[end]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>跳台阶</title>
    <url>/2020/05/21/%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p>裴波那契数列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] fb = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    fb[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    fb[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; target + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        fb[i] = fb[i - <span class="number">2</span>] + fb[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fb[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h1><p>链接：<a href="https://www.nowcoder.com/questionTerminal/8c82a5b80378478f9484d87d1c5f12a4?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/8c82a5b80378478f9484d87d1c5f12a4?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>本质上还是斐波那契数列，所以迭代也可以求</p>
<p>当成 dp 问题来想的话：首先分析问题，它最终解是由前面的解累积起来的解，如何缩小问题的规模？</p>
<p>首先可知，第一阶有只能一步，一种；，第二阶可以两次一步、一次两步两种</p>
<ul>
<li>若楼梯阶级 n = 3<ul>
<li>跳 2 步到 3：剩下的是第一步没跳，起始跳到第一步只有一种</li>
<li>跳 1 步到 3：剩下的是第二步没跳，起始跳到第二步有两种</li>
</ul>
</li>
</ul>
<p>通过分类讨论，问题规模就减少了:</p>
<ul>
<li>若楼梯阶级 n = n<ul>
<li>跳 2 步到 n：剩下的是第 n - 2 步没跳，起始跳到第 n - 2 步设它为 pre2 种</li>
<li>跳 1 步到 n：剩下的是第 n - 1 步没跳，起始跳到第 n - 1 步设它为 pre1 种</li>
</ul>
</li>
</ul>
<p>同时可以发现第 n 阶的解法，只要用到 n - 1 和 n - 2 阶是多少，其他的不用考虑，因此用两个变量临时存下来即可</p>
<p>dp(i) = dp(i-2) + dp(i-1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = pre2 + pre1;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>重建二叉树</title>
    <url>/2020/05/21/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p>递归建树即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span> || pre.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> rootInMid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[i] == pre[<span class="number">0</span>]) &#123;</span><br><span class="line">            rootInMid = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 左子树结点个数 */</span></span><br><span class="line">    <span class="keyword">int</span> leftNum = rootInMid;</span><br><span class="line"></span><br><span class="line">    root.left = reConstructBinaryTree(</span><br><span class="line">        Arrays.copyOfRange(pre, <span class="number">1</span>, leftNum + <span class="number">1</span>),</span><br><span class="line">        Arrays.copyOfRange(in, <span class="number">0</span>, rootInMid));</span><br><span class="line">    root.right = reConstructBinaryTree(</span><br><span class="line">        Arrays.copyOfRange(pre, leftNum + <span class="number">1</span>, pre.length),</span><br><span class="line">        Arrays.copyOfRange(in, rootInMid + <span class="number">1</span>, in.length));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h1><p>链接：<a href="https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="递归构建二叉树"><a href="#递归构建二叉树" class="headerlink" title="递归构建二叉树"></a>递归构建二叉树</h2><h3 id="1-分析"><a href="#1-分析" class="headerlink" title="1. 分析"></a>1. 分析</h3><p>根据中序遍历和前序遍历可以确定二叉树，具体过程为：</p>
<ol>
<li>根据前序序列第一个结点确定根结点 </li>
<li>根据根结点在中序序列中的位置分割出左右两个子序列 </li>
<li>对左子树和右子树分别递归使用同样的方法继续分解 </li>
</ol>
<p>例如：<br>前序序列{1,2,4,7,3,5,6,8} = pre<br>中序序列{4,7,2,1,5,3,8,6} = in</p>
<ol>
<li>根据当前前序序列的第一个结点确定根结点，为 1 </li>
<li>找到 1 在中序遍历序列中的位置，为 in[3] </li>
<li>切割左右子树，则 in[3] 前面的为左子树， in[3] 后面的为右子树 </li>
<li>则切割后的<strong>左子树前序序列</strong>为：{2,4,7}，切割后的<strong>左子树中序序列</strong>为：{4,7,2}；切割后的<strong>右子树前序序列</strong>为：{3,5,6,8}，切割后的<strong>右子树中序序列</strong>为：{5,3,8,6} </li>
<li>对子树分别使用同样的方法分解 </li>
</ol>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 在中序中找到前序的根</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == pre[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// 左子树，注意 copyOfRange 函数，左闭右开</span></span><br><span class="line">                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>), Arrays.copyOfRange(in, <span class="number">0</span>, i));</span><br><span class="line">                <span class="comment">// 右子树，注意 copyOfRange 函数，左闭右开</span></span><br><span class="line">                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + <span class="number">1</span>, pre.length), Arrays.copyOfRange(in, i + <span class="number">1</span>, in.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>链表中倒数第k个结点</title>
    <url>/2020/05/21/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<p>两个指针即可,注意处理k=0的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode kth = <span class="keyword">null</span>;</span><br><span class="line">    ListNode tmp = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span> &amp;&amp; tmp != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    kth = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; tmp.next != <span class="keyword">null</span>; tmp = tmp.next) &#123;</span><br><span class="line">        kth = kth.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h1><p>链接：<a href="https://www.nowcoder.com/questionTerminal/529d3ae5a407492994ad2a246518148a?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/529d3ae5a407492994ad2a246518148a?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="解法-1-两次循环"><a href="#解法-1-两次循环" class="headerlink" title="解法 1: 两次循环"></a>解法 1: 两次循环</h2><p>因为要求链表倒数第 k 个节点，也就是求正数第<code>length - k</code>个节点。整体过程如下：</p>
<ul>
<li>链表又是个单链表，并且没有保存长度信息。所以需要循环一次计算<code>length</code>。 </li>
<li>第二次循环找到第<code>length - k</code>个节点。 </li>
</ul>
<p>时间复杂度是 O(N)，需要 2 次循环。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindKthToTail</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> node = head;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        ++length;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k &gt; length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">let</span> offset = length - k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; offset; ++i) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法-2-快慢-双-指针"><a href="#解法-2-快慢-双-指针" class="headerlink" title="解法 2: 快慢(双)指针"></a>解法 2: 快慢(双)指针</h2><p>准备两个指针：left（慢）和 right（快）。整体过程如下：</p>
<ul>
<li>right 先向右移动 k 位，此时 <code>index(right) - index(left) = k</code> </li>
<li>left 和 right 一起向右移动，直到 right 抵达边界 </li>
<li>由于<code>index(right) - index(left) = k</code>，所以<code>index(left) = index(right) - k = length - k</code>。也就是 left 指针移动到了倒数第 k 个位置 </li>
</ul>
<p>时间复杂度是 O(N)，但仅需要遍历一次。空间复杂度是 O（1）</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindKthToTail</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> right = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (right === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 链表长度小于k</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = head;</span><br><span class="line">    <span class="keyword">while</span> (right) &#123;</span><br><span class="line">        left = left.next;</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2020/05/22/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<p>三个指针操作,注意将原链表的head.next置为null,同时注意处理原链表为空的情况.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode pre=head,cur=head.next,next=head.next.next;</span><br><span class="line">    head.next=<span class="keyword">null</span>;<span class="comment">//容易忘!</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        cur.next=pre;</span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=next;</span><br><span class="line">        <span class="keyword">if</span> (cur==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next=cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的镜像</title>
    <url>/2020/05/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">    	    8</span><br><span class="line">    	   &#x2F;  \</span><br><span class="line">    	  6   10</span><br><span class="line">    	 &#x2F; \  &#x2F; \</span><br><span class="line">    	5  7 9 11</span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    8</span><br><span class="line">    	   &#x2F;  \</span><br><span class="line">    	  10   6</span><br><span class="line">    	 &#x2F; \  &#x2F; \</span><br><span class="line">    	11 9 7  5</span><br></pre></td></tr></table></figure>

<p>递归最简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode left = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = left;</span><br><span class="line"></span><br><span class="line">    Mirror(root.left);</span><br><span class="line">    Mirror(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        TreeNode tmp = stack.pop();</span><br><span class="line">        TreeNode left = tmp.left;</span><br><span class="line">        tmp.left = tmp.right;</span><br><span class="line">        tmp.right = left;</span><br><span class="line">        <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tmp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>数值的整数次方</title>
    <url>/2020/05/22/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p>保证base和exponent不同时为0</p>
<p>非递归快速幂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;<span class="comment">//负数次幂</span></span><br><span class="line">        base = <span class="number">1.0</span> / base;</span><br><span class="line">        exponent = -exponent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">1.0</span>, tmpEx = base;</span><br><span class="line">    <span class="keyword">while</span> (exponent &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((exponent &amp; <span class="number">0x01</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            ans *= tmpEx;</span><br><span class="line">        &#125;</span><br><span class="line">        tmpEx *= tmpEx;<span class="comment">//翻倍</span></span><br><span class="line">        exponent = exponent &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="网上解法"><a href="#网上解法" class="headerlink" title="网上解法"></a>网上解法</h1><p>链接：<a href="https://www.nowcoder.com/questionTerminal/1a834e5e3e1a4b7ba251417554e07c00?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/1a834e5e3e1a4b7ba251417554e07c00?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h3 id="预处理：求pow-b-n-，如果n为负数怎么解决？"><a href="#预处理：求pow-b-n-，如果n为负数怎么解决？" class="headerlink" title="预处理：求pow(b, n)，如果n为负数怎么解决？"></a>预处理：求pow(b, n)，如果n为负数怎么解决？</h3><p>假如求<img src="https://www.nowcoder.com/equation?tex=x%5E%7B-2%7D" alt="图片说明"> ,是不是可以转换成<img src="https://www.nowcoder.com/equation?tex=(%5Cfrac%7B1%7D%7Bx%7D)%5E%7B2%7D" alt="图片说明"><br>于是，预处理代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        b = <span class="number">1</span> / b;</span><br><span class="line">        n = -n;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法一：暴力方法"><a href="#方法一：暴力方法" class="headerlink" title="方法一：暴力方法"></a>方法一：暴力方法</h2><p>很显然就是n个b相乘。循环n次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = <span class="number">1</span> / b;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ret = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) ret *= b;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h2 id="方法二：递归法（快速幂）"><a href="#方法二：递归法（快速幂）" class="headerlink" title="方法二：递归法（快速幂）"></a>方法二：递归法（快速幂）</h2><p>假设我们求<img src="https://www.nowcoder.com/equation?tex=x%5E%7B8%7D" alt="图片说明"> ，如果我们知道<img src="https://www.nowcoder.com/equation?tex=x%5E%7B4%7D" alt="图片说明"> ，那么<img src="https://www.nowcoder.com/equation?tex=x%5E%7B8%7D%20%3D%20(x%5E%7B4%7D)%5E%7B2%7D" alt="图片说明"> ，所以<img src="https://www.nowcoder.com/equation?tex=x%5E%7Bn%7D%20%3D%20(x%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D)%5E%7B2%7D" alt="图片说明"> </p>
<p>但是还有个小问题，如果n是偶数，那么上述没问题。</p>
<p>如果n是奇数，<img src="https://www.nowcoder.com/equation?tex=x%5E%7Bn%7D%20%3D%20(x%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D)%5E%7B2%7D%20*%20x" alt="图片说明"> ， 比如<img src="https://www.nowcoder.com/equation?tex=x%5E%7B7%7D%20%3D%20(x%5E%7B3%7D)%5E%7B2%7D%20*%20x" alt="图片说明"><br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">q_power</span><span class="params">(<span class="keyword">double</span> b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> ret = q_power(b, n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n&amp;<span class="number">1</span>) &#123; <span class="comment">// 奇数</span></span><br><span class="line">            <span class="keyword">return</span> ret * ret * b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ret * ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = <span class="number">1</span> / b;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q_power(b, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn)，每次规模减少一半<br>空间复杂度：O(logn)，递归栈，因为要记住logn个变量</p>
<h2 id="方法三：非递归的快速幂"><a href="#方法三：非递归的快速幂" class="headerlink" title="方法三：非递归的快速幂"></a>方法三：非递归的快速幂</h2><p>假设求<img src="https://www.nowcoder.com/equation?tex=x%5E%7B6%7D" alt="图片说明"> ,已知6可以表示成二进制<code>110</code><br>可以表示成<img src="https://www.nowcoder.com/equation?tex=6%20%3D%200*2%5E%7B0%7D%20%2B%201%20*%202%5E%7B1%7D%20%2B%201%20*%202%5E%7B2%7D" alt="图片说明"> ,所以<img src="https://www.nowcoder.com/equation?tex=x%5E%7B6%7D" alt="图片说明"> 可以表示成<img src="https://www.nowcoder.com/equation?tex=x%5E%7B6%7D%20%3D%20x%5E%20%7B0*2%5E%7B0%7D%20%2B%201*2%5E%7B1%7D%20%2B%201*2%5E%7B2%7D%7D%20%3D%20x%5E%7B0%7D%20*%20x%5E%7B1*2%5E%7B1%7D%7D*x%5E%7B1*2%5E%7B2%7D%7D" alt="图片说明"> 所以，对于二进制数，遇到位数是1的就乘到答案中。<br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = <span class="number">1</span> / b;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> x = b; <span class="comment">// 记录x^0, x^1, x^2 ...</span></span><br><span class="line">        <span class="keyword">double</span> ret = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                ret *= x; <span class="comment">// 二进制位数是1的，乘进答案。</span></span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述方法相当于遍历n的二进制位，是1就乘进结果<br>时间复杂度：O(logn)，因为n的二进制位个数为logn<br>空间复杂度：O(1)</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>STL标准库中，pow函数的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Integer</span>, <span class="title">class</span> <span class="title">MonoidOperation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">power_this</span>(<span class="title">T</span> <span class="title">x</span>, <span class="title">Integer</span> <span class="title">n</span>, <span class="title">MonoidOperation</span> <span class="title">op</span>)&#123;</span> <span class="comment">// 可以看成求pow(x, n)</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> identity_element(op); <span class="comment">// 可以看成 1</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            x = op(x, x); <span class="comment">//op看成乘法</span></span><br><span class="line">        &#125;</span><br><span class="line">        T result = x; <span class="comment">// 遇到 二进制中从低位到高位的第一个 1</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">            x = op(x, x);</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                result = op(result, x);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做法跟我们方法三是一样的。</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>合并两个排序的链表</title>
    <url>/2020/05/22/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode head = <span class="keyword">null</span>, pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = list1;</span><br><span class="line">                pre = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.next = list1;</span><br><span class="line">                pre = list1;</span><br><span class="line">            &#125;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = list2;</span><br><span class="line">                pre = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.next = list2;</span><br><span class="line">                pre = list2;</span><br><span class="line">            &#125;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = (list1 != <span class="keyword">null</span>) ? list1 : list2;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>todo:还可以用递归的方式</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>调整数组顺序使奇数位于偶数前面</title>
    <url>/2020/05/22/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>空间换时间,时间复杂度O(n),空间复杂度O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">int</span>[] oddList = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">int</span>[] evenList = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">int</span> oddNum = <span class="number">0</span>, evenNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            oddList[oddNum++] = array[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            evenList[evenNum++] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; oddNum; k++) &#123;</span><br><span class="line">        ans[k] = oddList[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; evenNum; k++) &#123;</span><br><span class="line">        ans[k + oddNum] = evenList[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">        array[i] = ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h1><p>链接：<a href="https://www.nowcoder.com/questionTerminal/beb5aa231adc45b2a5dcc5b62c93f593?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/beb5aa231adc45b2a5dcc5b62c93f593?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<p>思路：参考快速排序</p>
<ul>
<li><code>i++</code>往前走碰到偶数停下来，<code>j = i+1</code> </li>
<li>若<code>a[j]</code>为偶数，<code>j++</code>前进，直到碰到奇数</li>
<li><code>a[j]</code>对应的奇数插到a[i]位置，<code>j</code>经过的<code>j-i</code>个偶数依次后移 </li>
<li>如果<code>j==len-1</code>时还没碰到奇数，证明<code>i</code>和<code>j</code>之间都为偶数了，完成整个移动 </li>
</ul>
<p><img src="https://uploadfiles.nowcoder.com/images/20190821/807319133_1566376642654_29268C9D65CC420F5579430A2416F419" alt="图片说明"> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>)&#123; <span class="comment">// 数组空或长度为1</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i]%<span class="number">2</span> == <span class="number">0</span>)&#123; <span class="comment">// a[i]为偶数，j前进，直到替换</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="built_in">array</span>[j]%<span class="number">2</span> == <span class="number">0</span>)&#123; <span class="comment">// j为偶数，前进</span></span><br><span class="line">                    <span class="keyword">if</span>(j==len<span class="number">-1</span>)<span class="comment">// i为偶数，j也为偶数，一直后移到了末尾，证明后面都是偶数</span></span><br><span class="line">                         <span class="keyword">return</span>;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 此时j为奇数</span></span><br><span class="line">                <span class="keyword">int</span> count = j-i;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="built_in">array</span>[i];</span><br><span class="line">                <span class="built_in">array</span>[i] = <span class="built_in">array</span>[j];</span><br><span class="line">                <span class="keyword">while</span>(count&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="built_in">array</span>[i+count] = <span class="built_in">array</span>[i+count<span class="number">-1</span>];<span class="comment">//数组后移</span></span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">array</span>[i+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>斐波那契数列</title>
    <url>/2020/05/21/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</p>
<p>n&lt;=39;</p>
<p>使用数组存储中间状态(最简单的动态规划),避免递归造成的调用栈空间消耗</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] fb=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span>];</span><br><span class="line">    fb[<span class="number">0</span>]=<span class="number">0</span>;fb[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        fb[i]=fb[i-<span class="number">2</span>]+fb[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fb[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h1><p>链接：<a href="https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="1-递归法"><a href="#1-递归法" class="headerlink" title="1. 递归法"></a>1. 递归法</h2><h3 id="1-分析"><a href="#1-分析" class="headerlink" title="1. 分析"></a>1. 分析</h3><p>斐波那契数列的标准公式为：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）<br>根据公式可以直接写出：</p>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-复杂度"><a href="#3-复杂度" class="headerlink" title="3. 复杂度"></a>3. 复杂度</h3><p>时间复杂度：<img src="https://www.nowcoder.com/equation?tex=O(2%5En)&preview=true" alt="img"><br>空间复杂度：<img src="https://www.nowcoder.com/equation?tex=O(1)&preview=true" alt="img"></p>
<h2 id="2-优化递归"><a href="#2-优化递归" class="headerlink" title="2. 优化递归"></a>2. 优化递归</h2><h3 id="1-分析-1"><a href="#1-分析-1" class="headerlink" title="1. 分析"></a>1. 分析</h3><p>递归会重复计算大量相同数据，我们用个数组把结果存起来8！</p>
<h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2. 代码"></a>2. 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        ans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            ans[i] = ans[i-<span class="number">1</span>] + ans[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-复杂度："><a href="#3-复杂度：" class="headerlink" title="3. 复杂度："></a>3. 复杂度：</h3><p>时间复杂度：<img src="https://www.nowcoder.com/equation?tex=O(n)&preview=true" alt="img"><br>空间复杂度：<img src="https://www.nowcoder.com/equation?tex=O(n)&preview=true" alt="img"></p>
<h2 id="3-优化存储"><a href="#3-优化存储" class="headerlink" title="3. 优化存储"></a>3. 优化存储</h2><h3 id="1-分析-2"><a href="#1-分析-2" class="headerlink" title="1. 分析"></a>1. 分析</h3><p>其实我们可以发现每次就用到了最近的两个数，所以我们可以只存储最近的两个数</p>
<ul>
<li>sum 存储第 n 项的值 </li>
<li>one 存储第 n-1 项的值 </li>
<li>two 存储第 n-2 项的值 </li>
</ul>
<h3 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="2. 代码"></a>2. 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> two = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum = two + one;</span><br><span class="line">            two = one;</span><br><span class="line">            one = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-复杂度：-1"><a href="#3-复杂度：-1" class="headerlink" title="3. 复杂度："></a>3. 复杂度：</h3><p>时间复杂度：<img src="https://www.nowcoder.com/equation?tex=O(n)&preview=true" alt="img"><br>空间复杂度：<img src="https://www.nowcoder.com/equation?tex=O(1)&preview=true" alt="img"></p>
<h2 id="4-持续优化"><a href="#4-持续优化" class="headerlink" title="4. 持续优化"></a>4. 持续优化</h2><h3 id="1-分析-3"><a href="#1-分析-3" class="headerlink" title="1. 分析"></a>1. 分析</h3><p>观察上一版发现，sum 只在每次计算第 n 项的时候用一下，其实还可以利用 sum 存储第 n-1 项，例如当计算完 f(5) 时 sum 存储的是 f(5) 的值，当需要计算 f(6) 时，f(6) = f(5) + f(4)，sum 存储的 f(5)，f(4) 存储在 one 中，由 f(5)-f(3) 得到<br>如图：<br><img src="https://uploadfiles.nowcoder.com/images/20190809/1078265_1565356750394_CDC679BEBBE282E170AB6FE0DCA8445E" alt="图片标题"> </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190809/1078265_1565356789738_F3CCDD27D2000E3F9255A7E3E2C48800" alt="图片标题"> </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190809/1078265_1565356834024_156005C5BAF40FF51A327F1C34F2975B" alt="图片说明"> </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190809/1078265_1565356908370_799BAD5A3B514F096E69BBC4A7896CD9" alt="图片标题"> </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190809/1078265_1565356960932_D0096EC6C83575373E3A21D129FF8FEF" alt="图片标题"> </p>
<h3 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="2. 代码"></a>2. 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum = sum + one;</span><br><span class="line">            one = sum - one;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-复杂度-1"><a href="#3-复杂度-1" class="headerlink" title="3. 复杂度"></a>3. 复杂度</h3><p>时间复杂度：<img src="https://www.nowcoder.com/equation?tex=O(n)&preview=true" alt="img"><br>空间复杂度：<img src="https://www.nowcoder.com/equation?tex=O(1)&preview=true" alt="img"></p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>从上往下打印二叉树</title>
    <url>/2020/05/23/%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>二叉树的层次遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode tmp=queue.poll();</span><br><span class="line">        ans.add(tmp.val);</span><br><span class="line">        <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(tmp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>包含min函数的栈</title>
    <url>/2020/05/23/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<p>注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。</p>
<p>使用最小值辅助栈.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与上面的栈同步,存储栈中最小元素的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    stack.push(node);</span><br><span class="line">    <span class="keyword">if</span> (minStack.isEmpty() || minStack.peek() &gt; node) &#123;</span><br><span class="line">        minStack.push(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        minStack.push(minStack.peek());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    minStack.pop();</span><br><span class="line">    stack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack.peek();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> minStack.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>数组中出现次数超过一半的数字</title>
    <url>/2020/05/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<p>简单的做法，hash表记录出现次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=array.length;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(i)) &#123;</span><br><span class="line">            map.put(i,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(i,map.get(i)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : map.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(integer)&gt;len/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> integer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用tmp记录上一次访问的值，count表明当前值出现的次数，如果下一个值和当前值相同那么count++；如果不同count–，count减到0的时候就要更换新的tmp值了。如果存在超过数组长度一半的值tmp，那么最后一定会使count大于0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = array[<span class="number">0</span>], count = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == -<span class="number">1</span>) &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[i] == tmp) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            tmp = array[i];</span><br><span class="line">            count = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &lt;= <span class="number">0</span> ? <span class="number">0</span> : tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>栈的压入、弹出序列</title>
    <url>/2020/05/23/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p>用一个栈来模拟出栈序列.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span>[] pushA, <span class="keyword">int</span>[] popA)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; pushStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pushA[i] != popA[k]) &#123;</span><br><span class="line">            pushStack.push(pushA[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">while</span> (!pushStack.empty() &amp;&amp; pushStack.peek() == popA[k]) &#123;</span><br><span class="line">                pushStack.pop();</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; popA.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (popA[i] != pushStack.pop()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更简化的思路:新建一个栈，将pushA依次压入栈中，当栈顶元素等于数组B时，就将其出栈. 当循环结束时，判断栈是否为空，若为空则返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span>[] pushA, <span class="keyword">int</span>[] popA)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">        stack.push(pushA[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; stack.peek() == popA[k]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>树的子结构</title>
    <url>/2020/05/23/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>注意子结构和子树的区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;TreeNode&gt; treeNodeList = getNode(root2.val, root1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (TreeNode treeNode : treeNodeList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (judgeTree(treeNode, root2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断子结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">judgeTree</span><span class="params">(TreeNode r1, TreeNode r2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r1.val != r2.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> judgeTree(r1.left, r2.left) &amp;&amp; judgeTree(r1.right, r2.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到所有值相同的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;TreeNode&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> <span class="keyword">var</span>, TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        TreeNode tmp = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (tmp.val == <span class="keyword">var</span>) &#123;</span><br><span class="line">            ans.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tmp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/2020/05/23/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>四个方向,一圈一圈分别处理;最后处理单行,单列的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> circle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> stepCol = col - <span class="number">1</span>, stepRow = row - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (col - circle * <span class="number">2</span> &gt; <span class="number">1</span> &amp;&amp; row - circle * <span class="number">2</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> start1 = circle;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start1; i &lt; stepCol + start1; i++) &#123;</span><br><span class="line">            ans.add(matrix[circle][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start2 = circle;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = start2; j &lt; stepRow + start2; j++) &#123;</span><br><span class="line">            ans.add(matrix[j][col - circle - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start3 = col - circle - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start3; i &gt; start3 - stepCol; i--) &#123;</span><br><span class="line">            ans.add(matrix[row - circle - <span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start4 = row - circle - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = start4; j &gt; start4 - stepRow; j--) &#123;</span><br><span class="line">            ans.add(matrix[j][circle]);</span><br><span class="line">        &#125;</span><br><span class="line">        stepCol -= <span class="number">2</span>;</span><br><span class="line">        stepRow -= <span class="number">2</span>;</span><br><span class="line">        circle++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (row - circle * <span class="number">2</span> == <span class="number">1</span> &amp;&amp; col - circle * <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/** 处理最后剩一个的问题 */</span></span><br><span class="line">        ans.add(matrix[row / <span class="number">2</span>][col / <span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (col - circle * <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/** 处理单列 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = circle; i &lt; row - circle; i++) &#123;</span><br><span class="line">                ans.add(matrix[i][col / <span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (row - circle * <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/** 处理单行 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = circle; j &lt; col - circle; j++) &#123;</span><br><span class="line">                ans.add(matrix[row / <span class="number">2</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/9b4c81a02cd34f76be2659fa0d54342a?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/9b4c81a02cd34f76be2659fa0d54342a?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h3 id="1-分析"><a href="#1-分析" class="headerlink" title="1. 分析"></a>1. 分析</h3><p>刷 LeetCode 看到的大神题解，感觉容易理解且好写<br>简单来说，就是不断地收缩矩阵的边界<br>定义四个变量代表范围，up、down、left、right</p>
<ol>
<li>向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 up 加一，同时判断是否和代表下边界的 down 交错 </li>
<li>向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错 </li>
<li>向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 down 减一，同时判断是否和代表上边界的 up 交错 </li>
<li>向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错 </li>
</ol>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> down = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 最上面一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=left;col&lt;=right;col++)&#123;</span><br><span class="line">                list.add(matrix[up][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向下逼近</span></span><br><span class="line">            up++;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(up &gt; down)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最右边一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=up;row&lt;=down;row++)&#123;</span><br><span class="line">                list.add(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向左逼近</span></span><br><span class="line">            right--;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最下面一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=right;col&gt;=left;col--)&#123;</span><br><span class="line">                list.add(matrix[down][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向上逼近</span></span><br><span class="line">            down--;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(up &gt; down)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最左边一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=down;row&gt;=up;row--)&#123;</span><br><span class="line">                list.add(matrix[row][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向右逼近</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-复杂度"><a href="#3-复杂度" class="headerlink" title="3. 复杂度"></a>3. 复杂度</h3><p>时间复杂度：<img src="https://www.nowcoder.com/equation?tex=O(n)&preview=true" alt="img"><br>空间复杂度：<img src="https://www.nowcoder.com/equation?tex=O(1)&preview=true" alt="img"></p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>二叉搜索树与双向链表</title>
    <url>/2020/05/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p>后序遍历，最后来改根节点的指针，递归的思路</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">    TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (pRootOfTree == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode leftHead = Convert(pRootOfTree.left);</span><br><span class="line">    TreeNode rightHead = Convert(pRootOfTree.right);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pRootOfTree.left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (rightHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pRootOfTree.right = rightHead;</span><br><span class="line">        rightHead.left = pRootOfTree;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pRootOfTree.right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    head = pRootOfTree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode tn = leftHead;</span><br><span class="line">        <span class="keyword">for</span> (; tn.right != <span class="keyword">null</span>; tn = tn.right) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        tn.right = pRootOfTree;</span><br><span class="line">        pRootOfTree.left = tn;</span><br><span class="line">        head = leftHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树中和为某一值的路径</title>
    <url>/2020/05/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>深度优先遍历二叉树，走到叶子结点判断一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    getPath(root, <span class="keyword">new</span> Stack&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPath</span><span class="params">(TreeNode root, Stack&lt;Integer&gt; tmpPath)</span> </span>&#123;</span><br><span class="line">    tmpPath.add(root.val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="keyword">null</span> &amp;&amp; root.left == <span class="keyword">null</span>) &#123;<span class="comment">//叶子结点</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : tmpPath) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            list.add(list.size(), i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            ans.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getPath(root.left, tmpPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getPath(root.right, tmpPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tmpPath.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>二叉搜索树的后序遍历序列</title>
    <url>/2020/05/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<p>递归判断左右子树是否满足二叉搜索树的条件，即左子树都比root小，右子树都比root大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span>[] sequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sequence == <span class="keyword">null</span> || sequence.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, root = sequence[sequence.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (; left &lt; sequence.length - <span class="number">1</span>; left++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[left] &gt; root) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; sequence.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[i] &lt; root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> leftOk = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        leftOk = VerifySquenceOfBST(Arrays.copyOf(sequence, left));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> rightOk = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (sequence.length - <span class="number">1</span> - left &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        rightOk = VerifySquenceOfBST(Arrays.copyOfRange(sequence, left, sequence.length - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftOk &amp;&amp; rightOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>复杂链表的复制</title>
    <url>/2020/05/24/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<p>先按照next遍历复制链表，再对复制后的radom指针赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> label;</span><br><span class="line">    RandomListNode next = <span class="keyword">null</span>;</span><br><span class="line">    RandomListNode random = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    RandomListNode(<span class="keyword">int</span> label) &#123;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RandomListNode cloneHead = <span class="keyword">new</span> RandomListNode(pHead.label);</span><br><span class="line">    RandomListNode pre = cloneHead;</span><br><span class="line">    RandomListNode p = pHead.next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pre.next = <span class="keyword">new</span> RandomListNode(p.label);</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RandomListNode pt = pHead, cp = cloneHead; pt != <span class="keyword">null</span>; pt = pt.next, cp = cp.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pt.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cp.random = findNode(pt.random.label, cloneHead);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">findNode</span><span class="params">(<span class="keyword">int</span> label, RandomListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (RandomListNode p = head; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.label == label) &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/f836b2c43afc4b35ad6adc41ec941dba?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/f836b2c43afc4b35ad6adc41ec941dba?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<p>不用开辟新的Map，但是其实需要多次遍历。<br><img src="https://uploadfiles.nowcoder.com/images/20190817/1687_1566007452847_156049DB72618CDDC4D5C4002CBC6403" alt="图片说明"> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*解题思路：</span></span><br><span class="line"><span class="comment">*1、遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；</span></span><br><span class="line"><span class="comment">*2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</span></span><br><span class="line"><span class="comment">*3、拆分链表，将链表拆分为原链表和复制后的链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RandomListNode currentNode = pHead;</span><br><span class="line">        <span class="comment">//1、复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode cloneNode = <span class="keyword">new</span> RandomListNode(currentNode.label);</span><br><span class="line">            RandomListNode nextNode = currentNode.next;</span><br><span class="line">            currentNode.next = cloneNode;</span><br><span class="line">            cloneNode.next = nextNode;</span><br><span class="line">            currentNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentNode = pHead;</span><br><span class="line">        <span class="comment">//2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentNode.next.random = currentNode.random==<span class="keyword">null</span>?<span class="keyword">null</span>:currentNode.random.next;</span><br><span class="line">            currentNode = currentNode.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、拆分链表，将链表拆分为原链表和复制后的链表</span></span><br><span class="line">        currentNode = pHead;</span><br><span class="line">        RandomListNode pCloneHead = pHead.next;</span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloneNode = currentNode.next;</span><br><span class="line">            currentNode.next = cloneNode.next;</span><br><span class="line">            cloneNode.next = cloneNode.next==<span class="keyword">null</span>?<span class="keyword">null</span>:cloneNode.next.next;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>最小的K个数</title>
    <url>/2020/05/24/%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>无脑排序，输出前k个数。不得不说牛客网的测试用例太弱了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(input);</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (k &gt; input.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        list.add(input[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>借助TreeSet记录最小的k个值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (k &gt; input.length || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.size() &lt; k) &#123;</span><br><span class="line">            set.add(input[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.last() &gt; input[i]) &#123;</span><br><span class="line">                set.remove(set.last());</span><br><span class="line">                set.add(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : set) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的深度</title>
    <url>/2020/05/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>递归，非递归用栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(TreeDepth(root.left)+<span class="number">1</span>,TreeDepth(root.right)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>字符串的排列</title>
    <url>/2020/05/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>使用TreeSet消除重复，同时排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">TreeSet&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    getPermutation(<span class="keyword">new</span> String(), str);</span><br><span class="line">    <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">        list.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPermutation</span><span class="params">(String ordered, String unordered)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unordered == <span class="keyword">null</span> || unordered.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        set.add(ordered);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unordered.length(); i++) &#123;</span><br><span class="line">        getPermutation(ordered + unordered.charAt(i), unordered.substring(<span class="number">0</span>, i) + unordered.substring(i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/fe6b651b66ae47d7acce78ffdd9a96c7?f=discussion</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、递归算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 解析：http://www.cnblogs.com/cxjchen/p/3932949.html  (感谢该文作者！)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 对于无重复值的情况</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 固定第一个字符，递归取得首位后面的各种字符串组合；</span></span><br><span class="line"><span class="comment">     * 再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合； *递归的出口，就是只剩一个字符的时候，递归的循环过程，就是从每个子串的第二个字符开始依次与第一个字符交换，然后继续处理子串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 假如有重复值呢？</span></span><br><span class="line"><span class="comment">     * *由于全排列就是从第一个数字起，每个数分别与它后面的数字交换，我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这两个数就不交换了。</span></span><br><span class="line"><span class="comment">     * 例如abb，第一个数与后面两个数交换得bab，bba。然后abb中第二个数和第三个数相同，就不用交换了。</span></span><br><span class="line"><span class="comment">     * 但是对bab，第二个数和第三个数不 同，则需要交换，得到bba。</span></span><br><span class="line"><span class="comment">     * 由于这里的bba和开始第一个数与第三个数交换的结果相同了，因此这个方法不行。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 换种思维，对abb，第一个数a与第二个数b交换得到bab，然后考虑第一个数与第三个数交换，此时由于第三个数等于第二个数，</span></span><br><span class="line"><span class="comment">     * 所以第一个数就不再用与第三个数交换了。再考虑bab，它的第二个数与第三个数交换可以解决bba。此时全排列生成完毕！</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(str!=<span class="keyword">null</span> &amp;&amp; str.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            PermutationHelper(str.toCharArray(),<span class="number">0</span>,list);</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PermutationHelper</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> i,ArrayList&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == chars.length-<span class="number">1</span>)&#123;</span><br><span class="line">            list.add(String.valueOf(chars));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Set&lt;Character&gt; charSet = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;chars.length;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i || !charSet.contains(chars[j]))&#123;</span><br><span class="line">                    charSet.add(chars[j]);</span><br><span class="line">                    swap(chars,i,j);</span><br><span class="line">                    PermutationHelper(chars,i+<span class="number">1</span>,list);</span><br><span class="line">                    swap(chars,j,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] cs,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = cs[i];</span><br><span class="line">        cs[i] = cs[j];</span><br><span class="line">        cs[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、字典序排列算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 可参考解析： http://www.cnblogs.com/pmars/archive/2013/12/04/3458289.html  （感谢作者）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 一个全排列可看做一个字符串，字符串可有前缀、后缀。</span></span><br><span class="line"><span class="comment">     * 生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。</span></span><br><span class="line"><span class="comment">     * 这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * [例]839647521是1--9的排列。1—9的排列最前面的是123456789，最后面的987654321，</span></span><br><span class="line"><span class="comment">     * 从右向左扫描若都是增的，就到了987654321，也就没有下一个了。否则找出第一次出现下降的位置。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 【例】 如何得到346987521的下一个</span></span><br><span class="line"><span class="comment">     * 1，从尾部往前找第一个P(i-1) &lt; P(i)的位置</span></span><br><span class="line"><span class="comment">     * 3 4 6 &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1</span></span><br><span class="line"><span class="comment">     * 最终找到6是第一个变小的数字，记录下6的位置i-1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2，从i位置往后找到最后一个大于6的数</span></span><br><span class="line"><span class="comment">     * 3 4 6 -&gt; 9 -&gt; 8 -&gt; 7 5 2 1</span></span><br><span class="line"><span class="comment">     * 最终找到7的位置，记录位置为m</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3，交换位置i-1和m的值</span></span><br><span class="line"><span class="comment">     * 3 4 7 9 8 6 5 2 1</span></span><br><span class="line"><span class="comment">     * 4，倒序i位置后的所有数据</span></span><br><span class="line"><span class="comment">     * 3 4 7 1 2 5 6 8 9</span></span><br><span class="line"><span class="comment">     * 则347125689为346987521的下一个排列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation2</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        list.add(String.valueOf(chars));</span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> lIndex = len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rIndex;</span><br><span class="line">            <span class="keyword">while</span>(lIndex&gt;=<span class="number">1</span> &amp;&amp; chars[lIndex-<span class="number">1</span>]&gt;=chars[lIndex])&#123;</span><br><span class="line">                lIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lIndex == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            rIndex = lIndex;</span><br><span class="line">            <span class="keyword">while</span>(rIndex&lt;len &amp;&amp; chars[rIndex]&gt;chars[lIndex-<span class="number">1</span>])&#123;</span><br><span class="line">                rIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(chars,lIndex-<span class="number">1</span>,rIndex-<span class="number">1</span>);</span><br><span class="line">            reverse(chars,lIndex);</span><br><span class="line"> </span><br><span class="line">            list.add(String.valueOf(chars));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars==<span class="keyword">null</span> || chars.length&lt;=k)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(len-k)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = k+i;</span><br><span class="line">            <span class="keyword">int</span> n = len-<span class="number">1</span>-i;</span><br><span class="line">            <span class="keyword">if</span>(m&lt;=n)&#123;</span><br><span class="line">                swap(chars,m,n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>数组中重复的数字</title>
    <url>/2020/05/25/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>找重复用HashSet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(numbers[i])) &#123;</span><br><span class="line">            duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.add(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>第一个只出现一次的字符</title>
    <url>/2020/05/25/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>统计每个字符出现的次数，要保持key的插入顺序，使用LinkedHashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** K:字符 V:下标，出现多处下标置为-1 */</span></span><br><span class="line">    Map&lt;Character, Integer&gt; countMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (countMap.containsKey(c)) &#123;</span><br><span class="line">            countMap.put(c, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            countMap.put(c, index);</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Character character : countMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = countMap.get(character);</span><br><span class="line">        <span class="keyword">if</span> (id != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>连续子数组的最大和</title>
    <url>/2020/05/25/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>动态规划，dp[i]=max(dp[i-1]+array[i],array[i])</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array==<span class="keyword">null</span>||array.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    dp[<span class="number">0</span>]=array[<span class="number">0</span>];<span class="keyword">int</span> max=dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        dp[i]=Math.max(dp[i-<span class="number">1</span>]+array[i],array[i]);</span><br><span class="line">        <span class="keyword">if</span> (dp[i]&gt;max)&#123;</span><br><span class="line">            max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>两个链表的第一个公共结点</title>
    <url>/2020/05/27/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解法一：暴力枚举，时间复杂度O(M*N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ListNode p1 = pHead1; p1 != <span class="keyword">null</span>; p1 = p1.next) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ListNode p2 = pHead2; p2 != <span class="keyword">null</span>; p2 = p2.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">                <span class="keyword">return</span> p1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：由于两个有公共节点的单链表形如‘Y’型，即链表尾端的节点都是公共的，所以从后往前找最后一个公共节点就是第一个公共节点。为了便于反向查找，使用两个辅助栈存储节点。空间复杂度O(M+N),时间复杂度也是O(M+N)</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>把数组排成最小的数</title>
    <url>/2020/05/27/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>排序规则：<strong>比较两个字符串s1, s2大小的时候，先将它们拼接起来，比较s1+s2,和s2+s1哪个大，如果s1+s2大，那说明s2应该放前面，所以按这个规则，s2就应该排在s1前面</strong>。</p>
<p>TODO优化：冒泡排序可以改为快排</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    String[] strings = <span class="keyword">new</span> String[numbers.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        strings[i] = String.valueOf(numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(strings);</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">        builder.append(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] strings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = strings.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp(strings[j], strings[j + <span class="number">1</span>])) &#123;</span><br><span class="line">                String tmp = strings[j];</span><br><span class="line">                strings[j] = strings[j + <span class="number">1</span>];</span><br><span class="line">                strings[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cmp</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    String s1 = str1 + str2, s2 = str2 + str1;</span><br><span class="line">    <span class="keyword">return</span> s1.compareTo(s2) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>数组中只出现一次的数字</title>
    <url>/2020/05/27/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>使用<code>HashMap</code>的话空间复杂度为<code>O(N)</code>，这里使用异或抵消两个相同的数，空间复杂度可降为<code>O(1)</code></p>
<p>时间复杂度都为<code>O(N)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">        nor = nor ^ i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lastN = <span class="number">0</span>;<span class="comment">//nor中1出现的最低位</span></span><br><span class="line">    <span class="keyword">for</span> (; (nor &amp; <span class="number">1</span>) == <span class="number">0</span>; nor = nor &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">        lastN++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 将array分为两个子数组分别异或 */</span></span><br><span class="line">    <span class="keyword">int</span> ans1 = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((i &gt;&gt; lastN) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            ans1 ^= i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans2 ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num1[<span class="number">0</span>] = ans1;</span><br><span class="line">    num2[<span class="number">0</span>] = ans2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/e02fdb54d7524710a7d664d082bb7811?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/e02fdb54d7524710a7d664d082bb7811?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h3 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h3><p>可以先用最简单的HashMap的方法来做，这样主要是为了练习Map的用法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希算法</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(array[i]))</span><br><span class="line">                map.put(array[i],<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(array[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(array[i]) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                    num1[<span class="number">0</span>] =  array[i];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    num2[<span class="number">0</span>] =  array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="比较考验智商的做法"><a href="#比较考验智商的做法" class="headerlink" title="比较考验智商的做法"></a>比较考验智商的做法</h3><p>比较好用的剑指offer的做法：<br>首先：位运算中异或的性质：两个相同数字异或=0，一个数和0异或还是它本身。<br>当只有一个数出现一次时，我们把数组中所有的数，依次异或运算，最后剩下的就是落单的数，因为成对儿出现的都抵消了。</p>
<p>依照这个思路，我们来看两个数（我们假设是AB）出现一次的数组。我们首先还是先异或，剩下的数字肯定是A、B异或的结果，这个结果的二进制中的1，表现的是A和B的不同的位。我们就取第一个1所在的位数，假设是第3位，接着把原数组分成两组，分组标准是第3位是否为1。如此，相同的数肯定在一个组，因为相同数字所有位都相同，而不同的数，肯定不在一组。然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> xor1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">            xor1 = xor1^array[i];</span><br><span class="line">        <span class="comment">//在xor1中找到第一个不同的位对数据进行分类，分类为两个队列对数据进行异或求和找到我们想要的结果</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((index &amp; xor1)==<span class="number">0</span>)</span><br><span class="line">            index = index &lt;&lt;<span class="number">1</span>;<span class="comment">//因为可能有多个位为1所以需要求一下位置</span></span><br><span class="line">        <span class="keyword">int</span> result1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((index &amp; array[i]) == <span class="number">0</span>)</span><br><span class="line">                result1 = result1^array[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result2 = result2^array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        num1[<span class="number">0</span>] = result1;</span><br><span class="line">        num2[<span class="number">0</span>] = result2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>求1到n的和</title>
    <url>/2020/05/27/%E6%B1%821%E5%88%B0n%E7%9A%84%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>最简单用递归的思想，使用<code>tmp&gt;0</code>切断递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = n;</span><br><span class="line">        <span class="keyword">boolean</span> b=tmp &gt;<span class="number">0</span> &amp;&amp; (<span class="number">1</span>==(tmp += (Sum_Solution(n - <span class="number">1</span>))));</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/7a0da8fc483247ff8800059e12d7caf1?f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/7a0da8fc483247ff8800059e12d7caf1?f=discussion</a><br>来源：牛客网</p>
<p>总结前面大牛们的方法，提供java的两种阶梯思路： </p>
<p>  共同点：</p>
<p>​    一，利用利用短路 &amp;&amp; 来实现 if的功能；</p>
<p>​    二，利用递归来实现循环while的功能 </p>
<p>  不同点：</p>
<p>​    方法一：递归实现1+2+..+n;</p>
<p>​    方法二：n(n+1)/2,递归实现n(n+1)；</p>
<p>​    方法三，利用Math实现n(n+1) </p>
<p>  关于如何递归实现a*b，有大佬总结过，我搬下来：利用位运算来做，快速幂，快速模乘, </p>
<p>  原理是把a拆成2的幂的和，a = 2^e0 + 2^e1 + 2^e2….<br>    那么 a * b = (2^e0 + 2^e1 + 2^e2+…) * b </p>
<p>​             = b * 2^e0 + b * 2^e1 + b * 2^e2 + …<br>​            = (b &lt;&lt; e0) + (b &lt;&lt; e1) + ….<br> 接下来看代码：</p>
<p>  方法一：递归实现1+2+..+n; </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = n;</span><br><span class="line">        <span class="keyword">boolean</span> flag = (sum &gt; <span class="number">0</span>) &amp;&amp; ((sum += Sum_Solution(--n)) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  方法三，利用Math实现n(n+1) </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Sum_Solution1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.pow(n, <span class="number">2</span>) + n) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  方法二：n(n+1)/2,递归实现n(n+1)； </p>
<p>  先参考使用while的例子，再转换 </p>
<p>  原理是把a拆成2的幂的和，a = 2^e0 + 2^e1 + 2^e2…. </p>
<p>  那么 a * b = (2^e0 + 2^e1 + 2^e2+…) * b  </p>
<p>​                  = b * 2^e0 + b * 2^e1 + b * 2^e2 + …<br>​                  = (b &lt;&lt; e0) + (b &lt;&lt; e1) + ….  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Sum_Solution2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n;<span class="comment">//若a=2=10</span></span><br><span class="line">        <span class="keyword">int</span> b = n + <span class="number">1</span>;<span class="comment">//b=3=11</span></span><br><span class="line">        <span class="keyword">while</span> (a != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) == <span class="number">1</span>)<span class="comment">//a在第二位==1的时候才更新res=0+110=6</span></span><br><span class="line">                res += b;</span><br><span class="line">            a &gt;&gt;= <span class="number">1</span>;<span class="comment">//a右移1位 1</span></span><br><span class="line">            b &lt;&lt;= <span class="number">1</span>;<span class="comment">//b左移动1位 110</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res&gt;&gt;=<span class="number">1</span>;<span class="comment">//n(n+1)/2     </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>  接下来，用(a &amp; 1) == 1和(a != 0)来代替判断语句 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> res = multi(n, n + <span class="number">1</span>);<span class="comment">//n*(n-1)</span></span><br><span class="line">       <span class="keyword">return</span> res&gt;&gt;=<span class="number">1</span>;<span class="comment">//n*(n-1)/2</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">multi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//循环体内部, if ((a &amp; 1) == 1), res += b;</span></span><br><span class="line">       <span class="keyword">boolean</span> flag1 = ((a &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (res += b) &gt; <span class="number">0</span>;</span><br><span class="line">       a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">       b &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// while (a != 0) &#123;&#125;循环条件</span></span><br><span class="line">       <span class="keyword">boolean</span> flag2 = (a != <span class="number">0</span>) &amp;&amp; (res += multi(a,b)) &gt; <span class="number">0</span> ;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>Java：关于Static静态关键字的那些小事</title>
    <url>/2020/05/29/Java%EF%BC%9A%E5%85%B3%E4%BA%8EStatic%E9%9D%99%E6%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E9%82%A3%E4%BA%9B%E5%B0%8F%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h1><p>一种 表示<strong>静态属性</strong>的 关键字 / 修饰符</p>
<hr>
<h1 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h1><p>共用、共享</p>
<blockquote>
<p>能有此作用的原因分析：</p>
<ol>
<li>Java中，任何变量 / 代码存储时，都是 在编译时 由系统自动分配内存</li>
<li>在静态变量编译后，所分配的内存会一直存在，直到程序退出内存才会释放这个空间</li>
<li>类加载时，<code>JVM</code>会把静态变量放到 <strong>方法区</strong>，被本类 &amp; 本类的所有实例所共用</li>
</ol>
</blockquote>
<hr>
<h1 id="3-具体使用"><a href="#3-具体使用" class="headerlink" title="3. 具体使用"></a>3. 具体使用</h1><ul>
<li><code>Static</code>静态修饰符可应用于：类、代码块、方法 &amp; 变量</li>
<li>下面，我将详细分析</li>
</ul>
<h3 id="3-1-静态类"><a href="#3-1-静态类" class="headerlink" title="3.1 静态类"></a>3.1 静态类</h3><ul>
<li>定义<br>使用 <code>Static</code>关键字 修饰、定义 为 静态的 内部类</li>
</ul>
<blockquote>
<p>即：</p>
<ol>
<li>静态类又名为：静态内部类</li>
<li>该类独立存在，形式上与外部类有内外关系，实际上则没有，本质是为了隐藏自身</li>
</ol>
</blockquote>
<ul>
<li>具体使用 &amp; 相关规则</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 静态类的方法 = 静态 / 非静态</span></span><br><span class="line"><span class="comment"> *    (静态方法可在外层通过静态类调用，而非静态方法必须要创建类的对象后才能调用)</span></span><br><span class="line"><span class="comment"> * 2. 只能引用外部类的静态变量（static，即类变量）</span></span><br><span class="line"><span class="comment"> * 3. 注：</span></span><br><span class="line"><span class="comment"> *       a. 默认不持有外部类引用、使用不依赖于外部类（与外层类无绑定）：即使无创建外层类的对象，它一样存在</span></span><br><span class="line"><span class="comment"> *       b. 若一个内部类不是被定义成静态内部类，那么其成员变量 / 方法不能被定义成静态</span></span><br><span class="line"><span class="comment"> *       c. 静态内部类 &amp; 非静态内部类在创建时有区别，下面会详细说明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 非静态内部类（即 普通）</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类b &amp; 非静态内部类c 创建时的区别：</span></span><br><span class="line">A a=<span class="keyword">new</span> A(); </span><br><span class="line">A.B b=<span class="keyword">new</span> A.B(); </span><br><span class="line">A.C c=a.<span class="keyword">new</span> C();</span><br></pre></td></tr></table></figure>

<ul>
<li>静态内部类 与 内部类的区别</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669eabdd0c475e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="示意图"></p>
<ul>
<li>特别注意<br>a. 加载一个类时，其内部类不会同时被加载。<br>b. 一个类被加载时刻 = 当且仅当其某个静态成员被调用时（静态域、构造器、静态方法等）</li>
</ul>
<h3 id="3-2-静态代码块"><a href="#3-2-静态代码块" class="headerlink" title="3.2 静态代码块"></a>3.2 静态代码块</h3><ul>
<li>定义<br>类加载器加载类的最后1步（类初始化）时，执行类构造器<code>()</code>里需执行的一组语句</li>
</ul>
<blockquote>
<p>额外说明</p>
<ol>
<li>类初始化 = 真正开始执行类中定义<code>Java</code>程序代码 = 执行类构造器<code>()</code></li>
<li><code>()</code> = 由编译器自动收集类中所有类变量的赋值动作&amp;静态语句块中的语句合并产生的</li>
<li>与类构造函数（即实例构造器<code>()</code>）不同，<code>()</code>不需显式地调用父类构造器，虚拟机会保证子类的<code>()</code>执行前，父类的<code>()</code>已执行完毕</li>
</ol>
</blockquote>
<ul>
<li>具体使用 &amp; 相关规则</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 代码块 使用 Static修饰</span></span><br><span class="line"><span class="comment"> * 2. 静态块只会在类加载到内存中时执行1次</span></span><br><span class="line"><span class="comment"> *    a. 若有多个static代码块，JVM将按照它们在类中出现的先后顺序依次执行</span></span><br><span class="line"><span class="comment"> *    b. 静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量可以赋值，但不能访问。如下实例所示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> 	 <span class="comment">// 使用静态修饰的静态代码块</span></span><br><span class="line">     <span class="keyword">static</span>&#123; </span><br><span class="line">         i=<span class="number">0</span>;  <span class="comment">// 給变量赋值，可通过编译 </span></span><br><span class="line">         System.out.print(i); <span class="comment">// 非法， 提示：“非法向前引用” </span></span><br><span class="line">     &#125; </span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-静态方法"><a href="#3-3-静态方法" class="headerlink" title="3.3 静态方法"></a>3.3 静态方法</h3><ul>
<li>定义<br>使用 <code>Static</code>关键字 修饰、定义为静态的成员方法</li>
</ul>
<blockquote>
<p>也称：<strong>类方法</strong></p>
</blockquote>
<ul>
<li>具体使用 &amp; 相关规则</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 可直接通过类名调用，也可通过对象实例调用</span></span><br><span class="line"><span class="comment"> *    （属于类，不属于实例）</span></span><br><span class="line"><span class="comment"> * 2. 任何的实例都可调用（方便共享、公用）</span></span><br><span class="line"><span class="comment"> * 3. 只能访问所属类的静态成员变量 &amp; 方法、不能使用this、super关键字</span></span><br><span class="line"><span class="comment"> *   （this = 调用该函数的对象、但由于静态方法可以直接使用类名调用（即可能还没创建对象），所以不可使用this）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法的申明</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">int</span> param)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-静态变量"><a href="#3-4-静态变量" class="headerlink" title="3.4 静态变量"></a>3.4 静态变量</h3><ul>
<li>定义<br>使用 <code>Static</code>关键字 修饰、定义为静态的成员变量</li>
</ul>
<blockquote>
<p>也称：类变量</p>
</blockquote>
<ul>
<li>具体使用 &amp; 相关规则</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 静态变量在内存中只有1个拷贝：JVM只为静态分配1次内存</span></span><br><span class="line"><span class="comment"> *   a. 全部对象共用这个static关键字修饰的成员变量，方便对象间共享，节省内存</span></span><br><span class="line"><span class="comment"> *   b. 未被Static修饰的成员变量 = 实例变量：每创建1个实例，JVM就会为实例变量分配1次内存，实例变量在内存中可以有多个拷贝（但互相不影响，更加灵活）</span></span><br><span class="line"><span class="comment"> * 2. 可用类名直接访问：在加载类的过程中完成静态变量的内存分配，（也可通过对象实例访问）</span></span><br><span class="line"><span class="comment"> *  （属于类，不属于实例）</span></span><br><span class="line"><span class="comment"> * 3. 非线程安全：因静态变量被类的所有实例共用</span></span><br><span class="line"><span class="comment"> * 4. 局部变量也能被声明为static</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法的申明</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">//静态变量的申明</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态变量与实例变量的区别</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669eabdd0d169d7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="示意图"></p>
<p>至此，关于<code>Java</code>中的静态 <code>Static</code>关键字讲解完毕。</p>
<hr>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><ul>
<li>本文主要讲解了<code>Java</code>中的静态 <code>Static</code>关键字，总结如下：</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669eabdd0dba447?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="示意图"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>数字在排序数组中出现的次数</title>
    <url>/2020/05/27/%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计一个数字在排序数组中出现的次数。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(i)) &#123;</span><br><span class="line">            map.put(i, map.get(i) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(k)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/70610bf967994b22bb1c26f9ae901fa2?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/70610bf967994b22bb1c26f9ae901fa2?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<p>有序数组应该想到二分查找</p>
<p>这道题目思路挺简单的，就是先二叉搜索找一下这个元素的位置，然后再开始遍历搜索一下。<br>本来想自己写一个二叉搜索函数的，但是转念一下java中有排序，还是用一下吧，这样代码就简洁很多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = Arrays.binarySearch(array, k);</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index+<span class="number">1</span>; i &lt; array.length &amp;&amp; array[i]==k;i++)</span><br><span class="line">            cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index-<span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; array[i]==k;i--)</span><br><span class="line">            cnt++;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>什么是零拷贝技术</title>
    <url>/2020/05/28/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>转载文章  <a href="https://www.shangyexinzhi.com/article/1696425.html" target="_blank" rel="noopener">原文地址</a></p>
<p>在很多技术中都使用到了零拷贝技术，比如javaNIO、kafka、Netty、Linux等等。作为一个非常重要的知识点，而且又是高频面试题，有必要从零开始好好地认识一下。</p>
<h3 id="一、什么是零拷贝？"><a href="#一、什么是零拷贝？" class="headerlink" title="一、什么是零拷贝？"></a>一、什么是零拷贝？</h3><p><strong>1、从一个案例说起</strong></p>
<p>为了解释这个概念，我们先要从一个需求说起，说某天某领导给你下发了一个任务，完成一个从文件中读取数据，并传输到网络上的一个小程序。代码很简单：</p>
<blockquote>
<p>首先我们在我们的操作系统中找到这个文件，然后把数据先读到缓冲区，最后把缓冲区的数据发送到网络上。</p>
</blockquote>
<p>代码是很简单，现在我们考虑一下，这个数据从电脑到网络整个传输的过程：</p>
<p><img src="https://img.shangyexinzhi.com/image/article/fc2faa57ba1437b9ef9c17bfe89efd07.png" alt="新知图谱, 一道高频的面试题：什么是零拷贝技术？"></p>
<p>现在我们可以看到1-&gt;2-&gt;3-&gt;4的整个过程一共经历了四次拷贝的方式， <strong>但是真正消耗资源和浪费时间的是第二次和第三次，因为这两次都需要经过我们的CPU拷贝，而且还需要内核态和用户态之间的来回切换。</strong> 想想看，我们的CPU资源是多么宝贵，要处理大量的任务。还要去拷贝大量的数据。如果能把CPU的这两次拷贝给去除掉，岂不快哉！！！既能节省CPU资源，还可以避免内核态和用户态之间的切换。</p>
<p>这里还要先说一下用户态和内核态的区别：</p>
<blockquote>
<ul>
<li>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的</li>
<li>处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。</li>
</ul>
</blockquote>
<p><strong>2、优化方案</strong></p>
<p>要去除第二次和第三次之间的拷贝，Linux开发人员也早就注意到了这个问题，于是在linux 2.1内核中，添加了 “ <strong>数据被copy到socket buffer</strong>”的动作，于是我们的javaNIO，可以直接调用transferTo()的方法，就可以实现这种现象。</p>
<p><img src="https://img.shangyexinzhi.com/image/article/fda4fb8fd5b83ece9fe523bb1586ae42.png" alt="新知图谱, 一道高频的面试题：什么是零拷贝技术？"></p>
<p>现在一看，感觉性能资源都得到了很大的提升，不过现在还不并不是完美的。因为这三次拷贝还用到了CPU的拷贝技术，就是第二次。不过不要担心。Linux开发人员比我们更加深谋远虑。</p>
<p><strong>3、零拷贝优化方案</strong></p>
<p>在Linux2.4 内核做了优化，取而代之的是只包含<strong>关于数据的位置和长度的信息的描述符</strong>被追加到了socket buffer 缓冲区中。 <strong>DMA引擎直接把数据从内核缓冲区传输到协议引擎</strong> （protocol engine），从而消除了最后一次CPU copy。经过上述过程，数据只经过了2次copy就从磁盘传送出去了。这个才是真正的Zero-Copy</p>
<p><img src="https://img.shangyexinzhi.com/image/article/33430970f0d72a5c3b0c1b21a34d6a56.png" alt="新知图谱, 一道高频的面试题：什么是零拷贝技术？"></p>
<blockquote>
<p>注意：这里的零拷贝其实是根据内核状态划分的，在这里<strong>没有经过CPU的拷贝</strong>，数据在用户态的状态下，经历了零次拷贝，所以才叫做零拷贝，但不是说不拷贝。</p>
</blockquote>
<p>OK。 现在我们已经了解了什么是零拷贝技术，下面我们再说一下那些数据结构会用到零拷贝技术。</p>
<h3 id="二、哪些地方会用到零拷贝技术"><a href="#二、哪些地方会用到零拷贝技术" class="headerlink" title="二、哪些地方会用到零拷贝技术"></a>二、哪些地方会用到零拷贝技术</h3><p><strong>1、java的NIO</strong></p>
<p>先说java，是因为要给下面的netty做铺垫，在 <strong>Java NIO 中的通道（Channel）就相当于操作系统的内核空间（kernel space）的缓冲区</strong>，而<strong>缓冲区（Buffer）相当于操作系统的用户空间（user space）中的用户缓冲区（user buffer）</strong>。</p>
<p><strong>堆外内存（DirectBuffer）在使用后需要应用程序手动回收</strong>，而堆内存（HeapBuffer）的数据在 GC 时可能会被自动回收。因此，在使用 HeapBuffer 读写数据时，为了避免缓冲区数据因为 GC 而丢失，<strong>NIO 会先把 HeapBuffer 内部的数据拷贝到一个临时的 DirectBuffer 中的本地内存（native memory）</strong>，这个拷贝涉及到 sun.misc.Unsafe.copyMemory() 的调用，背后的实现原理与 memcpy() 类似。最后，将临时生成的 DirectBuffer 内部的数据的内存地址传给 I/O 调用函数，这样就避免了再去访问 Java 对象处理 I/O 读写。</p>
<p><strong>（1）MappedByteBuffer</strong></p>
<p><code>MappedByteBuffer</code>是 NIO 基于内存映射（mmap）这种零拷贝方式的提供的一种实现，意思是把一个文件从 position 位置开始的 size 大小的区域映射为内存映像文件。这样之添加地址映射，而不进行拷贝。</p>
<p><strong>（2）DirectByteBuffer</strong></p>
<p><code>DirectByteBuffer</code> 的对象引用位于 Java 内存模型的堆里面，JVM 可以对 DirectByteBuffer 的对象进行内存分配和回收管理，是 MappedByteBuffer 的具体实现类。因此同样具有零拷贝技术。</p>
<p><strong>（3）FileChannel</strong></p>
<p><code>FileChannel</code> 定义了 <code>transferFrom()</code> 和 <code>transferTo()</code> 两个抽象方法，它通过在通道和通道之间建立连接实现数据传输的。</p>
<p>我们直接看Linux2.4的版本，socket缓冲区做了调整，DMA带收集功能。</p>
<p>（1）DMA从硬盘（外部设备）拷贝至内核缓冲区</p>
<p>（2）将数据的位置和长度的信息的描述符增加至socket缓冲区（位于内核空间）</p>
<p>（3）DMA将数据从内核缓冲区拷贝至socket协议引擎</p>
<p>这个复制过程是零拷贝过程。</p>
<p><strong>2、Netty</strong></p>
<p>Netty 中的零拷贝和上面提到的操作系统层面上的零拷贝不太一样, 我们所说的 Netty 零拷贝完全是基于（Java 层面）用户态的。</p>
<p>（1）Netty 通过 <code>DefaultFileRegion</code> 类对<code>FileChannel</code>的 <code>tranferTo()</code>方法进行包装，相当于是间接的通过java进行零拷贝。</p>
<p>（2）我们的数据传输一般都是通过TCP/IP协议实现的，在实际应用中，很有可能 <strong>一条完整的消息被分割为多个数据包进行网络传输，而单个的数据包对你而言是没有意义的，只有当这些数据包组成一条完整的消息时你才能做出正确的处理</strong> ，而Netty可以通过零拷贝的方式将这些数据包组合成一条完整的消息供你来使用。</p>
<p>此时零拷贝的作用范围仅在用户空间中。那Netty是如何实现的呢？为此我们就要找到Netty进行数据传输的接口，这个接口一定包含了可以实现零拷贝的功能，这个接口就是<code>ChannelBuffer</code>。</p>
<p><strong>既然有接口肯定就有实现类，一个最主要的实现类是<code>CompositeChannelBuffer</code>，这个类的主要作用是将多个<code>ChannelBuffer</code>组成一个虚拟的<code>ChannelBuffer</code>来进行操作</strong></p>
<p><strong>为什么说是虚拟的呢，因为<code>CompositeChannelBuffer</code>并没有将多个<code>ChannelBuffer</code>真正的组合起来，而只是保存了他们的引用，这样就避免了数据的拷贝，实现了Zero Copy。</strong></p>
<p>（3）<code>ByteBuf</code> 可以通过 wrap 操作把<code>byte[]</code>、<code>ByteBuf</code>、<code>ByteBuffer</code> 包装成一个<code>ByteBuf</code> 对象, 进而避免了拷贝操作</p>
<p>（4）<code>ByteBuf</code>支持 <code>slice</code> 分片操作, 因此可以将 <code>ByteBuf</code> 分解为多个共享同一个存储区域的<code>ByteBuf</code>，避免了内存的拷贝</p>
<p><strong>3、kafka</strong></p>
<p>Kafka 的索引文件使用的是 mmap + write 方式，数据文件使用的是<code>sendfile</code>方式。适用于系统日志消息这种高吞吐量的大块文件的数据持久化和传输。</p>
<p>如果有10个消费者，传统方式下，数据复制次数为4*10=40次，而使用“零拷贝技术”只需要1+10=11次，一次为从磁盘复制到页面缓存，10次表示10个消费者各自读取一次页面缓存。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>和为S的两个数字</title>
    <url>/2020/05/28/%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对应每个测试案例，输出两个数，小的先输出。</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>两层遍历，O(N^2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = array.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] + array[j] &lt; sum) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i] + array[j] == sum) &#123;</span><br><span class="line">                ans.add(array[i]);</span><br><span class="line">                ans.add(array[j]);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更快的做法，O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i != j &amp;&amp; i &lt; array.length &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] + array[j] &lt; sum) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i] + array[j] &gt; sum) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.add(array[i]);</span><br><span class="line">            ans.add(array[j]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>丑数</title>
    <url>/2020/05/31/%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>暴力枚举会超时。根据丑数的定义，丑数一定是比它小的丑数乘2、3、5得到的。</p>
<p>维护一个数组<code>nums[]</code>，按照递增序列存储着已得到的丑数。已有丑数乘2、3、5得到的最小的超过已有最大丑数即为要找的下一个丑数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">    nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> curMax = <span class="number">1</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>, s5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t2, t3, t5;</span><br><span class="line">        <span class="keyword">for</span> (; nums[s2] * <span class="number">2</span> &lt;= curMax; s2++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        t2 = nums[s2] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (; nums[s3] * <span class="number">3</span> &lt;= curMax; s3++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        t3 = nums[s3] * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (; nums[s5] * <span class="number">5</span> &lt;= curMax; s5++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        t5 = nums[s5] * <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        nums[i] = Math.min(Math.min(t2, t3), t5);</span><br><span class="line">        curMax = nums[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[index - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>整数中1出现的次数</title>
    <url>/2020/05/31/%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求出1<del>13的整数中1出现的次数,并算出100</del>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>暴力解法，不推荐</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        String s = i + <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'1'</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= n; m *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = n / m, b = n % m;</span><br><span class="line">        cnt += (a + <span class="number">8</span>) / <span class="number">10</span> * m + (a % <span class="number">10</span> == <span class="number">1</span> ? b + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路是分别计算个位、十位、百位……..上出现 1 的个数。 </p>
<p>  以 n =216为例： </p>
<p>  个位上： 1 ，11，21，31，…..211。个位上共出现（216/10）+ 1个 1 。因为除法取整，210~216间个位上的1取不到，所以我们加8进位。你可能说为什么不加9，n=211怎么办，这里把最后取到的个位数为1的单独考虑，先往下看。  </p>
<p>  十位上：10<del>19，110</del>119，210<del>216.  十位上可看成 求（216/10）=21 个位上的1的个数然后乘10。这里再次把最后取到的十位数为1的单独拿出来，即210</del>216要单独考虑 ，个数为（216%10）+1 .这里加8就避免了判断的过程。 </p>
<p>  后面以此类推。  </p>
<p>  时间复杂度 O(logN)</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>删除链表中重复的结点</title>
    <url>/2020/05/31/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>这道题不复杂，就是要细心，有很多边界条件需要判断，容易出错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p, pHeadAns = <span class="keyword">null</span>, ptail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = pHead; p != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//与p.val相等的节点数</span></span><br><span class="line">        ListNode pp;</span><br><span class="line">        <span class="keyword">for</span> (pp = p; pp != <span class="keyword">null</span> &amp;&amp; pp.val == p.val; pp = pp.next) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;<span class="comment">//待加入新链表</span></span><br><span class="line">            <span class="keyword">if</span> (pHeadAns == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pHeadAns = p;<span class="comment">//待返回的头结点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ptail.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            ptail = p;<span class="comment">//新链表当前的尾结点</span></span><br><span class="line">            ptail.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除(跳过)连续的相等节点</span></span><br><span class="line">        p = pp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pHeadAns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>平衡二叉树</title>
    <url>/2020/05/31/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>还有优化空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = deepth(root.left) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = deepth(root.right) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.abs(left - right) &lt;= <span class="number">1</span> &amp;&amp; IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">deepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = deepth(root.left) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = deepth(root.right) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>左旋转字符串</title>
    <url>/2020/05/31/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>书p286，翻转字符串的困难版，要求空间复杂度O(1)</p>
<p>空间复杂度O(N)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span> || str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = n % str.length();</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    builder.append(str.substring(n));</span><br><span class="line">    builder.append(str, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>翻转单词顺序列</title>
    <url>/2020/05/31/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>测试用例没有说清楚，导致试了半天</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str.trim().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;<span class="comment">//没有说明，只能试，有点坑</span></span><br><span class="line">    &#125;</span><br><span class="line">    String[] strings = str.split(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(str.length());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = strings.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        builder.append(<span class="string">" "</span>);</span><br><span class="line">        builder.append(strings[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString().substring(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>链表中环的入口结点</title>
    <url>/2020/06/02/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>快慢指针法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span> || pHead.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = pHead.next, fast = pHead.next.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = pHead;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/253d2c59ec3e4bc68da16833f79a38e4?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/253d2c59ec3e4bc68da16833f79a38e4?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="方法一：哈希法"><a href="#方法一：哈希法" class="headerlink" title="方法一：哈希法"></a>方法一：哈希法</h2><ol>
<li><p>遍历单链表的每个结点 </p>
</li>
<li><p>如果当前结点地址没有出现在set中，则存入set中 </p>
</li>
<li><p>否则，出现在set中，则当前结点就是环的入口结点 </p>
</li>
<li><p>整个单链表遍历完，若没出现在set中，则不存在环</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;ListNode*&gt; st;</span><br><span class="line">        <span class="keyword">while</span> (pHead) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">find</span>(pHead) == st.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                st.insert(pHead);</span><br><span class="line">                pHead = pHead-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> pHead;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)<br>空间复杂度：O(n)，最坏情况下，单链表的所有结点都在存入set</p>
<h2 id="方法二：双指针法"><a href="#方法二：双指针法" class="headerlink" title="方法二：双指针法"></a>方法二：双指针法</h2><p>若不用辅助结构set，该怎么做呢？这里画了一张图<br><img src="https://uploadfiles.nowcoder.com/images/20200422/284295_1587551967334_9F5E82103ABBE2487DFB7C69C5D05D8F" alt=" "> </p>
<ol>
<li>初始化：快指针fast指向头结点， 慢指针slow指向头结点 </li>
<li>让fast一次走两步， slow一次走一步，第一次相遇在C处，停止 </li>
<li>然后让fast指向头结点，slow原地不动，让后fast，slow每次走一步，当再次相遇，就是入口结点。<br>如上解释：<br><img src="https://uploadfiles.nowcoder.com/images/20200422/284295_1587553517754_3DCB951FEBF0807DCA2148EC373574F2" alt=" "><br>如果慢指针slow第一次走到了B点处，距离C点处还有距离Y，那么fast指针应该停留在D点处，且BD距离为Y（图中所示是假设快指针走了一圈就相遇，为了便于分析），<br>也就是DB+BC=2Y，（因为fast一次走2步，慢指针一次走1步，并且相遇在C处）<br>在C点处，此时慢指针slow走的点为ABC，距离为X+Y，而快指针fast走的点为ABCDBC，距离为2X+2Y，<br>又因为：AB=X，BC=Y，快指针走了2次BC，所以CDB距离为X，而AB距离也为X。 </li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *fast = pHead;</span><br><span class="line">        ListNode *slow = pHead;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fast || !fast-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>和为S的连续正数序列</title>
    <url>/2020/05/31/%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>等差数列公式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span> * sum, <span class="number">0.5</span>); i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (<span class="number">2</span> * sum / i - i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (t % <span class="number">2</span> != <span class="number">0</span> || <span class="number">2</span> * sum % i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; tl = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        t = t &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            tl.add(t + j);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(tl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>不用加减乘除做加法</title>
    <url>/2020/06/02/%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (num2 != <span class="number">0</span>) &#123;<span class="comment">//当进位为零时停止</span></span><br><span class="line">        <span class="keyword">int</span> c = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;<span class="comment">//进位需要左移一次</span></span><br><span class="line">        num1 = num1 ^ num2;</span><br><span class="line">        num2 = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/59ac416b4b944300b617d4f7f111b215?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/59ac416b4b944300b617d4f7f111b215?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="方法：位运算"><a href="#方法：位运算" class="headerlink" title="方法：位运算"></a>方法：位运算</h2><p>知识补充：</p>
<ol>
<li>按位与&amp;，按位或|， 按位异或^<br><img src="https://uploadfiles.nowcoder.com/images/20200505/284295_1588686434571_209BD4459BD002D912E85E54433CA4C4" alt="图片说明"> </li>
<li>补码<br>计算机中存整数n是用补码存的。</li>
</ol>
<ul>
<li>如果n为正数，则原码=反码=补码 </li>
<li>如果n为负数，则补码=反码+1 </li>
</ul>
<p>本题是考察对位运算的运用，使用位运算来实现两数的加法。<br>设两数字的二进制形式 a，b ，其求和 s = a + b ，a(i) 代表 a 的二进制第 i 位，则分为以下四种情况：<br><img src="https://uploadfiles.nowcoder.com/images/20200505/284295_1588687181635_F1F0A0DAE581028E686FC568F55694CE" alt="图片说明"> </p>
<p>观察发现，无进位和运算就是按位异或结果，进位就是与运算结果但是需要左移一位，因为进位影响下一位的运算。<br>所以s = a + b,其实就是无进位和+进位的结果。<br>算法步骤：</p>
<ol>
<li>计算a和b的无进位和，和进位 </li>
<li>如果进位不为0，则说明a+b的结果等于无进位和+进位，此时，把无进位和作为a，进位作为b，继续计算 </li>
<li>如果进位等于0， 说明此时a+b的结果就等于无进位和，返回无进位和即可。<br>如图：<br><img src="https://uploadfiles.nowcoder.com/images/20200505/284295_1588688021116_933571186EC12CADAFC6064813BE06D4" alt="图片说明">  </li>
</ol>
<p>Q：你可能有疑问，如果是一个数为负数或者两个数都为负数怎么办？<br>A：上述补码的介绍，补码就是解决减法的问题，计算机把减法看做加法来运算。<br>所以代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num2 != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 负数左移会在低位补1，所以转化为无符号整数</span></span><br><span class="line">            <span class="keyword">int</span> c = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(num1 &amp; num2)) &lt;&lt; <span class="number">1</span>; </span><br><span class="line">            num1 ^= num2;</span><br><span class="line">            num2 = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)<br>空间复杂度：O(1)</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>数据流中的中位数</title>
    <url>/2020/06/02/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; list.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.get(i) &gt;= num) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(i, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list.size() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (list.get(list.size() / <span class="number">2</span> - <span class="number">1</span>) + list.get(list.size() / <span class="number">2</span>)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) list.get(list.size() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/9be0172896bd43948f8a32fb954e1be1?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/9be0172896bd43948f8a32fb954e1be1?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="方法一：暴力方法"><a href="#方法一：暴力方法" class="headerlink" title="方法一：暴力方法"></a>方法一：暴力方法</h2><p>对于一组数据，我们可以用<code>vector arr</code>来存取。如果对<code>vector</code>排好序，则很容易求出中位数。如果<code>vector</code>的大小为<code>sz</code>。</p>
<ul>
<li>如果<code>sz</code>为奇数，假如为<code>3，即[0 1 2]，</code>则中位数就是中间的那个数<code>arr[1]</code>。 </li>
<li>如果<code>sz</code>为偶数，假如为<code>4，即[0 1 2 3],</code> 则中位数就是中间两个数的加权平均数。即 <code>(arr[1] + arr[2]) / 2</code> </li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> SCD static_cast<span class="meta-string">&lt;double&gt;</span></span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v.push_back(num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> sz = v.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (sz &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> SCD(v[sz &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> SCD(v[sz &gt;&gt; <span class="number">1</span>] + v[(sz - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>Insert()</code>为<code>O(1)</code>,<code>GetMedian()</code>为<code>O(nlogn)</code><br>空间复杂度：<code>O(n)</code></p>
<h2 id="方法二：插入排序"><a href="#方法二：插入排序" class="headerlink" title="方法二：插入排序"></a>方法二：插入排序</h2><p>对于方法一，可以发现有个优化的地方。<br>方法一中<code>GetMEdian()</code>操作，是每次都对整个<code>vector</code>调用排序操作。<br>但是其实每次都是在一个有序数组中插入一个数据。因此可以用插入排序。<br>所以：</p>
<ul>
<li><code>Insert()</code>操作可改为插入排序 </li>
<li><code>GetMedian()</code>操作可直接从有序数组中获取中位数 </li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> SCD static_cast<span class="meta-string">&lt;double&gt;</span></span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.empty()) &#123;</span><br><span class="line">            v.push_back(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), num);</span><br><span class="line">            v.insert(it, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> sz = v.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (sz &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> SCD(v[sz &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> SCD(v[sz &gt;&gt; <span class="number">1</span>] + v[(sz - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>Insert()</code>为<code>O(n)</code>,即二分查找的<code>O(logn)</code>和挪动数据的<code>O(n)</code>, <code>GetMedian()</code>为<code>O(1)</code><br>空间复杂度：<code>O(n)</code></p>
<h2 id="方法三：堆"><a href="#方法三：堆" class="headerlink" title="方法三：堆"></a>方法三：堆</h2><p>中位数是指：有序数组中中间的那个数。则根据中位数可以把数组分为如下三段:<br><code>[0 ... median - 1], [median], [median ... arr.size() - 1]</code>，即<code>[中位数的左边，中位数，中位数的右边]</code></p>
<p>那么，如果我有个数据结构保留[0…median-1]的数据，并且可以<code>O(1)</code>时间取出最大值，即<code>arr[0...median-1]</code>中的最大值<br>相对应的，如果我有个数据结构可以保留<code>[median + 1 ... arr.size() - 1]</code> 的数据， 并且可以<code>O(1)</code>时间取出最小值，即<br><code>arr[median + 1 ... arr.size() - 1]</code> 中的最小值。<br>然后，我们把[median]即中位数，随便放到哪个都可以。</p>
<p>假设<code>[0 ... median - 1]</code>的长度为<code>l_len</code>, <code>[median + 1 ... arr.sise() - 1]</code>的长度为 <code>r_len</code>.<br>1.如果<code>l_len == r_len + 1</code>, 说明，中位数是左边数据结构的最大值<br>2.如果<code>l_len + 1 == r_len</code>, 说明，中位数是右边数据结构的最小值<br>3.如果<code>l_len == r_len</code>, 说明，中位数是左边数据结构的最大值与右边数据结构的最小值的平均值。</p>
<p>说了这么多，一个数据结构可以<code>O(1)</code>返回最小值的，其实就是小根堆，<code>O(1)</code>返回最大值的，其实就是大根堆。并且每次插入到堆中的时间复杂度为<code>O(logn)</code></p>
<p>所以，<code>GetMedian()</code>操作算法过程为：</p>
<ul>
<li>初始化一个大根堆，存中位数左边的数据，一个小根堆，存中位数右边的数据 </li>
<li>动态维护两个数据结构的大小，即最多只相差一个 </li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> SCD static_cast<span class="meta-string">&lt;double&gt;</span></span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; min_q; <span class="comment">// 大顶推</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; max_q; <span class="comment">// 小顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        min_q.push(num); <span class="comment">// 试图加入到大顶推</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 平衡一个两个堆</span></span><br><span class="line">        max_q.push(min_q.top()); </span><br><span class="line">        min_q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min_q.<span class="built_in">size</span>() &lt; max_q.si***_q.push(max_q.top());</span><br><span class="line">            max_q.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> GetMedian()</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">return</span> min_q.<span class="built_in">size</span>() &gt; max_q.<span class="built_in">size</span>() ? SCD(min_q.top()) : SCD(min_q.top() + max_q.top()) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>Insert()</code>为<code>O(logn)</code>, <code>GetMedian()</code>为<code>O(1)</code><br>空间复杂度：<code>O(n)</code></p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>滑动窗口的最大值</title>
    <url>/2020/06/02/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span> || size &gt; num.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        list.add(num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    arrayList.add(list.getLast());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num.length - size; i++) &#123;<span class="comment">//窗口前移</span></span><br><span class="line">        list.remove(<span class="keyword">new</span> Integer(num[i - <span class="number">1</span>]));</span><br><span class="line">        list.add(num[i + size - <span class="number">1</span>]);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        arrayList.add(list.getLast());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/1624bc35a45c42c0bc17d17fa0cba788?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/1624bc35a45c42c0bc17d17fa0cba788?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="方法一：暴力方法"><a href="#方法一：暴力方法" class="headerlink" title="方法一：暴力方法"></a>方法一：暴力方法</h2><p>根据题目描述，我们很容易想到暴力方法。并且也很轻松的就可以写出来。如果数组的大小是n，窗口的大小是size，那么窗口的数量就是 n - size + 1.<br>算法步骤如下：</p>
<ul>
<li>枚举每个窗口的左边界 i </li>
<li>根据窗口的左边界i可以对应计算出右边界j </li>
<li>遍历窗口，计算出最大值 </li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (num.<span class="built_in">size</span>() == <span class="number">0</span> || <span class="built_in">size</span> &lt; <span class="number">1</span> || num.<span class="built_in">size</span>() &lt; <span class="built_in">size</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="built_in">size</span> - <span class="number">1</span> &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> max_val = num[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; ++k) &#123;</span><br><span class="line">                max_val = <span class="built_in">max</span>(max_val, num[k]);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(max_val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*k), 其中n为数组大小，k为窗口大小<br>空间复杂度：O(1)，存结果必须要开的数组不算入额外空间</p>
<h2 id="方法二：单调队列"><a href="#方法二：单调队列" class="headerlink" title="方法二：单调队列"></a>方法二：单调队列</h2><p>方法一种存在很多大量重复计算，比如说，对于数组，假设我们当前遍历到下标i，对于下标i+1的元素（假设i和i+1都在同一个窗口），如果比arr[i]大，说明了什么？<br>如果arr[i+1] 已经大于了 arr[i], 那么还要arr[i]有什么用.就有点“既生瑜何生亮”的感觉。<br>如果arr[i+1] &lt; arr[i]呢？显然arr[i]还是需要保留的。为什么呢？<br>因为又可以arr[i] 对于下一个arr[i+1]所在的窗口来说，arr[i]已经失效了。</p>
<p>假设这里有那么一个容器可以保留上述操作。</p>
<ol>
<li>遍历数组的每一个元素， </li>
<li>如果容器为空，则直接将当前元素加入到容器中。 </li>
<li>如果容器不为空，则让当前元素和容器的最后一个元素比较，如果大于，则将容器的最后一个元素删除，然后继续讲当前元素和容器的最后一个元素比较 </li>
<li>如果当前元素小于容器的最后一个元素，则直接将当前元素加入到容器的末尾 </li>
<li>如果容器头部的元素已经不属于当前窗口的边界，则应该将头部元素删除 </li>
</ol>
<p>总结一下，首先容器中放的元素应该是单调递减的。然后还有删除容器头部元素和最后一个元素的操作。因此，这样的数据结构就是双端队列。c++中就是<code>deque</code></p>
<p>如何判断队列中头部的元素是否过期呢？<br>这里我们可以存数组的下标，根据下标的比较来判断。比如，当前遍历到下标为5的元素，窗口的大小为3， 显然显然下标为2的已经过期了。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (num.<span class="built_in">size</span>() == <span class="number">0</span> || <span class="built_in">size</span> &lt; <span class="number">1</span> || num.<span class="built_in">size</span>() &lt; <span class="built_in">size</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">           <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">               <span class="keyword">while</span> (!dq.empty() &amp;&amp; num[dq.back()] &lt; num[i]) &#123;</span><br><span class="line">                   dq.pop_back();</span><br><span class="line">               &#125;</span><br><span class="line">               dq.push_back(i);</span><br><span class="line">               <span class="comment">// 判断队列的头部的下标是否过期</span></span><br><span class="line">               <span class="keyword">if</span> (dq.front() + <span class="built_in">size</span> &lt;= i) &#123;</span><br><span class="line">                   dq.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否形成了窗口</span></span><br><span class="line">               <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= <span class="built_in">size</span>) &#123;</span><br><span class="line">                   ret.push_back(num[dq.front()]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ret; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n), 其中n为数组大小<br>空间复杂度：O(k)，k为窗口的大小</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>矩阵中的路径</title>
    <url>/2020/06/02/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a b c e</span><br><span class="line">s f c s</span><br><span class="line">a d e e</span><br></pre></td></tr></table></figure>

<p>矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] mat, str;</span><br><span class="line"><span class="keyword">int</span> X, Y;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= X || y &gt;= Y) &#123;</span><br><span class="line">            c = <span class="string">' '</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.c = mat[Y * x + y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == ((P) obj).x &amp;&amp; y == ((P) obj).y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = Integer.valueOf(x + <span class="string">""</span> + y);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    mat = matrix;</span><br><span class="line">    <span class="keyword">this</span>.str = str;</span><br><span class="line">    X = rows;</span><br><span class="line">    Y = cols;</span><br><span class="line">    List&lt;P&gt; list = findFirst(str[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (P p : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (findPath(p)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;P&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">boolean</span> ok = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findPath</span><span class="params">(P p)</span> </span>&#123;</span><br><span class="line">    ok = <span class="keyword">false</span>;</span><br><span class="line">    set.clear();</span><br><span class="line">    dfs(p, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(P p, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ok || p.c == <span class="string">' '</span> || set.contains(p)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.c == str[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == str.length - <span class="number">1</span>) &#123;<span class="comment">/** 路径找到了 */</span></span><br><span class="line">            ok = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(p);</span><br><span class="line">        dfs(<span class="keyword">new</span> P(p.x + <span class="number">1</span>, p.y), i + <span class="number">1</span>);</span><br><span class="line">        dfs(<span class="keyword">new</span> P(p.x - <span class="number">1</span>, p.y), i + <span class="number">1</span>);</span><br><span class="line">        dfs(<span class="keyword">new</span> P(p.x, p.y + <span class="number">1</span>), i + <span class="number">1</span>);</span><br><span class="line">        dfs(<span class="keyword">new</span> P(p.x, p.y - <span class="number">1</span>), i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;P&gt; <span class="title">findFirst</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    List&lt;P&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Y; j++) &#123;</span><br><span class="line">            P p = <span class="keyword">new</span> P(i, j);</span><br><span class="line">            <span class="keyword">if</span> (p.c == c) &#123;</span><br><span class="line">                list.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/c61c6999eecb4b8f88a98f66b273a3cc?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/c61c6999eecb4b8f88a98f66b273a3cc?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="方法：DFS"><a href="#方法：DFS" class="headerlink" title="方法：DFS"></a>方法：DFS</h2><p>这道题大家都知道是DFS的题，关键是怎么可以快速并且正确的写出，是本题解讨论的重点。<br>首先解释一下递归函数。<br>递归函数：就是当前处理的问题是什么，并且下一次在规模减小的情况下处理相同的问题。<br>比如此题：当前处理的问题是：判断字符串str[0 … len]是否在mat中匹配，显然下一次递归处理的问题是:如果str[0]已经匹配，则判断字符串str[1 … len]是否在mat中匹配。</p>
<p>这里先给出一个我认为比较清晰的DFS模板：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dfs()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步，检查下标是否满足条件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：检查是否被访问过，或者是否满足当前匹配条件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：检查是否满足返回结果条件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步：都没有返回，说明应该进行下一步递归</span></span><br><span class="line">    <span class="comment">// 标记</span></span><br><span class="line">    dfs(下一次)</span><br><span class="line">    <span class="comment">// 回溯</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    <span class="keyword">for</span> (对所有可能情况) &#123;</span><br><span class="line">        dfs()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面每步的顺序都不能颠倒。</p>
<p>所以，对于这道题来说，首先dfs()的参数是什么，返回值是什么。<br>可以像这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i, j 表示mat中的位置， pos表示当前正在匹配的字符串str的下标</span></span><br><span class="line"><span class="comment">// 成功返回整个字符串str, 则返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> pos, <span class="keyword">char</span> *str)</span></span>;</span><br></pre></td></tr></table></figure>

<p>主函数该怎么写？可以像如下这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 几个全局变量，便于程序的简洁，只是在刷题中建议</span></span><br><span class="line"><span class="keyword">char</span> *mat = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> str_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">5</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mat = matrix;</span><br><span class="line">        h = rows, w = cols;</span><br><span class="line">         str_len = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>, str)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后套用模板，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *mat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> str_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">5</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> pos, <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为dfs调用前，没有进行边界检查，</span></span><br><span class="line">        <span class="comment">// 所以需要第一步进行边界检查，</span></span><br><span class="line">        <span class="comment">// 因为后面需要访问mat中元素，不能越界访问</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= h || j &lt; <span class="number">0</span> || j &gt;= w) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> ch = mat[i * w + j];</span><br><span class="line">        <span class="comment">// 判断是否访问过</span></span><br><span class="line">        <span class="comment">// 如果没有访问过，判断是否和字符串str[pos]匹配</span></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'#'</span> || ch != str[pos]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果匹配，判断是否匹配到最后一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (pos + <span class="number">1</span>  == str_len) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明当前字符成功匹配，标记一下，下次不能再次进入</span></span><br><span class="line">        mat[i * w + j] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(i + dir[k], j + dir[k + <span class="number">1</span>], pos + <span class="number">1</span>, str)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 如果4个方向都无法匹配 str[pos + 1]</span></span><br><span class="line">        <span class="comment">// 则回溯， 将'#' 还原成 ch          </span></span><br><span class="line">        mat[i * w + j] = ch;</span><br><span class="line">        <span class="comment">// 说明此次匹配是不成功的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mat = matrix;</span><br><span class="line">        h = rows, w = cols;</span><br><span class="line">         str_len = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>, str)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(3^k)， 每个位置除当前自己的方向，还有3个方向可以展开。k为str的长度<br>空间复杂度：O(k), 最大递归栈的深度为k</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>二叉搜索树的第k个结点</title>
    <url>/2020/06/03/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）  中，按结点数值大小顺序第三小结点的值为4。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>中序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> K,i=<span class="number">0</span>;</span><br><span class="line">TreeNode node = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    K = k;</span><br><span class="line">    dfs(pRoot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(pRoot.left);</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; K) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == K) &#123;</span><br><span class="line">        node = pRoot;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(pRoot.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>序列化二叉树</title>
    <url>/2020/06/03/%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p>
<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<p>例如，我们可以把一个只有根节点为1的二叉树序列化为”1,”，然后通过自己的函数来解析回这个二叉树</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>树中节点值不重复的情况下可使用如下方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存前序和中序序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    StringBuilder pre = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    getPreOrder(root, pre);</span><br><span class="line">    StringBuilder in = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    getInOrder(root, in);</span><br><span class="line">    <span class="keyword">return</span> pre + <span class="string">";"</span> + in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getInOrder</span><span class="params">(TreeNode root, StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getInOrder(root.left, builder);</span><br><span class="line">    builder.append(root.val + <span class="string">","</span>);</span><br><span class="line">    getInOrder(root.right, builder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPreOrder</span><span class="params">(TreeNode root, StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(root.val + <span class="string">","</span>);</span><br><span class="line">    getPreOrder(root.left, builder);</span><br><span class="line">    getPreOrder(root.right, builder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归建树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    String[] strs = str.split(<span class="string">";"</span>);</span><br><span class="line">    <span class="keyword">if</span> (strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] pre = strs[<span class="number">0</span>].split(<span class="string">","</span>);</span><br><span class="line">    String[] in = strs[<span class="number">1</span>].split(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">    TreeNode root = buildTree(pre, in);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(String[] pre, String[] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span> || pre.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(pre[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">int</span> leftNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[i].equals(pre[<span class="number">0</span>])) &#123;</span><br><span class="line">            leftNum = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root.left = buildTree(Arrays.copyOfRange(pre, <span class="number">1</span>, leftNum + <span class="number">1</span>), Arrays.copyOfRange(in, <span class="number">0</span>, leftNum));</span><br><span class="line">    root.right = buildTree(Arrays.copyOfRange(pre, leftNum + <span class="number">1</span>, pre.length), Arrays.copyOfRange(in, leftNum + <span class="number">1</span>, in.length));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/cf7e25aa97c04cc1a68c8f040e71fb84?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/cf7e25aa97c04cc1a68c8f040e71fb84?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="方法一：先序遍历实现"><a href="#方法一：先序遍历实现" class="headerlink" title="方法一：先序遍历实现"></a>方法一：先序遍历实现</h2><p>预备知识：先序遍历的递归实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process root</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pre_order(root-&gt;left);</span><br><span class="line">    pre_order(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于本题来说，可以套用上述模板。<br>假设序列化的结果为字符串 str, 初始str = “”.根据要求，遇到nullptr节点，str += “#”<br>遇到非空节点，str += “val” + “!”; 假设val为3， 就是 str += “3!”</p>
<p>所以，最终的代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Serialize</span><span class="params">(TreeNode *root)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> res = to_string(root-&gt;val);</span><br><span class="line">    res.push_back(<span class="string">','</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* left = Serialize(root-&gt;left);</span><br><span class="line">    <span class="keyword">char</span>* right = Serialize(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* ret = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(left)+<span class="built_in">strlen</span>(right)+res.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="comment">// 如果是string类型，直接用operator += ,这里char* 需要用函数</span></span><br><span class="line">    <span class="built_in">strcpy</span>(ret,res.c_str());</span><br><span class="line">    <span class="built_in">strcat</span>(ret,left);</span><br><span class="line">    <span class="built_in">strcat</span>(ret,right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化的结果，就是根据先序遍历，再重建二叉树即可。<br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数使用引用&amp;， 以实现全局变量的目的</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">deseri</span><span class="params">(<span class="keyword">char</span> *&amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*s == <span class="string">'#'</span>) &#123;</span><br><span class="line">        ++s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造根节点值</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">','</span>) &#123;</span><br><span class="line">        num = num * <span class="number">10</span> + (*s - <span class="string">'0'</span>);</span><br><span class="line">        ++s;</span><br><span class="line">    &#125;</span><br><span class="line">    ++s; </span><br><span class="line">    <span class="comment">// 递归构造树</span></span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">    root-&gt;left = deseri(s);</span><br><span class="line">    root-&gt;right = deseri(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> deseri(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序遍历，后序遍历大致都差不多。</p>
<h2 id="方法二：层次遍历实现"><a href="#方法二：层次遍历实现" class="headerlink" title="方法二：层次遍历实现"></a>方法二：层次遍历实现</h2><p>层次遍历采用队列实现。跟先序遍历的思想差不多，无非都是把树的所有数据遍历一遍，然后记录下来。<br>层次遍历模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; qt;</span><br><span class="line">    qt.push(root);</span><br><span class="line">     <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (!qt.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// pop operator</span></span><br><span class="line">        TreeNode *node = qt.front();</span><br><span class="line">        qt.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process node</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push_back(<span class="string">'#'</span>);</span><br><span class="line">            s.push_back(<span class="string">','</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s += to_string(node-&gt;val);</span><br><span class="line">        s.push_back(<span class="string">','</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// push operator</span></span><br><span class="line">        qt.push(node-&gt;left);</span><br><span class="line">        qt.push(node-&gt;right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化的操作直接根据模板套即可。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Serialize</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; qt;</span><br><span class="line">    qt.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!qt.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// pop operator</span></span><br><span class="line">        TreeNode *node = qt.front();</span><br><span class="line">        qt.pop();</span><br><span class="line">        <span class="comment">// process null node</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push_back(<span class="string">'N'</span>);</span><br><span class="line">            s.push_back(<span class="string">','</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// process not null node</span></span><br><span class="line">        s += to_string(node-&gt;val);</span><br><span class="line">        s.push_back(<span class="string">','</span>);</span><br><span class="line">        <span class="comment">// push operator</span></span><br><span class="line">        qt.push(node-&gt;left);</span><br><span class="line">        qt.push(node-&gt;right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *ret = <span class="keyword">new</span> <span class="keyword">char</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(ret, s.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化就是根据层次遍历在走一遍即可。<br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可用string成员函数</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'#'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造头结点</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    TreeNode *ret = <span class="keyword">new</span> TreeNode(atoi(s.c_str()));</span><br><span class="line">    s = s.substr(s.find_first_of(<span class="string">','</span>) + <span class="number">1</span>);</span><br><span class="line">    nodes.push(ret);</span><br><span class="line">    <span class="comment">// 根据序列化字符串再层次遍历一遍，来构造树</span></span><br><span class="line">    <span class="keyword">while</span> (!nodes.empty() &amp;&amp; !s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *node = nodes.front();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            s = s.substr(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;left = <span class="keyword">new</span> TreeNode(atoi(s.c_str()));</span><br><span class="line">            nodes.push(node-&gt;left);</span><br><span class="line">            s = s.substr(s.find_first_of(<span class="string">','</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            s = s.substr(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;right = <span class="keyword">new</span> TreeNode(atoi(s.c_str()));</span><br><span class="line">            nodes.push(node-&gt;right);</span><br><span class="line">            s = s.substr(s.find_first_of(<span class="string">','</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此题主要考察对树的遍历和构造树。</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>把二叉树打印成多行</title>
    <url>/2020/06/03/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>层序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curLevelNum = <span class="number">1</span>, nextLevelNum = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(pRoot);</span><br><span class="line">    ArrayList&lt;Integer&gt; tmpList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode t = queue.poll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(t.left);</span><br><span class="line">            nextLevelNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(t.right);</span><br><span class="line">            nextLevelNum++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        num++;</span><br><span class="line">        tmpList.add(t.val);</span><br><span class="line">        <span class="keyword">if</span> (num == curLevelNum) &#123;</span><br><span class="line">            curLevelNum = nextLevelNum;</span><br><span class="line">            nextLevelNum = <span class="number">0</span>;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            lists.add(tmpList);</span><br><span class="line">            tmpList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/445c44d982d04483b04a54f298796288?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/445c44d982d04483b04a54f298796288?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="方法：队列"><a href="#方法：队列" class="headerlink" title="方法：队列"></a>方法：队列</h2><p>层次遍历打印二叉树，用队列实现。<br>有一句话，我觉得说的特别好：做题=解法+模板，意思就是说，对于一道题目，首先明白正确的解法已经解决该问题70%，剩下的就直接套模板。</p>
<p>所以<code>BFS</code>的模板为：</p>
<ol>
<li><p>如果不需要确定当前遍历到了哪一层，模板如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> vis[] = &#123;<span class="number">0</span>&#125;; <span class="comment">// or set</span></span><br><span class="line"> <span class="function"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pq</span><span class="params">(start_val)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">     <span class="keyword">int</span> cur = pq.front(); pq.pop();</span><br><span class="line">     <span class="keyword">for</span> (遍历cur所有的相邻节点nex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (nex节点有效 &amp;&amp; vis[nex]==<span class="number">0</span>)&#123;</span><br><span class="line">             vis[nex] = <span class="number">1</span>;</span><br><span class="line">             pq.push(nex)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="comment">// end for</span></span><br><span class="line"> &#125; <span class="comment">// end while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>上述是伪代码，不仅可用于二叉树，可针对所有用BFS解题。</p>
<ol>
<li><p>如果需要确定遍历到哪一层，模板如下；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"> vis[] = &#123;<span class="number">0</span>&#125;; <span class="comment">// or set</span></span><br><span class="line"> <span class="function"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pq</span><span class="params">(original_val)</span></span>;</span><br><span class="line"> <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">     <span class="keyword">int</span> sz = pq.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (sz--) &#123;</span><br><span class="line">             <span class="keyword">int</span> cur = pq.front(); pq.pop();</span><br><span class="line">         <span class="keyword">for</span> (遍历cur所有的相邻节点nex) &#123;</span><br><span class="line">             <span class="keyword">if</span> (nex节点有效 &amp;&amp; vis[nex] == <span class="number">0</span>) &#123;</span><br><span class="line">                 vis[nex] = <span class="number">1</span>;</span><br><span class="line">                 pq.push(nex)</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="comment">// end for</span></span><br><span class="line">     &#125; <span class="comment">// end inner while</span></span><br><span class="line">     level++;</span><br><span class="line"></span><br><span class="line"> &#125; <span class="comment">// end outer while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>所以此题可直接套用模板，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">Print</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(pRoot);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">            <span class="keyword">while</span> (sz--) &#123;</span><br><span class="line">                TreeNode *node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                ans.push_back(node-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(ans):</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)<br>空间复杂度：O(1), <code>vecotr&lt;vecotr&lt;int&gt;&gt;</code> 是必须要开的，不算在额外空间里</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>表示数值的字符串</title>
    <url>/2020/06/03/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>结合正则表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(str);</span><br><span class="line">    <span class="keyword">if</span> (s.startsWith(<span class="string">"+"</span>) || s.startsWith(<span class="string">"-"</span>)) &#123;</span><br><span class="line">        s = s.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.matches(<span class="string">"[0-9]+.*"</span>)) &#123;</span><br><span class="line">        s = s.replaceFirst(<span class="string">"[0-9]+"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">""</span>.equals(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.startsWith(<span class="string">"."</span>)) &#123;</span><br><span class="line">        s = s.substring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!s.matches(<span class="string">"[0-9]+.*"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.replaceFirst(<span class="string">"[0-9]+"</span>, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">""</span>.equals(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.startsWith(<span class="string">"e"</span>) || s.startsWith(<span class="string">"E"</span>)) &#123;</span><br><span class="line">        s = s.substring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (s.startsWith(<span class="string">"+"</span>) || s.startsWith(<span class="string">"-"</span>)) &#123;</span><br><span class="line">            s = s.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!s.matches(<span class="string">"[0-9]+"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我不服,也写了个正则表达式,好像也能通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    String pattern = <span class="string">"[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(str).matches(pattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/6f8c901d091949a5837e24bb82a731f2?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/6f8c901d091949a5837e24bb82a731f2?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<p>来玩正则表达式吧！~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        String pattern = <span class="string">"^[-+]?\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?$"</span>;</span><br><span class="line">        String s = <span class="keyword">new</span> String(str);</span><br><span class="line">        <span class="keyword">return</span> Pattern.matches(pattern,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ^ 和 美元符号框定正则表达式，它指引这个正则表达式对文本中的所有字符都进行匹配。如果省略这些标识，那么只要一个字符串中包含一个数字这个正则表达式就会进行匹配。如果仅包含 ^ ，它将匹配以一个数字开头的字符串。如果仅包含$ ，则匹配以一个数字结尾的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[-+]?</span><br></pre></td></tr></table></figure>

<p>正负号后面的 ? 后缀表示这个负号是可选的,表示有0到1个负号或者正号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\\d*</span><br></pre></td></tr></table></figure>

<p>\d的含义和[0-9]一样。它匹配一个数字。后缀 * 指引它可匹配零个或者多个数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(?:\\.\\d*)?</span><br></pre></td></tr></table></figure>

<p>(?: …)?表示一个可选的非捕获型分组。* 指引这个分组会匹配后面跟随的0个或者多个数字的小数点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(?:[eE][+\\-]?\d+)?</span><br></pre></td></tr></table></figure>

<p>这是另外一个可选的非捕获型分组。它会匹配一个e(或E)、一个可选的正负号以及一个或多个数字。</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>剪绳子</title>
    <url>/2020/06/02/%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个数n，意义见题面。（2 &lt;&#x3D; n &lt;&#x3D; 60）</span><br></pre></td></tr></table></figure>

<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出答案。</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>得到最大值的m值是距离sqrt(target)最近的两个整数.讨论这两种情况即可.</p>
<p>数学证明待补充</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (<span class="keyword">int</span>) Math.floor(Math.sqrt(target));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k1 = target / m, mult1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        mult1 *= k1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> remain = target - k1 * i;</span><br><span class="line">    mult1 *= remain;</span><br><span class="line"></span><br><span class="line">    m++;</span><br><span class="line">    <span class="keyword">int</span> k2 = (target / m) + <span class="number">1</span>, mult2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i * k2 &lt;= target; i++) &#123;</span><br><span class="line">        mult2 *= k2;</span><br><span class="line">    &#125;</span><br><span class="line">    remain = target - k2 * i;</span><br><span class="line">    <span class="keyword">if</span> (remain != <span class="number">0</span>) &#123;</span><br><span class="line">        mult2 *= remain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mult1 &gt; mult2 ? mult1 : mult2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/57d85990ba5b440ab888fc72b0751bf8?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/57d85990ba5b440ab888fc72b0751bf8?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<p>题目描述：给定一个长度为n的绳子，将其分成m段（m&gt;1）,求m段的乘积最大。<br>转化成数学上的描述：给定一个数n，求n = a1 + a2 … +am, （m&gt;1）在此条件下, s = a1 * a2 * … * am， s最大</p>
<p>进入此题的讲解之前，先提出一个问题：什么样的题适合用动态规划？<br>针对本题来说，假如我们用暴力枚举的思路去思考，会出现以下一些问题：</p>
<ol>
<li>这段绳子到底应该分几段，才能得到最优的结果？ </li>
<li>假设我已经知道了要分m段（假设m已知），那么每段的长度又应该是多少呢？ </li>
</ol>
<p>可能你的问题不止上面2个。但是，仅仅是上面两个问题，已经让我感觉要分好多种情况，然后选出一个最优的。</p>
<p>当然，普通的for循环枚举所有情况是有难度的，但是幸运的是，我们可以用递归回溯。<br>所以，方法一如下：</p>
<h3 id="方法一：暴力递归"><a href="#方法一：暴力递归" class="headerlink" title="方法一：暴力递归"></a>方法一：暴力递归</h3><p>暴力递归就要想到递归三部曲：</p>
<ol>
<li>递归函数的设计和功能：back_track(n); 含义是：求长度为n的数，最后分段后的最大乘积，这里我们不需要关心分成多少段 </li>
<li>递归函数的终止条件: 如果n &lt;= 4, 显然back_track(n) = n，初始条件也就是我们不用计算就能得到的。 </li>
<li>下一步递归：对于长度n，我们需要减少递归参数n，如果第一段为1， 显然下一步递归为back_track(n-1),如果第一段为2， 则下一步递归为<br>back_track(n-2)…因为要至少分2段，所以，最后一次可能的情况为最后一段为n-1, 下一步递归为back_track(1)，因此，每一步可能的结果为<br>1 * back_track(n-1), 2 * back_track(n-2), …, (n-1) * back_track(1),在n-1种情况中取一个最大值即可。 这里我们不用关系back_track(n-1)等的值为多少，因为最终会递归到我们的终止条件，因此绝对是可以求出来。 </li>
</ol>
<p>于是，有了上面三部曲，递归代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">back_track</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// n &lt;= 4, 表明不分，长度是最大的</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, i * back_track(n - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// number = 2 和 3 时，分 2 段和分 1 段的结果是不一样的，所以需要特判一下</span></span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (number == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> back_track(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n!)<br>空间复杂度：O(n), 最多分n段，每段长度为1， 所以递归深度为n</p>
<h3 id="方法二：记忆化递归"><a href="#方法二：记忆化递归" class="headerlink" title="方法二：记忆化递归"></a>方法二：记忆化递归</h3><p>根据方法一，假设求back_track(7)，如下图：<br><img src="https://uploadfiles.nowcoder.com/images/20200523/284295_1590216999783_2CC2B62A31846CE8FC9AB8E71A5EB53D" alt="图片说明"><br>我用f() 替代 back_track(),可知，红色的部分重复了。<br>因此，我们可以开一个数组，把计算过的结果存起来。<br>步骤如下：</p>
<ul>
<li><p>初始化一个大小为 n+1 的数组，初始值为 -1 ， 也可以-2， 反正是不可能得到的值</p>
</li>
<li><p>在方法一的代码上，记录一下，详细代码如下<br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">back_track</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;mark)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">4</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在方法一的基础上添加</span></span><br><span class="line">      <span class="keyword">if</span> (mark[n] != <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> mark[n];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">          ret = <span class="built_in">max</span>(ret, i * back_track(n - i));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 添加部分</span></span><br><span class="line">      <span class="keyword">return</span> mark[n] = ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (number == <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (number == <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 添加部分</span></span><br><span class="line">      <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mark</span><span class="params">(number, <span class="number">-1</span>)</span></span>;</span><br><span class="line">      <span class="keyword">return</span> back_track(numberm, mark);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)<br>空间复杂度：O(n)</p>
</li>
</ul>
<h3 id="方法三：动态规划"><a href="#方法三：动态规划" class="headerlink" title="方法三：动态规划"></a>方法三：动态规划</h3><p>有的书上认为方法二是一种递归版本的动态规划。<br>所以，我们可以将方法二修改为迭代版本的动态规划。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (number == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(number + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= number; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], j * f[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)<br>空间复杂度：O(n)</p>
<p>总的来说，方法一是基础。方法二，方法三都是在方法一的基础上修改的。</p>
<p>Q:接下来，我们就可以开篇的问题了，什么样的题适合用动态规划？<br>A：一般，动态规划有以下几种分类：</p>
<ol>
<li>最值型动态规划，比如求最大，最小值是多少 </li>
<li>计数型动态规划，比如换硬币，有多少种换法 </li>
<li>坐标型动态规划，比如在m*n矩阵求最值型，计数型，一般是二维矩阵 </li>
<li>区间型动态规划，比如在区间中求最值 </li>
</ol>
<p>其实，根据此题的启发，我们可以换种想法，就是什么样的题适合用暴力递归？<br>显然就是，可能的情况很多，需要枚举所有种情况。只不过动态规划，只记录子结构中最优的解。</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>按之字形顺序打印二叉树</title>
    <url>/2020/06/03/%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>层序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> curLevelNum = <span class="number">1</span>, nextLevelNum = <span class="number">0</span>, num = <span class="number">0</span>, level = <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(pRoot);</span><br><span class="line">    ArrayList&lt;Integer&gt; tmpList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode t = queue.poll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(t.left);</span><br><span class="line">            nextLevelNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(t.right);</span><br><span class="line">            nextLevelNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        tmpList.add(t.val);</span><br><span class="line">        <span class="keyword">if</span> (num == curLevelNum) &#123;</span><br><span class="line">            level++;</span><br><span class="line">            curLevelNum = nextLevelNum;</span><br><span class="line">            nextLevelNum = <span class="number">0</span>;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>) &#123;<span class="comment">//反转</span></span><br><span class="line">                Collections.reverse(tmpList);</span><br><span class="line">            &#125;</span><br><span class="line">            lists.add(tmpList);</span><br><span class="line">            tmpList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/91b69814117f4e8097390d107d2efbe0?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/91b69814117f4e8097390d107d2efbe0?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="方法：队列"><a href="#方法：队列" class="headerlink" title="方法：队列"></a>方法：队列</h2><p>层次遍历打印二叉树，用队列实现。<br>有一句话，我觉得说的特别好：做题=解法+模板，意思就是说，对于一道题目，首先明白正确的解法已经解决该问题70%，剩下的就直接套模板。</p>
<p>所以<code>BFS</code>的模板为：</p>
<ol>
<li><p>如果不需要确定当前遍历到了哪一层，模板如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> vis[] = &#123;<span class="number">0</span>&#125;; <span class="comment">// or set</span></span><br><span class="line"> <span class="function"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pq</span><span class="params">(start_val)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">     <span class="keyword">int</span> cur = pq.front(); pq.pop();</span><br><span class="line">     <span class="keyword">for</span> (遍历cur所有的相邻节点nex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (nex节点有效 &amp;&amp; vis[nex]==<span class="number">0</span>)&#123;</span><br><span class="line">             vis[nex] = <span class="number">1</span>;</span><br><span class="line">             pq.push(nex)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="comment">// end for</span></span><br><span class="line"> &#125; <span class="comment">// end while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>上述是伪代码，不仅可用于二叉树，可针对所有用<code>BFS</code>解题。</p>
<ol>
<li><p>如果需要确定遍历到哪一层，模板如下；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"> vis[] = &#123;<span class="number">0</span>&#125;; <span class="comment">// or set</span></span><br><span class="line"> <span class="function"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pq</span><span class="params">(original_val)</span></span>;</span><br><span class="line"> <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">     <span class="keyword">int</span> sz = pq.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (sz--) &#123;</span><br><span class="line">             <span class="keyword">int</span> cur = pq.front(); pq.pop();</span><br><span class="line">         <span class="keyword">for</span> (遍历cur所有的相邻节点nex) &#123;</span><br><span class="line">             <span class="keyword">if</span> (nex节点有效 &amp;&amp; vis[nex] == <span class="number">0</span>) &#123;</span><br><span class="line">                 vis[nex] = <span class="number">1</span>;</span><br><span class="line">                 pq.push(nex)</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="comment">// end for</span></span><br><span class="line">     &#125; <span class="comment">// end inner while</span></span><br><span class="line">     level++;</span><br><span class="line"></span><br><span class="line"> &#125; <span class="comment">// end outer while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>此题跟“按层打印二叉树”，仅有一点区别，“按层打印二叉树”是每层都按照从左到右打印二叉树。<br>而此题是，按照奇数层，从左到右打印，偶数层，从右到左打印。<br>所以此题可直接套用模板，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">Print</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!pRoot) <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(pRoot);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">            <span class="keyword">while</span> (sz--) &#123;</span><br><span class="line">                TreeNode *node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                ans.push_back(node-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ++level;</span><br><span class="line">            <span class="keyword">if</span> (!(level&amp;<span class="number">1</span>)) <span class="comment">// 偶数层 反转一下</span></span><br><span class="line">                reverse(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">            ret.push_back(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N^2)<br>空间复杂度：O(1), <code>vecotr&lt;vecotr&lt;int&gt;&gt;</code>是必须要开的，不算在额外空间里</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>机器人的运动范围</title>
    <url>/2020/06/02/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>dfs遍历即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来判断是否访问过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> X, Y, max;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    X = rows;</span><br><span class="line">    Y = cols;</span><br><span class="line">    max = threshold;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= X || y &gt;= Y) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String id = x + <span class="string">","</span> + y;</span><br><span class="line">    <span class="keyword">if</span> (set.contains(id)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        set.add(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] xs = String.valueOf(x).toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] ys = String.valueOf(y).toCharArray();</span><br><span class="line">    <span class="keyword">int</span> xc = <span class="number">0</span>, yc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : xs) &#123;</span><br><span class="line">        xc += (c - <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : ys) &#123;</span><br><span class="line">        yc += (c - <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (xc + yc &gt; max) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    dfs(x - <span class="number">1</span>, y);</span><br><span class="line">    dfs(x + <span class="number">1</span>, y);</span><br><span class="line">    dfs(x, y - <span class="number">1</span>);</span><br><span class="line">    dfs(x, y + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/6e5207314b5241fb83f2329e89fdecc8?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/6e5207314b5241fb83f2329e89fdecc8?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="方法一：DFS遍历"><a href="#方法一：DFS遍历" class="headerlink" title="方法一：DFS遍历"></a>方法一：DFS遍历</h2><p>根据题目描述，我们可以模拟题目，我们假设一个5x5矩阵，阈值sho=3，如果我们用DFS的话，就相当于“不撞南墙不回头”，我在下面画了一个图，<br><img src="https://uploadfiles.nowcoder.com/images/20200519/284295_1589877614926_ABC6FAAB5BAD4415E420440E8397D9B9" alt=" "><br>最开始，我们在(0,0)的位置，我们假设按照{右，下，左，上}的方向去试探。所以我们走的顺序应该是按照图中的下标走的。<br>当走到4的时候，发现不能往继续往右边走，并且4个方向都走不通了，那就回溯到3,发现可以走到5，接着就站在5的视角，发现可以走6，就一直按照这个想法。</p>
<p>本题的递归函数就是：首先站在(0,0)的视角，先往右试探，发现可以走，就以下一个为视角，继续做相同的事情。<br>递归函数模板为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dfs()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步，检查下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：检查是否被访问过，或者是否满足当前匹配条件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：检查是否满足返回结果条件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步：都没有返回，说明应该进行下一步递归</span></span><br><span class="line">    <span class="comment">// 标记</span></span><br><span class="line">    dfs(下一次)</span><br><span class="line">    <span class="comment">// 回溯</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照模板改写代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> V = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> VV = <span class="built_in">vector</span>&lt;V&gt;;    </span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">5</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> sho, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> &amp;ret, VV &amp;mark)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查下标 和 是否访问</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= r || y &lt; <span class="number">0</span> || y &gt;= c || mark[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查当前坐标是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (check(x) + check(y) &gt; sho) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代码走到这里，说明当前坐标符合条件</span></span><br><span class="line">        mark[x][y] = <span class="number">1</span>;</span><br><span class="line">        ret += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            dfs(x + dir[i], y + dir[i + <span class="number">1</span>], sho, r, c, ret, mark);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> sho, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sho &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">VV <span class="title">mark</span><span class="params">(rows, V(cols, <span class="number">-1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, sho, rows, cols, ret, mark);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m<em>n)， m,n为矩阵大小，每个元素最多访问过一次<br>空间复杂度：O(m</em>n)</p>
<h2 id="方法二：BFS遍历"><a href="#方法二：BFS遍历" class="headerlink" title="方法二：BFS遍历"></a>方法二：BFS遍历</h2><p>当前图的遍历算法还有bBFS，所以也可以用BFS做。方法一实例的图，用BFS就是如下这样：<br><img src="https://uploadfiles.nowcoder.com/images/20200519/284295_1589878467112_921F1E74912BCD2AD922A5DEFC42ED71" alt="图片说明"> </p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">5</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> sho, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sho &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mark[rows][cols];</span><br><span class="line">        <span class="built_in">memset</span>(mark, <span class="number">-1</span>, <span class="keyword">sizeof</span>(mark));</span><br><span class="line">        <span class="built_in">queue</span>&lt;pii&gt; q;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        mark[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// 每次保证进队列的都是满足条件的坐标</span></span><br><span class="line">            ++ret;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = node.first + dir[i];</span><br><span class="line">                <span class="keyword">int</span> y = node.second + dir[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols &amp;&amp; mark[x][y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (check(x) + check(y) &lt;= sho) &#123;</span><br><span class="line">                        q.push(&#123;x, y&#125;);</span><br><span class="line">                        mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m<em>n)， m,n为矩阵大小，每个元素最多访问过一次<br>空间复杂度：O(m</em>n)</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>Base64笔记</title>
    <url>/2020/06/04/Base64%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>转载   原文作者： <a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰</a></p>
<p>1.</p>
<p>昨天的<a href="http://www.ruanyifeng.com/blog/2008/06/mime.html" target="_blank" rel="noopener">《MIME笔记》</a>中提到，MIME主要使用两种编码转换方式—-Quoted-printable和Base64—-将8位的非英语字符转化为7位的ASCII字符。</p>
<p>虽然这样的初衷，是为了满足电子邮件中不能直接使用非ASCII码字符的规定，但是也有其他重要的意义：</p>
<blockquote>
<p>a）所有的二进制文件，都可以因此转化为可打印的文本编码，使用文本软件进行编辑；</p>
<p>b）能够对文本进行简单的加密。</p>
</blockquote>
<p>2.</p>
<p>首先，简单介绍一下Quoted-printable编码转换方式。它主要用于ACSII文本中夹杂少量非ASCII码字符的情况，不适合于转换纯二进制文件。</p>
<p>它规定将每一个8位的字节，转换为3个字符。</p>
<p>第一个字符是”=”号，这是固定不变的。</p>
<p>后面二个字符是二个十六进制数，分别代表了这个字节前四位和后四位的数值。</p>
<p>举例来说，ASCII码中”换页键”（form feed）是12，二进制形式是00001100，写成十六进制就是0C，因此它的编码值为”=0C”。”=”号的ASCII值是61，二进制形式是00111101，因为它的编码值是”=3D”。除了可打印的ASCII码以外，所有其他字符都必须用这种方式进行转换。</p>
<p>所有可打印的ASCII码字符（十进制值从33到126）都保持原样不变，”=”（十进制值61）除外。</p>
<p>3.</p>
<p>下面，详细介绍Base64的编码转换方式。</p>
<p>所谓Base64，就是说选出64个字符—-小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”/“（再加上作为垫字的”=”，实际上是65个字符）—-作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。</p>
<p>具体来说，转换方式可以分为四步。</p>
<blockquote>
<p>第一步，将每三个字节作为一组，一共是24个二进制位。</p>
<p>第二步，将这24个二进制位分为四组，每个组有6个二进制位。</p>
<p>第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节。</p>
<p>第四步，根据下表，得到扩展后的每个字节的对应符号，这就是Base64的编码值。</p>
</blockquote>
<blockquote>
<p>　　0　A　　17　R　　　34　i　　　51　z</p>
<p>　　1　B　　18　S　　　35　j　　　52　0</p>
<p>　　2　C　　19　T　　　36　k　　　53　1</p>
<p>　　3　D　　20　U　　　37　l　　　54　2</p>
<p>　　4　E　　21　V　　　38　m　　　55　3</p>
<p>　　5　F　　22　W　　　39　n　　　56　4</p>
<p>　　6　G　　23　X　　　40　o　　　57　5</p>
<p>　　7　H　　24　Y　　　41　p　　　58　6</p>
<p>　　8　I　　　25　Z　　　42　q　　　59　7</p>
<p>　　9　J　　26　a　　　43　r　　　60　8</p>
<p>　　10　K　　27　b　　　44　s　　　61　9</p>
<p>　　11　L　　28　c　　　45　t　　　62　+</p>
<p>　　12　M　　29　d　　　46　u　　　63　/</p>
<p>　　13　N　　30　e　　　47　v</p>
<p>　　14　O　　31　f　　　48　w　　　</p>
<p>　　15　P　　32　g　　　49　x</p>
<p>　　16　Q　　33　h　　　50　y</p>
</blockquote>
<p>因为，Base64将三个字节转化成四个字节，因此Base64编码后的文本，会比原文本大出三分之一左右。</p>
<p>4.</p>
<p>举一个具体的实例，演示英语单词Man如何转成Base64编码。</p>
<table>
<thead>
<tr>
<th>Text content</th>
<th><strong>M</strong></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>a</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>n</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>ASCII</td>
<td>77</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>97</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>110</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Bit pattern</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>Index</td>
<td>19</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>22</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>46</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Base64-Encoded</td>
<td><strong>T</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>W</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>F</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>u</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>第一步，”M”、”a”、”n”的ASCII值分别是77、97、110，对应的二进制值是01001101、01100001、01101110，将它们连成一个24位的二进制字符串010011010110000101101110。</p>
<p>第二步，将这个24位的二进制字符串分成4组，每组6个二进制位：010011、010110、000101、101110。</p>
<p>第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节：00010011、00010110、00000101、00101110。它们的十进制值分别是19、22、5、46。</p>
<p>第四步，根据上表，得到每个值对应Base64编码，即T、W、F、u。</p>
</blockquote>
<p>因此，Man的Base64编码就是TWFu。</p>
<p>5.</p>
<p>如果字节数不足三，则这样处理：</p>
<blockquote>
<p>a）二个字节的情况：将这二个字节的一共16个二进制位，按照上面的规则，转成三组，最后一组除了前面加两个0以外，后面也要加两个0。这样得到一个三位的Base64编码，再在末尾补上一个”=”号。</p>
<p>比如，”Ma”这个字符串是两个字节，可以转化成三组00010011、00010110、00010000以后，对应Base64值分别为T、W、E，再补上一个”=”号，因此”Ma”的Base64编码就是TWE=。</p>
</blockquote>
<blockquote>
<p>b）一个字节的情况：将这一个字节的8个二进制位，按照上面的规则转成二组，最后一组除了前面加二个0以外，后面再加4个0。这样得到一个二位的Base64编码，再在末尾补上两个”=”号。</p>
<p>比如，”M”这个字母是一个字节，可以转化为二组00010011、00010000，对应的Base64值分别为T、Q，再补上二个”=”号，因此”M”的Base64编码就是TQ==。</p>
</blockquote>
<p>6.</p>
<p>再举一个中文的例子，汉字”严”如何转化成Base64编码？</p>
<p>这里需要注意，汉字本身可以有多种编码，比如gb2312、utf-8、gbk等等，每一种编码的Base64对应值都不一样。下面的例子以utf-8为例。</p>
<p>首先，”严”的utf-8编码为E4B8A5，写成二进制就是三字节的”11100100 10111000 10100101”。将这个24位的二进制字符串，按照第3节中的规则，转换成四组一共32位的二进制值”00111001 00001011 00100010 00100101”，相应的十进制数为57、11、34、37，它们对应的Base64值就为5、L、i、l。</p>
<p>所以，汉字”严”（utf-8编码）的Base64值就是5Lil。</p>
<p>7.</p>
<p>在PHP语言中，有一对专门的函数用于Base64转换：base64_encode()用于编码、base64_decode()用于解码。</p>
<p>这对函数的特点是，它们不管输入文本的编码是什么，都会按照规则进行Base64编码。因此，如果你想得到utf-8编码下的Base64对应值，你就必须自己保证，输入的文本是utf-8编码的。</p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>JWT简介</title>
    <url>/2020/06/04/JWT%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>转载  原文作者： <a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰</a></p>
<p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，本文介绍它的原理和用法。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072301.jpg" alt="img"></p>
<h2 id="一、跨域认证的问题"><a href="#一、跨域认证的问题" class="headerlink" title="一、跨域认证的问题"></a>一、跨域认证的问题</h2><p>互联网服务离不开用户认证。一般流程是下面这样。</p>
<blockquote>
<p>1、用户向服务器发送用户名和密码。</p>
<p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p>
<p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p>
<p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p>
<p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p>
</blockquote>
<p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p>
<p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p>
<p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p>
<p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p>
<h2 id="二、JWT-的原理"><a href="#二、JWT-的原理" class="headerlink" title="二、JWT 的原理"></a>二、JWT 的原理</h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"姓名"</span>: <span class="string">"张三"</span>,</span><br><span class="line">  <span class="string">"角色"</span>: <span class="string">"管理员"</span>,</span><br><span class="line">  <span class="string">"到期时间"</span>: <span class="string">"2018年7月1日0点0分"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p>
<p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>
<h2 id="三、JWT-的数据结构"><a href="#三、JWT-的数据结构" class="headerlink" title="三、JWT 的数据结构"></a>三、JWT 的数据结构</h2><p>实际的 JWT 大概就像下面这样。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072304.jpg" alt="img"></p>
<p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p>
<p>JWT 的三个部分依次如下。</p>
<blockquote>
<ul>
<li>Header（头部）</li>
<li>Payload（负载）</li>
<li>Signature（签名）</li>
</ul>
</blockquote>
<p>写成一行，就是下面的样子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Header.Payload.Signature</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg" alt="img"></p>
<p>下面依次介绍这三个部分。</p>
<h3 id="3-1-Header"><a href="#3-1-Header" class="headerlink" title="3.1 Header"></a>3.1 Header</h3><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="string">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p>
<p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p>
<h3 id="3-2-Payload"><a href="#3-2-Payload" class="headerlink" title="3.2 Payload"></a>3.2 Payload</h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p>
<blockquote>
<ul>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
</blockquote>
<p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="string">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p>
<p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p>
<h3 id="3-3-Signature"><a href="#3-3-Signature" class="headerlink" title="3.3 Signature"></a>3.3 Signature</h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p>
<p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">"."</span> +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p>
<h3 id="3-4-Base64URL"><a href="#3-4-Base64URL" class="headerlink" title="3.4 Base64URL"></a>3.4 Base64URL</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p>
<p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p>
<h2 id="四、JWT-的使用方式"><a href="#四、JWT-的使用方式" class="headerlink" title="四、JWT 的使用方式"></a>四、JWT 的使用方式</h2><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p>
<p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p>
<h2 id="五、JWT-的几个特点"><a href="#五、JWT-的几个特点" class="headerlink" title="五、JWT 的几个特点"></a>五、JWT 的几个特点</h2><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p>
<p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p>
<p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p>
<p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p>
<p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p>
<p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>
<h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ul>
<li><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">Introduction to JSON Web Tokens</a>， by Auth0</li>
<li><a href="https://medium.com/@bryanmanuele/sessionless-authentication-withe-jwts-with-node-express-passport-js-69b059e4b22c" target="_blank" rel="noopener">Sessionless Authentication using JWTs (with Node + Express + Passport JS)</a>, by Bryan Manuele</li>
<li><a href="https://github.com/dwyl/learn-json-web-tokens/blob/master/README.md" target="_blank" rel="noopener">Learn how to use JSON Web Tokens</a>, by dwyl</li>
</ul>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>sleep()，wait()，yield()和join()方法的区别</title>
    <url>/2020/06/05/sleep()%EF%BC%8Cwait()%EF%BC%8Cyield()%E5%92%8Cjoin()%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h2><p>​    sleep()方法需要<strong>指定等待的时间</strong>，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态.</p>
<p>​    该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是sleep()方法<strong>不会释放“锁标志”</strong>，也就是说如果有synchronized同步块，其他线程仍然不能访问共享数据。
　　</p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h2><p>　　wait()方法需要和<code>notify()</code>及<code>notifyAll()</code>两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用，也就是说，调用<code>wait()</code>，<code>notify()</code>和<code>notifyAll()</code>的任务在调用这些方法前必须拥有对象的锁。注意，它们都是Object类的方法，而不是Thread类的方法。<br>　　<code>wait()</code>方法与<code>sleep()</code>方法的不同之处在于，<code>wait()</code>方法<strong>会释放对象的“锁标志”</strong>。当调用某一对象的<code>wait()</code>方法后，会使当前线程暂停执行，并<strong>将当前线程放入对象等待池中</strong>，直到调用了<code>notify()</code>方法后，将从对象等待池中<strong>移出任意一个线程</strong>并放入锁标志等待池中，只有<strong>锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。</strong>当调用了某个对象的<code>notifyAll()</code>方法，会<strong>将对象等待池中的所有线程</strong>都移动到该对象的锁标志等待池。<br>　　除了使用<code>notify()</code>和<code>notifyAll()</code>方法，还可以使用带毫秒参数的<code>wait(long timeout)</code>方法，效果是<strong>在延迟timeout毫秒后，被暂停的线程将被恢复到锁标志等待池。</strong><br>　　此外，<code>wait()</code>，<code>notify()</code>及<code>notifyAll()</code>只能在<code>synchronized</code>语句中使用，但是如果使用的是<code>ReenTrantLock</code>实现同步，该如何达到这三个方法的效果呢？解决方法是使用<code>ReenTrantLock.newCondition()</code>获取一个<code>Condition</code>类对象，然后<code>Condition</code>的<code>await()</code>，<code>signal()</code>以及<code>signalAll()</code>分别对应上面的三个方法。</p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><p>　　<code>yield()</code>方法和<code>sleep()</code>方法类似，也<strong>不会释放“锁标志”</strong>，区别在于，它没有参数，即<code>yield()</code>方法只是<strong>使当前线程重新回到可执行状态</strong>，所以执行<code>yield()</code>的线程有可能在进入到可执行状态后马上又被执行，另外<strong>yield()方法只能使同优先级或者高优先级的线程得到执行机会</strong>，这也和sleep()方法不同。</p>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>　　<code>join()</code>方法会使当前线程<strong>等待调用join()方法的线程结束</strong>后才能继续执行</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Object类的方法</title>
    <url>/2020/06/05/Object%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Object有几种方法呢？</p>
<blockquote>
<p>Java语言是一种单继承结构语言，Java中所有的类都有一个共同的祖先。这个祖先就是Object类。</p>
<p>如果一个类没有用extends明确指出继承于某个类，那么它默认继承Object类。</p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>Object类是Java中所有类的基类。位于java.lang包中，一共有13个方法。如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/8KKrHK5ic6XC97BDOiblPU3PjicVfd5IIXibJr1EPadLZ2U28FVeSfBEpDhmYwHHiceviaxzZvOZX99Z8BZWehcSiaupA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h2 id="具体解答"><a href="#具体解答" class="headerlink" title="具体解答"></a>具体解答</h2><h3 id="1-Object"><a href="#1-Object" class="headerlink" title="1.Object()"></a>1.Object()</h3><p>这个没什么可说的，Object类的构造方法。(非重点)</p>
<h3 id="2-registerNatives"><a href="#2-registerNatives" class="headerlink" title="2.registerNatives()"></a>2.registerNatives()</h3><p>为了使JVM发现本机功能，他们被一定的方式命名。例如，对于java.lang.Object.registerNatives，对应的C函数命名为Java_java_lang_Object_registerNatives。</p>
<p>通过使用registerNatives（或者更确切地说，JNI函数RegisterNatives），可以命名任何你想要你的C函数。(非重点)</p>
<h3 id="3-clone"><a href="#3-clone" class="headerlink" title="3.clone()"></a>3.clone()</h3><p>clone()函数的用途是用来另存一个当前存在的对象。只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。（注意：回答这里时可能会引出设计模式的提问）</p>
<h3 id="4-getClass"><a href="#4-getClass" class="headerlink" title="4.getClass()"></a>4.getClass()</h3><p>final方法，用于获得运行时的类型。该方法返回的是此Object对象的类对象/运行时类对象Class。效果与Object.class相同。（注意：回答这里时可能会引出类加载，反射等知识点的提问）</p>
<h3 id="5-equals"><a href="#5-equals" class="headerlink" title="5.equals()"></a>5.equals()</h3><p>equals用来比较两个对象的内容是否相等。默认情况下(继承自Object类)，equals和==是一样的，除非被覆写(override)了。（注意：这里可能引出更常问的“equals与==的区别”及hashmap实现原理的提问）</p>
<h3 id="6-hashCode"><a href="#6-hashCode" class="headerlink" title="6.hashCode()"></a>6.hashCode()</h3><p>该方法用来返回其所在对象的物理地址（哈希码值），常会和equals方法同时重写，确保相等的两个对象拥有相等的hashCode。（同样，可能引出hashmap实现原理的提问）</p>
<h3 id="7-toString"><a href="#7-toString" class="headerlink" title="7.toString()"></a>7.toString()</h3><p>toString()方法返回该对象的字符串表示，这个方法没什么可说的。</p>
<h3 id="8-wait"><a href="#8-wait" class="headerlink" title="8.wait()"></a>8.wait()</h3><p>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。（引出线程通信及“wait和sleep的区别”的提问）</p>
<h3 id="9-wait-long-timeout"><a href="#9-wait-long-timeout" class="headerlink" title="9.wait(long timeout)"></a>9.wait(long timeout)</h3><p>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。（引出线程通信及“wait和sleep的区别”的提问）</p>
<h3 id="10-wait-long-timeout-int-nanos"><a href="#10-wait-long-timeout-int-nanos" class="headerlink" title="10.wait(long timeout, int nanos)"></a>10.wait(long timeout, int nanos)</h3><p>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。（引出线程通信及“wait和sleep的区别”的提问）</p>
<h3 id="11-notify"><a href="#11-notify" class="headerlink" title="11.notify()"></a>11.notify()</h3><p>唤醒在此对象监视器上等待的单个线程。（引出线程通信的提问）</p>
<h3 id="12-notifyAll"><a href="#12-notifyAll" class="headerlink" title="12. notifyAll()"></a>12. notifyAll()</h3><p>唤醒在此对象监视器上等待的所有线程。（引出线程通信的提问）</p>
<h3 id="13-finalize"><a href="#13-finalize" class="headerlink" title="13.finalize()"></a>13.finalize()</h3><p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。（非重点，但小心引出垃圾回收的提问）</p>
<h2 id="引申常见问题"><a href="#引申常见问题" class="headerlink" title="引申常见问题"></a>引申常见问题</h2><ul>
<li>equals() 与 == 的区别是什么？</li>
<li>hashCode() 和 equals() 之间有什么联系？</li>
<li>wait()方法与sleep()方法的区别</li>
<li>为什么重写了equals就必须重写hashCode</li>
<li>HashMap的实现原理</li>
<li>谈谈类加载机制</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的下一个结点</title>
    <url>/2020/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>分情况判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeLinkNode tmp = pNode.right;</span><br><span class="line">        <span class="keyword">while</span> (tmp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//pNode.right == null</span></span><br><span class="line">        <span class="keyword">if</span> (pNode.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pNode.next.left == pNode) &#123;<span class="comment">//pNode is left child</span></span><br><span class="line">            <span class="keyword">return</span> pNode.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//pNode is right child</span></span><br><span class="line">            TreeLinkNode tmp = pNode.next;</span><br><span class="line">            <span class="keyword">while</span> (tmp.next.left != tmp) &#123;<span class="comment">//find first left child</span></span><br><span class="line">                tmp = tmp.next;</span><br><span class="line">                <span class="keyword">if</span> (tmp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<p>题目描述：给你一颗二叉树的一个结点，返回中序遍历顺序中这个结点的下一结点。二叉树不仅有左右孩子指针，还有指向父亲结点的指针。</p>
<p>Q1：首先问你一个问题，如果这道题出现在笔试题中，你会用什么方法做？如果出现在面试题中呢？<br>A1：我想你肯定有点疑惑，同一道题为什么还分出现在笔试题中还是面试题中呢？很显然，笔试题中只要能过就好，设计的算法丑点，慢点也无所畏，不一定需要最优解法，当然前提是能够通过。而面试中就不一样了，显然面试官希望听到最优解法。</p>
<h2 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h2><p>如果在笔试题中看到这道题，直接模拟题意就好了。题意需要找到某个结点中序遍历的下一个结点，那我们的做法很显然可以这样：</p>
<ol>
<li>根据给出的结点求出整棵树的根节点 </li>
<li>根据根节点递归求出树的中序遍历，存入vector </li>
<li>在vector中查找当前结点，则当前结点的下一结点即为所求。 </li>
</ol>
<p>虽然有点暴力，但是时间复杂度也是线性的，第一步：最坏为O(N), N为整棵树结点的个数。第二步：O(N), 第三步：最坏为O(N),<br>所以整的时间复杂度：3*O(N)</p>
<p>时间复杂度还可以接受，关键是思路好想并且每一步的代码都很简单。<br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre_order</span><span class="params">(TreeLinkNode *root, <span class="built_in">vector</span>&lt;TreeLinkNode*&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre_order(root-&gt;left, v);</span><br><span class="line">        v.push_back(root);</span><br><span class="line">        pre_order(root-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">          TreeLinkNode *root = <span class="literal">nullptr</span>;</span><br><span class="line">          TreeLinkNode *tmp = pNode;</span><br><span class="line">          <span class="comment">// 第一步</span></span><br><span class="line">          <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">              root = tmp;</span><br><span class="line">              tmp = tmp-&gt;next;</span><br><span class="line">          &#125;   </span><br><span class="line"></span><br><span class="line">          <span class="built_in">vector</span>&lt;TreeLinkNode*&gt; v;</span><br><span class="line">          <span class="comment">// 第二步</span></span><br><span class="line">          pre_order(root, v);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 第三步</span></span><br><span class="line">          <span class="keyword">int</span> n = v.<span class="built_in">size</span>();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">              <span class="keyword">if</span> (v[i] == pNode &amp;&amp; i + <span class="number">1</span> != n) &#123;</span><br><span class="line">                  <span class="keyword">return</span> v[i+<span class="number">1</span>];</span><br><span class="line">              &#125; </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)<br>空间复杂度：O(N)</p>
<h2 id="方法二：最优解法"><a href="#方法二：最优解法" class="headerlink" title="方法二：最优解法"></a>方法二：最优解法</h2><p>但是，如果在面试中，方法一肯定上不了台面。但是最优解法该怎么去想呢？想不出来就画图分析，举个中序遍历的图：如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20200526/284295_1590477193692_99D648423BB3F2113395149399A1462A" alt="图片说明"><br>红色数字是中序遍历的顺序。接下来，我们就假设，如果当前结点分别是1,2 … 7，下一结点看有什么规律没？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> =&gt; <span class="number">2</span> <span class="comment">// 显然下一结点是 1 的父亲结点</span></span><br><span class="line"><span class="number">2</span> =&gt; <span class="number">3</span> <span class="comment">// 下一节点是当前结点右孩子的左孩子结点，其实你也应该想到了，应该是一直到左孩子为空的那个结点</span></span><br><span class="line"><span class="number">3</span> =&gt; <span class="number">4</span> <span class="comment">// 跟 2 的情况相似，当前结点右孩子结点的左孩子为空的那个结点</span></span><br><span class="line"><span class="number">4</span> =&gt; <span class="number">5</span> <span class="comment">// 5 是父亲结点 3 的父亲结点，发现和1有点像，因为 1，3,同样是父亲结点的左孩子</span></span><br><span class="line"><span class="number">5</span> =&gt; <span class="number">6</span> <span class="comment">// 跟 4=&gt;5 一样的道理</span></span><br><span class="line"><span class="number">6</span> =&gt; <span class="number">7</span> <span class="comment">// 跟 3=&gt;4 一样的道理</span></span><br><span class="line"><span class="number">7</span> =&gt; null <span class="comment">// 因为属于最尾结点</span></span><br></pre></td></tr></table></figure>

<p>此时，可以总结一下：<br>[1] 是一类：特点：当前结点是父亲结点的左孩子<br>[2 3 6] 是一类，特点：当前结点右孩子结点，那么下一节点就是：右孩子结点的最左孩子结点,如果右孩子结点没有左孩子就是自己<br>[4 5]是一类，特点：当前结点为父亲结点的右孩子结点，本质还是[1]那一类<br>[7]是一类，特点：最尾结点</p>
<p>我写的可能不够清晰，但是，思想你要明白，当遇到不会的题，可以根据题意画图，分析，分析方法是关键。<br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pNode) &#123;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 属于[2 3 6]类</span></span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;right) &#123;</span><br><span class="line">            pNode = pNode-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (pNode-&gt;left) &#123;</span><br><span class="line">                pNode = pNode-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 属于 [1] 和 [4 5]</span></span><br><span class="line">        <span class="keyword">while</span> (pNode-&gt;next) &#123;</span><br><span class="line">            TreeLinkNode *root = pNode-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == pNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 属于[7]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：最坏情况下为O(N)<br>空间复杂度：O(1)</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>对称的二叉树</title>
    <url>/2020/06/04/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>递归判断,还可以更简洁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isSame(pRoot.left, pRoot.right)) &#123;</span><br><span class="line">        <span class="keyword">return</span> judgeSymmetrical(pRoot.left, pRoot.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judgeSymmetrical</span><span class="params">(TreeNode leftNode, TreeNode rightNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> &amp;&amp; rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSame(leftNode.left, rightNode.right) &amp;&amp; isSame(leftNode.right, rightNode.left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> judgeSymmetrical(leftNode.left, rightNode.right) &amp;&amp; judgeSymmetrical(leftNode.right, rightNode.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(TreeNode node1, TreeNode node2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node1.val == node2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/ff05d44dfdb04e1d83bdbdab320efbcb?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/ff05d44dfdb04e1d83bdbdab320efbcb?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="方法：递归"><a href="#方法：递归" class="headerlink" title="方法：递归"></a>方法：递归</h2><p>如图<br><img src="https://uploadfiles.nowcoder.com/images/20200506/284295_1588747824270_AF837BEBDDD3BDB7B0D96A05FFDE86DD" alt=" "><br>根据上图可知：若满足对称二叉树，必须满足：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. L-&gt;val &#x3D;&#x3D; R-&gt;val</span><br><span class="line">2. L-&gt;left-&gt;val &#x3D;&#x3D; R-&gt;right-&gt;val</span><br><span class="line">3. L-&gt;right-&gt;val &#x3D;&#x3D; R-&gt;left-&gt;val</span><br></pre></td></tr></table></figure>

<p>因此可以自顶向下，递归求解即可。</p>
<ol>
<li>设置一个递归函数<code>isSame(r1, r2)</code>,表示如果对称，返回<code>true</code>，否则返回<code>false</code> </li>
<li>递归终止条件：<code>r1==nullptr &amp;&amp; r2==nulllptr</code>, 直接返回<code>true</code>，否则，如果只有一个为<code>nullptr</code>，返回<code>false</code> </li>
<li>下一步递归：如果<code>r1-&gt;val == r2-&gt;val, 则isSame(root1-&gt;left, root2-&gt;right) &amp;&amp; isSame(root1-&gt;right, root2-&gt;left);</code> </li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode *root1, TreeNode *root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root1 || !root2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> root1-&gt;val == root2-&gt;val &amp;&amp; </span><br><span class="line">        isSame(root1-&gt;left, root2-&gt;right) &amp;&amp;</span><br><span class="line">        isSame(root1-&gt;right, root2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSame(pRoot, pRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)<br>空间复杂度：O(N),最坏情况下，二叉树退化为链表</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>字符流中第一个不重复的字符</title>
    <url>/2020/06/04/%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果当前字符流没有存在出现一次的字符，返回#字符。</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Insert one char from stringstream</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(ch)) &#123;</span><br><span class="line">        map.put(ch, map.get(ch) + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        map.put(ch, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator iter = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>) entry.getValue() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">char</span>) entry.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/00de97733b8e4f97a3fb5c680ee10720?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/00de97733b8e4f97a3fb5c680ee10720?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<p>题目描述：对于动态字符流，返回第一个不重复的字符。如果不存在，返回’#’。</p>
<h2 id="方法：哈希-队列"><a href="#方法：哈希-队列" class="headerlink" title="方法：哈希+队列"></a>方法：哈希+队列</h2><p>针对题目的描述，我们先提出两个问题？</p>
<p>Q1. 给定一个字符串（只不过这里的字符串是可变的），如果快速判断一个字符是否存在于字符串中，如果存在，也就是重复？<br>Q2. 这里先不考虑重复，如果快速返回第一个字符？有没有感觉有点像先来先服务？</p>
<p>对于一道题，如果没有思路，就要针对题目给自己问问题。然后针对问题，来考虑需要什么样的算法或者数据结构。</p>
<p>A1：对于“重复问题”，惯性思维应该想到哈希或者set。对于“字符串问题”，大多会用到哈希。因此一结合，应该可以想到，判断一个字符是否重复，可以选择用哈希，在c++中，可以选择用<code>unordered_map</code></p>
<p>A2：对于字符流，源源不断的往池子中添加字符，然后还要返回第一个满足什么条件的字符，显然设计到了“顺序”，也就是先来的先服务，这种先进先出的数据结构不就是队列嘛。因此，这里可以用队列。</p>
<p>假如你已经知道了要用hash 和 queue 这两个数据结构，你可以试着自己想一想，接下来的算法过程是怎么样的？<br>这里我提供一个算法过程，如下：</p>
<ol>
<li>初始化一个<code>unordered_map mp, queue q</code></li>
<li>对于<code>Insert(char ch)</code>操作， 如果ch是第一次出现，则添加到q中，然后在mp中记录一下次数，如果不是第一次出现，也就是重复了，那么我们就没必要添加到q中，但是还是需要在mp中更新一下次数，因为之后要根据次数来判断是否重复。</li>
<li>对于<code>FirstAppearingOnce()</code>操作，我们直接判断q的头部，然后在mp中检查一下，是否重复，如果没有重复，那就是我们想要的数据。否则，如果重复了，那就应该弹出头部，然后判断下一个头部是否满足要求。</li>
</ol>
<p>根据算法的过程，你可以试着自己写一下代码。</p>
<p>我的示例代码如下，仅供参考：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; q;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="comment">// 如果是第一次出现， 则添加到队列中</span></span><br><span class="line">         <span class="keyword">if</span> (mp.<span class="built_in">find</span>(ch) == mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">             q.push(ch);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 不管是不是第一次出现，都进行计数</span></span><br><span class="line">         ++mp[ch];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = q.front();</span><br><span class="line">            <span class="comment">// 拿出头部，如果是第一次出现，则返回</span></span><br><span class="line">            <span class="keyword">if</span> (mp[ch] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ch;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不是第一次出现，则弹出，然后继续判断下一个头部</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：对于<code>Insert(char ch)</code>操作，为O(1), 对于<code>FirstAppearingOnce()</code>操作，为O(N)，因为最坏情况下，队列中存入一半的重复数据， 比如“abcdabcd”，队列会存入“abcd”，并且弹出的时候都是重复的。</p>
<p>空间复杂度：O(N)</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式匹配</title>
    <url>/2020/06/04/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’<em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab\</em>ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>待补充</p>
<h2 id="网上题解"><a href="#网上题解" class="headerlink" title="网上题解"></a>网上题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/45327ae22b7b413ea21df13ee7d6429c?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/45327ae22b7b413ea21df13ee7d6429c?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h2><p>假设主串为s，长度为<code>sn</code>， 模式串为<code>p</code>，长度为<code>pn</code>，对于模式串p当前的第<code>i</code>位来说，有<code>&#39;正常字符&#39;、&#39;*&#39;、&#39;.&#39;</code>三种情况。我们针对这三种情况进行讨论：</p>
<ol>
<li>如果<code>p[i]</code>为正常字符， 那么我们看<code>s[i]</code>是否等于<code>p[i]</code>, 如果相等，说明第i位匹配成功,接下来看<code>s[i+1...sn-1] 和 p[i+1...pn-1]</code></li>
<li>如果p[i] 为<code>&#39;.&#39;</code>, 它能匹配任意字符，直接看<code>s[i+1...sn-1] 和 p[i+1...pn-1]</code></li>
<li>如果<code>p[i]</code> 为<code>&#39;*&#39;</code>， 表明<code>p[i-1]</code>可以重复<code>0</code>次或者多次，需要把<code>p[i-1] 和 p[i]</code>看成一个整体.<ul>
<li>如果<code>p[i-1]</code>重复<code>0</code>次，则直接看<code>s[i...sn-1] 和 p[i+2...pn-1]</code> </li>
<li>如果<code>p[i-1]</code>重复一次或者多次,则直接看<code>s[i+1...sn-1] 和p[i...pn-1]</code>，但是有个前提：<code>s[i]==p[i] 或者 p[i] == &#39;.&#39;</code> </li>
</ul>
</li>
</ol>
<p>三种情况如下图：<br><img src="https://uploadfiles.nowcoder.com/images/20200509/284295_1589013766371_56D5186BDC1AB01FA96CC2C22507B1F7" alt="图片说明"><br><img src="https://uploadfiles.nowcoder.com/images/20200509/284295_1589013796397_0432A5039CAF5F0EF87F6CB864FF5787" alt="图片说明"><br><img src="https://uploadfiles.nowcoder.com/images/20200509/284295_1589013961988_7005C0EF0F08F8F8753D173CA5021486" alt=" "><br><img src="https://uploadfiles.nowcoder.com/images/20200509/284295_1589013997068_082222C32703837926302706F005BADC" alt=" "><br>显然上述的过程可以递归进行计算。<br>则递归三部曲为：</p>
<ol>
<li>递归函数功能：<code>match(s, p) -&gt; bool</code>, 表示<code>p</code>是否可以匹配s</li>
<li>递归终止条件：<ul>
<li>如果<code>s 和 p</code> 同时为空，表明正确匹配 </li>
<li>如果<code>s不为空，p为空</code>，表明，不能正确匹配 </li>
<li>如果<code>s为空，p不为空</code>，需要计算，不能直接给出结果 </li>
</ul>
</li>
<li>下一步递归：<ul>
<li>对于前面讨论的情况<code>1，2</code>进行合并，如果<code>*s == *p || *p == &#39;.&#39;,则match(s+1, p+1)</code></li>
<li>对于情况<code>3</code>，如果重复一次或者多次，则<code>match(s+1,p),如果重复0次，则match(s, p+2)</code></li>
</ul>
</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="comment">// 如果 s 和 p 同时为空</span></span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">'\0'</span> &amp;&amp; *p == <span class="string">'\0'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果 s不为空， 但是 p 为空</span></span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">'\0'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果没有 '*'</span></span><br><span class="line">        <span class="keyword">if</span> (*(p+<span class="number">1</span>) != <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*s != <span class="string">'\0'</span> &amp;&amp; (*s == *p || *p == <span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">return</span> match(s+<span class="number">1</span>, p+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有 '*'</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 重复 1 次或多次</span></span><br><span class="line">            <span class="keyword">if</span> (*s != <span class="string">'\0'</span> &amp;&amp; (*s == *p || *p == <span class="string">'.'</span>))</span><br><span class="line">                ret = match(s+<span class="number">1</span>, p);</span><br><span class="line">            <span class="comment">// 重复 0 次</span></span><br><span class="line">            <span class="keyword">return</span> ret || match(s, p+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h2><p>方法一的递归代码属于自顶向下，而动态规划的代码属于自底向上。</p>
<ol>
<li>动态规划转移方程：<br><code>f[i][j]</code>表示<code>s</code>的前<code>i</code>个和<code>p</code>的前<code>j</code>个能否匹配 </li>
</ol>
<ul>
<li><p>对于方法一种的<code>1,2</code>两种情况可知：<code>f[i][j] = f[i-1][j-1]</code> </p>
</li>
<li><p>对于第</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>种情况可知：</p>
<ul>
<li>如果重复<code>0</code>次，<code>f[i][j] = f[i][j-2]</code> </li>
<li>如果重复<code>1</code>次或者多次，<code>f[i][j] = f[i-1][j]</code> </li>
</ul>
</li>
</ul>
<ol>
<li>动态规划初始条件： </li>
</ol>
<ul>
<li><code>s为空且p为空，为真: f[0][0] = 1</code> </li>
<li><code>s不为空且p为空,为假: f[1..sn][0] = 0</code> </li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn = <span class="built_in">strlen</span>(s), pn = <span class="built_in">strlen</span>(p);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; <span class="title">f</span><span class="params">(sn+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(pn+<span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=sn; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=pn; ++j) &#123;</span><br><span class="line">                <span class="comment">// 初始条件</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) f[i][j] = (i == <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果没有 '*'</span></span><br><span class="line">                    <span class="keyword">if</span> (p[j<span class="number">-1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">                            f[i][j] = f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果有 '*'</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 重复 0 次</span></span><br><span class="line">                        <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            f[i][j] |= f[i][j<span class="number">-2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 重复 1 次或者多次</span></span><br><span class="line">                        <span class="comment">// 这里要用 | 连接， 不然重复 0 次的会直接覆盖</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j&gt;=<span class="number">2</span> &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">                            f[i][j] |= f[i<span class="number">-1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[sn][pn];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>跳表</title>
    <url>/2020/06/05/%E8%B7%B3%E8%A1%A8/</url>
    <content><![CDATA[<p>跳表(skip list) 对标的是平衡树(AVL Tree)，是一种 插入/删除/搜索 都是 <code>O(log n)</code> 的数据结构。它最大的优势是原理简单、容易实现、方便扩展、效率更高。因此在一些热门的项目里用来替代平衡树，如 redis, leveldb 等。</p>
<h2 id="跳表的基本思想"><a href="#跳表的基本思想" class="headerlink" title="跳表的基本思想"></a>跳表的基本思想</h2><p>首先，跳表处理的是有序的链表（一般是双向链表，下图未表示双向），如下：</p>
<p><img src="https://lotabout.me/2018/skip-list/linked-list.svg" alt="Linked List"></p>
<p>这个链表中，如果要搜索一个数，需要从头到尾比较每个元素是否匹配，直到找到匹配的数为止，即时间复杂度是 O(n)O(n)。同理，插入一个数并保持链表有序，需要先找到合适的插入位置，再执行插入，总计也是 O(n)O(n) 的时间。</p>
<p>那么如何提高搜索的速度呢？很简单，做个索引：</p>
<p><img src="https://lotabout.me/2018/skip-list/linked-list-2.svg" alt="Linked List With 2 level"></p>
<p>如上图，我们新创建一个链表，它包含的元素为前一个链表的偶数个元素。这样在搜索一个元素时，我们先在上层链表进行搜索，当元素未找到时再到下层链表中搜索。例如搜索数字 <code>19</code> 时的路径如下图：</p>
<p><img src="https://lotabout.me/2018/skip-list/linked-list-search-path.svg" alt="Linked List Search Path"></p>
<p>先在上层中搜索，到达节点 <code>17</code> 时发现下一个节点为 <code>21</code>，已经大于 <code>19</code>，于是转到下一层搜索，找到的目标数字 <code>19</code>。</p>
<p>我们知道上层的节点数目为 n/2n/2，因此，有了这层索引，我们搜索的时间复杂度降为了：O(n/2)O(n/2)。同理，我们可以不断地增加层数，来减少搜索的时间：</p>
<p><img src="https://lotabout.me/2018/skip-list/linked-list-4.svg" alt="Linked List Level 4"></p>
<p>在上面的 4 层链表中搜索 <code>25</code>，在最上层搜索时就可以直接跳过 <code>21</code> 之前的所有节点，因此十分高效。</p>
<p>更一般地，如果有 kk 层，我们需要的搜索次数会小于 ⌈n2k⌉+k⌈n2k⌉+k ，这样当层数 kk 增加到 ⌈log2n⌉⌈log2⁡n⌉ 时，搜索的时间复杂度就变成了 lognlog⁡n。其实这背后的原理和二叉搜索树或二分查找很类似，通过索引来跳过大量的节点，从而提高搜索效率。</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>上节的结构是“静态”的，即我们先拥有了一个链表，再在之上建了多层的索引。但是在实际使用中，我们的链表是通过多次插入/删除形成的，换句话说是“动态”的。上节的结构要求上层相邻节点与对应下层节点间的个数比是 <code>1:2</code>，随意插入/删除一个节点，这个要求就被被破坏了。</p>
<p>因此跳表（skip list）表示，我们就不强制要求 <code>1:2</code> 了，一个节点要不要被索引，建几层的索引，都在节点插入时由抛硬币决定。当然，虽然索引的节点、索引的层数是随机的，为了保证搜索的效率，要大致保证每层的节点数目与上节的结构相当。下面是一个随机生成的跳表：</p>
<p><img src="https://lotabout.me/2018/skip-list/skip-list.svg" alt="Skip List"></p>
<p>可以看到它每层的节点数还和上节的结构差不多，但是上下层的节点的对应关系已经完全被打破了。</p>
<p>现在假设节点 <code>17</code> 是最后插入的，在插入之前，我们需要搜索得到插入的位置：</p>
<p><img src="https://lotabout.me/2018/skip-list/skip-list-insert-17.svg" alt="Skip List Search Path"></p>
<p>接着，抛硬币决定要建立几层的索引，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">randomLevel()</span><br><span class="line">    lvl :&#x3D; 1</span><br><span class="line">    -- random() that returns a random value in [0...1)</span><br><span class="line">    while random() &lt; p and lvl &lt; MaxLevel do</span><br><span class="line">        lvl :&#x3D; lvl + 1</span><br><span class="line">    return lvl</span><br></pre></td></tr></table></figure>

<p>上面的伪代码相当于抛硬币，如果是正面（<code>random() &lt; p</code>）则层数加一，直到抛出反面为止。其中的 <code>MaxLevel</code> 是防止如果运气太好，层数就会太高，而太高的层数往往并不会提供额外的性能，一般 MaxLevel=log1/pnMaxLevel=log1/p⁡n。现在假设 <code>randomLevel</code> 返回的结果是 <code>2</code>，那么就得到下面的结果。</p>
<p><img src="https://lotabout.me/2018/skip-list/skip-list.svg" alt="Skip List"></p>
<p>如果要删除节点，则把节点和对应的所有索引节点全部删除即可。当然，要删除节点时需要先搜索得到该节点，搜索过程中可以把路径记录下来，这样删除索引层节点的时候就不需要多次搜索了。</p>
<p>显然，在最坏的情况下，所有节点都没有创建索引，时间复杂度为O(n)O(n)，但在平均情况下，搜索的时间复杂度却是 O(logn)O(log⁡n)，为什么呢？</p>
<h2 id="简单的性能分析"><a href="#简单的性能分析" class="headerlink" title="简单的性能分析"></a>简单的性能分析</h2><p>一些严格的证明会涉及到比较复杂的概率统计学知识，所以这里只是简单地说明。</p>
<h3 id="搜索的时间复杂度"><a href="#搜索的时间复杂度" class="headerlink" title="搜索的时间复杂度"></a>搜索的时间复杂度</h3><p>为了计算搜索的时间复杂度，我们可以将查找的过程倒过来，从搜索最后的节点开始，一直向左或向上，直到最顶层。如下图，在路径上的每一点，都可能有两种情况：</p>
<p><img src="https://lotabout.me/2018/skip-list/skip-list-back-search.svg" alt="Skip List Search Backward"></p>
<ol>
<li>节点有上一层的节点，向上。这种情况出现的概率是 <code>p</code>。</li>
<li>节点没有上一层的节点，向左。出现的概率是 <code>1-p</code>。</li>
</ol>
<p>于是，设 <code>C(k)</code> 为反向搜索爬到第 <code>k</code> 层的平均路径长度，则有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C(0) &#x3D; 0</span><br><span class="line">C(k) &#x3D; p * (情况1) + (1-p) * (情况2)</span><br></pre></td></tr></table></figure>

<p>将两种情况也用 <code>C</code> 代入，有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C(k) &#x3D; p*(1 + C(k–1)) + (1–p)*(1 + C(k))</span><br><span class="line">C(k) &#x3D; C(k–1) + 1&#x2F;p</span><br><span class="line">C(k) &#x3D; k&#x2F;p</span><br></pre></td></tr></table></figure>

<p>上式表明，搜索时，平均在每层上需要搜索的路径长度为 1/p1/p，从平均的角度上和我们第一小节构造的“静态”结构相同（p 取 <code>1/2</code>）。</p>
<p>又注意到，上小节我们知道跳表的最大层数为 O(logn)O(log⁡n)，因此，搜索的复杂度 O(logn)/p=O(logn)O(log⁡n)/p=O(log⁡n)。</p>
<p>P.S. 这里我们用到的是最大层数，原论文证明时用到的是 L(n)L(n)，然后再考虑从 L(n)L(n) 层到最高层的平均节点个数。这里为了理解方便不再详细证明。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>各种搜索结构提高效率的方式都是通过空间换时间得到的。</li>
<li>跳表最终形成的结构和搜索树很相似。</li>
<li>跳表通过随机的方式来决定新插入节点来决定索引的层数。</li>
<li>跳表搜索的时间复杂度是 O(logn)O(log⁡n)，插入/删除也是。</li>
</ol>
<p>想到快排(quick sort)与其它排序算法（如归并排序/堆排序）虽然时间复杂度是一样的，但复杂度的常数项较小；跳表的原论文也说跳表能提供一个常数项的速度提升，因此想着常数项小是不是随机算法的一个特点？这也它们大放异彩的重要因素吧。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf">ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf</a> 原论文</li>
<li><a href="https://ticki.github.io/blog/skip-lists-done-right/" target="_blank" rel="noopener">https://ticki.github.io/blog/skip-lists-done-right/</a> skip list 的一些变种、优化</li>
<li><a href="https://eugene-eeo.github.io/blog/skip-lists.html" target="_blank" rel="noopener">https://eugene-eeo.github.io/blog/skip-lists.html</a> skip list 的一些相关复杂度分析</li>
<li><a href="http://cglab.ca/~morin/teaching/5408/refs/p90b.pdf" target="_blank" rel="noopener">http://cglab.ca/~morin/teaching/5408/refs/p90b.pdf</a> skip list cookbook，算是 skip list 各方面的汇总</li>
<li><a href="https://juejin.im/entry/59b0eed46fb9a0249471f357" target="_blank" rel="noopener">一个可以在有序元素中实现快速查询的数据结构</a> 包含 skip list 的 C++ 实现</li>
<li><a href="http://zhangtielei.com/posts/blog-redis-skiplist.html" target="_blank" rel="noopener">Redis内部数据结构详解(6)——skiplist</a> 图文并茂讲解 skip list，可与本文交叉对照</li>
<li><a href="https://www.youtube.com/watch?v=2g9OSRKJuzM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=2g9OSRKJuzM</a> MIT 关于 skip list 的课程</li>
<li><a href="https://courses.csail.mit.edu/6.046/spring04/handouts/skiplists.pdf" target="_blank" rel="noopener">https://courses.csail.mit.edu/6.046/spring04/handouts/skiplists.pdf</a> MIT 课程讲义<a href="https://lotabout.me/2018/skip-list/#fnref:1" target="_blank" rel="noopener">https://lotabout.me/2018/skip-list/#fnref:1</a>)</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>把字符串转换成整数</title>
    <url>/2020/06/05/%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个字符串,包括数字字母符号,可以为空</span><br></pre></td></tr></table></figure>

<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果是合法的数值表达则返回该数字，否则返回0</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+2147483647</span><br><span class="line">1a33</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2147483647</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>不用库函数的版本待补充</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         x=Integer.valueOf(str);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>题目意思很明确，这道题难就难在边界的考察。如果对于一般规则的数字“字符串”转化为数字都很容易，比如：<br><img src="https://uploadfiles.nowcoder.com/images/20200506/284295_1588744261164_3DDF36E47CA5CD2FF36EEBF22FAAA1F5" alt="图片说明"><br>对于“123456”可以利用如下代码进行转化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    ans = ans * <span class="number">10</span> + (str[i] - <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>int的范围为 <img src="https://www.nowcoder.com/equation?tex=%5B2%5E%7B31%7D-1%2C%20-2%5E%7B31%7D%5D" alt="图片说明"><br>如果超过了这两个范围该怎么办？<br>其实也很简单，首先判断这个数的正负，如果正数，超过了INT_MAX，就设置为INT_MAX，如果是负数，首先我们不考虑负号，如果超过了INT_MAX+1, 则就置为INT_MAX+1, 最后再根据正负号，来加负号。<br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> neg = str[i]==<span class="string">'-'</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">i = <span class="built_in">isdigit</span>(str[i]) ? i : i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0L</span>; <span class="comment">// 因为INT_MAX+1超过了int的范围</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; len &amp;&amp; <span class="built_in">isdigit</span>(str[i])) &#123;</span><br><span class="line">    ans = ans * <span class="number">10</span> + (str[i++]-<span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!neg &amp;&amp; ans &gt; INT_MAX) &#123;</span><br><span class="line">        ans = INT_MAX;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">//因为此处以为最大值，所以直接break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (neg &amp;&amp; ans &gt; <span class="number">1L</span> + INT_MAX) &#123;</span><br><span class="line">        ans = <span class="number">1L</span> + INT_MAX;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后再考虑一些特殊情况即可。<br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; str[i] == <span class="string">' '</span>) &#123; ++i; &#125; <span class="comment">// 排除开头的空格</span></span><br><span class="line">        <span class="keyword">if</span> (i == len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(str[i]) &amp;&amp; str[i] != <span class="string">'+'</span> &amp;&amp; str[i] != <span class="string">'-'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> neg = str[i]==<span class="string">'-'</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        i = <span class="built_in">isdigit</span>(str[i]) ? i : i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; <span class="built_in">isdigit</span>(str[i])) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + (str[i++]-<span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!neg &amp;&amp; ans &gt; INT_MAX) &#123;</span><br><span class="line">                ans = INT_MAX;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (neg &amp;&amp; ans &gt; <span class="number">1L</span> + INT_MAX) &#123;</span><br><span class="line">                ans = <span class="number">1L</span> + INT_MAX;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != len) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不要此处，就是atoi()库函数的实现</span></span><br><span class="line">        <span class="keyword">return</span> !neg ? <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ans) : <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(-ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是本题有个样例：<br><img src="https://uploadfiles.nowcoder.com/images/20200506/284295_1588744964301_69A71460A384B711484AEC692B79AA00" alt="图片说明"><br>感觉很无语。<br>时间复杂度：O(N)<br>空间复杂度：O(1)</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>构建乘积数组</title>
    <url>/2020/06/05/%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];）</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>不能用除法,只能尽量减少乘法次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">    <span class="keyword">int</span>[] D = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">    D[D.length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = D.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        D[i] = D[i + <span class="number">1</span>] * A[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> C = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.length; i++) &#123;</span><br><span class="line">        B[i] = C * D[i];</span><br><span class="line">        C *= A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/94a4d381a68b47b7a8bed86f2975db46?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/94a4d381a68b47b7a8bed86f2975db46?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><p>根据题目描述，如果可以使用除法，就很简单。但是要求不能使用。</p>
<p>假设：<br><code>left[i] = A[0]*...*A[i-1]</code><br><code>right[i] = A[i+1]*...*A[n-1]</code><br>所以：<br><code>B[i] = left[i] * right[i]</code></p>
<p>这样就避免使用了除法。但是如果对每个B[i], 0&lt;=i&lt;n,都这么求，显然时间复杂度太高。</p>
<p>我们把整个结果画到下面图：<br><img src="https://uploadfiles.nowcoder.com/images/20200506/284295_1588756073632_8F528B3C1F44C5BD5ED7012E809F9A49" alt="图片说明"> </p>
<p>可知：<br><code>left[i+1] = A[0]*...A[i-1]*A[i]</code><br><code>right[i+1] = A{i+2]*...*A[n-1]</code></p>
<p>于是，<br><code>left[i+1] = left[i] * A[i]</code><br><code>right[i] = right[i+1] * A[i+1]</code></p>
<p>所以，我们可以先把所有的left[i]求出，right[i]求出。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">B</span><span class="params">(A.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            B[i] = B[i<span class="number">-1</span>] * A[i<span class="number">-1</span>]; <span class="comment">// left[i]用B[i]代替</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=A.<span class="built_in">size</span>()<span class="number">-2</span>; j&gt;=<span class="number">0</span>; --j) &#123;</span><br><span class="line">            tmp *= A[j+<span class="number">1</span>]; <span class="comment">// right[i]用tmp代替</span></span><br><span class="line">            B[j] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)<br>空间复杂度: O(1)</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>扑克牌顺子</title>
    <url>/2020/06/06/%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(numbers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numbers.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[j] == numbers[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> gap = numbers[<span class="number">4</span>] - numbers[i];</span><br><span class="line">    <span class="keyword">if</span> (gap &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/762836f4d43d43ca9deb273b3de8e1f4?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/762836f4d43d43ca9deb273b3de8e1f4?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<p>题目抽象：给定一个长度为5（排除空vector），包含0-13的数组，判断公差是否为1.</p>
<h2 id="方法一：set-遍历"><a href="#方法一：set-遍历" class="headerlink" title="方法一：set+遍历"></a>方法一：set+遍历</h2><p>我们分两种情况考虑，<br><strong>一.</strong> 如果vector中不包含0的情况：<br>那么如何判断呢？因为需要是顺子，所以首先不能有<strong>重复值</strong>， 如果没有重复值，那么形如<code>[1 2 3 4 5]</code><br><code>[5 6 7 8 9]</code>， 会发现<strong>最大值与最小值的差值应该小于5.</strong></p>
<p><strong>二.</strong> 如果vector中包含0：<br>发现除去0后的值，判断方法和1中是一样的。</p>
<p>所以根据如上两个条件，算法过程如下：</p>
<ol>
<li>初始化一个<code>set</code>，最大值max_ = 0, 最小值min_ = 14 </li>
<li>遍历数组， 对于大于0的整数，没有在set中出现，则加入到set中，同时更新max_, min_ </li>
<li>如果出现在了<code>set</code>中，直接返回<code>false</code> </li>
<li>数组遍历完，最后再判断一下最大值与最小值的差值是否小于5 </li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> max_ = <span class="number">0</span>, min_ = <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> val : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (st.count(val) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                st.insert(val);</span><br><span class="line">                max_ = <span class="built_in">max</span>(max_, val);</span><br><span class="line">                min_ = <span class="built_in">min</span>(min_, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_ - min_ &lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)<br>空间复杂度：O(N)</p>
<h2 id="方法二：排序-遍历"><a href="#方法二：排序-遍历" class="headerlink" title="方法二：排序+遍历"></a>方法二：排序+遍历</h2><p>根据方法一的分析，实现上如果不用set判断是否有重复值的话，还可以先排序，然后如果有重复值，那么肯定相邻。<br>所以代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sort(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, sz = numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;sz; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                ++i; <span class="comment">// i 记录最小值的下标</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j+<span class="number">1</span>&lt;sz &amp;&amp; numbers[j] == numbers[j+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers.back() - numbers[i] &lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(NlogN)<br>空间复杂度：O(1)</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>死锁的条件和解决办法</title>
    <url>/2020/06/07/%E6%AD%BB%E9%94%81%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h3 id="死锁概念和产生原因"><a href="#死锁概念和产生原因" class="headerlink" title="死锁概念和产生原因"></a>死锁概念和产生原因</h3><p>死锁是指多个进程循环等待彼此占有的资源而无限期的僵持等待下去的局面。原因是：</p>
<ul>
<li>系统提供的资源太少了，远不能满足并发进程对资源的需求</li>
<li>进程推进顺序不合适，互相占有彼此需要的资源，同时请求对方占有的资源，往往是程序设计不合理</li>
</ul>
<h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><p>需要同时具有以下四个条件：</p>
<ul>
<li><strong>互斥</strong>条件：即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有</li>
<li><strong>不可抢占</strong>条件：进程所获得的资源在未使用完毕之前，资源申请者不能强行的从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放</li>
<li><strong>占有且等待</strong>条件：进程至少已经占有了一个资源，但又申请了一个新的被其他进程所占有的资源，此时处于等待状态</li>
<li><strong>循环等待</strong>条件：若干个进程形成环形链，每个都占用对方申请的下一个资源</li>
</ul>
<p>只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<h3 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h3><p>为使系统不发生死锁，必须设法破坏产生死锁的四个必要条件之一，或者允许死锁产生，但当死锁发生时能检测出思索，并有能力实现恢复。<br> 一般有死锁的预防、死锁避免、死锁的检测与恢复三种方法。<br> (1) <strong>死锁预防</strong>：破坏导致死锁必要条件中的任意一个就可以预防死锁。例如，要求用户申请资源时一次性申请所需要的全部资源，这就破坏了保持和等待条件；将资源分层，得到上一层资源后，才能够申请下一层资源，它破坏了环路等待条件。预防通常会<strong>降低系统的效率</strong>。</p>
<p>(2) <strong>死锁避免</strong>：避免是指进程在每次申请资源时判断这些操作是否安全，例如，使用银行家算法。死锁避免算法的执行会增加系统的开销。允许前三个必要条件，但通过明智的选择，确保永远不会到达死锁点，因此死锁避免比死锁预防允许更多的并发。</p>
<p>(3) <strong>死锁检测</strong>：不须实现采取任何限制性措施，而是允许系统在运行过程发生死锁，但可通过系统设置的检测机构及时检测出死锁的发生，并精确地确定于死锁相关的进程和资源，然后采取适当的措施，从系统中将已发生的死锁清除掉。死锁预防和避免都是事前措施，而死锁的检测则是判断系统是否处于死锁状态，如果是，则执行死锁解除策略。</p>
<p>(4) <strong>死锁解除</strong>：这是与死锁检测结合使用的，它使用的方式就是剥夺。即将某进程所拥有的资源强行收回，分配给其他的进程。常用方法：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程。死锁检测盒解除有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。</p>
<h4 id="死锁预防："><a href="#死锁预防：" class="headerlink" title="死锁预防："></a>死锁预防：</h4><ul>
<li>打破互斥条件：允许进程同时访问资源（有些资源就是不可以同时访问的，它是设备的固有属性所决定的，不仅不能改变，还应该加以保证。无实用价值）</li>
<li>打破不可抢占条件：比如给进程设置优先级，高优先级的可以抢占资源(实现困难，降低系统性能)</li>
<li>打破占有且等待条件：实行资源预分配策略，即进程在运行前一次性的向系统申请它所需要的全部资源(不可预测资源的使用，利用率低，降低并发性)</li>
<li>破坏循环等待条件：把资源事先分类编号，按优先级分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出（限制和编号实现困难，增加系统开销，有些资源暂时不用也需要先申请，增加了进程对资源的占用时间）</li>
</ul>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>允许进程动态的申请资源，但系统在进行资源分配前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源你分配给进程，否则，让进程等待。<br> 所谓安全状态，是指系统能按某种进程推进顺序，为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，是每个进程都可以顺序的完成。此时成P1P2P3…为安全序列，如果系统无法找到一个安全序列，则称系统处于不安全状态。<br> 并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可以避免进入死锁状态。</p>
<p> 银行家算法是最著名的死锁避免算法。</p>
<p>(1)两种死锁避免算法：</p>
<p>进程启动拒绝：如果一个进程的请求会导致死锁，则不启动该进程。</p>
<p>资源分配拒绝：如果一个进程增加的资源请求会导致死锁，则不允许此分配(<strong>银行家算法</strong>)。</p>
<p>(2)<strong>银行家算法</strong>：</p>
<p>1.如果request&lt;=need，转向步骤2；否则认为出错，因为请求资源大于需要资源。</p>
<p>2.如果request&lt;=available，转向步骤3,；否则尚无足够资源，进程p阻塞；</p>
<p>3.系统尝试为把资源分配给进程P，并修改available、allocation和need的数值。</p>
<p>4.系统执行安全性算法，检查此次分配后系统是否处于安全状态，若安全，才正式将资源分配给进程P，否则将本次试探性分配作废，让进程P等待。</p>
<h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p>资源分配图&amp;&amp;死锁定理</p>
<h4 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h4><p>1）资源剥夺法。挂起某些思索进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源时，而处于资源匮乏的状态。<br> 2）进程撤销法。强制撤销一个或一部分进程并剥夺这些进程的资源。撤销的原则可以按进程的优先级和撤销进程代价的高低进行。<br> 3）进程回退法。让一个或多个进程回退到足以回避死锁的地步，进程回退时资源释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>孩子们的游戏(圆圈中最后剩下的数)</title>
    <url>/2020/06/06/%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F(%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0)/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<p>如果没有小朋友，请返回-1</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (m - <span class="number">1</span> + begin) % n;</span><br><span class="line">        list.remove(t);</span><br><span class="line">        begin = t;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/f78a359491e64a50bce2d89cff857eb6?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/f78a359491e64a50bce2d89cff857eb6?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<p>题目抽象：给定一个由[0…n-1]构成的数组，第一次从0开始数m个数，然后删除，以后每次都从删除的数下一个位置开始数m个数，然后删除，直到剩余一个数字，找出那个数字。<br>比如：arr = [0 1 2 3 4]， m = 3<br>第一次：删除2 ，变成 arr = [0 1 3 4]<br>第二次，删除0，变成 arr = [1 3 4]<br>第三次，删除4，变成 arr = [1 3]<br>第四次，删除1，变成 arr = [3]</p>
<h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p>最开始长度为n，每次删除一个数，长度变为n-1，如果用数组模拟操作的话，删除一个数据，涉及大量的数据搬移操作，所以我们可以使用链表来模拟操作。<br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) </span><br><span class="line">            lt.push_back(i);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            index = (index + m - <span class="number">1</span>) % n;</span><br><span class="line">            <span class="keyword">auto</span> it = lt.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="built_in">std</span>::advance(it, index); <span class="comment">// 让it向后移动index个位置</span></span><br><span class="line">            lt.erase(it);</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lt.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N^2), 每次删除一个节点，需要先找到那个节点，然后再删除，查找的时间复杂度为O(N)<br>空间复杂度：O(N)</p>
<h2 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h2><p>假设f(n, m) 表示最终留下元素的序号。比如上例子中表示为:f(5,3) = 3</p>
<p>首先，长度为 n 的序列会先删除第 m % n 个元素，然后剩下一个长度为 n - 1 的序列。那么，我们可以递归地求解 f(n - 1, m)，就可以知道对于剩下的 n - 1 个元素，最终会留下第几个元素，我们设答案为 x = f(n - 1, m)。</p>
<p>由于我们删除了第 m % n 个元素，将序列的长度变为 n - 1。当我们知道了 f(n - 1, m) 对应的答案 x 之后，我们也就可以知道，长度为 n 的序列最后一个删除的元素，应当是从 m % n 开始数的第 x 个元素。因此有 f(n, m) = (m % n + x) % n = (m + x) % n。</p>
<p>当n等于1时，f(1,m) = 0<br>代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = f(n<span class="number">-1</span>, m);</span><br><span class="line">        <span class="keyword">return</span> (x+m) % n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">return</span> f(n,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)<br>空间复杂度: O(N)</p>
<h2 id="方法三：迭代法"><a href="#方法三：迭代法" class="headerlink" title="方法三：迭代法"></a>方法三：迭代法</h2><p>根据方法二可知，<br>f[1] = 0<br>f[2] = (f{1] + m) % 2<br>f[3] = (f[2] + m) % 3<br>…<br>f[n] = (f[n-1] + m) % n<br>所以代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">            index = (index + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)<br>空间复杂度: O(1)</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>详解布隆过滤器的原理，使用场景和注意事项</title>
    <url>/2020/06/07/%E8%AF%A6%E8%A7%A3%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>转载自<a href="https://zhuanlan.zhihu.com/p/43263751" target="_blank" rel="noopener">详解布隆过滤器的原理，使用场景和注意事项</a></p>
<p>在进入正文之前，之前看到的有句话我觉得说得很好：</p>
<blockquote>
<p>Data structures are nothing different. They are like the bookshelves of your application where you can organize your data. Different data structures will give you different facility and benefits. To properly use the power and accessibility of the data structures you need to know the trade-offs of using one.</p>
<p>大意是不同的数据结构有不同的适用场景和优缺点，你需要仔细权衡自己的需求之后妥善适用它们，布隆过滤器就是践行这句话的代表。</p>
</blockquote>
<h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a><strong>什么是布隆过滤器</strong></h2><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。</p>
<p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h2><p><strong>HashMap 的问题</strong></p>
<p>讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。</p>
<p>还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。</p>
<p><strong>布隆过滤器数据结构</strong></p>
<p>布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：</p>
<p><img src="https://pic3.zhimg.com/80/v2-530c9d4478398718c15632b9aa025c36_720w.jpg" alt="img"></p>
<p>如果我们要映射一个值到布隆过滤器中，我们需要使用<strong>多个不同的哈希函数</strong>生成<strong>多个哈希值，</strong>并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：</p>
<p><img src="https://pic4.zhimg.com/80/v2-a0ee721daf43f29dd42b7d441b79d227_720w.jpg" alt="img"></p>
<p>Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p>
<p><img src="https://pic3.zhimg.com/80/v2-c0c20d8e06308aae1578c16afdea3b6a_720w.jpg" alt="img"></p>
<p>值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，<strong>说明没有任何一个值映射到这个 bit 位上</strong>，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” <strong>存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</strong></p>
<p>这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p>
<h2 id="支持删除么"><a href="#支持删除么" class="headerlink" title="支持删除么"></a>支持删除么</h2><p>感谢评论区提醒，传统的布隆过滤器并不支持删除操作。但是名为 Counting Bloom filter 的变种可以用来测试元素计数个数是否绝对小于某个阈值，它支持元素删除。可以参考文章 <a href="https://cloud.tencent.com/developer/article/1136056" target="_blank" rel="noopener">Counting Bloom Filter 的原理和实现</a></p>
<h2 id="如何选择哈希函数个数和布隆过滤器长度"><a href="#如何选择哈希函数个数和布隆过滤器长度" class="headerlink" title="如何选择哈希函数个数和布隆过滤器长度"></a><strong>如何选择哈希函数个数和布隆过滤器长度</strong></h2><p>很显然，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。</p>
<p>另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。</p>
<p><img src="https://pic4.zhimg.com/80/v2-05d4a17ec47911d9ff0e72dc788d5573_720w.jpg" alt="img">k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率</p>
<p>如何选择适合业务的 k 和 m 值呢，这里直接贴一个公式：</p>
<p><img src="https://pic1.zhimg.com/80/v2-1ed5b79aa7ac2e9cd66c83690fdbfcf0_720w.jpg" alt="img"></p>
<p>如何推导这个公式这里只是提一句，因为对于使用来说并没有太大的意义，你让一个高中生来推会推得很快。k 次哈希函数某一 bit 位未被置为 1 的概率为：</p>
<p><img src="https://www.zhihu.com/equation?tex=%281-%5Cfrac%7B1%7D%7Bm%7D%29%5E%7Bk%7D" alt="[公式]"></p>
<p>插入n个元素后依旧为 0 的概率和为 1 的概率分别是：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cleft%28+1-%5Cfrac%7B1%7D%7Bm%7D+%5Cright%29%5E%7Bnk%7D" alt="[公式]"> <img src="https://www.zhihu.com/equation?tex=1-+%5Cleft%28+1-%5Cfrac%7B1%7D%7Bm%7D+%5Cright%29%5E%7Bnk+%7D" alt="[公式]"></p>
<p>标明某个元素是否在集合中所需的 k 个位置都按照如上的方法设置为 1，但是该方法可能会使算法错误的认为某一原本不在集合中的元素却被检测为在该集合中（False Positives），该概率由以下公式确定</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cleft%5B+1-+%5Cleft%28+1-%5Cfrac%7B1%7D%7Bm%7D+%5Cright%29%5E%7Bnk%7D+%5Cright%5D%5E%7Bk%7D%5Capprox%5Cleft%28+1-e%5E%7B-kn%2Fm%7D+%5Cright%29%5E%7Bk%7D" alt="[公式]"></p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h2><p>常见的适用常见有，利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。</p>
<p>另外，既然你使用布隆过滤器来加速查找和判断是否存在，那么性能很低的哈希函数不是个好选择，推荐 MurmurHash、Fnv 这些。</p>
<p><strong>大Value拆分</strong></p>
<p>Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。</p>
<p>拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><p><a href="https://hackernoon.com/probabilistic-data-structures-bloom-filter-5374112a7832" target="_blank" rel="noopener">https://hackernoon.com/probabilistic-data-structures-bloom-filter-5374112a7832hackernoon.com</a><a href="https://www.jasondavies.com/bloomfilter/" target="_blank" rel="noopener">Bloom Filterswww.jasondavies.com<img src="https://pic2.zhimg.com/v2-8fe8b3a427a0db249407ee62e428f1cd_180x120.jpg" alt="图标"></a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>进程间通信方式</title>
    <url>/2020/06/07/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>链接：<a href="https://www.nowcoder.com/questionTerminal/490a8b7adb02451dbb5b9414397d9a0b" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/490a8b7adb02451dbb5b9414397d9a0b</a><br>来源：牛客网</p>
<ul>
<li>管道:管道中还有命名管道和非命名管道之分，非命名管道只能用于父子进程通讯，命名管道可用于非父子进程，命名管道就是FIFO，管道是先进先出的通讯方式。FIFO是一种先进先出的队列。它类似于一个管道，只允许数据的单向流动。每个FIFO都有一个名字，允许不相关的进程访问同一个FIFO，因此也成为命名管。      </li>
<li>消息队列：是用于两个进程之间的通讯，首先在一个进程中创建一个消息队列，然后再往消息队列中写数据，而另一个进程则从那个消息队列中取数据。需要注意的是，消息队列是用创建文件的方式建立的，如果一个进程向某个消息队列中写入了数据之后，另一个进程并没有取出数据，即使向消息队列中写数据的进程已经结束，保存在消息队列中的数据并没有消失，也就是说下次再从这个消息队列读数据的时候，就是上次的数据！！！      </li>
<li>信号量， 不能传递复杂消息，只能用来同步      </li>
<li>共享内存，只要首先创建一个共享内存区，其它进程按照一定的步骤就能访问到这个共享内存区中的数据，当然可读可写；    </li>
</ul>
<p>​    几种方式的比较：   </p>
<ul>
<li>​     管道：速度慢，容量有限      </li>
<li>​     消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。      </li>
<li>​     信号量：不能传递复杂消息，只能用来同步      </li>
<li>​     共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了一块内存的。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>负载均衡算法总结</title>
    <url>/2020/06/07/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h1><p>常用的6种负载均衡算法：</p>
<h2 id="1、轮询法"><a href="#1、轮询法" class="headerlink" title="1、轮询法"></a>1、轮询法</h2><p>将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</p>
<h2 id="2、加权轮询法"><a href="#2、加权轮询法" class="headerlink" title="2、加权轮询法"></a>2、加权轮询法</h2><p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。</p>
<p>给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p>
<h2 id="3、随机法"><a href="#3、随机法" class="headerlink" title="3、随机法"></a>3、随机法</h2><p>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</p>
<h2 id="4、加权随机法"><a href="#4、加权随机法" class="headerlink" title="4、加权随机法"></a>4、加权随机法</h2><p>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p>
<h2 id="5、源IP地址哈希法"><a href="#5、源IP地址哈希法" class="headerlink" title="5、源IP地址哈希法"></a>5、源IP地址哈希法</h2><p> 源IP地址哈希的思想是根据获取客户端的<code>IP地址</code>，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一<code>IP地址</code>的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问(若后端服务器列表改变,需要一致性哈希算法来优化,见下文)。</p>
<h2 id="6、最小连接数法"><a href="#6、最小连接数法" class="headerlink" title="6、最小连接数法"></a>6、最小连接数法</h2><p>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p>
<h1 id="一致性哈希-Consistent-Hashing"><a href="#一致性哈希-Consistent-Hashing" class="headerlink" title="一致性哈希(Consistent Hashing)"></a>一致性哈希(Consistent Hashing)</h1><p>在上面的源地址hash算法中,存在以下的2个问题</p>
<ol>
<li><p>当一台服务器宕机了或者新添加一台机器之后,这个时候<code>hashCode % servers.size()</code>需要重新计算hash值, 如果在缓存的环境中,所有的请求都会涌向数据库服务器,给数据库服务器带来巨大的压力,可能导致整个系统不可用,形成雪崩效应.</p>
</li>
<li><p>当新增了一台性能强的机器后,利用上述的hash算法无法让新增的性能强的服务器多承担压力.</p>
</li>
</ol>
<p>基于上面的2个问题,提出了hash算法的改进,即Consistent Hashing算法.Consistent Hashing也是一种 hash 算法，简单的说，<strong>在移除 / 添加操作，它能够尽可能小的改变已存在 key 映射关系.</strong></p>
<p>Consistent Hashing算法的原理是它<strong>将hash函数的值域组织成一个环形</strong>,整个空间按照顺时针的方式进行组织,将对应的服务器节点进行hash,将他们映射到hash环上,假设有四台机器node1-4,hash之后如图所示:</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6024043-de85b3798f9d53c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/835/format/webp" alt="img"></p>
<p>接下来使用相同的hash函数,计算出对应的key值和hash值,按照顺时针的方式,分布在node1和node2的key,访问时被定位在node2,分布在node2和node4的key被定位在node4上,以此类推.假设现在新增一个node5,假设hash之后在node2和node4之间,如图所示:</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6024043-326c19e2430af9f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/822/format/webp" alt="img"></p>
<p>那么受影响的节点只有node2和node5,他们将会从新hash,而其他的key的映射将不会变化.</p>
<p>当然,上面描绘了一种很理想的情况,即各个节点在环上分布的十分均匀.正常情况下,当节点数量少的时候,节点分布并不均匀,这时需要引入虚拟节点机制.</p>
<p>部分转载自<a href="https://www.jianshu.com/p/40e196414cfa" target="_blank" rel="noopener">常见的一些负载均衡算法总结</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>ThreadLocal详解</title>
    <url>/2020/06/09/ThreadLocal%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>ThreadLocal 提供<strong>线程局部变量</strong>；一个线程局部变量在多个线程中分别有独立的值(副本)</p>
<h2 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h2><p>用于多线程场景,<strong>避免</strong>一致性问题</p>
<p>一致性问题：</p>
<ol>
<li>发生在多个主体对同一份数据无法达成共识。</li>
<li>包括：分布式一致性问题、并发问题等。</li>
<li>特点：场景多、问题复杂、难以察觉—需要严密的思考甚至数学论证。</li>
</ol>
<p>一致性问题解决办法：</p>
<ol>
<li>排队（例如：锁synchronized、互斥量、管程、屏障等）</li>
<li>投票（例如：Paxos，Raft等）</li>
<li>避免（例如：ThreadLocal等 空间换时间的方式）</li>
</ol>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p><code>ThreadLocal</code>模型:<br><img src="https://segmentfault.com/img/bVbIdVN" alt="image.png"></p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="线程资源持有"><a href="#线程资源持有" class="headerlink" title="线程资源持有"></a>线程资源持有</h3><p>在一个用户一个线程的情况下,用户数据使用ThreadLocal存储,其他程序模块可以方便地拿到分配给当前线程的用户的数据,全局获取,减少编程难度.<br><img src="https://segmentfault.com/img/bVbIcAO" alt="image.png"></p>
<h3 id="线程资源一致性"><a href="#线程资源一致性" class="headerlink" title="线程资源一致性"></a>线程资源一致性</h3><p>以JDBC为例,一个事务分为多个Part,它们在同一个线程中(如Spring响应池中分配的一个线程)请求获取一个数据库连接,将会得到同一个JDBC连接.这样的好处是一个JDBC连接维护了事务的状态,相同事务多次获取连接可以拿到同一个JDBC连接.ThreadLocal帮助需要保持线程一致的资源(如数据库事务)维护一致性,降低编程难度.<br><img src="https://segmentfault.com/img/bVbIcDA" alt="image.png"></p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>在以前C语言中常用<code>setLastError()</code>和<code>getLastError()</code>,多线程下就需要ThreadLocal保证一致性.ThreadLocal帮助只考虑了单线程的程序库,无缝向多线程场景迁移.<br><img src="https://segmentfault.com/img/bVbIcGF" alt="image.png"></p>
<h3 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h3><p>将计算任务分给不同的线程,用<code>ThreadLocal</code>存储本线程的计算结果,然后再汇总.</p>
<p><img src="https://segmentfault.com/img/bVbIcHL" alt="image.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>CAS存在的问题以及解决方案</title>
    <url>/2020/06/11/CAS%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="CAS的由来"><a href="#CAS的由来" class="headerlink" title="CAS的由来"></a>CAS的由来</h2><p>在JDK 5之前Java语言是靠synchronized关键字保证同步的，有锁机制存在以下问题：</p>
<p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p>
<p>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。</p>
<p>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p>
<p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p>
<p>独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。</p>
<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS,compare and swap的缩写，中文翻译成比较并交换。</p>
<p>我们都知道，在java语言之前，并发就已经广泛存在并在服务器领域得到了大量的应用。所以硬件厂商老早就在芯片中加入了大量直至并发操作的原语，从而在硬件层面提升效率。在intel的CPU中，使用cmpxchg指令。</p>
<p>在Java发展初期，java语言是不能够利用硬件提供的这些便利来提升系统的性能的。而随着java不断的发展,Java本地方法(JNI)的出现，使得java程序越过JVM直接调用本地方法提供了一种便捷的方式，因而java在并发的手段上也多了起来。而在Doug Lea提供的cucurenct包中，CAS理论是它实现整个java包的基石。</p>
<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”</p>
<p>通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。</p>
<p>类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。</p>
<h2 id="CAS的目的"><a href="#CAS的目的" class="headerlink" title="CAS的目的"></a>CAS的目的</h2><p>利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。</p>
<h2 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h2><blockquote>
<p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</p>
</blockquote>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</p>
<p>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>AtomicStampedReference 实例使用Demo示例代码:<br><a href="https://www.cnblogs.com/java20130722/p/3206742.html" target="_blank" rel="noopener">https://www.cnblogs.com/java20130722/p/3206742.html</a></p>
<h3 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h3><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p>
<p>转载自<a href="https://blog.csdn.net/hl_java/article/details/90520405" target="_blank" rel="noopener">CAS存在的问题以及解决方案</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java显式锁和隐式锁比较</title>
    <url>/2020/06/10/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8C%E9%9A%90%E5%BC%8F%E9%94%81%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>转载自<a href="https://blog.csdn.net/kaizi_1992/article/details/105550689" target="_blank" rel="noopener">Java并发之显式锁和隐式锁的区别</a></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3NpMS5nbzJ5ZC5jb20vZ2V0LWltYWdlLzBmeFNtQVJGZzVn?x-oss-process=image/format,png" alt="img"></p>
<p>在Java并发编程中，锁有两种实现：使用隐式锁和使用显示锁分别是什么？两者的区别是什么？所谓的显式锁和隐式锁的区别也就是说说Synchronized(下文简称：sync)和lock(下文就用ReentrantLock来代之lock)的区别。</p>
<p>本文主要内容：将通过七个方面详细介绍sync和lock的区别。</p>
<p>Java中隐式锁：synchronized；显式锁：lock</p>
<h2 id="sync和lock的区别"><a href="#sync和lock的区别" class="headerlink" title="sync和lock的区别"></a>sync和lock的区别</h2><h3 id="一：出身不同"><a href="#一：出身不同" class="headerlink" title="一：出身不同"></a>一：出身不同</h3><p>从sync和lock的出身(原始的构成)来看看两者的不同。</p>
<ul>
<li><p>Sync:Java中的关键字，是由JVM来维护的。是JVM层面的锁。</p>
</li>
<li><p>Lock：是JDK5以后才出现的具体的类。使用lock是调用对应的API。是API层面的锁</p>
</li>
</ul>
<p>sync是底层是通过monitorenter进行加锁（底层是通过monitor对象来完成的，其中的wait/notify等方法也是依赖于monitor对象的。只有在同步块或者是同步方法中才可以调用wait/notify等方法的。因为只有在同步块或者是同步方法中，JVM才会调用monitory对象的）；通过monitorexit来退出锁的。</p>
<p>而lock是通过调用对应的API方法来获取锁和释放锁的。</p>
<p>我们通过Javap命令来查看调用sync和lock的汇编指令：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3NpMS5nbzJ5ZC5jb20vZ2V0LWltYWdlLzBmeFNtQjBJam5V?x-oss-process=image/format,png" alt="img"></p>
<p>从编译后的汇编指令，我们也能够清晰的看出sync关键字和lock的区别。</p>
<h3 id="二：使用方式"><a href="#二：使用方式" class="headerlink" title="二：使用方式"></a>二：使用方式</h3><ul>
<li><p>Sync是隐式锁。</p>
</li>
<li><p>Lock是显示锁</p>
</li>
</ul>
<p>所谓的显示和隐式就是在使用的时候，使用者<strong>要不要手动写代码去获取锁和释放锁</strong>的操作。</p>
<p>我们大家都知道，在使用sync关键字的时候，我们使用者根本不用写其他的代码，然后程序就能够获取锁和释放锁了。那是因为当sync代码块执行完成之后，系统会自动的让程序释放占用的锁。Sync是由系统维护的，如果非逻辑问题的话话，是不会出现死锁的。</p>
<p>在使用lock的时候，我们使用者需要手动的获取和释放锁。如果没有释放锁，就有可能导致出现死锁的现象。手动获取锁方法：lock.lock()。释放锁：unlock方法。需要配合tyr/finaly语句块来完成。</p>
<p>两者用法对比如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3NpMS5nbzJ5ZC5jb20vZ2V0LWltYWdlLzBmeFNtQmFBVjBx?x-oss-process=image/format,png" alt="img"></p>
<h3 id="三：等待是否可中断"><a href="#三：等待是否可中断" class="headerlink" title="三：等待是否可中断"></a>三：等待是否可中断</h3><p>Sync是不可中断的。除非抛出异常或者正常运行完成</p>
<p>Lock可以中断的。中断方式：</p>
<p>1：调用设置超时方法<code>tryLock(long timeout ,timeUnit unit)</code></p>
<p>2：调用<code>lockInterruptibly()</code>放到代码块中，然后调用<code>interrupt()</code>方法可以中断</p>
<p>四：加锁的时候是否可以公平</p>
<ul>
<li><p>Sync;非公平锁</p>
</li>
<li><p>lock：两者都可以的。默认是非公平锁。在其构造方法的时候可以传入Boolean值。true：公平锁 false：非公平锁</p>
</li>
</ul>
<p>Lock的公平锁和非公平锁：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3NpMS5nbzJ5ZC5jb20vZ2V0LWltYWdlLzBmeFNtQzE2aEpR?x-oss-process=image/format,png" alt="img"></p>
<h3 id="五：锁能否绑定多个条件condition"><a href="#五：锁能否绑定多个条件condition" class="headerlink" title="五：锁能否绑定多个条件condition"></a>五：锁能否绑定多个条件condition</h3><p>Sync:没有。要么随机唤醒一个线程；要么是唤醒所有等待的线程。</p>
<p>Lock:用来实现分组唤醒需要唤醒的线程，可以精确的唤醒，而不是像sync那样，不能精确唤醒线程。</p>
<h3 id="六：性能"><a href="#六：性能" class="headerlink" title="六：性能"></a>六：性能</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3NpMS5nbzJ5ZC5jb20vZ2V0LWltYWdlLzBmeFNtQ3lBem15?x-oss-process=image/format,png" alt="img"></p>
<h3 id="七-使用锁的方式"><a href="#七-使用锁的方式" class="headerlink" title="七:  使用锁的方式"></a>七:  使用锁的方式</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3NpMS5nbzJ5ZC5jb20vZ2V0LWltYWdlLzBmeFNtRG9URWxF?x-oss-process=image/format,png" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>看图学HTTPS</title>
    <url>/2020/06/11/%E7%9C%8B%E5%9B%BE%E5%AD%A6HTTPS/</url>
    <content><![CDATA[<p>转载自<a href="https://juejin.im/post/5b0274ac6fb9a07aaa118f49" target="_blank" rel="noopener">看图学HTTPS</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前说到HTTPS，在我的概念中就是更安全，需要服务器配置证书，但是到底什么是HTTPS，为什么会更安全，整套流程又是如何实现的，在脑子里没有具体的概念。所以，我花了几天的时间，通过参考一些文章，学习了HTTPS整套机制的实现，想要通过一篇文章把我学习到的东西总结出来，让更多之前不清楚HTTPS到底是什么的同学有一个入门的理解。</p>
<p>我看过的很多文章都是通过大量的文字和协议图来解释，但往往会让人感觉有点枯燥，这篇文章我会通过一幅幅流程图，形象的说明从HTTP到HTTPS的演变过程，让大家可以更容易理解一些。当然，这个只是入门级，如果想要学习更深入的HTTPS的知识，还是要深入到一个个协议里面，看一些大部头，才可以达到完全理解的效果。</p>
<p>本文也会同步到我的<a href="http://blog.liuxuan.site" target="_blank" rel="noopener">个人网站</a>。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="HTTP是什么样的？"><a href="#HTTP是什么样的？" class="headerlink" title="HTTP是什么样的？"></a>HTTP是什么样的？</h2><p>HTTP是属于应用层的协议，它是基于TCP/IP的，所以它只是规定一些要传输的内容，以及头部信息，然后通过TCP协议进行传输，依靠IP协议进行寻址，通过一幅最简单的图来描述：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638197d2ee65cb6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http-1"></p>
<p>客户端发出请求，服务端进行响应，就是这么简单。在整个过程中，没有任何加密的东西，所以它是不安全的，中间人可以进行拦截，获取传输和响应的数据，造成数据泄露。</p>
<h2 id="加个密呢？"><a href="#加个密呢？" class="headerlink" title="加个密呢？"></a>加个密呢？</h2><p>因为上图中数据是明文传输的，我们能想到最简单的提高安全性的方法就是在传输前对数据进行加密，如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638197d2f188c52?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http-2"></p>
<p>这种加密方式叫做：<strong>对称加密</strong>。 加密和解密用同一个秘钥的加密方式叫做对称加密。</p>
<p>好了，我们对数据进行加密了，问题解决了吗？</p>
<h2 id="多个客户端怎么办？"><a href="#多个客户端怎么办？" class="headerlink" title="多个客户端怎么办？"></a>多个客户端怎么办？</h2><p>这是一个客户端，但是在WWW上，是成千上万的客户端，情况会怎样呢？</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638197d2ec7d8ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http-3"></p>
<p>为所有的客户端都应用同一个秘钥A，这种方式很显然是不合理的，破解了一个用户，所有的用户信息都会被盗取。</p>
<p>想一想，是不是还有别的办法呢？</p>
<p>相信大家都可以想到，如果对每一个客户端都用不同的秘钥进行传输是不是就解决这个问题了：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638197d2eab0301?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http-4"></p>
<h2 id="对称加密秘钥如何传输？"><a href="#对称加密秘钥如何传输？" class="headerlink" title="对称加密秘钥如何传输？"></a>对称加密秘钥如何传输？</h2><p>我们对每个客户端应用不同的对称加密秘钥，那么这个秘钥客户端或者服务端是如何知道的呢，只能是在一端生成一个秘钥，然后通过HTTP传输给另一端：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638197d2f463922?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http-5"></p>
<p>那么这个传输秘钥的过程，又如何保证加密？如果被中间人拦截，秘钥也会被获取。也许你会说，对秘钥再进行加密，那又如何保证对秘钥加密的过程，是加密的呢？</p>
<p>好像我们走入了 <strong>while(1)</strong>，出不来了。</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>在对称加密的路上走不通了，我们换个思路，还有一种加密方式叫非对称加密，比如RSA。 非对称加密会有一对秘钥：<strong>公钥</strong>和<strong>私钥</strong>。 公钥加密的内容，只有私钥可以解开，私钥加密的内容，所有的公钥都可以解开（当然是指和秘钥是一对的公钥）。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638197d2f09eab3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http-6"></p>
<p>私钥只保存在服务器端，公钥可以发送给所有的客户端。</p>
<p>在传输公钥的过程中，肯定也会有被中间人获取的风险，但在目前的情况下，至少可以保证客户端通过公钥加密的内容，中间人是无法破解的，因为私钥只保存在服务器端，只有私钥可以破解公钥加密的内容。</p>
<p>现在我们还存在一个问题，如果公钥被中间人拿到篡改呢：</p>
<p><strong>MITM</strong>：Man-in-the-MiddleAttack</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638197d56d46dc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http-7"></p>
<p>客户端拿到的公钥是假的，如何解决这个问题？</p>
<h2 id="第三方认证"><a href="#第三方认证" class="headerlink" title="第三方认证"></a>第三方认证</h2><p>公钥被掉包，是因为客户端无法分辨传回公钥的到底是中间人，还是服务器，这也是密码学中的身份验证问题。</p>
<p>在HTTPS中，使用 <strong>证书 + 数字签名</strong> 来解决这个问题。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638197d961729a3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http-9"></p>
<p>这里假设加密方式是MD5，将网站的信息加密后通过第三方机构的私钥再次进行加密，生成数字签名。</p>
<p><strong>数字证书 = 网站信息 + 数字签名</strong></p>
<p>假如中间人拦截后把服务器的公钥替换为自己的公钥，因为数字签名的存在，会导致客户端验证签名不匹配，这样就防止了中间人替换公钥的问题。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638197d6f402850?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http-10"></p>
<p>浏览器安装后会内置一些权威第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等，验证签名的时候直接就从本地拿到相应第三方机构的公钥，对私钥加密后的数字签名进行解密得到真正的签名，然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。</p>
<h2 id="为什么要有签名？"><a href="#为什么要有签名？" class="headerlink" title="为什么要有签名？"></a>为什么要有签名？</h2><p>大家可以想一下，为什么要有数字签名这个东西呢？</p>
<p>第三方认证机构是一个开放的平台，我们可以去申请，中间人也可以去申请呀：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638197d6fb66044?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http-11"></p>
<p>如果没有签名，只对网站信息进行第三方机构私钥加密的话，会存在下面的问题：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638197d977c8344?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http-12"></p>
<p>因为没有认证，所以中间人也向第三方认证机构进行申请，然后拦截后把所有的信息都替换成自己的，客户端仍然可以解密，并且无法判断这是服务器的还是中间人的，最后造成数据泄露。</p>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>在安全的拿到服务器的公钥之后，客户端会随机生成一个对称秘钥，使用服务器公钥加密，传输给服务端，此后，相关的 <strong>Application Data</strong> 就通过这个随机生成的对称秘钥进行加密/解密，服务器也通过该对称秘钥进行解密/加密：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638197d96d391ca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http-13"></p>
<h2 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h2><p>HTTPS = HTTP + TLS/SSL</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638197d976620af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http-15"></p>
<p>HTTPS中具体的内容还有很多，可以通过下图做一个参考：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638197d98cf3281?imageslim" alt="http-14"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>HTTPS就是使用SSL/TLS协议进行加密传输，让客户端拿到服务器的公钥，然后客户端随机生成一个对称加密的秘钥，使用公钥加密，传输给服务端，后续的所有信息都通过该对称秘钥进行加密解密，完成整个HTTPS的流程。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>显式锁（Lock）及Condition的学习与使用</title>
    <url>/2020/06/10/%E6%98%BE%E5%BC%8F%E9%94%81%EF%BC%88Lock%EF%BC%89%E5%8F%8ACondition%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>转载自<a href="[https://silencedut.github.io/2016/06/12/%E6%98%BE%E7%A4%BA%E9%94%81%EF%BC%88Lock%EF%BC%89%E5%8F%8ACondition%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/](https://silencedut.github.io/2016/06/12/显示锁（Lock）及Condition的学习与使用/)">显示锁（Lock）及Condition的学习与使用</a></p>
<p>synchronized是不错，但它并不完美。它有一些功能性的限制，比如</p>
<ul>
<li>它无法中断一个正在等候获得锁的线程，也无法通过投票得到锁。多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。<br>高并发的情况下会导致性能下降。</li>
<li>synchronized上是非公平的,新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待。</li>
</ul>
<p>而Lock的一些实现类则很好的解决了这些问题。</p>
<h2 id="可重入锁ReentrantLock"><a href="#可重入锁ReentrantLock" class="headerlink" title="可重入锁ReentrantLock"></a>可重入锁ReentrantLock</h2><p>java.util.concurrent.lock 中的Lock 框架是锁定的一个抽象，它允许把锁定的实现作为 Java 类，而不是作为语言的特性来实现。这就为Lock 的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。</p>
<p>ReentrantLock 类实现了Lock ，它拥有与synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。（换句话说，当许多线程都想访问共享资源时，JVM 可以花更少的时候来调度线程，把更多时间用在执行线程上。）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockStudy</span> </span>&#123;     </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">// 锁对象   </span></span><br><span class="line">             </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">                        </span><br><span class="line">        lock.lock();      <span class="comment">// 得到锁       </span></span><br><span class="line">        <span class="keyword">try</span> &#123;                   </span><br><span class="line">            <span class="comment">//doSomething            </span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;                  </span><br><span class="line">            lock.unlock();<span class="comment">// 释放锁                </span></span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，用synchronized修饰的方法或者语句块在代码执行完之后锁自动释放，而是用Lock需要我们手动释放锁，所以为了保证锁最终被释放(发生异常情况)，要把互斥区放在try内，释放锁放在finally内。</p>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>ReentrantLock里有个函数newCondition(),该函数得到一个锁上的”条件”，用于实现线程间的通信，条件变量很大一个程度上是为了解决Object.wait/notify/notifyAll难以使用的问题。</p>
<p>Condition拥有await(),signal(),signalAll(),<strong>await</strong>对应于<strong>Object.wait</strong>，<strong>signal</strong>对应于<strong>Object.notify</strong>，<strong>signalAll</strong>对应于<strong>Object.notifyAll</strong>。特别说明的是<strong>Condition</strong>的接口改变名称就是为了避免与Object中的<strong>wait/notify/notifyAll</strong>的语义和使用上混淆，因为Condition同样有<strong>wait/notify/notifyAll</strong>方法()因为任何类都拥有这些方法。</p>
<p>每一个<strong>Lock</strong>可以有任意数据的<strong>Condition</strong>对象，<strong>Condition</strong>是与<strong>Lock</strong>绑定的，所以就有<strong>Lock</strong>的公平性特性：如果是公平锁，线程为按照FIFO的顺序从<strong>Condition.await</strong>中释放，如果是非公平锁，那么后续的锁竞争就不保证FIFO顺序了。下面是一个用Lock和Condition实现的一个生产者消费者的模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head, tail, count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        items = T[] <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(count == getCapacity()) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            items[tail] = t;</span><br><span class="line">            <span class="keyword">if</span>(++tail==getCapacity())&#123;</span><br><span class="line">                tail = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            T ret = items[head];</span><br><span class="line">            items[head] = <span class="keyword">null</span>;<span class="comment">//GC  </span></span><br><span class="line">            <span class="keyword">if</span> (++head == getCapacity()) &#123;</span><br><span class="line">                head = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signalAll();</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是多个Condition的强大之处，假设缓存队列中已经存满，那么阻塞的肯定是写线程，唤醒的肯定是读线程，相反，阻塞的肯定是读线程，唤醒的肯定是写线程，那么假设只有一个Condition会有什么效果呢，缓存队列中已经存满，这个Lock不知道唤醒的是读线程还是写线程了，如果唤醒的是读线程，皆大欢喜，如果唤醒的是写线程，那么线程刚被唤醒，又被阻塞了，这时又去唤醒，这样就浪费了很多时间。</p>
<h2 id="ReentrantLock与synchronized的对比"><a href="#ReentrantLock与synchronized的对比" class="headerlink" title="ReentrantLock与synchronized的对比"></a>ReentrantLock与synchronized的对比</h2><p>ReentrantLock同样是一个可重入锁，但与目前的 synchronized 实现相比，争用下的 ReentrantLock 实现更具可伸缩性。除了synchronized的功能,多了三个高级功能.</p>
<p>等待可中断,公平锁,绑定多个Condition。</p>
<p>1.等待可中断</p>
<p>在持有锁的线程长时间不释放锁的时候,等待的线程可以选择放弃等待.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tryLock(long timeout, TimeUnit unit)；</span><br></pre></td></tr></table></figure>

<p>2.公平锁</p>
<p>按照申请锁的顺序来一次获得锁称为公平锁.synchronized的是非公平锁,ReentrantLock可以通过构造函数实现公平锁.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new RenentrantLock(boolean fair)；</span><br></pre></td></tr></table></figure>

<p>3.绑定多个Condition</p>
<p>通过多次newCondition可以获得多个Condition对象,可以简单的实现比较复杂的线程同步的功能。通过await(),signal()等方法实现。</p>
<h2 id="Lock的其他实现类"><a href="#Lock的其他实现类" class="headerlink" title="Lock的其他实现类"></a>Lock的其他实现类</h2><p>如ReadWriteLock。ReentrantReadWriteLock实现了ReadWriteLock接口，构造器提供了公平锁和非公平锁两种创建方式。读-写锁定允许对共享数据进行更高级别的并发访问。虽然一次只有一个线程（writer 线程）可以修改共享数据，但在许多情况下，任何数量的线程可以同时读取共享数据（reader 线程）。读写锁适用于读多写少的情况，可以实现更好的并发性。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>为什么 MD5 不能用于存储密码-转载</title>
    <url>/2020/05/15/%E4%B8%BA%E4%BB%80%E4%B9%88%20MD5%20%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E5%AD%98%E5%82%A8%E5%AF%86%E7%A0%81-%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<p>很多软件工程师都认为 MD5 是一种加密算法，然而这种观点其实是大错特错并且十分危险的，作为一个 1992 年第一次被公开的算法，到今天为止已经被发现了一些致命的漏洞，我们在生产环境的任何场景都不应该继续使用 MD5 算法，无论是对数据或者文件的内容进行校验还是用于所谓的『加密』。</p>
<p>这篇文章的主要目的是帮助读者理解 MD5 到底是什么，为什么我们不应该继续使用它，尤其是不应该使用它在数据库中存储密码，作者也希望使用过 MD5 或者明文存储密码的开发者们能够找到更加合理和安全的方式对用户的这些机密信息进行存储（这样也可以间接提高我在各类网站中存储密码的安全性）。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>与『为什么我们不能使用 MD5 来存储密码？』这一问题相似的其实还有『为什么我们不能使用明文来存储密码？』，使用明文来存储密码是一种看起来就不可行的方案，除非我们能够 100% 保证数据库中的密码字段不会被<strong>任何人</strong>访问到，不仅包括潜在的攻击者，还包括系统的开发者和管理员。</p>
<p>不过这是一个非常理想的情况，在实际的生产环境中，我们不能抵御来自黑客的所有攻击，甚至也不能完全阻挡开发者和管理员的访问，因为我们总需要信任并授权一些人或者程序具有当前数据库的所有访问权限，这也就给攻击者留下了可以利用的漏洞，在抵御外部攻击时我们没有办法做到全面，只能尽可能提高攻击者的成本，这也就是使用 MD5 或者其他方式存储密码的原因了。</p>
<p><img src="https://img.draveness.me/md5-hashed-values.png" alt="md5-hashed-values"></p>
<p>很多开发者对于 MD5 的作用和定义都有着非常大的误解，<strong>MD5 并不是一种加密算法，而是一种摘要算法</strong>，我们也可以叫它哈希函数，哈希函数可以将无限键值空间中的所有键都均匀地映射到一个指定大小的键值空间中；一个好的摘要算法能够帮助我们保证文件的完整性，避免攻击者的恶意篡改，但是加密算法或者加密的功能是 —— 通过某种特定的方式来编码消息或者信息，只有授权方可以访问原始数据，而没有被授权的人无法从密文中获取原文。</p>
<p>由于加密需要同时保证消息的秘密性和完整性，所以加密的过程使用一系列的算法，MD5 确实可以在加密的过程中作为哈希函数使用来保证消息的完整性，但是我们还需要另一个算法来保证消息的秘密性，所以由于 MD5 哈希的信息无法被还原，只依靠 MD5 是无法完成加密的。</p>
<blockquote>
<p>在任何场景下，我们都应该避免 MD5 的使用，可以选择更好的摘要算法替代 MD5，例如 SHA256、SHA512。</p>
</blockquote>
<p>聊了这么多对于 MD5 的误解，我们重新回到今天最开始的题目，『为什么 MD5 不能用于存储密码』，对于这个问题有一个最简单的答案，也就是 <strong>MD5 不够安全</strong>。当整个系统中的数据库被攻击者入侵之后，存储密码的摘要而不是明文是我们能够对所有用户的最大保护。需要知道的是，不够安全的不只是 MD5，任何摘要算法在存储密码这一场景下都不够安全，我们在这篇文章中就会哈希函数『为什么哈希函数不能用于存储密码』以及其他相关机制的安全性。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>既然我们已经对哈希函数和加密算法有了一些简单的了解，接下来的这一节中分析使用以下几种不同方式存储密码的安全性：</p>
<ul>
<li>使用哈希存储密码；</li>
<li>使用哈希加盐存储密码；</li>
<li>使用加密算法存储密码；</li>
<li>使用 bcrypt 存储密码；</li>
</ul>
<p>在分析的过程中可能会涉及到一些简单的密码学知识，也会谈到一些密码学历史上的一些事件，不过这对于理解不同方式的安全性不会造成太大的障碍。</p>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>在今天，如果我们直接使用哈希来存储密码，那其实跟存储明文没有太多的区别，所有的攻击者在今天都已经掌握了彩虹表这个工具，我们可以将彩虹表理解成一张预计算的大表，其中存储着一些常见密码的哈希，当攻击者通过入侵拿到某些网站的数据库之后就可以通过预计算表中存储的映射来查找原始密码。</p>
<p><img src="https://img.draveness.me/attack-against-hashed-password.png" alt="attack-against-hashed-password"></p>
<p>攻击者只需要将一些常见密码提前计算一些哈希就可以找到数据库中很多用于存储的密码，Wikipedia 上有一份关于最常见密码的 <a href="https://en.wikipedia.org/wiki/List_of_the_most_common_passwords" target="_blank" rel="noopener">列表</a>，在 2016 年的统计中发现使用情况最多的前 25 个密码占了调查总数的 10%，虽然这不能排除统计本身的不准确因素，但是也足以说明仅仅使用哈希的方式存储密码是不够安全的。</p>
<h3 id="哈希加盐"><a href="#哈希加盐" class="headerlink" title="哈希加盐"></a>哈希加盐</h3><p>仅仅使用哈希来存储密码无法抵御来自彩虹表的攻击，在上世纪 70 到 80 年代，早期版本的 Unix 系统就在 <code>/etc/passwrd</code> 中存储加盐的哈希密码，密码加盐后的哈希与盐会被一起存储在 <code>/etc/passwd</code> 文件中，今天哈希加盐的策略与几十年前的也没有太多的不同，差异可能在于盐的生成和选择：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">md5(salt, password), salt</span><br></pre></td></tr></table></figure>

<p>加盐的方式主要还是为了增加攻击者的计算成本，当攻击者顺利拿到数据库中的数据时，由于每个密码都使用了随机的盐进行哈希，所以预先计算的彩虹表就没有办法立刻破译出哈希之前的原始数据，攻击者对每一个哈希都需要单独进行计算，这样能够增加了攻击者的成本，减少原始密码被大范围破译的可能性。</p>
<p><img src="https://img.draveness.me/attack-against-hashes-of-salted-password.png" alt="attack-against-hashes-of-salted-password"></p>
<p>在这种情况下，攻击者破解一个用户密码的成本其实就等于发现哈希碰撞的概率，因为攻击者其实不需要知道用户的密码是什么，他只需要找到一个值 <code>value</code>，这个值加盐后的哈希与密码加盐后的哈希完全一致就能登录用户的账号：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash(salt, value) = hash(salt, password)</span><br></pre></td></tr></table></figure>

<p>这种情况在密码学中叫做哈希碰撞，也就是两个不同值对应哈希相同，一个哈希函数或者摘要算法被找到哈希碰撞的概率决定了该算法的安全性，早在几十年前，我们就在 MD5 的设计中发现了缺陷并且在随后的发展中找到了低成本快速制造哈希碰撞的方法。</p>
<ol>
<li>1996 年 <a href="https://www.semanticscholar.org/paper/The-Status-of-MD5-After-a-Recent-Attack-Dobbertin/c51288ac5d2a5b8f5c8d20e94fe999ea6379bc65" target="_blank" rel="noopener">The Status of MD5 After a Recent Attack</a> —— 发现了 MD5 设计中的缺陷，但是并没有被认为是致命的缺点，密码学专家开始推荐使用其他的摘要算法；</li>
<li>2004 年 <a href="http://merlot.usc.edu/csac-f06/papers/Wang05a.pdf" target="_blank" rel="noopener">How to Break MD5 and Other Hash Functions</a> —— 发现了 MD5 摘要算法不能抵抗哈希碰撞，我们不能在数字安全领域使用 MD5 算法；</li>
<li>2006 年 <a href="https://www.cs.colorado.edu/~jrblack/papers/md5e-full.pdf" target="_blank" rel="noopener">A Study of the MD5 Attacks: Insights and Improvements</a> —— 创建一组具有相同 MD5 摘要的文件；</li>
<li>2008 年 <a href="https://www.win.tue.nl/hashclash/rogue-ca/" target="_blank" rel="noopener">MD5 considered harmful today</a> —— 创建伪造的 SSL 证书；</li>
<li>2010 年 <a href="https://en.wikipedia.org/wiki/MD5#cite_note-31" target="_blank" rel="noopener">MD5 vulnerable to collision attacks</a> —— CMU 软件工程机构认为 MD5 摘要算法已经在密码学上被破译并且不适合使用;</li>
<li>2012 年 <a href="https://en.wikipedia.org/wiki/Flame_(malware)" target="_blank" rel="noopener">Flame</a> —— 恶意软件利用了 MD5 的漏洞并伪造了微软的数字签名；</li>
</ol>
<p>从过往的历史来看，为了保证用户敏感信息的安全，我们不应该使用 MD5 加盐的方式来存储用户的密码，那么我们是否可以使用更加安全的摘要算法呢？不可以，哈希函数并不是专门用来设计存储用户密码的，所以它的计算可能相对来说还是比较快，攻击者今天可以<strong>通过 GPU 每秒执行上亿次的计算来破解用户的密码</strong>，所以不能使用这种方式存储用户的密码，感兴趣的读者可以了解一下用于恢复密码的工具 <a href="https://hashcat.net/hashcat/" target="_blank" rel="noopener">Hashcat</a>。</p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>既然今天的硬件已经能够很快地帮助攻击者破解用户的密码，那么我们能否通过其他的方式来取代哈希函数来存储密码呢？有些工程师想到使用加密算法来替代哈希函数，这样能够从源头上避免哈希碰撞的的发生，这种方式看起来非常美好，但是有一个致命的缺点，就是我们<strong>如何存储用于加密密码的秘钥</strong>。</p>
<p>既然存储密码的仓库能被泄露，那么用于存储秘钥的服务也可能会被攻击，我们永远都没有办法保证我们的数据库和服务器是安全的，一旦秘钥被攻击者获取，他们就可以轻而易举地恢复用户的密码，因为核对用户密码的过程需要在内存对密码进行解密，这时明文的密码就可能暴露在内存中，依然有导致用户密码泄露的风险。</p>
<p><img src="https://img.draveness.me/encrypted-password.png" alt="encrypted-password"></p>
<p>使用加密的方式存储密码相比于哈希加盐的方式，在一些安全意识和能力较差的公司和网站反而更容易导致密码的泄露和安全事故。</p>
<h3 id="bcrypt"><a href="#bcrypt" class="headerlink" title="bcrypt"></a>bcrypt</h3><p>哈希加盐的方式确实能够增加攻击者的成本，但是今天来看还远远不够，我们需要一种更加安全的方式来存储用户的密码，这也就是今天被广泛使用的 <code>bcrypt</code>，使用 <code>bcrypt</code> 相比于直接使用哈希加盐是一种更加安全的方式，也是我们目前推荐使用的方法，为了增加攻击者的成本，<code>bcrypt</code> 引入了计算成本这一可以调节的参数，能够调节执行 <code>bcrypt</code> 函数的成本。</p>
<p><img src="https://img.draveness.me/cost-of-user-and-attackers.png" alt="cost-of-user-and-attackers"></p>
<p>当我们将验证用户密码的成本提高几个数量级时，攻击者的成本其实也相应的提升了几个数量级，只要我们让攻击者的攻击成本大于硬件的限制，同时保证正常请求的耗时在合理范围内，我们就能够保证用户密码的相对安全。</p>
<blockquote>
<p>“<code>bcrypt</code> was designed for password hashing hence it is a slow algorithm. This is good for password hashing as it reduces the number of passwords by second an attacker could hash when crafting a dictionary attack. “</p>
</blockquote>
<p><code>bcrypt</code> 这一算法就是为哈希密码而专门设计的，所以它是一个执行相对较慢的算法，这也就能够减少攻击者每秒能够处理的密码数量，从而避免攻击者的字典攻击。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> cost := <span class="number">10</span>; cost &lt;= <span class="number">15</span>; cost++ &#123;</span><br><span class="line">		startedAt := time.Now()</span><br><span class="line">		bcrypt.GenerateFromPassword([]<span class="keyword">byte</span>(<span class="string">"password"</span>), cost)</span><br><span class="line">		duration := time.Since(startedAt)</span><br><span class="line">		fmt.Printf(<span class="string">"cost: %d, duration: %v\n"</span>, cost, duration)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run bcrypt.<span class="keyword">go</span></span><br><span class="line">cost: <span class="number">10</span>, duration: <span class="number">51.483401</span>ms</span><br><span class="line">cost: <span class="number">11</span>, duration: <span class="number">100.639251</span>ms</span><br><span class="line">cost: <span class="number">12</span>, duration: <span class="number">202.788492</span>ms</span><br><span class="line">cost: <span class="number">13</span>, duration: <span class="number">399.552731</span>ms</span><br><span class="line">cost: <span class="number">14</span>, duration: <span class="number">801.041128</span>ms</span><br><span class="line">cost: <span class="number">15</span>, duration: <span class="number">1.579692689</span>s</span><br></pre></td></tr></table></figure>

<p>运行上述 <a href="https://play.golang.org/p/uCNm-qckWxQ" target="_blank" rel="noopener">代码片段</a> 时就能发现 <code>cost</code> 和运行时间的关系，算法运行的成本每 <code>+1</code>，当前算法最终的耗时就会翻一倍，这与 <code>bcrypt</code> 算法的实现原理有关，你可以在 <a href="https://en.wikipedia.org/wiki/Bcrypt" target="_blank" rel="noopener">Wikipedia</a> 上找到算法执行过程的伪代码，这可以帮助我们快速理解算法背后的设计。</p>
<p>如果硬件的发展使攻击者能够对使用 <code>bcrypt</code> 存储的密码进行攻击时，我们就可以直接提升 <code>bcrypt</code> 算法的 <code>cost</code> 参数以增加攻击者的成本，这也是 <code>bcrypt</code> 设计上的精妙之处，所以使用 <code>bcrypt</code> 是一种在存储用户密码时比较安全的方式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章分析的问题其实是 —— 当数据库被攻击者获取时，我们怎么能够保证用户的密码很难被攻击者『破译』，作为保护用户机密信息的最后手段，选择安全并且合适的方法至关重要。攻击者能否破解用户的密码一般取决于两个条件：</p>
<ul>
<li>使用的加密算法是否足够安全，使用暴力破解的方式时间成本极高；</li>
<li>足够好的硬件支持，能够支持大规模地高速计算哈希；</li>
</ul>
<p>抵御攻击者的攻击的方式其实就是提高单次算法运行的成本，当我们将用户的验证耗时从 <code>0.1ms</code> 提升到了 <code>500ms</code>，攻击者的计算成本也就提升了 5000 倍，这种结果就是之前需要几小时破解的密码现在需要几年的时间。</p>
<p>不论如何，<strong>使用 MD5、MD5 加盐或者其他哈希的方式来存储密码都是不安全的</strong>，希望各位工程师能够避免在这样的场景下使用 MD5，在其他必须使用哈希函数的场景下也建议使用其他算法代替，例如 SHA-512 等。</p>
<p>当然，如何保证用户机密信息的安全不只是一个密码学问题，它还是一个工程问题，任何工程开发商的疏漏都可能导致安全事故，所以我们作为开发者在与用于敏感信息打交道时也应该小心谨慎、怀有敬畏之心。到最后，我们还是来看一些比较开放的相关问题，有兴趣的读者可以仔细思考一下下面的问题：</p>
<ol>
<li>使用 GPU 每秒可以计算多少 MD5 哈希（数量级）？能够在多长时间破解使用 MD5 加盐存储的密码？</li>
<li>假设计算一次哈希耗时 <code>500ms</code>，破解 <code>bcrypt</code> 算法生成的哈希需要多长时间？</li>
<li>MD5 哈希 <code>23cdc18507b52418db7740cbb5543e54</code> 对应的原文可能是？谈谈你使用的工具和破译的过程。</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://security.stackexchange.com/questions/61489/is-salted-md5-or-salted-sha-considered-secure" target="_blank" rel="noopener">Is salted MD5 or salted SHA considered secure?</a></li>
<li><a href="https://security.stackexchange.com/questions/211/how-to-securely-hash-passwords?noredirect=1&lq=1" target="_blank" rel="noopener">How to securely hash passwords?</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rainbow_table" target="_blank" rel="noopener">Rainbow table</a></li>
<li><a href="https://tools.ietf.org/html/rfc1321" target="_blank" rel="noopener">The MD5 Message-Digest Algorithm · RFC1321</a></li>
<li><a href="https://en.wikipedia.org/wiki/Collision_(computer_science)" target="_blank" rel="noopener">Collision (computer science)</a></li>
<li><a href="https://www.sitepoint.com/why-you-should-use-bcrypt-to-hash-stored-passwords/" target="_blank" rel="noopener">Why You Should Use Bcrypt to Hash Stored Passwords</a></li>
<li><a href="https://stackoverflow.com/questions/6832445/how-can-bcrypt-have-built-in-salts" target="_blank" rel="noopener">How can bcrypt have built-in salts?</a></li>
<li><a href="https://en.wikipedia.org/wiki/Bcrypt" target="_blank" rel="noopener">bcrypt</a></li>
</ul>
<p>转载自<a href="https://draveness.me/whys-the-design-password-with-md5/" target="_blank" rel="noopener">https://draveness.me/whys-the-design-password-with-md5/</a></p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title>为什么 TCP 协议有粘包问题-转载</title>
    <url>/2020/05/15/%E4%B8%BA%E4%BB%80%E4%B9%88%20TCP%20%E5%8D%8F%E8%AE%AE%E6%9C%89%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98-%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<p>TCP/IP 协议簇建立了互联网中通信协议的概念模型，该协议簇中的两个主要协议就是 TCP 和 IP 协议。TCP/ IP 协议簇中的 TCP 协议能够保证数据段（Segment）的可靠性和顺序，有了可靠的传输层协议之后，应用层协议就可以直接使用 TCP 协议传输数据，不在需要关心数据段的丢失和重复问题<a href="https://draveness.me/whys-the-design-tcp-message-frame/#fn:1" target="_blank" rel="noopener">1</a>。</p>
<p><img src="https://img.draveness.me/2020-03-05-15834216958567-tcp-and-application-protocols.png" alt="tcp-and-application-protocols"></p>
<p><strong>图 1 - TCP 协议与应用层协议</strong></p>
<p>IP 协议解决了数据包（Packet）的路由和传输，上层的 TCP 协议不再关注路由和寻址<a href="https://draveness.me/whys-the-design-tcp-message-frame/#fn:2" target="_blank" rel="noopener">2</a>，那么 TCP 协议解决的是传输的可靠性和顺序问题，上层不需要关心数据能否传输到目标进程，只要写入 TCP 协议的缓冲区的数据，协议栈几乎都能保证数据的送达。</p>
<p>当应用层协议使用 TCP 协议传输数据时，TCP 协议可能会将应用层发送的数据分成多个包依次发送，而数据的接收方收到的数据段可能有多个『应用层数据包』组成，所以当应用层从 TCP 缓冲区中读取数据时发现粘连的数据包时，需要对收到的数据进行拆分。</p>
<p>粘包并不是 TCP 协议造成的，它的出现是因为应用层协议设计者对 TCP 协议的错误理解，忽略了 TCP 协议的定义并且缺乏设计应用层协议的经验。本文将从 TCP 协议以及应用层协议出发，分析我们经常提到的 TCP 协议中的粘包是如何发生的：</p>
<ul>
<li>TCP 协议是面向字节流的协议，它可能会组合或者拆分应用层协议的数据；</li>
<li>应用层协议的没有定义消息的边界导致数据的接收方无法拼接数据；</li>
</ul>
<p>很多人可能会认为粘包是一个比较低级的甚至不值得讨论的问题，但是在作者看来这个问题还是很有趣的，不是所有人都系统性地学过基于 TCP 的应用层协议设计，也不是所有人对 TCP 协议也没有那么深入的理解，相信很多人学习编程的过程都是自底向上的，所以作者认为这是一个值得回答的问题，我们应该传递正确的知识，而不是负面的和居高临下的情绪。</p>
<h2 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h2><p>TCP 协议是面向连接的、可靠的、基于字节流的传输层通信协议<a href="https://draveness.me/whys-the-design-tcp-message-frame/#fn:3" target="_blank" rel="noopener">3</a>，应用层交给 TCP 协议的数据并不会以消息为单位向目的主机传输，这些数据在某些情况下会被组合成一个数据段发送给目标的主机。</p>
<p>Nagle 算法是一种通过减少数据包的方式提高 TCP 传输性能的算法<a href="https://draveness.me/whys-the-design-tcp-message-frame/#fn:4" target="_blank" rel="noopener">4</a>。因为网络 带宽有限，它不会将小的数据块直接发送到目的主机，而是会在本地缓冲区中等待更多待发送的数据，这种批量发送数据的策略虽然会影响实时性和网络延迟，但是能够降低网络拥堵的可能性并减少额外开销。</p>
<p>在早期的互联网中，Telnet 是被广泛使用的应用程序，然而使用 Telnet 会产生大量只有 1 字节负载的有效数据，每个数据包都会有 40 字节的额外开销，带宽的利用率只有 ~2.44%，Nagle 算法就是在当时的这种场景下设计的。</p>
<p>当应用层协议通过 TCP 协议传输数据时，实际上待发送的数据先被写入了 TCP 协议的缓冲区，如果用户开启了 Nagle 算法，那么 TCP 协议可能不会立刻发送写入的数据，它会等待缓冲区中数据超过最大数据段（MSS）或者上一个数据段被 ACK 时才会发送缓冲区中的数据。</p>
<p><img src="https://img.draveness.me/2020-03-05-15834216958612-nagle-algorithm.png" alt="nagle-algorithm"></p>
<p><strong>图 2 - Nagle 算法</strong></p>
<p>几十年前还会发生网络拥塞的问题，但是今天的网络带宽资源不再像过去那么紧张，在默认情况下，Linux 内核都会使用如下的方式默认关闭 Nagle 算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCP_NODELAY = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Linux 内核中使用如下所示的 <a href="https://github.com/torvalds/linux/blob/bd2463ac7d7ec51d432f23bf0e893fb371a908cd/net/ipv4/tcp_output.c#L1897" target="_blank" rel="noopener"><code>tcp_nagle_test</code></a> 函数测试我们是否应该发送当前的 TCP 数据段，感兴趣的读者可以以这段代码为入口详细了解 Nagle 算法在今天的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">tcp_nagle_test</span><span class="params">(<span class="keyword">const</span> struct tcp_sock *tp, <span class="keyword">const</span> struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">unsigned</span> <span class="keyword">int</span> cur_mss, <span class="keyword">int</span> nonagle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nonagle &amp; TCP_NAGLE_PUSH)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcp_urg_mode(tp) || (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tcp_nagle_check(skb-&gt;len &lt; cur_mss, tp, nonagle))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nagle 算法确实能够在数据包较小时提高网络带宽的利用率并减少 TCP 和 IP 协议头带来的额外开销，但是使用该算法也可能会导致应用层协议多次写入的数据被合并或者拆分发送，当接收方从 TCP 协议栈中读取数据时会发现不相关的数据出现在了同一个数据段中，应用层协议可能没有办法对它们进行拆分和重组。</p>
<p>除了 Nagle 算法之外，TCP 协议栈中还有另一个用于延迟发送数据的选项 <code>TCP_CORK</code>，如果我们开启该选项，那么当发送的数据小于 MSS 时，TCP 协议就会延迟 200ms 发送该数据或者等待缓冲区中的数据超过 MSS<a href="https://draveness.me/whys-the-design-tcp-message-frame/#fn:5" target="_blank" rel="noopener">5</a>。</p>
<p>无论是 <code>TCP_NODELAY</code> 还是 <code>TCP_CORK</code>，它们都会通过延迟发送数据来提高带宽的利用率，它们会对应用层协议写入的数据进行拆分和重组，而这些机制和配置能够出现的最重要原因是 — TCP 协议是基于字节流的协议，其本身没有数据包的概念，不会按照数据包发送数据。</p>
<h2 id="消息边界"><a href="#消息边界" class="headerlink" title="消息边界"></a>消息边界</h2><p>如果我们系统性地学习过 TCP 协议以及基于 TCP 的应用层协议设计，那么设计一个能够被 TCP 协议栈任意拆分和组装数据包的应用层协议就不会有什么问题。既然 TCP 协议是基于字节流的，这其实就意味着应用层协议要自己划分消息的边界。</p>
<p>如果我们能在应用层协议中定义消息的边界，那么无论 TCP 协议如何对应用层协议的数据包进程拆分和重组，接收方都能根据协议的规则恢复对应的消息。在应用层协议中，最常见的两种解决方案就是基于长度或者基于终结符（Delimiter）。</p>
<p><img src="https://img.draveness.me/2020-03-05-15834216958643-message-framing.png" alt="message-framing"></p>
<p><strong>图 3 - 实现消息边界的方法</strong></p>
<p>基于长度的实现有两种方式，一种是使用固定长度，所有的应用层消息都使用统一的大小，另一种方式是使用不固定长度，但是需要在应用层协议的协议头中增加表示负载长度的字段，这样接收方才可以从字节流中分离出不同的消息，HTTP 协议的消息边界就是基于长度实现的：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=UTF-8</span><br><span class="line"><span class="attribute">Content-Length</span>: 138</span><br><span class="line">...</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;An Example Page&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Hello World, this is a very simple HTML document.&lt;/p&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>在上述 HTTP 消息中，我们使用 <code>Content-Length</code> 头表示 HTTP 消息的负载大小，当应用层协议解析到足够的字节数后，就能从中分离出完整的 HTTP 消息，无论发送方如何处理对应的数据包，我们都可以遵循这一规则完成 HTTP 消息的重组<a href="https://draveness.me/whys-the-design-tcp-message-frame/#fn:6" target="_blank" rel="noopener">6</a>。</p>
<p>不过 HTTP 协议除了使用基于长度的方式实现边界，也会使用基于终结符的策略，当 HTTP 使用块传输（Chunked Transfer）机制时，HTTP 头中就不再包含 <code>Content-Length</code> 了，它会使用负载大小为 0 的 HTTP 消息作为终结符表示消息的边界。</p>
<p>当然除了这两种方式之外，我们可以基于特定的规则实现消息的边界，例如：使用 TCP 协议发送 JSON 数据，接收方可以根据接收到的数据是否能够被解析成合法的 JSON 判断消息是否终结。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TCP 协议粘包问题是因为应用层协议开发者的错误设计导致的，他们忽略了 TCP 协议数据传输的核心机制 — 基于字节流，其本身不包含消息、数据包等概念，所有数据的传输都是流式的，需要应用层协议自己设计消息的边界，即消息帧（Message Framing），我们重新回顾一下粘包问题出现的核心原因：</p>
<ol>
<li>TCP 协议是基于字节流的传输层协议，其中不存在消息和数据包的概念；</li>
<li>应用层协议没有使用基于长度或者基于终结符的消息边界，导致多个消息的粘连；</li>
</ol>
<p>网络协议的学习过程非常有趣，不断思考背后的问题能够让我们对定义有更深的认识。到最后，我们还是来看一些比较开放的相关问题，有兴趣的读者可以仔细思考一下下面的问题：</p>
<ul>
<li>基于 UDP 协议的应用层协议应该如何设计？会出现粘包的问题么？</li>
<li>有哪些应用层协议使用基于长度的分帧？又有哪些使用基于终结符的分帧？</li>
</ul>
<blockquote>
<p>如果对文章中的内容有疑问或者想要了解更多软件工程上一些设计决策背后的原因，可以在博客下面留言，作者会及时回复本文相关的疑问并选择其中合适的主题作为后续的内容。</p>
</blockquote>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="https://draveness.me/whys-the-design-tcp-three-way-handshake" target="_blank" rel="noopener">为什么 TCP 建立连接需要三次握手</a></li>
<li><a href="https://draveness.me/whys-the-design-tcp-segment-ip-packet" target="_blank" rel="noopener">为什么 TCP/IP 协议会拆分数据</a></li>
</ul>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li>JC Mogul. “Rethinking the TCP Nagle Algorithm” <a href="http://ccr.sigcomm.org/archive/2001/jan01/ccr-200101-mogul.pdf" target="_blank" rel="noopener">http://ccr.sigcomm.org/archive/2001/jan01/ccr-200101-mogul.pdf</a></li>
<li>Stephen Cleary. Apr 30, 2009. “Message Framing” <a href="https://blog.stephencleary.com/2009/04/message-framing.html" target="_blank" rel="noopener">https://blog.stephencleary.com/2009/04/message-framing.html</a></li>
</ul>
<hr>
<ol>
<li>Wikipedia: Internet protocol suite <a href="https://en.wikipedia.org/wiki/Internet_protocol_suite" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Internet_protocol_suite</a> <a href="https://draveness.me/whys-the-design-tcp-message-frame/#fnref:1" target="_blank" rel="noopener">↩︎</a></li>
<li>What is the Internet Protocol? <a href="https://www.cloudflare.com/learning/ddos/glossary/internet-protocol/" target="_blank" rel="noopener">https://www.cloudflare.com/learning/ddos/glossary/internet-protocol/</a> <a href="https://draveness.me/whys-the-design-tcp-message-frame/#fnref:2" target="_blank" rel="noopener">↩︎</a></li>
<li>Wikipedia: Transmission Control Procol <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Transmission_Control_Protocol</a> <a href="https://draveness.me/whys-the-design-tcp-message-frame/#fnref:3" target="_blank" rel="noopener">↩︎</a></li>
<li>Nagle, J., “Congestion Control in IP/TCP Internetworks”, RFC 896, DOI 10.17487/RFC0896, January 1984, <a href="https://www.rfc-editor.org/info/rfc896" target="_blank" rel="noopener">https://www.rfc-editor.org/info/rfc896</a>. <a href="https://draveness.me/whys-the-design-tcp-message-frame/#fnref:4" target="_blank" rel="noopener">↩︎</a></li>
<li>Is there any significant difference between TCP_CORK and TCP_NODELAY in this use-case? <a href="https://stackoverflow.com/questions/22124098/is-there-any-significant-difference-between-tcp-cork-and-tcp-nodelay-in-this-use" target="_blank" rel="noopener">https://stackoverflow.com/questions/22124098/is-there-any-significant-difference-between-tcp-cork-and-tcp-nodelay-in-this-use</a> <a href="https://draveness.me/whys-the-design-tcp-message-frame/#fnref:5" target="_blank" rel="noopener">↩︎</a></li>
<li>Wikipedia: Hypertext Transfer Protocol <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a> <a href="https://draveness.me/whys-the-design-tcp-message-frame/#fnref:6" target="_blank" rel="noopener">↩︎</a></li>
</ol>
<p><a href="https://draveness.me/whys-the-design-tcp-message-frame/" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>Java中的静态代理与动态代理</title>
    <url>/2020/05/16/Java%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p><a href="https://chenjiayang.me/2018/10/05/dynamic-proxy/" target="_blank" rel="noopener">原文地址</a> 作者:<a href="https://www.yuque.com/chenjiayang" target="_blank" rel="noopener"><strong>YoungChen</strong></a></p>
<h2 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h2><p>人话来讲就是由代理对象来执行目标对象的方法，且还可以在代理对象中增强目标对象方法的一种设计模式。类比生活，像是房产中介。代理模式存在的意义和一个架构设计原则息息相关 —— 开闭原则（对扩展开放，对修改关闭），即一种好的设计模式，都是在不修改原有形态的基础上扩展出新的功能。</p>
<h2 id="为什么需要代理"><a href="#为什么需要代理" class="headerlink" title="为什么需要代理"></a>为什么需要代理</h2><p>代理模式的概念很容易理解，但是早期的我即使读懂了代理模式的概念，对为什么要使用代理模式，还是一头雾水。为什么我不直接调用目标对象的方法，非得要借助个代理对象呢？</p>
<h3 id="1-调用的目标对象在远程主机上，并不在你本地"><a href="#1-调用的目标对象在远程主机上，并不在你本地" class="headerlink" title="1. 调用的目标对象在远程主机上，并不在你本地"></a>1. 调用的目标对象在远程主机上，并不在你本地</h3><p>类似中介就是房东出国了，联系不上，你只能跟我沟通。对应到我们程序设计的时候就是：客户端无法直接操作实际目标对象。为什么无法直接操作？一种情况是你需要调用的对象在另外一台机器上，你需要跨越网络才能访问，如果让你直接编码实现远程调用，你需要处理网络连接、处理打包、解包等等非常复杂的步骤，所以为了简化客户端的处理，我们使用代理模式，在客户端建立一个远程目标对象的代理，客户端就象调用本地对象一样调用该代理，再由代理去跟实际对象联系，对于客户端来说背后这个通信过程是透明的。</p>
<h3 id="2-你不想理会目标类繁杂的功能，只希望增加一些自己的行为进去"><a href="#2-你不想理会目标类繁杂的功能，只希望增加一些自己的行为进去" class="headerlink" title="2. 你不想理会目标类繁杂的功能，只希望增加一些自己的行为进去"></a>2. 你不想理会目标类繁杂的功能，只希望增加一些自己的行为进去</h3><p>例如常见的例子就是 Spring AOP 实现日志功能，你不必关心目标类究竟如何繁杂，你只是想要在前后调用的时候打印一下日志，那么你就可以使用代理模式，通过 AOP 提供的切面进行编码实现，你通过代理模式达到了在目标对象的方法前后增加了一些自定义行为的目的。类似的例子还有权限校验。这样做的好处有很多，一方面你需要在意目标类的代码，二来你维护了目标类功能的单一性，而不是将日志或者权限校验的功能硬编码到目标类的方法中。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理非常简单，就是实现类和代理类均实现同样的接口，然后在代理类中通过构造器将接口或者实现类注入进来，然后就可以在代理类的方法实现中增加一些自己的逻辑。看个 <a href="https://www.cnblogs.com/daniels/p/8242592.html" target="_blank" rel="noopener">例子</a> 就懂了：</p>
<h3 id="静态代理的例子"><a href="#静态代理的例子" class="headerlink" title="静态代理的例子"></a>静态代理的例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BuyHouse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buyHosue</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyHouseImpl</span> <span class="keyword">implements</span> <span class="title">BuyHouse</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyHosue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HHHHH"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyHouseProxy</span> <span class="keyword">implements</span> <span class="title">BuyHouse</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> BuyHouse buyHouse;</span><br><span class="line">    <span class="comment">// 将接口引入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuyHouseProxy</span><span class="params">(<span class="keyword">final</span> BuyHouse buyHouse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buyHouse = buyHouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyHosue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 增加一些自己的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"HHHHH"</span>);</span><br><span class="line">        buyHouse.buyHosue();</span><br><span class="line">        System.out.println(<span class="string">"66666"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态代理的缺点"><a href="#静态代理的缺点" class="headerlink" title="静态代理的缺点"></a>静态代理的缺点</h3><p>很明显，静态代理中，一个代理类只能对一个业务接口的实现类进行包装，如果有多个业务接口的话就要定义很多实现类和代理类才行。而且，如果代理类对业务方法的预处理、调用后操作都是一样的（比如：调用前输出提示、调用后自动关闭连接），则多个代理类就会有很多重复代码。这时我们可以定义这样一个代理类，它能代理所有实现类的方法调用：根据传进来的业务实现类和方法名进行具体调用。即动态代理模式。Java 中常见的有 JDK 动态代理和 CGLib 动态代理，前者只能代理接口，后者可以代理实现类。</p>
<h2 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h2><p>JDK 的动态代理使用到 Java reflect 包下的 Proxy 类和 InvocationHandler 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HHHHH"</span>);</span><br><span class="line">        Object result = method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">"66666"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyHouse buyHouse = <span class="keyword">new</span> BuyHouseImpl();</span><br><span class="line">        BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(BuyHouse.class.getClassLoader(), new Class[]&#123;BuyHouse.class&#125;, new DynamicProxyHandler(buyHouse));</span><br><span class="line">        proxyBuyHouse.buyHosue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DynamicProxyHandler 实现了 InvocationHandler 接口，并复写其 invoke 方法，我们可以看到 invoke 方法的参数是实现类和方法参数列表。测试类中通过 newProxyInstance 这个静态工厂方法创建了代理对象，代理对象的每个执行方法都会替换执行InvocationHandler 中的 invoke 方法。这个方法总共有3个参数：</p>
<ol>
<li>ClassLoader loader用来指明生成代理对象使用哪个类装载器</li>
<li>Class&lt;?&gt;[] interfaces用来指明生成哪个对象的代理对象，通过接口指定，这就是为什么 JDK 动态代理必须要通过接口的方式</li>
<li>InvocationHandler 用来指明产生的这个代理对象要做什么事情。</li>
</ol>
<p>newProxyInstance 内部本质上是根据反射机制生成了一个新类。</p>
<h2 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a>CGLib 动态代理</h2><p>CGLib 是针对类来实现代理的，原理是对指定的实现类生成一个子类，并覆盖其中的方法实现代理。因为采用的是继承，所以不能对final 修饰的类进行代理。<a href="https://www.cnblogs.com/ygj0930/p/6542259.html" target="_blank" rel="noopener">例子</a> 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现类，有没有实现接口无所谓</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeImpl</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"新增图书..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeCglib</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 业务类对象，供代理方法中进行真正的业务方法调用</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 相当于JDK动态代理中的绑定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 给业务对象赋值</span></span><br><span class="line">        <span class="keyword">this</span>.target = target;  </span><br><span class="line">        <span class="comment">// 创建加强器，用来创建动态代理类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer(); </span><br><span class="line">        <span class="comment">// 为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）</span></span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());  </span><br><span class="line">        <span class="comment">// 设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>); </span><br><span class="line">       <span class="comment">// 创建动态代理类对象并返回 </span></span><br><span class="line">       <span class="keyword">return</span> enhancer.create(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现回调方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"预处理——————"</span>);</span><br><span class="line">        <span class="comment">//调用业务类（父类中）的方法</span></span><br><span class="line">        proxy.invokeSuper(obj, args); </span><br><span class="line">        System.out.println(<span class="string">"调用后操作——————"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      </span><br><span class="line">    BookFacadeImpl bookFacade = <span class="keyword">new</span> BookFacadeImpl()；</span><br><span class="line">    BookFacadeCglib cglib = <span class="keyword">new</span> BookFacadeCglib();  </span><br><span class="line">    BookFacadeImpl bookCglib = (BookFacadeImpl)cglib.getInstance(bookFacade);  </span><br><span class="line">    bookCglib.addBook(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.cnblogs.com/ygj0930/p/6542259.html" target="_blank" rel="noopener">Java动态代理之JDK实现和CGlib实现（简单易懂）</a></li>
<li><a href="https://www.cnblogs.com/xiaoluo501395377/p/3383130.html" target="_blank" rel="noopener">java的动态代理机制详解</a></li>
<li><a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html" target="_blank" rel="noopener">java动态代理实现与原理详细分析</a></li>
</ol>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><ul>
<li>本文遵守创作共享 <a href="https://link.zhihu.com/?target=https%3A//creativecommons.org/licenses/by-nc-sa/3.0/cn/">CC BY-NC-SA 3.0协议</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>为什么 Redis 快照使用子进程</title>
    <url>/2020/05/18/%E4%B8%BA%E4%BB%80%E4%B9%88%20Redis%20%E5%BF%AB%E7%85%A7%E4%BD%BF%E7%94%A8%E5%AD%90%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://draveness.me/whys-the-design-redis-single-thread/" target="_blank" rel="noopener">原文链接</a> 作者:Draven</p>
<p>虽然我们经常将 Redis 看做一个纯内存的键值存储系统，但是我们也会用到它的持久化功能，RDB 和 AOF 就是 Redis 为我们提供的两种持久化工具，其中 RDB 就是 Redis 的数据快照，我们在这篇文章想要分析 Redis 为什么在对数据进行快照持久化时会需要使用子进程，而不是将内存中的数据结构直接导出到磁盘上进行存储。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在具体分析今天的问题之前，我们首先需要了解 Redis 的持久化存储机制 RDB 究竟是什么，RDB 会每隔一段时间中对 Redis 服务中当下的数据集进行快照，除了 Redis 的配置文件可以对快照的间隔进行设置之外，Redis 客户端还同时提供两个命令来生成 RDB 存储文件，也就是 <code>SAVE</code> 和 <code>BGSAVE</code>，通过命令的名字我们就能猜出这两个命令的区别。</p>
<p><img src="https://img.draveness.me/save-and-bgsave.png" alt="save-and-bgsave"></p>
<p>其中 <code>SAVE</code> 命令在执行时会直接阻塞当前的线程，由于 Redis 是 <a href="https://draveness.me/whys-the-design-redis-single-thread" target="_blank" rel="noopener">单线程</a> 的，所以 <code>SAVE</code> 命令会直接阻塞来自客户端的所有其他请求，这在很多时候对于需要提供较强可用性保证的 Redis 服务都是无法接受的。</p>
<p>我们往往需要 <code>BGSAVE</code> 命令在后台生成 Redis 全部数据对应的 RDB 文件，当我们使用 <code>BGSAVE</code> 命令时，Redis 会立刻 <code>fork</code> 出一个子进程，子进程会执行『将内存中的数据以 RDB 格式保存到磁盘中』这一过程，而 Redis 服务在 <code>BGSAVE</code> 工作期间仍然可以处理来自客户端的请求。</p>
<p><a href="https://github.com/antirez/redis/blob/e916058f0ba59e964f5de3dee17f46ae08f1d385/src/rdb.c#L1343-L1378" target="_blank" rel="noopener"><code>rdbSaveBackground</code></a> 就是用来处理在后台将数据保存到磁盘上的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasActiveChildProcess()) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((childpid = redisFork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        redisSetProcTitle(<span class="string">"redis-rdb-bgsave"</span>);</span><br><span class="line">        retval = rdbSave(filename,rsi);</span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK) &#123;</span><br><span class="line">            sendChildCOWInfo(CHILD_INFO_TYPE_RDB, <span class="string">"RDB"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exitFromChild((retval == C_OK) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis 服务器会在触发 <code>BGSAVE</code> 时调用 <code>redisFork</code> 函数来创建子进程并调用 <code>rdbSave</code> 在子进程中对数据进行持久化，我们在这里虽然省略了函数中的一些内容，但是整体的结构还是非常清晰的，感兴趣的读者可以在点击上面的链接了解整个函数的实现。</p>
<p>使用 <code>fork</code> 的目的最终一定是为了不阻塞主进程来提升 Redis 服务的可用性，但是到了这里我们其实能够发现两个问题：</p>
<ol>
<li>为什么 <code>fork</code> 之后的子进程能够获取父进程内存中的数据？</li>
<li><code>fork</code> 函数是否会带来额外的性能开销，这些开销我们怎么样才可以避免？</li>
</ol>
<p>既然 Redis 选择使用了 <code>fork</code> 的方式来解决快照持久化的问题，那就说明这两个问题已经有了答案，首先 <code>fork</code> 之后的子进程是可以获取父进程内存中的数据的，而 <code>fork</code> 带来的额外性能开销相比阻塞主线程也一定是可以接受的，只有同时具备这两点，Redis 最终才会选择这样的方案。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>为了分析上一节提出的两个问题，我们在这里需要了解以下的这些内容，这些内容是 Redis 服务器使用 <code>fork</code> 函数的前提条件，也是最终促使它选择这种实现方式的关键：</p>
<ol>
<li>通过 <code>fork</code> 生成的父子进程会共享包括内存空间在内的资源；</li>
<li><code>fork</code> 函数并不会带来明显的性能开销，尤其是对内存进行大量的拷贝，它能通过写时拷贝将拷贝内存这一工作推迟到真正需要的时候；</li>
</ol>
<h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h3><p>在计算机编程领域，尤其是 Unix 和类 Unix 系统中，<code>fork</code> 都是一个进程用于创建自己拷贝的操作，它往往都是被操作系统内核实现的系统调用，也是操作系统在 *nix 系统中创建新进程的主要方法。</p>
<p><img src="https://img.draveness.me/fork-and-processes.png" alt="fork-and-processes"></p>
<p>当程序调用了 <code>fork</code> 方法之后，我们就可以通过 <code>fork</code> 的返回值确定父子进程，以此来执行不同的操作：</p>
<ul>
<li><code>fork</code> 函数返回 0 时，意味着当前进程是子进程；</li>
<li><code>fork</code> 函数返回非 0 时，意味着当前进程是父进程，返回值是子进程的 <code>pid</code>；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child process</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent process</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>fork</code> 的 <a href="http://man7.org/linux/man-pages/man2/fork.2.html" target="_blank" rel="noopener">手册</a> 中，我们会发现调用 <code>fork</code> 后的父子进程会运行在不同的内存空间中，当 <code>fork</code> 发生时两者的内存空间有着完全相同的内容，对内存的写入和修改、文件的映射都是独立的，两个进程不会相互影响。</p>
<blockquote>
<p>The child process and the parent process run in separate memory spaces. At the time of fork() both memory spaces have the same content. Memory writes, file mappings (mmap(2)), and unmappings (munmap(2)) performed by one of the processes do not affect other.</p>
</blockquote>
<p>除此之外，子进程几乎是父进程的完整副本（Exact duplicate），然而这两个进程在以下的一些方面会有较小的区别：</p>
<ul>
<li>子进程用于独立且唯一的进程 ID；</li>
<li>子进程的父进程 ID 与父进程 ID 完全相同；</li>
<li>子进程不会继承父进程的内存锁；</li>
<li>子进程会重新设置进程资源利用率和 CPU 计时器；</li>
<li>…</li>
</ul>
<p>最关键的点在于父子进程的内存在 <code>fork</code> 时是完全相同的，在 <code>fork</code> 之后进行写入和修改也不会相互影响，这其实就完美的解决了快照这个场景的问题 —— 只需要某个时间点下内存中的数据，而父进程可以继续对自己的内存进行修改，这既不会被阻塞，也不会影响生成的快照。</p>
<h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><p>既然父进程和子进程拥有完全相同的内存空间并且两者对内存的写入都不会相互影响，那么是否意味着子进程在 <code>fork</code> 时需要对父进程的内存进行全量的拷贝呢？假设子进程需要对父进程的内存进行拷贝，这对于 Redis 服务来说基本都是灾难性的，尤其是在以下的两个场景中：</p>
<ol>
<li>内存中存储大量的数据，<code>fork</code> 时拷贝内存空间会消耗大量的时间和资源，会导致程序一段时间的不可用；</li>
<li>Redis 占用了 10G 的内存，而物理机或者虚拟机的资源上限只有 16G，在这时我们就无法对 Redis 中的数据进行持久化，也就是说 Redis 对机器上内存资源的最大利用率不能超过 50%；</li>
</ol>
<p>如果无法解决上面的两个问题，使用 <code>fork</code> 来生成内存镜像的方式也无法真正落地，不是一个工程中真正可以使用的方法。</p>
<blockquote>
<p>就算脱离了 Redis 的场景，<code>fork</code> 时全量拷贝内存也是难以接受的，假设我们需要在命令行中执行一个命令，我们需要先通过 <code>fork</code> 创建一个新的进程再通过 <code>exec</code> 来执行程序，<code>fork</code> 拷贝的大量内存空间对于子进程来说可能完全没有任何作用的，但是却引入了巨大的额外开销。</p>
</blockquote>
<p>写时拷贝（Copy-on-Write）的出现就是为了解决这一问题，就像我们在这一节开头介绍的，写时拷贝的主要作用就是<strong>将拷贝推迟到写操作真正发生时</strong>，这也就避免了大量无意义的拷贝操作。在一些早期的 *nix 系统上，系统调用 <code>fork</code> 确实会立刻对父进程的内存空间进行复制，但是在今天的多数系统中，<code>fork</code> 并不会立刻触发这一过程：</p>
<p><img src="https://img.draveness.me/process-shared-memory.png" alt="process-shared-memory"></p>
<p>在 <code>fork</code> 函数调用时，父进程和子进程会被 Kernel 分配到不同的虚拟内存空间中，所以在两个进程看来它们访问的是不同的内存：</p>
<ul>
<li>在真正访问虚拟内存空间时，Kernel 会将虚拟内存映射到物理内存上，所以父子进程共享了物理上的内存空间；</li>
<li>当父进程或者子进程对共享的内存进行修改时，共享的内存才会<strong>以页为单位进行拷贝</strong>，父进程会保留原有的物理空间，而子进程会使用拷贝后的新物理空间；</li>
</ul>
<p>在 Redis 服务中，子进程只会读取共享内存中的数据，它并不会执行任何写操作，只有父进程会在写入时才会触发这一机制，而对于大多数的 Redis 服务或者数据库，写请求往往都是远小于读请求的，所以使用 <code>fork</code> 加上写时拷贝这一机制能够带来非常好的性能，也让 <code>BGSAVE</code> 这一操作的实现变得非常简单。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis 实现后台快照的方式非常巧妙，通过操作系统提供的 <code>fork</code> 和写时拷贝的特性轻而易举的就实现了这个功能，从这里我们就能看出作者对于操作系统知识的掌握还是非常扎实的，大多人在面对类似的场景时，想到的方法可能就是手动实现类似『写时拷贝』的特性，然而这不仅增加了工作量，还增加了程序出现问题的可能性。</p>
<p>到这里，我们简单总结一下 Redis 为什么在使用 RDB 进行快照时会通过子进程的方式进行实现：</p>
<ol>
<li>通过 <code>fork</code> 创建的子进程能够获得和父进程完全相同的内存空间，父进程对内存的修改对于子进程是不可见的，两者不会相互影响；</li>
<li>通过 <code>fork</code> 创建子进程时不会立刻触发大量内存的拷贝，内存在被修改时会以页为单位进行拷贝，这也就避免了大量拷贝内存而带来的性能问题；</li>
</ol>
<p>上述两个原因中，一个为子进程访问父进程提供了支撑，另一个为减少额外开销做了支持，这两者缺一不可，共同成为了 Redis 使用子进程实现快照持久化的原因。到最后，我们还是来看一些比较开放的相关问题，有兴趣的读者可以仔细思考一下下面的问题：</p>
<ul>
<li>Nginx 的主进程会在运行时 <code>fork</code> 一组子进程，这些子进程可以分别处理请求，还有哪些服务会使用这一特性？</li>
<li>写时拷贝其实是一个比较常见的机制，在 Redis 之外还有哪里会用到它？</li>
</ul>
<blockquote>
<p>如果对文章中的内容有疑问或者想要了解更多软件工程上一些设计决策背后的原因，可以在博客下面留言，作者会及时回复本文相关的疑问并选择其中合适的主题作为后续的内容。</p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://redis.io/topics/persistence" target="_blank" rel="noopener">Redis Persistence</a></li>
<li><a href="https://jobs.zalando.com/tech/blog/understanding-redis-background-memory-usage/?gh_src=4n3gxh1" target="_blank" rel="noopener">Understanding Redis Background Memory Usage</a></li>
<li><a href="https://redis.io/topics/faq" target="_blank" rel="noopener">FAQ · Redis</a></li>
<li><a href="https://en.wikipedia.org/wiki/Copy-on-write" target="_blank" rel="noopener">Copy-on-write</a></li>
<li><a href="https://github.com/antirez/redis/blob/e916058f0ba59e964f5de3dee17f46ae08f1d385/src/rdb.c#L1343-L1378" target="_blank" rel="noopener">rdbSaveBackground · Redis</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fork_(system_call)" target="_blank" rel="noopener">Fork (system call)</a></li>
<li><a href="https://unix.stackexchange.com/questions/87551/which-file-in-kernel-specifies-fork-vfork-to-use-sys-clone-system-call" target="_blank" rel="noopener">Which file in kernel specifies fork(), vfork()… to use sys_clone() system call</a></li>
<li><a href="https://www.reddit.com/r/compsci/comments/31szui/trying_to_understand_fork_and_copyonwrite_cow/" target="_blank" rel="noopener">Trying to understand fork() and Copy-on-Write (COW)</a></li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>为什么 Redis 选择单线程模型</title>
    <url>/2020/05/18/%E4%B8%BA%E4%BB%80%E4%B9%88%20Redis%20%E9%80%89%E6%8B%A9%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><a href="https://draveness.me/whys-the-design-redis-single-thread/" target="_blank" rel="noopener">原文链接</a> 作者:Draven</p>
<p>Redis 作为广为人知的内存数据库，在玩具项目和复杂的工业级别项目中都看到它的身影，然而 Redis 却是使用单线程模型进行设计的，这与很多人固有的观念有所冲突，为什么单线程的程序能够抗住每秒几百万的请求量呢？这也是我们今天要讨论的问题之一。</p>
<p>除此之外，Redis 4.0 之后的版本却抛弃了单线程模型这一设计，原本使用单线程运行的 Redis 也开始选择性使用多线程模型，这一看似有些矛盾的设计决策是今天需要讨论的另一个问题。</p>
<blockquote>
<p>However with Redis 4.0 we started to make Redis more threaded. For now this is limited to deleting objects in the background, and to blocking commands implemented via Redis modules. For the next releases, the plan is to make Redis more and more threaded.</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>就像在介绍中说的，这一篇文章想要讨论的两个与 Redis 有关的问题就是：</p>
<ul>
<li>为什么 Redis 在最初的版本中选择单线程模型？</li>
<li>为什么 Redis 在 4.0 之后的版本中加入了多线程的支持？</li>
</ul>
<p>这两个看起来有些矛盾的问题实际上并不冲突，我们会分别阐述对这个看起来完全相反的设计决策作出分析和解释，不过在具体分析它们的设计之前，我们先来看一下不同版本 Redis 顶层的设计：</p>
<p><img src="https://img.draveness.me/redis-io-multiplexing.png" alt="redis-io-multiplexing"></p>
<p>Redis 作为一个内存服务器，它需要处理很多来自外部的网络请求，它使用 I/O 多路复用机制同时监听多个文件描述符的可读和可写状态，一旦收到网络请求就会在内存中快速处理，由于绝大多数的操作都是纯内存的，所以处理的速度会非常地快。</p>
<p>在 <a href="https://raw.githubusercontent.com/antirez/redis/4.0/00-RELEASENOTES" target="_blank" rel="noopener">Redis 4.0</a> 之后的版本，情况就有了一些变动，新版的 Redis 服务在执行一些命令时就会使用『主处理线程』之外的其他线程，例如 <code>UNLINK</code>、<code>FLUSHALL ASYNC</code>、<code>FLUSHDB ASYNC</code> 等非阻塞的删除操作。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>无论是使用单线程模型还是多线程模型，这两个设计上的决定都是为了更好地提升 Redis 的开发效率、运行性能，想要理解两个看起来矛盾的设计决策，我们首先需要重新梳理做出决定的上下文和大前提，从下面的角度来看，使用单线程模型和多线程模型其实也并不矛盾。</p>
<p>虽然 Redis 在较新的版本中引入了多线程，不过是在<strong>部分命令</strong>上引入的，其中包括非阻塞的删除操作，在整体的架构设计上，主处理程序还是单线程模型的；由此看来，我们今天想要分析的两个问题可以简化成：</p>
<ul>
<li>为什么 Redis 服务使用单线程模型处理绝大多数的网络请求？</li>
<li>为什么 Redis 服务增加了多个非阻塞的删除操作，例如：<code>UNLINK</code>、<code>FLUSHALL ASYNC</code> 和 <code>FLUSHDB ASYNC</code>？</li>
</ul>
<p>接下来的两个小节将从多个角度分析这两个问题。</p>
<h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><p>Redis 从一开始就选择使用单线程模型处理来自客户端的绝大多数网络请求，这种考虑其实是多方面的，作者分析了相关的资料，发现其中最重要的几个原因如下：</p>
<ol>
<li>使用单线程模型能带来更好的可维护性，方便开发和调试；</li>
<li>使用单线程模型也能并发的处理客户端的请求；</li>
<li>Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU；</li>
</ol>
<p>上述三个原因中的最后一个是最终使用单线程模型的决定性因素，其他的两个原因都是使用单线程模型额外带来的好处，在这里我们会按顺序介绍上述的几个原因。</p>
<h4 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h4><p>可维护性对于一个项目来说非常重要，如果代码难以调试和测试，问题也经常难以复现，这对于任何一个项目来说都会严重地影响项目的可维护性。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，代码的执行过程不再是串行的，多个线程同时访问的变量如果没有谨慎处理就会带来诡异的问题。</p>
<p><img src="https://img.draveness.me/multi-threading.png" alt="multi-threading"></p>
<p>在网络上有一个调侃多线程模型的段子，就很好地展示了多线程模型带来的潜在问题：<a href="https://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="noopener">竞争条件 (race condition)</a> —— 如果计算机中的两个进程（线程同理）同时尝试修改一个共享内存的内容，在没有并发控制的情况下，最终的结果依赖于两个进程的执行顺序和时机，如果发生了并发访问冲突，最后的结果就会是不正确的。</p>
<blockquote>
<p>Some people, when confronted with a problem, think, “I know, I’ll use threads,” and then two they hav erpoblesms.</p>
</blockquote>
<p>引入了多线程，我们就必须要同时引入并发控制来保证在多个线程同时访问数据时程序行为的正确性，这就需要工程师额外维护并发控制的相关代码，例如，我们会需要在可能被并发读写的变量上增加互斥锁：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu Mutex <span class="comment">// cost</span></span><br><span class="line">    data <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    data += <span class="number">1</span></span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread 2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    data -= <span class="number">1</span></span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在访问这些变量或者内存之前也需要先对获取互斥锁，一旦忘记获取锁或者忘记释放锁就可能会导致各种诡异的问题，管理相关的并发控制机制也需要付出额外的研发成本和负担。</p>
<h4 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h4><p>使用单线程模型也并不意味着程序不能并发的处理任务，Redis 虽然使用单线程模型处理用户的请求，但是它却使用 I/O 多路复用机制<strong>并发</strong>处理来自客户端的多个连接，同时等待多个连接发送的请求。</p>
<p>在 I/O 多路复用模型中，最重要的函数调用就是 <code>select</code> 以及类似函数，该方法的能够同时监控多个文件描述符（也就是客户端的连接）的可读可写情况，当其中的某些文件描述符可读或者可写时，<code>select</code> 方法就会返回可读以及可写的文件描述符个数。</p>
<p>使用 I/O 多路复用技术能够极大地减少系统的开销，系统不再需要额外创建和维护进程和线程来监听来自客户端的大量连接，减少了服务器的开发成本和维护成本。</p>
<h4 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h4><p>最后要介绍的其实就是 Redis 选择单线程模型的决定性原因 —— 多线程技术能够帮助我们充分利用 CPU 的计算资源来并发的执行不同的任务，但是 CPU 资源往往都不是 Redis 服务器的性能瓶颈。哪怕我们在一个普通的 Linux 服务器上启动 Redis 服务，它也能在 1s 的时间内处理 1,000,000 个用户请求。</p>
<blockquote>
<p>It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.</p>
</blockquote>
<p>如果这种吞吐量不能满足我们的需求，更推荐的做法是使用分片的方式将不同的请求交给不同的 Redis 服务器来处理，而不是在同一个 Redis 服务中引入大量的多线程操作。</p>
<p>简单总结一下，Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作都会在内存中完成不会涉及任何的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；整个服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。</p>
<blockquote>
<p>AOF 是 Redis 的一种持久化机制，它会在每次收到来自客户端的写请求时，将其记录到日志中，每次 Redis 服务器启动时都会重放 AOF 日志构建原始的数据集，保证数据的持久性。</p>
</blockquote>
<p>多线程虽然会帮助我们更充分地利用 CPU 资源，但是操作系统上线程的切换也不是免费的，线程切换其实会带来额外的开销，其中包括：</p>
<ol>
<li>保存线程 1 的执行上下文；</li>
<li>加载线程 2 的执行上下文；</li>
</ol>
<p>频繁的对线程的上下文进行切换可能还会导致性能地急剧下降，这可能会导致我们不仅没有提升请求处理的平均速度，反而进行了负优化，所以这也是为什么 Redis 对于使用多线程技术非常谨慎。</p>
<h3 id="引入多线程"><a href="#引入多线程" class="headerlink" title="引入多线程"></a>引入多线程</h3><p>Redis 在最新的几个版本中加入了一些可以被其他线程异步处理的删除操作，也就是我们在上面提到的 <code>UNLINK</code>、<code>FLUSHALL ASYNC</code> 和 <code>FLUSHDB ASYNC</code>，我们为什么会需要这些删除操作，而它们为什么需要通过多线程的方式异步处理？</p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>我们可以在 Redis 在中使用 <code>DEL</code> 命令来删除一个键对应的值，如果待删除的键值对占用了较小的内存空间，那么哪怕是<strong>同步地</strong>删除这些键值对也不会消耗太多的时间。</p>
<p>但是对于 Redis 中的一些超大键值对，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务，影响 Redis 服务处理请求的 PCT99 和可用性。</p>
<p><img src="https://img.draveness.me/redis-unlink.png" alt="redis-unlink"></p>
<p>然而释放内存空间的工作其实可以由后台线程异步进行处理，这也就是 <code>UNLINK</code> 命令的实现原理，它只会将键从元数据中删除，真正的删除操作会在后台异步执行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis 选择使用单线程模型处理客户端的请求主要还是因为 CPU 不是 Redis 服务器的瓶颈，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 I/O 操作上；而 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。</p>
<blockquote>
<p>如果对文章中的内容有疑问或者想要了解更多软件工程上一些设计决策背后的原因，可以在博客下面留言，作者会及时回复本文相关的疑问并选择其中合适的主题作为后续的内容。</p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://redis.io/topics/faq#redis-is-single-threaded-how-can-i-exploit-multiple-cpu--cores" target="_blank" rel="noopener">Redis is single threaded. How can I exploit multiple CPU / cores?</a></li>
<li><a href="https://stackoverflow.com/questions/10489298/redis-is-single-threaded-then-how-does-it-do-concurrent-i-o" target="_blank" rel="noopener">Redis is single-threaded, then how does it do concurrent I/O?</a></li>
<li><a href="https://www.quora.com/Why-isnt-Redis-designed-to-benefit-from-multi-threading" target="_blank" rel="noopener">Why isn’t Redis designed to benefit from multi-threading?</a></li>
<li><a href="https://blog.golang.org/concurrency-is-not-parallelism" target="_blank" rel="noopener">Concurrency is not parallelism</a></li>
<li><a href="http://www.odbms.org/2018/03/the-little-known-feature-of-redis-4-0-that-will-speed-up-your-applications/" target="_blank" rel="noopener">The little-known feature of Redis 4.0 that will speed up your applications</a></li>
<li><a href="https://draveness.me/redis-io-multiplexing" target="_blank" rel="noopener">Redis 和 I/O 多路复用</a></li>
<li><a href="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/6_CPU_Scheduling.html" target="_blank" rel="noopener">CPU Scheduling</a></li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Copy On Write机制</title>
    <url>/2020/05/18/Copy%20On%20Write%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><a href="https://juejin.im/post/5bd96bcaf265da396b72f855" target="_blank" rel="noopener">原文链接</a> 作者:Java3y</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在读《Redis设计与实现》关于哈希表扩容的时候，发现这么一段话：</p>
<blockquote>
<p>执行BGSAVE命令或者BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用<strong>写时复制（copy-on-write）来优化子进程的使用效率</strong>，所以在子进程存在期间，服务器会提高负载因子的阈值，从而避免在子进程存在期间进行哈希表扩展操作，避免不必要的内存写入操作，最大限度地节约内存。</p>
</blockquote>
<p>触及到知识的盲区了，于是就去搜了一下copy-on-write写时复制这个技术究竟是怎么样的。发现涉及的东西蛮多的，也挺难读懂的。于是就写下这篇笔记来记录一下我学习copy-on-write的过程。</p>
<p>本文<strong>力求简单讲清copy-on-write这个知识点</strong>，希望大家看完能有所收获。</p>
<h1 id="一、Linux下的copy-on-write"><a href="#一、Linux下的copy-on-write" class="headerlink" title="一、Linux下的copy-on-write"></a>一、Linux下的copy-on-write</h1><p>在说明Linux下的copy-on-write机制前，我们首先要知道两个函数：<code>fork()</code>和<code>exec()</code>。需要注意的是<code>exec()</code>并不是一个特定的函数, 它是<strong>一组函数的统称</strong>, 它包括了<code>execl()</code>、<code>execlp()</code>、<code>execv()</code>、<code>execle()</code>、<code>execve()</code>、<code>execvp()</code>。</p>
<h2 id="1-1简单来用用fork"><a href="#1-1简单来用用fork" class="headerlink" title="1.1简单来用用fork"></a>1.1简单来用用fork</h2><p>首先我们来看一下<code>fork()</code>函数是什么鬼：</p>
<blockquote>
<p>fork is an operation whereby a process creates a copy of itself.</p>
</blockquote>
<p>fork是类Unix操作系统上<strong>创建进程</strong>的主要方法。fork用于<strong>创建子进程</strong>(等同于当前进程的副本)。</p>
<ul>
<li>新的进程要通过老的进程复制自身得到，这就是fork！</li>
</ul>
<p>如果接触过Linux，我们会知道Linux下<strong>init进程是所有进程的爹</strong>(相当于Java中的Object对象)</p>
<ul>
<li>Linux的进程都通过init进程或init的子进程fork(vfork)出来的。</li>
</ul>
<p>下面以例子说明一下fork吧：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">pid_t</span> fpid; <span class="comment">//fpid表示fork函数返回的值  </span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调用fork，创建出子进程  </span></span><br><span class="line">    fpid=fork();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所以下面的代码有两个进程执行！</span></span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建进程失败!/n"</span>);   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是子进程，由父进程fork出来/n"</span>);   </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是父进程/n"</span>);   </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"统计结果是: %d/n"</span>,count);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的结果输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是子进程，由父进程fork出来</span><br><span class="line"></span><br><span class="line">统计结果是: 1</span><br><span class="line"></span><br><span class="line">我是父进程</span><br><span class="line"></span><br><span class="line">统计结果是: 1</span><br></pre></td></tr></table></figure>

<p>解释一下：</p>
<ul>
<li>fork作为一个函数被调用。这个函数会有<strong>两次返回</strong>，将<strong>子进程的PID返回给父进程，0返回给子进程</strong>。(如果小于0，则说明创建子进程失败)。</li>
<li>再次说明：当前进程调用<code>fork()</code>，会创建一个跟当前进程完全相同的子进程(除了pid)，所以子进程同样是会执行<code>fork()</code>之后的代码。</li>
</ul>
<p>所以说：</p>
<ul>
<li>父进程在执行if代码块的时候，<code>fpid变量</code>的值是子进程的pid</li>
<li>子进程在执行if代码块的时候，<code>fpid变量</code>的值是0</li>
</ul>
<h2 id="1-2再来看看exec-函数"><a href="#1-2再来看看exec-函数" class="headerlink" title="1.2再来看看exec()函数"></a>1.2再来看看exec()函数</h2><p>从上面我们已经知道了fork会创建一个子进程。<strong>子进程的是父进程的副本</strong>。</p>
<p>exec函数的作用就是：<strong>装载一个新的程序</strong>（可执行映像）覆盖<strong>当前进程</strong>内存空间中的映像，<strong>从而执行不同的任务</strong>。</p>
<ul>
<li>exec系列函数在执行时会<strong>直接替换掉当前进程的地址空间</strong>。</li>
</ul>
<p>我去画张图来理解一下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/31/166c94cfc1728f4e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="exec函数的作用"></p>
<p>参考资料：</p>
<ul>
<li>程序员必备知识——fork和exec函数详解<a href="https://blog.csdn.net/bad_good_man/article/details/49364947" target="_blank" rel="noopener">blog.csdn.net/bad_good_ma…</a></li>
<li>linux中fork（）函数详解（原创！！实例讲解）：<a href="https://blog.csdn.net/jason314/article/details/5640969" target="_blank" rel="noopener">blog.csdn.net/jason314/ar…</a></li>
<li>linux c语言 fork() 和 exec 函数的简介和用法：<a href="https://blog.csdn.net/nvd11/article/details/8856278" target="_blank" rel="noopener">blog.csdn.net/nvd11/artic…</a></li>
<li>Linux下Fork与Exec使用：<a href="https://www.cnblogs.com/hicjiajia/archive/2011/01/20/1940154.html" target="_blank" rel="noopener">www.cnblogs.com/hicjiajia/a…</a></li>
<li>Linux 系统调用 —— fork()内核源码剖析：<a href="https://blog.csdn.net/chen892704067/article/details/76596225" target="_blank" rel="noopener">blog.csdn.net/chen8927040…</a></li>
</ul>
<h2 id="1-3回头来看Linux下的COW是怎么一回事"><a href="#1-3回头来看Linux下的COW是怎么一回事" class="headerlink" title="1.3回头来看Linux下的COW是怎么一回事"></a>1.3回头来看Linux下的COW是怎么一回事</h2><blockquote>
<p>fork()会产生一个和父进程完全相同的子进程(除了pid)</p>
</blockquote>
<p>如果按<strong>传统</strong>的做法，会<strong>直接</strong>将父进程的数据拷贝到子进程中，拷贝完之后，父进程和子进程之间的数据段和堆栈是<strong>相互独立的</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/31/166c94cfc1818295?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="父进程的数据拷贝到子进程中"></p>
<p>但是，以我们的使用经验来说：往往子进程都会执行<code>exec()</code>来做自己想要实现的功能。</p>
<ul>
<li>所以，如果按照上面的做法的话，创建子进程时复制过去的数据是没用的(因为子进程执行<code>exec()</code>，原有的数据会被清空)</li>
</ul>
<p>既然很多时候复制给子进程的数据是无效的，于是就有了Copy On Write这项技术了，原理也很简单：</p>
<ul>
<li>fork创建出的子进程，<strong>与父进程共享内存空间</strong>。也就是说，如果子进程<strong>不对内存空间进行写入操作的话，内存空间中的数据并不会复制给子进程</strong>，这样创建子进程的速度就很快了！(不用复制，直接引用父进程的物理空间)。</li>
<li>并且如果在fork函数返回之后，子进程<strong>第一时间</strong>exec一个新的可执行映像，那么也不会浪费时间和内存空间了。</li>
</ul>
<p>另外的表达方式：</p>
<blockquote>
<p>在fork之后exec之前两个进程<strong>用的是相同的物理空间</strong>（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的<strong>物理空间是同一个</strong>。</p>
</blockquote>
<blockquote>
<p>当父子进程中<strong>有更改相应段的行为发生时</strong>，再<strong>为子进程相应的段分配物理空间</strong>。</p>
</blockquote>
<blockquote>
<p>如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。</p>
</blockquote>
<blockquote>
<p>而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。</p>
</blockquote>
<p>Copy On Write技术<strong>实现原理：</strong></p>
<blockquote>
<p>fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会<strong>把触发的异常的页复制一份</strong>，于是父子进程各自持有独立的一份。</p>
</blockquote>
<p>Copy On Write技术<strong>好处</strong>是什么？</p>
<ul>
<li>COW技术可<strong>减少</strong>分配和复制大量资源时带来的<strong>瞬间延时</strong>。</li>
<li>COW技术可减少<strong>不必要的资源分配</strong>。比如fork进程时，并不是所有的页面都需要复制，父进程的<strong>代码段和只读数据段都不被允许修改，所以无需复制</strong>。</li>
</ul>
<p>Copy On Write技术<strong>缺点</strong>是什么？</p>
<ul>
<li>如果在fork()之后，父子进程都还需要继续进行写操作，<strong>那么会产生大量的分页错误(页异常中断page-fault)</strong>，这样就得不偿失。</li>
</ul>
<p>几句话总结Linux的Copy On Write技术：</p>
<ul>
<li>fork出的子进程共享父进程的物理空间，当父子进程<strong>有内存写入操作时</strong>，read-only内存页发生中断，<strong>将触发的异常的内存页复制一份</strong>(其余的页还是共享父进程的)。</li>
<li>fork出的子进程功能实现和父进程是一样的。如果有需要，我们会用<code>exec()</code>把当前进程映像替换成新的进程文件，完成自己想要实现的功能。</li>
</ul>
<p>参考资料：</p>
<ul>
<li>Linux进程基础：<a href="http://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html" target="_blank" rel="noopener">www.cnblogs.com/vamei/archi…</a></li>
<li>Linux写时拷贝技术(copy-on-write)<a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html" target="_blank" rel="noopener">www.cnblogs.com/biyeymyhjob…</a></li>
<li>当你在 Linux 上启动一个进程时会发生什么？<a href="https://zhuanlan.zhihu.com/p/33159508" target="_blank" rel="noopener">zhuanlan.zhihu.com/p/33159508</a></li>
<li>Linux fork()所谓的写时复制(COW)到最后还是要先复制再写吗？<a href="https://www.zhihu.com/question/265400460" target="_blank" rel="noopener">www.zhihu.com/question/26…</a></li>
<li>写时拷贝（copy－on－write） COW技术<a href="https://blog.csdn.net/u012333003/article/details/25117457" target="_blank" rel="noopener">blog.csdn.net/u012333003/…</a></li>
<li>Copy-On-Write 写时复制原理<a href="https://blog.csdn.net/ppppppppp2009/article/details/22750939" target="_blank" rel="noopener">blog.csdn.net/ppppppppp20…</a></li>
</ul>
<h2 id="二、解释一下Redis的COW"><a href="#二、解释一下Redis的COW" class="headerlink" title="二、解释一下Redis的COW"></a>二、解释一下Redis的COW</h2><p>基于上面的基础，我们应该已经了解COW这么一项技术了。</p>
<p>下面我来说一下我对《Redis设计与实现》那段话的理解：</p>
<ul>
<li>Redis在持久化时，如果是采用BGSAVE命令或者BGREWRITEAOF的方式，那Redis会<strong>fork出一个子进程来读取数据，从而写到磁盘中</strong>。</li>
<li>总体来看，Redis还是读操作比较多。如果子进程存在期间，发生了大量的写操作，那可能就会出现<strong>很多的分页错误(页异常中断page-fault)</strong>，这样就得耗费不少性能在复制上。</li>
<li>而在<strong>rehash阶段上，写操作是无法避免</strong>的。所以Redis在fork出子进程之后，<strong>将负载因子阈值提高</strong>，尽量减少写操作，避免不必要的内存写入操作，最大限度地节约内存。</li>
</ul>
<p>参考资料：</p>
<ul>
<li>fork()后copy on write的一些特性：<a href="https://zhoujianshi.github.io/articles/2017/fork(" target="_blank" rel="noopener">zhoujianshi.github.io/articles/20…</a>后copy on write的一些特性/index.html)</li>
<li>写时复制：<a href="https://miao1007.github.io/gitbook/java/juc/cow/" target="_blank" rel="noopener">miao1007.github.io/gitbook/jav…</a></li>
</ul>
<h1 id="三、文件系统的COW"><a href="#三、文件系统的COW" class="headerlink" title="三、文件系统的COW"></a>三、文件系统的COW</h1><p>下面来看看文件系统中的COW是啥意思：</p>
<p>Copy-on-write在对数据进行修改的时候，<strong>不会直接在原来的数据位置上进行操作</strong>，而是重新找个位置修改，这样的好处是一旦系统突然断电，重启之后不需要做Fsck。好处就是能<strong>保证数据的完整性，掉电的话容易恢复</strong>。</p>
<ul>
<li>比如说：要修改数据块A的内容，先把A读出来，写到B块里面去。如果这时候断电了，原来A的内容还在！</li>
</ul>
<p>参考资料：</p>
<ul>
<li>文件系统中的 copy-on-write 模式有什么具体的好处？<a href="https://www.zhihu.com/question/19782224/answers/created" target="_blank" rel="noopener">www.zhihu.com/question/19…</a></li>
<li>新一代 Linux 文件系统 btrfs 简介:<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-btrfs/" target="_blank" rel="noopener">www.ibm.com/developerwo…</a></li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>最后我们再来看一下写时复制的思想(摘录自维基百科)：</p>
<blockquote>
<p>写入时复制（英语：Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被建立，因此多个调用者只是读取操作时可以共享同一份资源。</p>
</blockquote>
<p>至少从本文我们可以总结出：</p>
<ul>
<li>Linux通过Copy On Write技术极大地<strong>减少了Fork的开销</strong>。</li>
<li>文件系统通过Copy On Write技术一定程度上保证<strong>数据的完整性</strong>。</li>
</ul>
<p>其实在Java里边，也有Copy On Write技术，称为延迟拷贝。</p>
<p>Java中有三种类型的对象拷贝：浅拷贝(Shallow Copy)、深拷贝(Deep Copy)、延迟拷贝(Lazy Copy)。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/31/166c94cfc1b8a75f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Java中的COW"></p>
<p>这部分留到下一篇来说，敬请期待~</p>
<p>参考资料：</p>
<ul>
<li>写时复制，写时拷贝，写时分裂，Copy on write：<a href="https://my.oschina.net/dubenju/blog/815836" target="_blank" rel="noopener">my.oschina.net/dubenju/blo…</a></li>
<li>不会产奶的COW(Copy-On-Write)<a href="https://www.jianshu.com/p/b2fb2ee5e3a0" target="_blank" rel="noopener">www.jianshu.com/p/b2fb2ee5e…</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>NIO优势？堆内存？直接内存？映射文件？Transfer to？</title>
    <url>/2020/05/26/NIO%E4%BC%98%E5%8A%BF%EF%BC%9F%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%9F%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%9F%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%EF%BC%9FTransfer%20to%EF%BC%9F/</url>
    <content><![CDATA[<p>原文作者：远o_O<br>链接：<a href="https://www.jianshu.com/p/c81f8a93d42f" target="_blank" rel="noopener">https://www.jianshu.com/p/c81f8a93d42f</a><br>来源：简书</p>
<h2 id="一、操作系统相关基础"><a href="#一、操作系统相关基础" class="headerlink" title="一、操作系统相关基础"></a>一、操作系统相关基础</h2><ul>
<li>在传统的文件IO操作中，我们都是调用操作系统提供的底层标准IO系统调用函数  read()、write() ，此时调用此函数的进程（在JAVA中即java进程）由当前的用户态切换到内核态，然后OS的内核代码负责将相应的文件数据读取到内核的IO缓冲区，然 后再把数据从内核IO缓冲区拷贝到进程的私有地址空间中去，这样便完成了一次IO操作。</li>
</ul>
<blockquote>
<p>至于为什么要多此一举搞一个内核IO缓冲区把原本只需一次拷贝数据 的事情搞成需要2次数据拷贝呢？ 我想学过操作系统或者计算机系统结构的人都知道，这么做是为了减少磁盘的IO操作，为了提高性能而考虑的，因为我们的程序访问一般都带有局部性，也就是所 谓的局部性原理，在这里主要是指的空间局部性，即我们访问了文件的某一段数据，那么接下去很可能还会访问接下去的一段数据，由于磁盘IO操作的速度比直接 访问内存慢了好几个数量级，所以OS根据局部性原理会在一次 read()系统调用过程中预读更多的文件数据缓存在内核IO缓冲区中，当继续访问的文件数据在缓冲区中时便直接拷贝数据到进程私有空间，避免了再次的低 效率磁盘IO操作。</p>
</blockquote>
<ul>
<li>BufferedInputStream减少<strong>系统调用</strong>。</li>
</ul>
<blockquote>
<p>JAVA虚拟机内部便会调用OS底层的 read()系统调用完成操作，如上所述，在第二次调用 in.read()的时候可能就是从内核缓冲区直接返回数据了（可能还有经过 native堆做一次中转，因为这些函数都被声明为 native，即本地平台相关，所以可能在C代码中有做一次中转，如 win32中是通过 C代码从OS读取数据，然后再传给JVM内存）。既然如此，JAVA的IO包中为啥还要提供一个 BufferedInputStream 类来作为缓冲区呢。关键在于四个字，”系统调用”！当读取OS内核缓冲区数据的时候，便发起了一次系统调用操作（通过native的C函数调用），而系统 调用的代价相对来说是比较高的，涉及到进程用户态和内核态的上下文切换等一系列操作，所以我们经常采用如下的包装：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\java.txt"</span>); </span><br><span class="line">BufferedInputStream buf_in = <span class="keyword">new</span> BufferedInputStream(in);  </span><br><span class="line">buf_in.read();</span><br></pre></td></tr></table></figure>

<p>这样一来，我们每一次 buf_in.read() 时候，<strong>BufferedInputStream 会根据情况自动为我们预读更多的字节数据到它自己维护的一个内部字节数组缓冲区中，这样我们便可以减少系统调用次数，从而达到其缓冲区的目的。所以要明确 的一点是 BufferedInputStream 的作用不是减少 磁盘IO操作次数（这个OS已经帮我们做了），而是通过减少系统调用次数来提高性能的。</strong>同理 BufferedOuputStream , BufferedReader/Writer 也是一样的。在 <a href="https://link.jianshu.com?t=http://lib.csdn.net/base/c" target="_blank" rel="noopener">C语言</a>的函数库中也有类似的实现，如 fread()，这个函数就是 <a href="https://link.jianshu.com?t=http://lib.csdn.net/base/c" target="_blank" rel="noopener">c语言</a>中的缓冲IO，作用与BufferedInputStream()相同.</p>
<h2 id="二、与传统I-O流相比，NIO的HeapByteBuffer有什么优势？"><a href="#二、与传统I-O流相比，NIO的HeapByteBuffer有什么优势？" class="headerlink" title="二、与传统I/O流相比，NIO的HeapByteBuffer有什么优势？"></a>二、与传统I/O流相比，NIO的HeapByteBuffer有什么优势？</h2><ul>
<li>开始讲NIO之前，了解为什么会有NIO，相比传统流I/O的优势在哪，它可以用来做什么等等的问题，还是很有必要的。</li>
</ul>
<blockquote>
<p>传统流I/O是基于字节的，所有I/O都被视为单个字节的移动；而NIO是基于块的，大家可能猜到了，NIO的性能肯定优于流I/O。没错！其性能的提高 要得益于其使用的结构更接近操作系统执行I/O的方式：通道和缓冲器。我们可以把它想象成一个煤矿，通道是一个包含煤层（数据）的矿藏，而缓冲器则是派送 到矿藏的卡车。卡车载满煤炭而归，我们再从卡车上获得煤炭。也就是说，我们并没有直接和通道交互；我们只是和缓冲器交互，并把缓冲器派送到通道。通道要么 从缓冲器获得数据，要么向缓冲器发送数据。（这段比喻出自Java编程思想）</p>
</blockquote>
<h2 id="三、内存映射文件MappedByteBuffer-和DirectByteBuffer不同，少了将数据拷贝到OS内核缓冲区这一步"><a href="#三、内存映射文件MappedByteBuffer-和DirectByteBuffer不同，少了将数据拷贝到OS内核缓冲区这一步" class="headerlink" title="三、内存映射文件MappedByteBuffer(和DirectByteBuffer不同，少了将数据拷贝到OS内核缓冲区这一步)"></a>三、内存映射文件MappedByteBuffer(和DirectByteBuffer不同，少了将数据拷贝到OS内核缓冲区这一步)</h2><ul>
<li>内存映射文件和之前说的 标准IO操作最大的不同之处就在于它虽然最终也是要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一 部分区域与文件对象建立起映射关系，就好像直接从内存中读、写文件一样，速度当然快了。为了说清楚这个，我们以 Linux操作系统为例子，看下图：</li>
</ul>
<p><img src="https:////upload-images.jianshu.io/upload_images/5807849-9072d7c30c619a62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/555/format/webp" alt="img"></p>
<p>image.png</p>
<blockquote>
<p>此图为 Linux 2.X 中的进程虚拟存储器，即进程的虚拟地址空间，如果你的机子是 32 位，那么就有 2^32 = 4G的虚拟地址空间，我们可以看到图中有一块区域： “Memory mapped region for shared libraries” ，这段区域就是在内存映射文件的时候将某一段的虚拟地址和文件对象的某一部分建立起映射关系，此时并没有拷贝数据到内存中去，而是当进程代码第一次引用这 段代码内的虚拟地址时，触发了缺页异常，这时候OS根据映射关系直接将文件的相关部分数据拷贝到进程的用户私有空间中去，当有操作第N页数据的时候重复这样的OS页面调度程序操作。注意啦，<strong>原来内存映射文件的效率比标准IO高的重要原因就是因为少了把数据拷贝到OS内核缓冲区这一步</strong>。</p>
</blockquote>
<ul>
<li>java中提供了3种内存映射模式，即：只读(readonly)、读写(read_write)、专用(private) ，</li>
</ul>
<blockquote>
<p>对于 只读模式来说，如果程序试图进行写操作，则会抛出ReadOnlyBufferException异 常；第二种的读写模式表明了通过内存映射文件的方式写或修改文件内容的话是会立刻反映到磁盘文件中去的，别的进程如果共享了同一个映射文件，那么也会立即 看到变化！而不是像标准IO那样每个进程有各自的内核缓冲区，比如JAVA代码中，没有执行<br> IO输出流的 flush() 或者 close() 操作，那么对文件的修改不会更新到磁盘去，除非进程运行结束；最后一种专用模式采用的是OS的“写时拷贝”原则，即在没有发生写操作的情况下，多个进程之 间都是共享文件的同一块物理内存（进程各自的虚拟地址指向同一片物理地址），一旦某个进程进行写操作，那么将会把受影响的文件数据单独拷贝一份到进程的私 有缓冲区中，不会反映到物理文件中去。</p>
</blockquote>
<h2 id="四、DirectBuffer相比HeapBuffer优势？-比HeapBuffer少了一次内存拷贝-，注意下方参考中的，知乎专栏。"><a href="#四、DirectBuffer相比HeapBuffer优势？-比HeapBuffer少了一次内存拷贝-，注意下方参考中的，知乎专栏。" class="headerlink" title="四、DirectBuffer相比HeapBuffer优势？(比HeapBuffer少了一次内存拷贝)，注意下方参考中的，知乎专栏。"></a>四、DirectBuffer相比HeapBuffer优势？(比HeapBuffer少了一次内存拷贝)，注意下方参考中的，知乎专栏。</h2><ul>
<li>一个Java进程相对于操作系统而言，肯定是一个用户进程。所以Java就有了这3G的使用权。JVM想使用这些内存的时候，就要使用一个叫 malloc 的方法去问操作系统要（其实中间还隔了一个C runtime，我们不去管这个细节，只把malloc往下都看成是操作系统的功能，并不会带来太大的问题）。</li>
</ul>
<p><img src="https:////upload-images.jianshu.io/upload_images/5807849-5463c1cee98f810e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/673/format/webp" alt="img"></p>
<p>image.png</p>
<h4 id="DirectBuffer的GC优点"><a href="#DirectBuffer的GC优点" class="headerlink" title="DirectBuffer的GC优点"></a><strong>DirectBuffer的GC优点</strong></h4><ul>
<li>直接内存不受 GC(新生代的Minor GC)影响，只有当执行老年代的 Full GC时候才会顺便回收直接内存！</li>
<li>DirectBuffer当然还有一个直观的优点，不被GC管理，所以发生GC的时候，整理内存的压力就会小。当然，我后面也会讲，它并不是完全不被GC管理，它还是能被回收的，但是在GC平常整理内存的时候确实是不会去管它的。</li>
</ul>
<h2 id="五、“零拷贝”（FileChannel的transferTo和transferFrom）"><a href="#五、“零拷贝”（FileChannel的transferTo和transferFrom）" class="headerlink" title="五、“零拷贝”（FileChannel的transferTo和transferFrom）"></a>五、“零拷贝”（FileChannel的transferTo和transferFrom）</h2><blockquote>
<p>Java NIO中提供的FileChannel拥有transferTo和transferFrom两个方法，可直接把FileChannel中的数据拷贝到另外一个Channel，或者直接把另外一个Channel中的数据拷贝到FileChannel。该接口常被用于高效的网络/文件的数据传输和大文件拷贝。在操作系统支持的情况下，通过该方法传输数据并不需要将源数据从内核态拷贝到用户态，再从用户态拷贝到目标通道的内核态，同时也避免了两次用户态和内核态间的上下文切换，也即使用了“零拷贝”，所以其性能一般高于Java IO中提供的方法。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://link.jianshu.com?t=http://www.aichengxu.com/java/888073.htm" target="_blank" rel="noopener">http://www.aichengxu.com/java/888073.htm</a><br> <a href="https://link.jianshu.com?t=https://zhuanlan.zhihu.com/p/27625923" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27625923</a></p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java中Enum类型的介绍</title>
    <url>/2020/05/26/Java%20%E4%B8%AD%20Enum%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>转载，原文链接<a href="https://www.ibm.com/developerworks/cn/java/j-lo-enum/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-enum/index.html</a></p>
<h2 id="Enum-类型的介绍"><a href="#Enum-类型的介绍" class="headerlink" title="Enum 类型的介绍"></a>Enum 类型的介绍</h2><p>枚举类型（Enumerated Type） 很早就出现在编程语言中，它被用来将一组类似的值包含到一种类型当中。而这种枚举类型的名称则会被定义成独一无二的类型描述符，在这一点上和常量的定义相似。不过相比较常量类型，枚举类型可以为申明的变量提供更大的取值范围。</p>
<p>举个例子来说明一下，如果希望为彩虹描绘出七种颜色，你可以在 Java 程序中通过常量定义方式来实现。</p>
<h5 id="清单-1-常量定义"><a href="#清单-1-常量定义" class="headerlink" title="清单 1. 常量定义"></a>清单 1. 常量定义</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RainbowColor</span> </span>&#123; </span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 红橙黄绿青蓝紫七种颜色的常量定义</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RED = <span class="number">0</span>; </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORANGE = <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> YELLOW = <span class="number">2</span>; </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GREEN = <span class="number">3</span>; </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CYAN = <span class="number">4</span>; </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLUE = <span class="number">5</span>; </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PURPLE = <span class="number">6</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，你可以在程序中直接引用这些常量。但是，这种方式还是存在着一些问题。</p>
<ol>
<li>类型不安全</li>
</ol>
<p>由于颜色常量的对应值是整数形，所以程序执行过程中很有可能给颜色变量传入一个任意的整数值，导致出现错误。</p>
<ol>
<li>没有命名空间</li>
</ol>
<p>由于颜色常量只是类的属性，当你使用的时候不得不通过类来访问。</p>
<ol>
<li>一致性差</li>
</ol>
<p>因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。</p>
<ol>
<li>类型无指意性</li>
</ol>
<p>由于颜色枚举值仅仅是一些无任何含义的整数值，如果在运行期调试时候，你就会发现日志中有很多魔术数字，但除了程序员本身，其他人很难明白其奥秘。</p>
<h2 id="如何定义-Enum-类型"><a href="#如何定义-Enum-类型" class="headerlink" title="如何定义 Enum 类型"></a>如何定义 Enum 类型</h2><p>为了改进 Java 语言在这方面的不足弥补缺陷，5.0 版本 SDK 发布时候，在语言层面上增加了枚举类型。枚举类型的定义也非常的简单，用 enum 关键字加上名称和大括号包含起来的枚举值体即可，例如上面提到的彩虹颜色就可以用新的 enum 方式来重新定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> RainbowColor &#123; RED, ORANGE, YELLOW, GREEN, CYAN, BLUE, PURPLE &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的定义形式来看，似乎 Java 中的枚举类型很简单，但实际上 Java 语言规范赋予枚举类型的功能非常的强大，它不仅是简单地将整形数值转换成对象，而是将枚举类型定义转变成一个完整功能的类定义。这种类型定义的扩展允许开发者给枚举类型增加任何方法和属性，也可以实现任意的接口。另外，Java 平台也为 Enum 类型提供了高质量的实现，比如默认实现 Comparable 和 Serializable 接口，让开发者一般情况下不用关心这些细节。</p>
<p>回到本文的主题上来，引入枚举类型到底能够给我们开发带来什么样好处呢？一个最直接的益处就是扩大 switch 语句使用范围。5.0 之前，Java 中 switch 的值只能够是简单类型，比如 int、byte、short、char, 有了枚举类型之后，就可以使用对象了。这样一来，程序的控制选择就变得更加的方便，看下面的例子：</p>
<h5 id="清单-2-定义-Enum-类型"><a href="#清单-2-定义-Enum-类型" class="headerlink" title="清单 2. 定义 Enum 类型"></a>清单 2. 定义 Enum 类型</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一周七天的枚举类型         </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> WeekDayEnum &#123; Mon, Tue, Wed, Thu, Fri, Sat, Sun &#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 读取当天的信息</span></span><br><span class="line">WeekDayEnum today = readToday(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 根据日期来选择进行活动</span></span><br><span class="line"><span class="keyword">switch</span>(today) &#123; </span><br><span class="line"> Mon: <span class="keyword">do</span> something; <span class="keyword">break</span>; </span><br><span class="line"> Tue: <span class="keyword">do</span> something; <span class="keyword">break</span>; </span><br><span class="line"> Wed: <span class="keyword">do</span> something; <span class="keyword">break</span>; </span><br><span class="line"> Thu: <span class="keyword">do</span> something; <span class="keyword">break</span>; </span><br><span class="line"> Fri: <span class="keyword">do</span> something; <span class="keyword">break</span>; </span><br><span class="line"> Sat: play sports game; <span class="keyword">break</span>; </span><br><span class="line"> Sun: have a rest; <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对于这些枚举的日期，JVM 都会在运行期构造成出一个简单的对象实例一一对应。这些对象都有唯一的 identity，类似整形数值一样，switch 语句就根据此来进行执行跳转。</p>
<h2 id="如何定制-Enum-类型"><a href="#如何定制-Enum-类型" class="headerlink" title="如何定制 Enum 类型"></a>如何定制 Enum 类型</h2><p>除了以上这种最常见的枚举定义形式外，如果需要给枚举类型增加一些复杂功能，也可以通过类似 class 的定义来给枚举进行定制。比如要给 enum 类型增加属性，可以像下面这样定义：</p>
<h5 id="清单-3-定制枚举类型"><a href="#清单-3-定制枚举类型" class="headerlink" title="清单 3. 定制枚举类型"></a>清单 3. 定制枚举类型</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 RSS(Really Simple Syndication) 种子的枚举类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> NewsRSSFeedEnum &#123; </span><br><span class="line">   <span class="comment">// 雅虎头条新闻 RSS 种子</span></span><br><span class="line">   YAHOO_TOP_STORIES(<span class="string">"&lt;a href="</span>http:<span class="comment">//rss.news.yahoo.com/rss/topstories"&gt;&lt;code&gt;http://rss.news.yahoo.com/rss/topstories&lt;/code&gt;&lt;/a&gt;"), </span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//CBS 头条新闻 RSS 种子</span></span><br><span class="line">   CBS_TOP_STORIES(<span class="string">"&lt;a href="</span>http:<span class="comment">//feeds.cbsnews.com/CBSNewsMain?format=xml"&gt;&lt;code&gt;http://feeds.cbsnews.com/CBSNewsMain?format=xml&lt;/code&gt;&lt;/a&gt;"), </span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 洛杉矶时报头条新闻 RSS 种子</span></span><br><span class="line">   LATIMES_TOP_STORIES(<span class="string">"&lt;a href="</span>http:<span class="comment">//feeds.latimes.com/latimes/news?format=xml"&gt;&lt;code&gt;http://feeds.latimes.com/latimes/news?format=xml&lt;/code&gt;&lt;/a&gt;"); </span></span><br><span class="line">        </span><br><span class="line">   <span class="comment">// 枚举对象的 RSS 地址的属性</span></span><br><span class="line">   <span class="keyword">private</span> String rss_url; </span><br><span class="line">        </span><br><span class="line">   <span class="comment">// 枚举对象构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">NewsRSSFeedEnum</span><span class="params">(String rss)</span> </span>&#123; </span><br><span class="line">       <span class="keyword">this</span>.rss_url = rss; </span><br><span class="line">   &#125; </span><br><span class="line">        </span><br><span class="line">   <span class="comment">// 枚举对象获取 RSS 地址的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getRssURL</span><span class="params">()</span> </span>&#123; </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.rss_url; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面头条新闻的枚举类型增加了一个 RSS 地址的属性 , 记录头条新闻的访问地址。同时，需要外部传入 RSS 访问地址的值，因而需要定义一个构造函数来初始化此属性。另外，还需要向外提供方法来读取 RSS 地址。</p>
<h2 id="如何避免错误使用-Enum"><a href="#如何避免错误使用-Enum" class="headerlink" title="如何避免错误使用 Enum"></a>如何避免错误使用 Enum</h2><p>不过在使用 Enum 时候有几个地方需要注意：</p>
<ol>
<li>enum 类型不支持 public 和 protected 修饰符的构造方法，因此构造函数一定要是 private 或 friendly 的。也正因为如此，所以枚举对象是无法在程序中通过直接调用其构造方法来初始化的。</li>
<li>定义 enum 类型时候，如果是简单类型，那么最后一个枚举值后不用跟任何一个符号；但如果有定制方法，那么最后一个枚举值与后面代码要用分号’;’隔开，不能用逗号或空格。</li>
<li>由于 enum 类型的值实际上是通过运行期构造出对象来表示的，所以在 cluster 环境下，每个虚拟机都会构造出一个同义的枚举对象。因而在做比较操作时候就需要注意，如果直接通过使用等号 ( ‘ == ’ ) 操作符，这些看似一样的枚举值一定不相等，因为这不是同一个对象实例。</li>
</ol>
<p>看下面的这个例子：</p>
<h5 id="清单-4-避免错误使用-Enum-示例"><a href="#清单-4-避免错误使用-Enum-示例" class="headerlink" title="清单 4. 避免错误使用 Enum 示例"></a>清单 4. 避免错误使用 Enum 示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个一周七天的枚举类型</span></span><br><span class="line"><span class="keyword">package</span> example.enumeration.codes; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> WeekDayEnum &#123; </span><br><span class="line">   Mon(<span class="number">1</span>), Tue(<span class="number">2</span>), Wed(<span class="number">3</span>), Thu(<span class="number">4</span>), Fri(<span class="number">5</span>), Sat(<span class="number">6</span>), Sun(<span class="number">7</span>); </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> index; </span><br><span class="line"> </span><br><span class="line">   WeekDayEnum(<span class="keyword">int</span> idx) &#123; </span><br><span class="line">       <span class="keyword">this</span>.index = idx; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123; </span><br><span class="line">       <span class="keyword">return</span> index; </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 客户端程序，将一个枚举值通过网络传递给服务器端</span></span><br><span class="line"><span class="keyword">package</span> example.enumeration.codes; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException; </span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream; </span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream; </span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress; </span><br><span class="line"><span class="keyword">import</span> java.net.Socket; </span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationClient</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123; </span><br><span class="line">       Socket socket = <span class="keyword">new</span> Socket(); </span><br><span class="line"> <span class="comment">// 建立到服务器端的连接</span></span><br><span class="line">       socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8999</span>)); </span><br><span class="line">   <span class="comment">// 从连接中得到输出流</span></span><br><span class="line">       OutputStream os = socket.getOutputStream(); </span><br><span class="line">       ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(os); </span><br><span class="line"> <span class="comment">// 将星期五这个枚举值传递给服务器端</span></span><br><span class="line">       oos.writeObject(WeekDayEnum.Fri); </span><br><span class="line">       oos.close(); </span><br><span class="line">       os.close(); </span><br><span class="line">       socket.close(); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 服务器端程序，将从客户端收到的枚举值应用到逻辑处理中</span></span><br><span class="line"><span class="keyword">package</span> example.enumeration.codes; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.*; </span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket; </span><br><span class="line"><span class="keyword">import</span> java.net.Socket; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationServer</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123; </span><br><span class="line">       ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8999</span>); </span><br><span class="line"> <span class="comment">// 建立服务器端的网络连接侦听</span></span><br><span class="line">       Socket socket = server.accept(); </span><br><span class="line"> <span class="comment">// 从连接中获取输入流</span></span><br><span class="line">       InputStream is = socket.getInputStream(); </span><br><span class="line">       ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(is); </span><br><span class="line"> <span class="comment">// 读出客户端传递来的枚举值</span></span><br><span class="line">       WeekDayEnum day = (WeekDayEnum) ois.readObject(); </span><br><span class="line"> <span class="comment">// 用值比较方式来对比枚举对象</span></span><br><span class="line">       <span class="keyword">if</span> (day == WeekDayEnum.Fri) &#123; </span><br><span class="line">           System.out.println(<span class="string">"client Friday enum value is same as server's"</span>); </span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (day.equals(WeekDayEnum.Fri)) &#123; </span><br><span class="line">           System.out.println(<span class="string">"client Friday enum value is equal to server's"</span>); </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">           System.out.println(<span class="string">"client Friday enum value is not same as server's"</span>); </span><br><span class="line">       &#125; </span><br><span class="line">        </span><br><span class="line"> <span class="comment">// 用 switch 方式来比较枚举对象</span></span><br><span class="line">       <span class="keyword">switch</span> (day) &#123; </span><br><span class="line">           <span class="keyword">case</span> Mon: </span><br><span class="line">               System.out.println(<span class="string">"Do Monday work"</span>); </span><br><span class="line">               <span class="keyword">break</span>; </span><br><span class="line">           <span class="keyword">case</span> Tue: </span><br><span class="line">               System.out.println(<span class="string">"Do Tuesday work"</span>); </span><br><span class="line">               <span class="keyword">break</span>; </span><br><span class="line">           <span class="keyword">case</span> Wed: </span><br><span class="line">               System.out.println(<span class="string">"Do Wednesday work"</span>); </span><br><span class="line">               <span class="keyword">break</span>; </span><br><span class="line">           <span class="keyword">case</span> Thu: </span><br><span class="line">               System.out.println(<span class="string">"Do Thursday work"</span>); </span><br><span class="line">               <span class="keyword">break</span>; </span><br><span class="line">           <span class="keyword">case</span> Fri: </span><br><span class="line">               System.out.println(<span class="string">"Do Friday work"</span>); </span><br><span class="line">               <span class="keyword">break</span>; </span><br><span class="line">           <span class="keyword">case</span> Sat: </span><br><span class="line">               System.out.println(<span class="string">"Do Saturday work"</span>); </span><br><span class="line">               <span class="keyword">break</span>; </span><br><span class="line">           <span class="keyword">case</span> Sun: </span><br><span class="line">               System.out.println(<span class="string">"Do Sunday work"</span>); </span><br><span class="line">               <span class="keyword">break</span>; </span><br><span class="line">           <span class="keyword">default</span>: </span><br><span class="line">               System.out.println(<span class="string">"I don't know which is day"</span>); </span><br><span class="line">               <span class="keyword">break</span>; </span><br><span class="line">       &#125; </span><br><span class="line">        </span><br><span class="line">       ois.close(); </span><br><span class="line">       is.close(); </span><br><span class="line">       socket.close(); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client Friday enum value is same as server&#39;s </span><br><span class="line">Do Friday work</span><br></pre></td></tr></table></figure>

<p>通过程序执行结果，我们能够发现在分布式条件下客户端和服务端的虚拟机上都生成了一个枚举对象，即使看起来一样的 Fri 枚举值，如果使用等号‘ == ’进行比较的话会出现不等的情况。而 switch 语句则是通过 equal 方法来比较枚举对象的值，因此当你的枚举对象较复杂时候，你就需要小心 override 与比较相关的方法，防止出现值比较方面的错误。</p>
<h2 id="Enum-相关工具类"><a href="#Enum-相关工具类" class="headerlink" title="Enum 相关工具类"></a>Enum 相关工具类</h2><p>JDK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。EnumSet 是一个针对枚举类型的高性能的 Set 接口实现。EnumSet 中装入的所有枚举对象都必须是同一种类型，在其内部，是通过 bit-vector 来实现，也就是通过一个 long 型数。EnumSet 支持在枚举类型的所有值的某个范围中进行迭代。回到上面日期枚举的例子上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> WeekDayEnum &#123; Mon, Tue, Wed, Thu, Fri, Sat, Sun &#125;</span><br></pre></td></tr></table></figure>

<p>你能够在每周七天日期中进行迭代，EnumSet 类提供一个静态方法 range 让迭代很容易完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(WeekDayEnum day : EnumSet.range(WeekDayEnum.Mon, WeekDayEnum.Fri)) &#123; </span><br><span class="line">    System.out.println(day); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mon </span><br><span class="line">Tue </span><br><span class="line">Wed </span><br><span class="line">Thu </span><br><span class="line">Fri</span><br></pre></td></tr></table></figure>

<p>EnumSet 还提供了很多个类型安全的获取子集的 of 方法，使你很容易取得子集：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EnumSet&lt;WeekDayEnum&gt; subset = EnumSet.of(WeekDayEnum.Mon, WeekDayEnum.Wed); </span><br><span class="line">     <span class="keyword">for</span> (WeekDayEnum day : subset) &#123; </span><br><span class="line">         System.out.println(day);  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mon </span><br><span class="line">Wed</span><br></pre></td></tr></table></figure>

<p>与 EnumSet 类似，EnumMap 也是一个高性能的 Map 接口实现，用来管理使用枚举类型作为 keys 的映射表，内部是通过数组方式来实现。EnumMap 将丰富的和安全的 Map 接口与数组快速访问结合到一起，如果你希望要将一个枚举类型映射到一个值，你应该使用 EnumMap。看下面的例子：</p>
<h5 id="清单-5-EnumMap-示例"><a href="#清单-5-EnumMap-示例" class="headerlink" title="清单 5. EnumMap 示例"></a>清单 5. EnumMap 示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个 EnumMap 对象，映射表主键是日期枚举类型，值是颜色枚举类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;WeekDayEnum, RainbowColor&gt; schema = </span><br><span class="line">           <span class="keyword">new</span> EnumMap&lt;WeekDayEnum, RainbowColor&gt;(WeekDayEnum<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span>&#123; </span><br><span class="line">   <span class="comment">// 将一周的每一天与彩虹的某一种色彩映射起来</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WeekDayEnum.values().length; i++) &#123; </span><br><span class="line">       schema.put(WeekDayEnum.values()[i], RainbowColor.values()[i]); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(<span class="string">"What is the lucky color today?"</span>); </span><br><span class="line">System.out.println(<span class="string">"It's "</span> + schema.get(WeekDayEnum.Sat));</span><br></pre></td></tr></table></figure>

<p>当你询问周六的幸运色彩时候，会得到蓝色：</p>
<h5 id="清单-6-运行结果"><a href="#清单-6-运行结果" class="headerlink" title="清单 6. 运行结果"></a>清单 6. 运行结果</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">What is the lucky color today?</span><br><span class="line">It&#39;s BLUE</span><br></pre></td></tr></table></figure>

<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Enum 类型提出给 JAVA 编程带了了极大的便利，让程序的控制更加的容易，也不容易出现错误。所以在遇到需要控制程序流程时候，可以多想想是否可以利用 enum 来实现。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java修饰符</title>
    <url>/2020/05/26/Java%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>转载，原文链接<a href="https://www.runoob.com/java/java-modifier-types.html#protected-desc" target="_blank" rel="noopener">https://www.runoob.com/java/java-modifier-types.html#protected-desc</a></p>
<p>Java语言提供了很多修饰符，主要分为以下两类：</p>
<ul>
<li>访问修饰符</li>
<li>非访问修饰符</li>
</ul>
<p>修饰符用来定义类、方法或者变量，通常放在语句的最前端。</p>
<hr>
<h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p>
<ul>
<li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li>
<li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li>
<li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li>
<li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li>
</ul>
<p>我们可以通过以下表来说明访问权限：</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">当前类</th>
<th align="left">同一包内</th>
<th align="left">子孙类(同一包)</th>
<th align="left">子孙类(不同包)</th>
<th align="left">其他包</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>public</code></td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left"><code>protected</code></td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y/N（<a href="https://www.runoob.com/java/java-modifier-types.html#protected-desc" target="_blank" rel="noopener">说明</a>）</td>
<td align="left">N</td>
</tr>
<tr>
<td align="left"><code>default</code></td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">N</td>
<td align="left">N</td>
</tr>
<tr>
<td align="left"><code>private</code></td>
<td align="left">Y</td>
<td align="left">N</td>
<td align="left">N</td>
<td align="left">N</td>
<td align="left">N</td>
</tr>
</tbody></table>
<h3 id="默认访问修饰符-不使用任何关键字"><a href="#默认访问修饰符-不使用任何关键字" class="headerlink" title="默认访问修饰符-不使用任何关键字"></a>默认访问修饰符-不使用任何关键字</h3><p>使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 <strong>public static final</strong>,而接口里的方法默认情况下访问权限为 <strong>public</strong>。</p>
<p>如下例所示，变量和方法的声明可以不使用任何修饰符。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String version = <span class="string">"1.5.1"</span>; </span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">processOrder</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="私有访问修饰符-private"><a href="#私有访问修饰符-private" class="headerlink" title="私有访问修饰符-private"></a>私有访问修饰符-private</h3><p>私有访问修饰符是最严格的访问级别，所以被声明为 <strong>private</strong> 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 <strong>private</strong>。</p>
<p>声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。</p>
<p>Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。</p>
<p>下面的类使用了私有访问修饰符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String format;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFormat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.format;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFormat</span><span class="params">(String format)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.format = format;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例中，Logger 类中的 format 变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两个 public 方法：getFormat() （返回 format的值）和 setFormat(String)（设置 format 的值）</p>
<h3 id="公有访问修饰符-public"><a href="#公有访问修饰符-public" class="headerlink" title="公有访问修饰符-public"></a>公有访问修饰符-public</h3><p>被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。</p>
<p>如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。</p>
<p>Java 程序的 main() 方法必须设置成公有的，否则，Java 解释器将不能运行该类。</p>
<h3 id="受保护的访问修饰符-protected"><a href="#受保护的访问修饰符-protected" class="headerlink" title="受保护的访问修饰符-protected"></a>受保护的访问修饰符-protected</h3><p>protected 需要从以下两个点来分析说明：</p>
<ul>
<li><strong>子类与基类在同一包中</strong>：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li>
<li><strong>子类与基类不在同一包中</strong>：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。</li>
</ul>
<p>protected 可以修饰数据成员，构造方法，方法成员，<strong>不能修饰类（内部类除外）</strong>。</p>
<p>接口及接口的成员变量和成员方法不能声明为 protected。 可以看看下图演示：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/java-protected.gif" alt="img"></p>
<p>子类能访问 protected 修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。</p>
<p>下面的父类使用了 protected 访问修饰符，子类重写了父类的 openSpeaker() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudioPlayer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">openSpeaker</span><span class="params">(Speaker sp)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 实现细节</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamingAudioPlayer</span> <span class="keyword">extends</span> <span class="title">AudioPlayer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">openSpeaker</span><span class="params">(Speaker sp)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 实现细节</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果把 openSpeaker() 方法声明为 private，那么除了 AudioPlayer 之外的类将不能访问该方法。</p>
<p>如果把 openSpeaker() 声明为 public，那么所有的类都能够访问该方法。</p>
<p>如果我们只想让该方法对其所在类的子类可见，则将该方法声明为 protected。</p>
<blockquote>
<p>protected 是最难理解的一种 Java 类成员访问权限修饰词，更多详细内容请查看 <a href="https://www.runoob.com/w3cnote/java-protected-keyword-detailed-explanation.html" target="_blank" rel="noopener">Java protected 关键字详解</a>。</p>
</blockquote>
<h3 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h3><p>请注意以下方法继承的规则：</p>
<ul>
<li>父类中声明为 public 的方法在子类中也必须为 public。</li>
<li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li>
<li>父类中声明为 private 的方法，不能够被继承。</li>
</ul>
<hr>
<h2 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h2><p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p>
<p>static 修饰符，用来修饰类方法和类变量。</p>
<p>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p>
<p>abstract 修饰符，用来创建抽象类和抽象方法。</p>
<p>synchronized 和 volatile 修饰符，主要用于线程的编程。</p>
<h3 id="static-修饰符"><a href="#static-修饰符" class="headerlink" title="static 修饰符"></a>static 修饰符</h3><ul>
<li><p><strong>静态变量：</strong></p>
<p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p>
</li>
<li><p><strong>静态方法：</strong></p>
<p>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p>
</li>
</ul>
<p>对类变量和方法的访问可以直接使用 <strong>classname.variablename</strong> 和 <strong>classname.methodname</strong> 的方式访问。</p>
<p>如下例所示，static修饰符用来创建类方法和类变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceCounter</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numInstances = <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> numInstances;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      numInstances++;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   InstanceCounter() &#123;</span><br><span class="line">      InstanceCounter.addInstance();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arguments)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Starting with "</span> +</span><br><span class="line">      InstanceCounter.getCount() + <span class="string">" instances"</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; ++i)&#123;</span><br><span class="line">         <span class="keyword">new</span> InstanceCounter();</span><br><span class="line">          &#125;</span><br><span class="line">      System.out.println(<span class="string">"Created "</span> +</span><br><span class="line">      InstanceCounter.getCount() + <span class="string">" instances"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行编辑结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Starting with 0 instances</span><br><span class="line">Created 500 instances</span><br></pre></td></tr></table></figure>

<h3 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h3><p><strong>final 变量：</strong></p>
<p>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p>
<p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 下面是声明常量的实例</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOXWIDTH = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String TITLE = <span class="string">"Manager"</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">     value = <span class="number">12</span>; <span class="comment">//将输出一个错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>final 方法</strong></p>
<p>父类中的 final 方法可以被子类继承，但是不能被子类重写。</p>
<p>声明 final 方法的主要目的是防止该方法的内容被修改。</p>
<p>如下所示，使用 final 修饰符声明方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">changeName</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>final 类</strong></p>
<p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;   </span><br><span class="line">	<span class="comment">// 类体 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="abstract-修饰符"><a href="#abstract-修饰符" class="headerlink" title="abstract 修饰符"></a>abstract 修饰符</h3><p><strong>抽象类：</strong></p>
<p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p>
<p>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p>
<p>抽象类可以包含抽象方法和非抽象方法。</p>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Caravan</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">   <span class="keyword">private</span> String model;</span><br><span class="line">   <span class="keyword">private</span> String year;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">goFast</span><span class="params">()</span></span>; <span class="comment">//抽象方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">changeColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象方法</strong></p>
<p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p>
<p>抽象方法不能被声明成 final 和 static。</p>
<p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p>
<p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p>
<p>抽象方法的声明以分号结尾，例如：<strong>public abstract sample();</strong>。</p>
<h3 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a>synchronized 修饰符</h3><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</p>
<h3 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a>transient 修饰符</h3><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</p>
<p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p>
<h2 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> limit = <span class="number">55</span>;   <span class="comment">// 不会持久化 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> b; <span class="comment">// 持久化</span></span><br></pre></td></tr></table></figure>



<h3 id="volatile-修饰符"><a href="#volatile-修饰符" class="headerlink" title="volatile 修饰符"></a>volatile 修饰符</h3><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>
<p>一个 volatile 对象引用可能是 null。</p>
<h2 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> active;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        active = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (active) <span class="comment">// 第一行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        active = <span class="keyword">false</span>; <span class="comment">// 第二行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下，在一个线程调用 run() 方法（在 Runnable 开启的线程），在另一个线程调用 stop() 方法。 如果 <strong><em>第一行\</em></strong> 中缓冲区的 active 值被使用，那么在 <strong><em>第二行\</em></strong> 的 active 值为 false 时循环不会停止。</p>
<p>但是以上代码中我们使用了 volatile 修饰 active，所以该循环会停止。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>字符编码笔记：ASCII，Unicode 和 UTF-8</title>
    <url>/2020/05/28/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0%EF%BC%9AASCII%EF%BC%8CUnicode%20%E5%92%8C%20UTF-8/</url>
    <content><![CDATA[<p>转载，<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">原文地址</a>    作者： 阮一峰</p>
<p>今天中午，我突然想搞清楚 Unicode 和 UTF-8 之间的关系，就开始查资料。</p>
<p>这个问题比我想象的复杂，午饭后一直看到晚上9点，才算初步搞清楚。</p>
<p>下面就是我的笔记，主要用来整理自己的思路。我尽量写得通俗易懂，希望能对其他朋友有用。毕竟，字符编码是计算机技术的基石，想要熟练使用计算机，就必须懂得一点字符编码的知识。</p>
<h2 id="一、ASCII-码"><a href="#一、ASCII-码" class="headerlink" title="一、ASCII 码"></a><strong>一、ASCII 码</strong></h2><p>我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有<code>0</code>和<code>1</code>两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从<code>00000000</code>到<code>11111111</code>。</p>
<p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p>
<p>ASCII 码一共规定了128个字符的编码，比如空格<code>SPACE</code>是32（二进制<code>00100000</code>），大写的字母<code>A</code>是65（二进制<code>01000001</code>）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为<code>0</code>。</p>
<h2 id="二、非-ASCII-编码"><a href="#二、非-ASCII-编码" class="headerlink" title="二、非 ASCII 编码"></a><strong>二、非 ASCII 编码</strong></h2><p>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的<code>é</code>的编码为130（二进制<code>10000010</code>）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。</p>
<p>但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了<code>é</code>，在希伯来语编码中却代表了字母<code>Gimel</code> (<code>ג</code>)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。</p>
<p>至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。</p>
<p>中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。</p>
<h2 id="三-Unicode"><a href="#三-Unicode" class="headerlink" title="三. Unicode"></a><strong>三. Unicode</strong></h2><p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p>
<p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p>
<p>Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，<code>U+0639</code>表示阿拉伯字母<code>Ain</code>，<code>U+0041</code>表示英语的大写字母<code>A</code>，<code>U+4E25</code>表示汉字<code>严</code>。具体的符号对应表，可以查询<a href="http://www.unicode.org/" target="_blank" rel="noopener">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">汉字对应表</a>。</p>
<h2 id="四、Unicode-的问题"><a href="#四、Unicode-的问题" class="headerlink" title="四、Unicode 的问题"></a><strong>四、Unicode 的问题</strong></h2><p>需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p>
<p>比如，汉字<code>严</code>的 Unicode 是十六进制数<code>4E25</code>，转换成二进制数足足有15位（<code>100111000100101</code>），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</p>
<p>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是<code>0</code>，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>
<p>它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。</p>
<h2 id="五、UTF-8"><a href="#五、UTF-8" class="headerlink" title="五、UTF-8"></a><strong>五、UTF-8</strong></h2><p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。<strong>重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。</strong></p>
<p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>
<p>UTF-8 的编码规则很简单，只有二条：</p>
<p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p>
<p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p>
<p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unicode符号范围     |        UTF-8编码方式</span><br><span class="line">(十六进制)        |              （二进制）</span><br><span class="line">----------------------+---------------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure>
</blockquote>
<p>跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p>
<p>下面，还是以汉字<code>严</code>为例，演示如何实现 UTF-8 编码。</p>
<p><code>严</code>的 Unicode 是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的 UTF-8 编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最后一个二进制位开始，依次从后向前填入格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的 UTF-8 编码是<code>11100100 10111000 10100101</code>，转换成十六进制就是<code>E4B8A5</code>。</p>
<h2 id="六、Unicode-与-UTF-8-之间的转换"><a href="#六、Unicode-与-UTF-8-之间的转换" class="headerlink" title="六、Unicode 与 UTF-8 之间的转换"></a><strong>六、Unicode 与 UTF-8 之间的转换</strong></h2><p>通过上一节的例子，可以看到<code>严</code>的 Unicode码 是<code>4E25</code>，UTF-8 编码是<code>E4B8A5</code>，两者是不一样的。它们之间的转换可以通过程序实现。</p>
<p>Windows平台，有一个最简单的转化方法，就是使用内置的记事本小程序<code>notepad.exe</code>。打开文件后，点击<code>文件</code>菜单中的<code>另存为</code>命令，会跳出一个对话框，在最底部有一个<code>编码</code>的下拉条。</p>
<p><a href="http://www.ruanyifeng.com/blog/2007/10/bg2007102801.jpg" target="_blank" rel="noopener"><img src="http://www.ruanyifeng.com/blog/2007/10/bg2007102801-thumb.jpg" alt="bg2007102801.jpg"></a></p>
<p>里面有四个选项：<code>ANSI</code>，<code>Unicode</code>，<code>Unicode big endian</code>和<code>UTF-8</code>。</p>
<p>1）<code>ANSI</code>是默认的编码方式。对于英文文件是<code>ASCII</code>编码，对于简体中文文件是<code>GB2312</code>编码（只针对 Windows 简体中文版，如果是繁体中文版会采用 Big5 码）。</p>
<p>2）<code>Unicode</code>编码这里指的是<code>notepad.exe</code>使用的 UCS-2 编码方式，即直接用两个字节存入字符的 Unicode 码，这个选项用的 little endian 格式。</p>
<p>3）<code>Unicode big endian</code>编码与上一个选项相对应。我在下一节会解释 little endian 和 big endian 的涵义。</p>
<p>4）<code>UTF-8</code>编码，也就是上一节谈到的编码方法。</p>
<p>选择完”编码方式”后，点击”保存”按钮，文件的编码方式就立刻转换好了。</p>
<h2 id="七、Little-endian-和-Big-endian"><a href="#七、Little-endian-和-Big-endian" class="headerlink" title="七、Little endian 和 Big endian"></a><strong>七、Little endian 和 Big endian</strong></h2><p>上一节已经提到，UCS-2 格式可以存储 Unicode 码（码点不超过<code>0xFFFF</code>）。以汉字<code>严</code>为例，Unicode 码是<code>4E25</code>，需要用两个字节存储，一个字节是<code>4E</code>，另一个字节是<code>25</code>。存储的时候，<code>4E</code>在前，<code>25</code>在后，这就是 Big endian 方式；<code>25</code>在前，<code>4E</code>在后，这是 Little endian 方式。</p>
<p>这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。</p>
<p>第一个字节在前，就是”大头方式”（Big endian），第二个字节在前就是”小头方式”（Little endian）。</p>
<p>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？</p>
<p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用<code>FEFF</code>表示。这正好是两个字节，而且<code>FF</code>比<code>FE</code>大<code>1</code>。</p>
<p>如果一个文本文件的头两个字节是<code>FE FF</code>，就表示该文件采用大头方式；如果头两个字节是<code>FF FE</code>，就表示该文件采用小头方式。</p>
<h2 id="八、实例"><a href="#八、实例" class="headerlink" title="八、实例"></a><strong>八、实例</strong></h2><p>下面，举一个实例。</p>
<p>打开”记事本”程序<code>notepad.exe</code>，新建一个文本文件，内容就是一个<code>严</code>字，依次采用<code>ANSI</code>，<code>Unicode</code>，<code>Unicode big endian</code>和<code>UTF-8</code>编码方式保存。</p>
<p>然后，用文本编辑软件<a href="http://www.google.cn/search?aq=t&oq=UltraEdit&complete=1&hl=zh-CN&newwindow=1&rlz=1B3GGGL_zh-CNCN216CN216&q=ultraedit+下载&btnG=Google+搜索&meta=" target="_blank" rel="noopener">UltraEdit 中</a>的”十六进制功能”，观察该文件的内部编码方式。</p>
<p>1）ANSI：文件的编码就是两个字节<code>D1 CF</code>，这正是<code>严</code>的 GB2312 编码，这也暗示 GB2312 是采用大头方式存储的。</p>
<p>2）Unicode：编码是四个字节<code>FF FE 25 4E</code>，其中<code>FF FE</code>表明是小头方式存储，真正的编码是<code>4E25</code>。</p>
<p>3）Unicode big endian：编码是四个字节<code>FE FF 4E 25</code>，其中<code>FE FF</code>表明是大头方式存储。</p>
<p>4）UTF-8：编码是六个字节<code>EF BB BF E4 B8 A5</code>，前三个字节<code>EF BB BF</code>表示这是UTF-8编码，后三个<code>E4B8A5</code>就是<code>严</code>的具体编码，它的存储顺序与编码顺序是一致的。</p>
<h2 id="九、延伸阅读"><a href="#九、延伸阅读" class="headerlink" title="九、延伸阅读"></a><strong>九、延伸阅读</strong></h2><ul>
<li><a href="http://www.joelonsoftware.com/articles/Unicode.html" target="_blank" rel="noopener">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets</a>（关于字符集的最基本知识）</li>
<li><a href="http://www.pconline.com.cn/pcedu/empolder/gj/other/0505/616631.html" target="_blank" rel="noopener">谈谈Unicode编码</a></li>
<li><a href="http://www.ietf.org/rfc/rfc3629.txt" target="_blank" rel="noopener">RFC3629：UTF-8, a transformation format of ISO 10646</a>（如果实现UTF-8的规定）</li>
</ul>
<p>（完）</p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
  </entry>
  <entry>
    <title>JavaNIO和零拷贝（Zero Copy）</title>
    <url>/2020/05/28/JavaNIO%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%88Zero%20Copy%EF%BC%89/</url>
    <content><![CDATA[<p>[原文地址]（<a href="https://blog.csdn.net/cringkong/article/details/80274148）" target="_blank" rel="noopener">https://blog.csdn.net/cringkong/article/details/80274148）</a></p>
<h2 id="一-Linux操作系统中的零拷贝"><a href="#一-Linux操作系统中的零拷贝" class="headerlink" title="一.Linux操作系统中的零拷贝"></a>一.Linux操作系统中的零拷贝</h2><h3 id="1-1-先从Linux的普通I-O过程说起"><a href="#1-1-先从Linux的普通I-O过程说起" class="headerlink" title="1.1 先从Linux的普通I/O过程说起"></a>1.1 先从Linux的普通I/O过程说起</h3><p><img src="https://img-blog.csdn.net/20180510163922461?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyaW5nS29uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>这是一个从磁盘文件中读取并且通过Socket写出的过程，对应的系统调用如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span>(file, tmp_buf, len);</span><br><span class="line"><span class="built_in">write</span>(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>

<ol>
<li>程序使用<code>read()</code>系统调用，系统由用户态转换为内核态，磁盘中的数据由DMA（Direct memory access）的方式读取到内核读缓冲区（kernel buffer）。DMA过程中CPU不需要参与数据的读写，而是DMA处理器直接将硬盘数据通过总线传输到内存中。</li>
<li>系统由内核态转为用户态，当程序要读的数据已经完全存入内核读缓冲区以后，程序会将数据由内核读缓冲区，写入到用户缓冲区，这个过程需要CPU参与数据的读写。</li>
<li>程序使用<code>write()</code>系统调用，系统由用户态切换到内核态，数据从用户缓冲区写入到网络缓冲区（Socket Buffer），这个过程需要CPU参与数据的读写。</li>
<li>系统由内核态切换到用户态，网络缓冲区的数据通过DMA的方式传输到网卡的驱动（存储缓冲区）中（protocol engine）<br>可以看到，普通的拷贝过程经历了四次内核态和用户态的切换（上下文切换），两次CPU从内存中进行数据的读写过程，这种拷贝过程相对来说比较消耗系统资源。</li>
</ol>
<p>程序使用read()系统调用，系统由用户态转换为内核态，磁盘中的数据由DMA（Direct memory access）的方式读取到内核读缓冲区（kernel buffer）。DMA过程中CPU不需要参与数据的读写，而是DMA处理器直接将硬盘数据通过总线传输到内存中。<br>系统由内核态转为用户态，当程序要读的数据已经完全存入内核读缓冲区以后，程序会将数据由内核读缓冲区，写入到用户缓冲区，这个过程需要CPU参与数据的读写。<br>程序使用write()系统调用，系统由用户态切换到内核态，数据从用户缓冲区写入到网络缓冲区（Socket Buffer），这个过程需要CPU参与数据的读写。<br>系统由内核态切换到用户态，网络缓冲区的数据通过DMA的方式传输到网卡的驱动（存储缓冲区）中（protocol engine）<br>可以看到，普通的拷贝过程经历了四次内核态和用户态的切换（上下文切换），两次CPU从内存中进行数据的读写过程，这种拷贝过程相对来说比较消耗系统资源。</p>
<h3 id="1-2-内存映射方式I-O"><a href="#1-2-内存映射方式I-O" class="headerlink" title="1.2 内存映射方式I/O"></a>1.2 内存映射方式I/O</h3><p><img src="https://img-blog.csdn.net/2018051020291133?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyaW5nS29uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tmp_buf &#x3D; mmap(file, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>


<p>这是使用的系统调用方法，这种方式的I/O原理就是将用户缓冲区(user buffer)的内存地址和内核缓冲区(kernel buffer) 的内存地址做一个映射，也就是说系统在用户态可以直接读取并操作内核空间的数据。</p>
<ol>
<li><code>mmap()</code>系统调用首先会使用DMA的方式将磁盘数据读取到内核缓冲区，然后通过内存映射的方式，使用户缓冲区和内核读缓冲区的内存地址为同一内存地址，也就是说不需要CPU再讲数据从内核读缓冲区复制到用户缓冲区。</li>
<li>当使用<code>write()</code>系统调用的时候，cpu将内核缓冲区（等同于用户缓冲区）的数据直接写入到网络发送缓冲区（socket buffer），然后通过DMA的方式将数据传入到网卡驱动程序中准备发送。</li>
</ol>
<p>可以看到这种内存映射的方式减少了CPU的读写次数，但是用户态到内核态的切换（上下文切换）依旧有四次，这种方式可以让应用程序对数据进行相应的读写操作。</p>
<h3 id="1-3-内核空间内部传输I-O"><a href="#1-3-内核空间内部传输I-O" class="headerlink" title="1.3 内核空间内部传输I/O"></a>1.3 内核空间内部传输I/O</h3><p><img src="https://img-blog.csdn.net/20180510204945959?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyaW5nS29uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sendfile(socket, file, len);</span><br></pre></td></tr></table></figure>


<p>通过<code>sendfile()</code>系统调用，可以做到内核空间内部直接进行I/O传输。</p>
<ol>
<li><code>sendfile()</code>系统调用也会引起用户态到内核态的切换，与内存映射方式不同的是，用户空间此时是无法看到或修改数据内容，也就是说这是一次完全意义上的数据传输过程。</li>
<li>从磁盘读取到内存是DMA的方式，从内核读缓冲区读取到网络发送缓冲区，依旧需要CPU参与拷贝，而从网络发送缓冲区到网卡中的缓冲区依旧是DMA方式。</li>
</ol>
<p>依旧有一次CPU进行数据拷贝，两次用户态和内核态的切换操作，相比较于内存映射的方式有了很大的进步，但问题是程序不能对数据进行修改，而只是单纯地进行了一次数据的传输过程。</p>
<p>1.4 升级版-内核空间内部传输I/O</p>
<p><img src="https://img-blog.csdn.net/20180510205721658?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyaW5nS29uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>依旧是系统调用sendfile()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sendfile(socket, file, len);</span><br></pre></td></tr></table></figure>

<p><strong>在 Linux 内核 2.4 及后期版本中，针对套接字缓冲区描述符做了相应调整，支持了DMA自带了收集功能，对于用户方面，用法还是一样的，但是内部操作已经发生了改变。</strong></p>
<p>可以看到，这是真正意义上的零拷贝，因为其间CPU已经不参与数据的拷贝过程，当然这样的过程需要硬件的支持才能实现。</p>
<blockquote>
<p>借助于硬件上的帮助，我们是可以办到的。之前我们是把页缓存的数据拷贝到socket缓存中，实际上，我们仅仅需要把缓冲区描述符传到socket缓冲区，再把数据长度传过去，这样DMA控制器直接将页缓存中的数据打包发送到网络中就可以了。</p>
</blockquote>
<p>系统调用<code>sendfile()</code>发起后，磁盘数据通过DMA方式读取到内核缓冲区，内核缓冲区中的数据通过DMA聚合网络缓冲区，然后一齐发送到网卡中。<br><strong>可以看到在这种模式下，是没有一次CPU进行数据拷贝的，所以就做到了真正意义上的零拷贝</strong></p>
<h3 id="1-5-后续优化-splice-系统调用"><a href="#1-5-后续优化-splice-系统调用" class="headerlink" title="1.5 后续优化-splice()系统调用"></a>1.5 后续优化-splice()系统调用</h3><blockquote>
<p>splice() 系统调用和 sendfile() 非常类似，用户应用程序必须拥有两个已经打开的文件描述符，一个用于表示输入设备，一个用于表示输出设备。与 sendfile() 不同的是，splice() 允许任意两个文件之间互相连接，而并不只是文件到 socket 进行数据传输。对于从一个文件描述符发送数据到 socket 这种特例来说，一直都是使用 sendfile() 这个系统调用，而 splice 一直以来就只是一种机制，它并不仅限于 sendfile() 的功能。也就是说，sendfile() 只是 splice() 的一个子集，在 Linux 2.6.23 中，sendfile() 这种机制的实现已经没有了，但是这个 API 以及相应的功能还存在，只不过 API 以及相应的功能是利用了 splice() 这种机制来实现的。</p>
</blockquote>
<p>总体来讲<code>splice()</code>是Linux 2.6.23 内核版本中替换<code>sendfile()</code>系统调用的一个方法，它不仅支持文件到Socket的直接传输，也支持文件到文件的直接传输I/O，但是其底层的传输过程和<code>sendfile()</code>并无区别，也就是上面那两张图。</p>
<h2 id="二-JavaNIO中的零拷贝"><a href="#二-JavaNIO中的零拷贝" class="headerlink" title="二.JavaNIO中的零拷贝"></a>二.JavaNIO中的零拷贝</h2><p>真是没想到对于操作系统中的零拷贝技术要占这么多内容，但是不说又不行，因为Java中的零拷贝也是通过操作系统的系统调用来实现的。</p>
<h3 id="2-1-NIO中内存映射方式I-O"><a href="#2-1-NIO中内存映射方式I-O" class="headerlink" title="2.1 NIO中内存映射方式I/O"></a>2.1 NIO中内存映射方式I/O</h3><p>操作系统的读写缓冲区和JavaNIO没有关系任何关系，操作系统的读写缓冲区（Linux中就是PageCache）是内核中直接和IO设备驱动交互的内存区域，程序员平时是接触不到的</p>
<p>我们来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"test.zip"</span>);</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel fileChannel = raf.getChannel();</span><br><span class="line">MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, fileChannel.size());</span><br></pre></td></tr></table></figure>
<p><strong>NIO中的<code>FileChannel.map()</code>方法其实就是采用了操作系统中的内存映射方式。</strong></p>
<p><strong>内存地址映射其实是操作系统将内存地址和磁盘文件做一个映射，读写这块内存，相当于直接对磁盘文件进行读写，但是实际上的读还是要经过OS读取到内存<code>PageCache</code>中，写过程也需要OS自动进行脏页置换到磁盘中。</strong></p>
<p>这种方式适合读取大文件，同时也能对文件内容进行更改，但是如果其后要通过SocketChannel发送，还是需要CPU进行数据的拷贝。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">processData();</span><br><span class="line"><span class="comment">// 数据处理完成以后，打卡一个SocketChannel</span></span><br><span class="line">SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">""</span>, <span class="number">1234</span>));</span><br><span class="line"><span class="comment">// 这时依旧需要CPU将内核缓冲区的内容拷贝到网络缓冲区</span></span><br><span class="line">socketChannel.write(buffer);</span><br></pre></td></tr></table></figure>


<h3 id="2-2-NIO中的零拷贝"><a href="#2-2-NIO中的零拷贝" class="headerlink" title="2.2 NIO中的零拷贝"></a>2.2 NIO中的零拷贝</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"test.zip"</span>);</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel fileChannel = raf.getChannel();</span><br><span class="line">SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">""</span>, <span class="number">1234</span>));</span><br><span class="line"><span class="comment">// 直接使用了transferTo()进行通道间的数据传输</span></span><br><span class="line">fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180510221828799?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyaW5nS29uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>这种方式就是NIO中的零拷贝，我们来分析一下其中原理：</p>
<ol>
<li><p>NIO中的Buffer都在用户空间中，包括<code>DirectBuffer</code>，也是C语言<code>malloc</code>出来的一块内存。</p>
</li>
<li><p><code>transferTo()</code>的实现方式就是通过系统调用<code>sendfile()</code>（当然这是Linux中的系统调用，Windows中系统调用有所不同），根据我们上面所写说这个过程是效率远高于从内核缓冲区到用户缓冲区的读写的。</p>
</li>
</ol>
<p>同理<code>transferFrom()</code>也是这种实现方式。</p>
<h2 id="三-补充内容"><a href="#三-补充内容" class="headerlink" title="三. 补充内容"></a>三. 补充内容</h2><p>这篇文章写的时间已经有一年多了，在这一年里我学习了更多中间件的知识，也认识到了更多现实，首先就是Java语言得IO效率比起C和C++是远远不如的，因为有JVM的存在就导致了Java的IO永远要比其他语言多一层内存交换，但是Java在中间件方面还是大有可为的，比如说消息队列，kafka就是Java写的，吞吐量和稳定性都达到了令人满意的效果。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「CringKong」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/cringkong/article/details/80274148" target="_blank" rel="noopener">https://blog.csdn.net/cringkong/article/details/80274148</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java中四种引用类型</title>
    <url>/2020/06/05/Java%E4%B8%AD%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>转载 <a href="https://www.javazhiyin.com/60330.html" target="_blank" rel="noopener">原文地址</a></p>
<p>以前学习强软弱虚引用的时候，只是走马观花看看博客，并没有自己写代码去实践、去证明，导致每次看完后，过不了多久就忘了，后来下定决心，一定要自己敲敲代码，这样才能让印象更加深刻，古人云：纸上得来终觉浅，绝知此事要躬行。</p>
<h3 id="Java中的四种引用"><a href="#Java中的四种引用" class="headerlink" title="Java中的四种引用"></a>Java中的四种引用</h3><p>Java中有四种引用类型：强引用、软引用、弱引用、虚引用。</p>
<h3 id="Java为什么要设计这四种引用"><a href="#Java为什么要设计这四种引用" class="headerlink" title="Java为什么要设计这四种引用"></a>Java为什么要设计这四种引用</h3><p>Java的内存分配和内存回收，都不需要程序员负责，都是由伟大的JVM去负责，一个对象是否可以被回收，主要看是否有引用指向此对象，说的专业点，叫可达性分析。</p>
<p><strong>Java设计这四种引用的主要目的有两个：</strong></p>
<ul>
<li>可以让程序员通过代码的方式来决定某个<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247491186&idx=2&sn=78cf718d5ce5c591a9fddd28c5931c0d&chksm=ebd6215edca1a84824d48032eef62fd5276b14c484d1691ff3054a051b794a2e01a1663b60fa&scene=21#wechat_redirect" target="_blank" rel="noopener">对象的生命周期</a>；</li>
<li>有利用垃圾回收。</li>
</ul>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>强引用是最普遍的一种引用，我们写的代码，99.9999%都是强引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<p>这种就是强引用了，是不是在代码中随处可见，最亲切。</p>
<p>只要某个对象有强引用与之关联，这个对象永远不会被回收，即使内存不足，JVM宁愿抛出OOM，也不会去回收。</p>
<p>那么什么时候才可以被回收呢？当强引用和对象之间的关联被中断了，就可以被回收了。</p>
<p>我们可以手动把关联给中断了，方法也特别简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">o = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以手动调用GC，看看如果强引用和对象之间的关联被中断了，资源会不会被回收，为了更方便、更清楚的观察到回收的情况，我们需要新写一个类，然后重写finalize方法，下面我们来进行这个实验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student 被回收了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student 被回收了</span><br></pre></td></tr></table></figure>

<p>可以很清楚的看到资源被回收了。</p>
<p><strong>当然，在实际开发中，千万不要重写finalize方法</strong></p>
<p>在实际的开发中，看到有一些对象被手动赋值为NULL，很大可能就是为了“特意提醒”JVM这块资源可以进行垃圾回收了。</p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用用来描述一些还有用,但非必须的对象.下面先来看看如何创建一个软引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;Student&gt; studentSoftReference = <span class="keyword">new</span> SoftReference&lt;Student&gt;(<span class="keyword">new</span> Student());</span><br></pre></td></tr></table></figure>

<p>软引用就是把对象用SoftReference包裹一下，当我们需要从软引用对象获得包裹的对象，只要get一下就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;Student&gt;studentSoftReference=<span class="keyword">new</span> SoftReference&lt;Student&gt;(<span class="keyword">new</span> Student());</span><br><span class="line">Student student = studentSoftReference.get();</span><br><span class="line">System.out.println(student);</span><br></pre></td></tr></table></figure>

<p>软引用有什么特点呢：<strong>当内存不足，会触发JVM的GC，如果GC后，内存还是不足，就会把软引用的包裹的对象给干掉，也就是只有在内存不足，JVM才会回收该对象。</strong></p>
<p>还是一样的，必须做实验，才能加深印象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;<span class="keyword">byte</span>[]&gt; softReference = <span class="keyword">new</span> SoftReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>]);</span><br><span class="line">System.out.println(softReference.get());</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];</span><br><span class="line">System.out.println(softReference.get());</span><br></pre></td></tr></table></figure>

<p>我定义了一个软引用对象，里面包裹了byte[]，byte[]占用了10M，然后又创建了10Mbyte[]。</p>
<p>运行程序，需要带上一个参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xmx20M</span><br></pre></td></tr></table></figure>

<p>代表最大堆内存是20M。</p>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[B@11d7fff</span><br><span class="line">[B@11d7fff</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p>可以很清楚的看到手动完成GC后，软引用对象包裹的byte[]还活的好好的，但是当我们创建了一个10M的byte[]后，最大堆内存不够了，所以把软引用对象包裹的byte[]给干掉了，如果不干掉，<a href="http://mp.weixin.qq.com/s?__biz=MzU2MTI4MjI0MQ==&mid=2247489313&idx=1&sn=cb158851106a8b3296f683d17912f540&chksm=fc7a7a8fcb0df3995b464892e15776bbabcabb384a2c1934281ad0a1adb981790aca5c2a80dd&scene=21#wechat_redirect" target="_blank" rel="noopener">就会抛出OOM</a>。</p>
<p>软引用到底有什么用呢？比较适合用作缓存，当内存足够，可以正常的拿到缓存，当内存不够，就会先干掉缓存，不至于马上抛出OOM。比如Mybatis的二级缓存回收策略为Soft时,其实现类<code>SoftCache</code>就是一个软引用类型.</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用和软引用类似,都是用来描述非必须对象的,但它只能生存到下一次GC前，关键字为WeakReference：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>]);</span><br><span class="line">System.out.println(weakReference.get());</span><br></pre></td></tr></table></figure>

<p>根据JDK文档,弱引用常用来实现规范化映射,特点是不管内存是否足够，只要发生GC，都会被回收：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>]);</span><br><span class="line">System.out.println(weakReference.get());</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(weakReference.get());</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[B@11d7fff</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p>可以很清楚的看到明明内存还很充足，但是触发了GC，资源还是被回收了。弱引用在很多地方都有用到，比如<code>ThreadLocal</code>、<code>WeakHashMap</code>。</p>
<p><code>ThreadLocal</code>通过使用弱引用<code>Entry</code>来避免内存泄漏，我们知道<code>ThreadLocal</code>变量在不同的线程中有不同的值，原理是每个线程都有一个<code>ThreadLocalMap</code>，用来存放<code>ThreadLocal</code>变量表.<code>ThreadLocal</code> 本身并不存储值，它只是作为一个 <code>key</code> 来让线程从 <code>ThreadLocalMap</code> 获取 <code>value</code>。结构如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1272254-df040bae132e019b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/714/format/webp" alt="img"></p>
<p>图中的虚线表示 <code>ThreadLocalMap</code> 是使用 <code>ThreadLocal</code> 的弱引用作为 <code>Key</code> 的，当<code>ThreadLocalRef</code>使用完毕释放以后,仅有弱引用的对象<code>ThreadLocal</code>在 GC 时会被回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里为什么要使用弱引用呢？</strong></p>
<p>如果不使用弱引用，当持有value的强引用释放掉后，而且线程没有结束(回收释放)时，<code>threadLocalMap</code>会一直持有ThreadLocal以及value的强引用，导致value不能够被回收，从而造成内存泄漏。</p>
<p>通过使用弱引用，当ThreadLocal的强引用释放掉后，通过一次系统gc检查，发现ThreadLocal对象只有threadLocalMap中Entry的若引用持有，此时根据弱引用的机制就会回收ThreadLocal对象，从而避免了内存泄露。</p>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用又被称为幻影引用，我们来看看它的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference&lt;<span class="keyword">byte</span>[]&gt; reference = <span class="keyword">new</span> PhantomReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>], queue);</span><br><span class="line">System.out.println(reference.get());</span><br></pre></td></tr></table></figure>

<p>虚引用的使用和上面说的软引用、弱引用的区别还是挺大的，我们先不管ReferenceQueue 是个什么鬼，直接来运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">null</span><br></pre></td></tr></table></figure>

<p>竟然打印出了null，我们来看看get方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是几个意思，竟然直接返回了null。</p>
<p>这就是虚引用特点之一了：<strong>无法通过虚引用来获取对一个对象的真实引用。</strong></p>
<p>那虚引用存在的意义是什么呢？这就要回到我们上面的代码了，我们把代码复制下，以免大家再次往上翻：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference&lt;<span class="keyword">byte</span>[]&gt; reference = <span class="keyword">new</span> PhantomReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>], queue);</span><br><span class="line">System.out.println(reference.get());</span><br></pre></td></tr></table></figure>

<p>创建虚引用对象，我们除了把包裹的对象传了进去，还传了一个<code>ReferenceQueue</code>，从名字就可以看出它是一个队列。</p>
<p>虚引用的特点之二就是 <strong>虚引用必须与ReferenceQueue一起使用，当GC准备回收一个对象，如果发现它还有虚引用，就会在回收之前，把这个虚引用加入到与之关联的ReferenceQueue中。</strong></p>
<p>我们来用代码实践下吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">    List&lt;<span class="keyword">byte</span>[]&gt; bytes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    PhantomReference&lt;Student&gt; reference = <span class="keyword">new</span> PhantomReference&lt;Student&gt;(<span class="keyword">new</span> Student(),queue);</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>;i++ ) &#123;</span><br><span class="line">            bytes.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Reference poll = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"虚引用被回收了："</span> + poll);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    scanner.hasNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student 被回收了</span><br><span class="line">虚引用被回收了：java.lang.ref.PhantomReference@1ade6f1</span><br></pre></td></tr></table></figure>

<p>我们简单的分析下代码：</p>
<blockquote>
<p>第一个线程往集合里面塞数据，随着数据越来越多，肯定会发生GC。<br>第二个线程死循环，从queue里面拿数据，如果拿出来的数据不是null，就打印出来。</p>
</blockquote>
<p>从运行结果可以看到：<strong>当发生GC，虚引用就会被回收，并且会把回收的通知放到ReferenceQueue中。</strong></p>
<p>虚引用有什么用呢？在NIO中，就运用了虚引用管理堆外内存。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>理解Netty中的零拷贝（Zero-Copy）机制</title>
    <url>/2020/06/05/%E7%90%86%E8%A7%A3Netty%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%88Zero-Copy%EF%BC%89%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>转载 <a href="https://my.oschina.net/plucury/blog/192577" target="_blank" rel="noopener">原文地址</a></p>
<h2 id="理解零拷贝"><a href="#理解零拷贝" class="headerlink" title="理解零拷贝"></a>理解零拷贝</h2><p>零拷贝是Netty的重要特性之一，而究竟什么是零拷贝呢？ WIKI中对其有如下定义：</p>
<blockquote>
<p>“Zero-copy” describes computer operations in which the CPU does not perform the task of copying data from one memory area to another.</p>
</blockquote>
<p>从WIKI的定义中，我们看到“零拷贝”是指计算机操作的过程中，CPU不需要为数据在内存之间的拷贝消耗资源。而它通常是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间（User Space）而直接在内核空间（Kernel Space）中传输到网络的方式。</p>
<p>Non-Zero Copy方式： <img src="http://static.oschina.net/uploads/space/2014/0108/104700_qc4H_859646.png" alt="Non-Zero Copy"></p>
<p>Zero Copy方式： <img src="http://static.oschina.net/uploads/space/2014/0108/104957_UW6E_859646.png" alt="在此输入图片描述"></p>
<p>从上图中可以清楚的看到，Zero Copy的模式中，避免了数据在用户空间和内存空间之间的拷贝，从而提高了系统的整体性能。Linux中的<code>sendfile()</code>以及Java NIO中的<code>FileChannel.transferTo()</code>方法都实现了零拷贝的功能，而在Netty中也通过在<code>FileRegion</code>中包装了NIO的<code>FileChannel.transferTo()</code>方法实现了零拷贝。</p>
<p>而在Netty中还有另一种形式的零拷贝，即Netty允许我们将多段数据合并为一整段虚拟数据供用户使用，而过程中不需要对数据进行拷贝操作，这也是我们今天要讲的重点。我们都知道在stream-based transport（如TCP/IP）的传输过程中，数据包有可能会被重新封装在不同的数据包中，例如当你发送如下数据时：</p>
<p><img src="http://static.oschina.net/uploads/space/2014/0108/112132_6ASE_859646.png" alt="Data Stream Sent"></p>
<p>有可能实际收到的数据如下：</p>
<p><img src="http://static.oschina.net/uploads/space/2014/0108/112212_qD2w_859646.png" alt="Data Stream Received"></p>
<p>因此在实际应用中，很有可能一条完整的消息被分割为多个数据包进行网络传输，而单个的数据包对你而言是没有意义的，只有当这些数据包组成一条完整的消息时你才能做出正确的处理，而Netty可以通过零拷贝的方式将这些数据包组合成一条完整的消息供你来使用。而此时，零拷贝的作用范围仅在用户空间中。</p>
<p><img src="http://static.oschina.net/uploads/space/2014/0108/113714_EoXP_859646.png" alt="Virtual Buffer"> ##Netty3中零拷贝的实现机制 <em>以下以Netty 3.8.0.Final的源代码来进行说明</em> </p>
<h3 id="ChannelBuffer接口"><a href="#ChannelBuffer接口" class="headerlink" title="ChannelBuffer接口"></a>ChannelBuffer接口</h3><p>Netty为需要传输的数据制定了统一的<code>ChannelBuffer</code>接口。该接口的主要设计思路如下：</p>
<ul>
<li>使用<code>getByte(int index)</code>方法来实现随机访问</li>
<li>使用双指针的方式实现顺序访问<ul>
<li>每个Buffer都有一个读指针（readIndex）和写指针（writeIndex）</li>
<li>在读取数据时读指针后移，在写入数据时写指针后移 <img src="http://static.oschina.net/uploads/space/2014/0113/105411_Hrta_859646.png" alt="在此输入图片描述"></li>
</ul>
</li>
</ul>
<p>定义了统一的接口之后，就是来做各种实现了。Netty主要实现了<code>HeapChannelBuffer</code>,<code>ByteBufferBackedChannelBuffer</code>等等，下面我们就来讲讲与Zero Copy直接相关的<code>CompositeChannelBuffer</code>类。 </p>
<h3 id="CompositeChannelBuffer类"><a href="#CompositeChannelBuffer类" class="headerlink" title="CompositeChannelBuffer类"></a>CompositeChannelBuffer类</h3><p><code>CompositeChannelBuffer</code>类的作用是将多个<code>ChannelBuffer</code>组成一个虚拟的<code>ChannelBuffer</code>来进行操作。为什么说是虚拟的呢，因为<code>CompositeChannelBuffer</code>并没有将多个<code>ChannelBuffer</code>真正的组合起来，而只是保存了他们的引用，这样就避免了数据的拷贝，实现了Zero Copy。 下面我们来看看具体的代码实现，首先是成员变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int readerIndex;</span><br><span class="line">private int writerIndex;</span><br><span class="line">private ChannelBuffer[] components;</span><br><span class="line">private int[] indices;</span><br><span class="line">private int lastAccessedComponentId;</span><br></pre></td></tr></table></figure>

<p>以上这里列出了几个比较重要的成员变量。其中<code>readerIndex</code>既读指针和<code>writerIndex</code>既写指针是从<code>AbstractChannelBuffer</code>继承而来的；然后<code>components</code>是一个<code>ChannelBuffer</code>的数组，他保存了组成这个虚拟Buffer的所有子Buffer，<code>indices</code>是一个<code>int</code>类型的数组，它保存的是各个Buffer的索引值；最后的<code>lastAccessedComponentId</code>是一个<code>int</code>值，它记录了最后一次访问时的子Buffer ID。从这个数据结构，我们不难发现所谓的<code>CompositeChannelBuffer</code>实际上就是将一系列的Buffer通过数组保存起来，然后实现了<code>ChannelBuffer</code> 的接口，使得在上层看来，操作这些Buffer就像是操作一个单独的Buffer一样。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p> 接下来，我们再看一下<code>CompositeChannelBuffer.setComponents</code>方法，它会在初始化<code>CompositeChannelBuffer</code>时被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Setup this ChannelBuffer from the list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setComponents</span><span class="params">(List&lt;ChannelBuffer&gt; newComponents)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> !newComponents.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the cache.</span></span><br><span class="line">    lastAccessedComponentId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the component array.</span></span><br><span class="line">    components = <span class="keyword">new</span> ChannelBuffer[newComponents.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; components.length; i ++) &#123;</span><br><span class="line">        ChannelBuffer c = newComponents.get(i);</span><br><span class="line">        <span class="keyword">if</span> (c.order() != order()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"All buffers must have the same endianness."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> c.readerIndex() == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">assert</span> c.writerIndex() == c.capacity();</span><br><span class="line"></span><br><span class="line">        components[i] = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the component lookup table.</span></span><br><span class="line">    indices = <span class="keyword">new</span> <span class="keyword">int</span>[components.length + <span class="number">1</span>];</span><br><span class="line">    indices[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= components.length; i ++) &#123;</span><br><span class="line">        indices[i] = indices[i - <span class="number">1</span>] + components[i - <span class="number">1</span>].capacity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the indexes.</span></span><br><span class="line">    setIndex(<span class="number">0</span>, capacity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过代码可以看到该方法的功能就是将一个<code>ChannelBuffer</code>的List给组合起来。它首先将List中得元素放入到<code>components</code>数组中，然后创建<code>indices</code>用于数据的查找，最后使用<code>setIndex</code>来重置指针。这里需要注意的是<code>setIndex(0, capacity())</code>会将读指针设置为0，写指针设置为当前Buffer的长度，这也就是前面需要做<code>assert c.readerIndex() == 0</code>和<code>assert c.writerIndex() == c.capacity()</code>这两个判断的原因，否则很容易会造成数据重复读写的问题，所以Netty推荐我们使用<code>ChannelBuffers.wrappedBuffer</code>方法来进行Buffer的合并，因为在该方法中Netty会通过<code>slice()</code>方法来确保构建<code>CompositeChannelBuffer</code>是传入的所有子Buffer都是符合要求的。</p>
<h3 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h3><p><code>CompositeChannelBuffer.getByte(int index)</code>的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> componentId = componentId(index);</span><br><span class="line">    <span class="keyword">return</span> components[componentId].getByte(index - indices[componentId]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码我们可以看到，在随机查找时会首先通过index获取这个字节所在的<code>componentId</code>既字节所在的子Buffer序列，然后通过<code>index - indices[componentId]</code>计算出它在这个子Buffer中的第几个字节，然后返回结果。</p>
<p>下面再来看一下<code>componentId(int index)</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">componentId</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastComponentId = lastAccessedComponentId;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= indices[lastComponentId]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; indices[lastComponentId + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> lastComponentId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Search right</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lastComponentId + <span class="number">1</span>; i &lt; components.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; indices[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                lastAccessedComponentId = i;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Search left</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lastComponentId - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= indices[i]) &#123;</span><br><span class="line">                lastAccessedComponentId = i;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Invalid index: "</span> + index + <span class="string">", maximum: "</span> + indices.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中我们发现，Netty以<code>lastComponentId</code>既上次访问的子Buffer序号为中心，向左右两边进行搜索，这样做的目的是，当我们两次随机查找的字符序列相近时（大部分情况下都是这样），可以最快的搜索到目标索引的<code>componentId</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://my.oschina.net/flashsword/blog/164237" target="_blank" rel="noopener">http://my.oschina.net/flashsword/blog/164237</a></li>
<li><a href="http://en.wikipedia.org/wiki/Zero-copy" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Zero-copy</a></li>
<li><a href="http://stackoverflow.com/questions/20727615/is-nettys-zero-copy-different-from-os-level-zero-copy" target="_blank" rel="noopener">http://stackoverflow.com/questions/20727615/is-nettys-zero-copy-different-from-os-level-zero-copy</a></li>
<li><a href="http://www-old.itm.uni-luebeck.de/teaching/ws1112/vs/Uebung/GrossUebungNetty/VS-WS1112-xx-Zero-Copy_Event-Driven_Servers_with_Netty.pdf?lang=de" target="_blank" rel="noopener">http://www-old.itm.uni-luebeck.de/teaching/ws1112/vs/Uebung/GrossUebungNetty/VS-WS1112-xx-Zero-Copy_Event-Driven_Servers_with_Netty.pdf?lang=de</a></li>
</ol>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>数组中的逆序对</title>
    <url>/2020/06/06/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题目保证输入的数组中没有的相同的数字数据范围：	对于%50的数据,size&lt;&#x3D;10^4	对于%75的数据,size&lt;&#x3D;10^5	对于%100的数据,size&lt;&#x3D;2*10^5</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,2,3,4,5,6,7,0</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>归并排序.leetcode上可以通过,牛客网剑指Offer没有完全通过,由于错误用例看不完整,正在排查原因</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mergeSort(array);</span><br><span class="line">    <span class="keyword">return</span> c % <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n.length == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n[<span class="number">0</span>] &gt; n[<span class="number">1</span>]) &#123;</span><br><span class="line">            c++;</span><br><span class="line">            <span class="keyword">int</span> t = n[<span class="number">0</span>];</span><br><span class="line">            n[<span class="number">0</span>] = n[<span class="number">1</span>];</span><br><span class="line">            n[<span class="number">1</span>] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] n1, n2;</span><br><span class="line">    n1 = mergeSort(Arrays.copyOfRange(n, <span class="number">0</span>, n.length / <span class="number">2</span>));</span><br><span class="line">    n2 = mergeSort(Arrays.copyOfRange(n, n.length / <span class="number">2</span>, n.length));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo merge 统计逆序对</span></span><br><span class="line">    <span class="keyword">int</span>[] n3 = <span class="keyword">new</span> <span class="keyword">int</span>[n.length];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1.length &amp;&amp; j &lt; n2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n1[i] &lt;= n2[j]) &#123;</span><br><span class="line">            n3[k] = n1[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            n3[k] = n2[j];</span><br><span class="line">            j++;</span><br><span class="line">            c += (n1.length - i);</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n1.length; k++, i++) &#123;</span><br><span class="line">        n3[k] = n1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt; n2.length; k++, j++) &#123;</span><br><span class="line">        n3[k] = n2[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/96bd6684e04a44eb80e6a68efc0ec6c5?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/96bd6684e04a44eb80e6a68efc0ec6c5?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<p>题目描述：给定一个数组arr， 数组元素各不相同，求arr[i] &gt; arr[j] 且 i &lt; j的个数。</p>
<p>首先还是提出两个问题，带着问题来看题解，我觉得效率更好。<br>Q1：为什么归并排序需要额外的空间？<br>Q2：为什么此题的最优解法可以借助归并排序的思想？</p>
<h2 id="方法一：暴力方法"><a href="#方法一：暴力方法" class="headerlink" title="方法一：暴力方法"></a>方法一：暴力方法</h2><p>对于此题，按住一个arr[i], 依次判断{i+1 … n-1]是否满足条件。n为数组的大小。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    const int kmod &#x3D; 1000000007;</span><br><span class="line">public:</span><br><span class="line">    int InversePairs(vector&lt;int&gt; data) &#123;</span><br><span class="line">        int ret &#x3D; 0;</span><br><span class="line">        int n &#x3D; data.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">                if (data[i] &gt; data[j]) &#123;</span><br><span class="line">                    ret +&#x3D; 1;</span><br><span class="line">                    ret %&#x3D; kmod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于10^5数据，O(N^2)算法显然超时。<br>时间复杂度：O(N^2)<br>空间复杂度：O(1)</p>
<h2 id="方法二：归并排序思想"><a href="#方法二：归并排序思想" class="headerlink" title="方法二：归并排序思想"></a>方法二：归并排序思想</h2><p>A1：    首先回答一下第一个问题，为什么归并排序需要额外空间？<br>显然我们知道，归并排序的过程就是，递归划分整个区间为基本相等的左右区间，之间左右区间各只有一个数字，然后就合并两个有序区间。<br>问题就出在了合并两个有序区间上，需要额外的空间。<br>为什么呢？<br>这里我举个例子，比如需要合并的两个有序区间为[3 4] 和 [1 2]<br>我们需要得到最后的结果为[1 2 3 4]， 如果不需要额外的空间的话，是做不到的，<br>当比较1 和 3 的时候， 1 比 3 小，就会覆盖原来的位置。</p>
<p>A2：回答第二个问题之前，先了解一下归并排序的过程，主要有以下两个操作：</p>
<ul>
<li>递归划分整个区间为基本相等的左右两个区间 </li>
<li>合并两个有序区间 </li>
</ul>
<p>可能看了代码，更好理解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 合并过程</span><br><span class="line">void merge__(vector&lt;int&gt; &amp;arr, int l, int mid, int r) &#123;</span><br><span class="line">    &#x2F;&#x2F; 在这个地方创建额外空间，是一种不好的做法，更好的做法，等下讲</span><br><span class="line">    vector&lt;int&gt; tmp(r - l + 1);</span><br><span class="line">    int i &#x3D; l, j &#x3D; mid + 1, k &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r) &#123;</span><br><span class="line">        if (arr[i] &gt;&#x3D; arr[j]) &#123;</span><br><span class="line">            tmp[k++] &#x3D; arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            tmp[k++] &#x3D; arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (i &lt;&#x3D; mid) &#123;</span><br><span class="line">        tmp[k++] &#x3D; arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (j &lt;&#x3D; r) &#123;</span><br><span class="line">        tmp[k++] &#x3D; arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (k &#x3D; 0, i &#x3D; l; i &lt;&#x3D; r; ++i, ++k) &#123;</span><br><span class="line">        arr[i] &#x3D; tmp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归划分过程</span><br><span class="line">void merge_sort__(vector&lt;int&gt; &amp;arr, int l, int r) &#123;</span><br><span class="line">    &#x2F;&#x2F; 只有一个数字，则停止划分</span><br><span class="line">    if (l &gt;&#x3D; r) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int mid &#x3D; l + ((r - l) &gt;&gt; 1);</span><br><span class="line">    merge_sort__(arr, l, mid);</span><br><span class="line">    merge_sort__(arr, mid + 1, r);</span><br><span class="line">    &#x2F;&#x2F; 合并两个有序区间</span><br><span class="line">    merge__(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 要排序的数组 arr</span><br><span class="line">void merge_sort(vector&lt;int&gt;&amp; arr) &#123;</span><br><span class="line">    merge_sort__(arr, 0, arr.size() - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明白了归并排序的过程，那么回答问题2.<br>如果两个区间为[4, 3] 和[1, 2]<br>那么逆序数为(4,1),(4,2),(3,1),(3,2)，同样的如果区间变为有序，比如[3,4] 和 [1,2]的结果是一样的，也就是说区间有序和无序结果是一样的。<br>但是如果区间有序会有什么好处吗？当然，如果区间有序，比如[3,4] 和 [1,2]<br>如果3 &gt; 1, 显然3后面的所有数都是大于1， 这里为 4 &gt; 1, 明白其中的奥秘了吧。所以我们可以在合并的时候利用这个规则。</p>
<p>直接上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    const int kmod &#x3D; 1000000007;</span><br><span class="line">public:</span><br><span class="line">    int InversePairs(vector&lt;int&gt; data) &#123;</span><br><span class="line">        int ret &#x3D; 0;</span><br><span class="line">        merge_sort__(data, 0, data.size() - 1, ret);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void merge_sort__(vector&lt;int&gt; &amp;arr, int l, int r, int &amp;ret) &#123;</span><br><span class="line">        if (l &gt;&#x3D; r) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int mid &#x3D; l + ((r - l) &gt;&gt; 1);</span><br><span class="line">        merge_sort__(arr, l, mid, ret);</span><br><span class="line">        merge_sort__(arr, mid + 1, r, ret);</span><br><span class="line">        merge__(arr, l, mid, r, ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void merge__(vector&lt;int&gt; &amp;arr, int l, int mid, int r, int &amp;ret) &#123;</span><br><span class="line">        vector&lt;int&gt; tmp(r - l + 1);</span><br><span class="line">        int i &#x3D; l, j &#x3D; mid + 1, k &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r) &#123;</span><br><span class="line">            if (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                tmp[k++] &#x3D; arr[j++];</span><br><span class="line">                &#x2F;&#x2F; 奥妙之处</span><br><span class="line">                ret +&#x3D; (mid - i + 1);</span><br><span class="line">                ret %&#x3D; kmod;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                tmp[k++] &#x3D; arr[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (i &lt;&#x3D; mid) &#123;</span><br><span class="line">            tmp[k++] &#x3D; arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &lt;&#x3D; r) &#123;</span><br><span class="line">            tmp[k++] &#x3D; arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (k &#x3D; 0, i &#x3D; l; i &lt;&#x3D; r; ++i, ++k) &#123;</span><br><span class="line">            arr[i] &#x3D; tmp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>刚才提到在函数内部开辟额外空间的做法很不好。因为这样会涉及到频繁的构建 vector 和析构vector，所以比较好的做法是：直接在最外层开辟一个足够大的数组，然后传引用到函数。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    const int kmod &#x3D; 1000000007;</span><br><span class="line">public:</span><br><span class="line">    int InversePairs(vector&lt;int&gt; data) &#123;</span><br><span class="line">        int ret &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 在最外层开辟数组</span><br><span class="line">        vector&lt;int&gt; tmp(data.size());</span><br><span class="line">        merge_sort__(data, tmp, 0, data.size() - 1, ret);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void merge_sort__(vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;tmp, int l, int r, int &amp;ret) &#123;</span><br><span class="line">        if (l &gt;&#x3D; r) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int mid &#x3D; l + ((r - l) &gt;&gt; 1);</span><br><span class="line">        merge_sort__(arr, tmp, l, mid, ret);</span><br><span class="line">        merge_sort__(arr, tmp, mid + 1, r, ret);</span><br><span class="line">        merge__(arr, tmp, l, mid, r, ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void merge__(vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;tmp, int l, int mid, int r, int &amp;ret) &#123;</span><br><span class="line">        int i &#x3D; l, j &#x3D; mid + 1, k &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r) &#123;</span><br><span class="line">            if (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                tmp[k++] &#x3D; arr[j++];</span><br><span class="line">                ret +&#x3D; (mid - i + 1);</span><br><span class="line">                ret %&#x3D; kmod;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                tmp[k++] &#x3D; arr[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (i &lt;&#x3D; mid) &#123;</span><br><span class="line">            tmp[k++] &#x3D; arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &lt;&#x3D; r) &#123;</span><br><span class="line">            tmp[k++] &#x3D; arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (k &#x3D; 0, i &#x3D; l; i &lt;&#x3D; r; ++i, ++k) &#123;</span><br><span class="line">            arr[i] &#x3D; tmp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(NlogN)<br>空间复杂度：O(N)</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>通过HashMap认识equals与hashcode</title>
    <url>/2020/06/05/%E9%80%9A%E8%BF%87HashMap%E8%AE%A4%E8%AF%86equals%E4%B8%8Ehashcode/</url>
    <content><![CDATA[<p>转载 <a href="https://www.jianshu.com/p/56e793643d8f" target="_blank" rel="noopener">原文链接</a></p>
<h2 id="什么是hashcode-hashcode的作用是什么"><a href="#什么是hashcode-hashcode的作用是什么" class="headerlink" title="什么是hashcode,hashcode的作用是什么"></a>什么是hashcode,hashcode的作用是什么</h2><p>hashcode并不是java中独有的。设想一下，如果让你设计一个算法，根据关键码去得到一个集合中的某个值或者这个关键码所在的位置。普通的做法就是挨个比较，高级一点的使用二分检索或者树形检索等算法。但是以上的检索算法都跟集合的长度N有关，当问题规模N很大时，这些检索的效率可能十分低下。</p>
<p>理想的情况是，根据关键码，我们就可以定位记录所在的位置，而不用去挨个进行比较。也就是说，在关键码与记录存放的位置之间做一种映射。这个映射的方法就是hash(哈希)函数，或者叫散列函数，也就是java中的hashCode()方法，他所返回的值就是hashcode，根据hashcode可以找到记录的位置。</p>
<p>按照散列的存储方式构造的存储结构叫做散列表。散列表中的一个位置称之为一个槽。</p>
<p>hashCode()方法存在于java.lang.Object类当中，任何类都可以继承修改这个方法。hashCode()方法返回调用它的实例的hashCode值，是个int值。</p>
<p>注：以下代码均来自jdk1.7</p>
<p>String中hashCode()方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是equals-Object-obj-方法"><a href="#什么是equals-Object-obj-方法" class="headerlink" title="什么是equals(Object obj)方法"></a>什么是equals(Object obj)方法</h2><p>equals(Object obj)方法同样来自Object类。在Object类中，他是这样实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，默认的equals(Object obj)方法直接将要比较的两个对象的内存地址进行了比较，一致则返回true。</p>
<p>这个方法主要用来实现两个对象间的比较，确认他们在逻辑上是否相等。我们同样可以实现自己的equals(Object obj)方法。</p>
<p>String中equals(Object obj)方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String) anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在java中hashcode方法与equals方法的作用"><a href="#在java中hashcode方法与equals方法的作用" class="headerlink" title="在java中hashcode方法与equals方法的作用"></a>在java中hashcode方法与equals方法的作用</h2><p>首先看一下HashMap中的put方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);<span class="comment">//得到hash值</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//找到槽</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们从 int hash = hash(key); 这一行看起，这行起才是put方法的核心。</p>
<p>首先 int hash = hash(key); key就是我们之前提到的关键码，我们看看HashMap中的这个hash方法做了些什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">        <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">        <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个方法里调用了key本身的hashCode方法，得到了key的hashcode，然后对该hashcode进行了一些移位操作，最终返回操作后的int值。返回的这个值就是HashMap要用到的hashcode值，通过他可以找到记录所在的位置。那么现在有一个问题：为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？可以直接使用key的hashcode的呀，这样做看起来不是多此一举吗？</p>
<p>其实这样做的目的是为下面的函数做准备的，我们看接下来要执行的代码：</p>
<p><code>int i = indexFor(hash, table.length);</code>找到所谓的槽，也就是记录存在的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns index for hash code h.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，indexFor(int h, int length)如何通过hashcode得到记录的位置。indexFor方法内部是一个取模运算，h是我们通过上面的hash方法得到的，length是散列表的长度。HashMap中的散列表是一个数组，通过取模运算能保证indexFor方法的返回值(记录的位置)一定在这个数组内，没有超过其长度。因为h往往是一个很大的数字(int可以表示40亿这么大的数字)，而散列表的初始长度是可以由我们指定的(默认是16),另一方面，就算给他这么大的数组，内存也是放不下的。所以取模运算是必须的。经过取模运算得到的才是真正的槽值。</p>
<p>回到上一个问题，<strong>为什么要专门调用这个hash(Onject key)方法来对key的hashcode进行包装然后再使用呢？而不是直接使用key的hashcode的</strong>？</p>
<p>想明白这个问题，参考<a href="https://link.jianshu.com?t=https://www.zhihu.com/question/20733617" target="_blank" rel="noopener">JDK 源码中 HashMap 的 hash 方法原理是什么？</a>。我们上面也说了这样做的目的是为indexFor方法做准备的，总的来说就是为了让取模运算不会出现一种极端情况：<strong>大量的不同的h经过取模后返回同样的槽值</strong>。这样会带来严重的性能问题，也就是严重的冲突情况导致性能下降。关于冲突，看下文。</p>
<p>要理解接下来的代码，我们就需要知道哈希算法的另一个概念：冲突。</p>
<p>散列函数可能对于不相等的关键码计算出相同的hashcode，该现象称为冲突。怎么理解呢？</p>
<p>比如我们有这样一个串abcd，我们给出这样一个散列函数：将每一个字符的ascii值加起来除以字符的个数，得到他们的平均值就是这个串的hashcode。那么，可以保证没有其他的串经过这样的算法得到相同的hashcode吗？也就是说，无限多的元素通过散列函数映射到有穷集合上，一定会产生冲突。这也是我们理解hashcode的一个重要的点：<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。</p>
<p>那么，产生冲突怎么办呢？产生冲突之后，不同的对象在散列表中找到了相同的位置，为了解决这个问题，我们将这个槽中的内容设计成一个链表，当产生冲突的时候，就将新的元素放到链表中，他看起来是这样的：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/5555632-b4a42ccffa5bf44f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/580/format/webp" alt="img"></p>
<p>其中：A，B，C分别为三条记录，他们就是产生冲突的三条记录。1,2,3….为散列表的索引位置。</p>
<p>接下来的代码  <code>for (Entry e = table[i]; e != null; e = e.next)</code>就容易理解了。找到记录所对应的槽之后，遍历这个链表直到找到与关键码相同的位置(可能之前已经有以这个关键码为key的value插入)。如果遍历完链表还没有找到这样的值，说明还不存在此关键码对应的记录，直接插入即可：<code>addEntry(hash, key, value, i);</code>.</p>
<p>那么，怎么判断两个关键码在逻辑上是否相同呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k)))</span><br></pre></td></tr></table></figure>

<p>可以看到，首先判断关键码的hashcode与链表记录的关键码hashcode是否相同：·<code>e.hash == hash</code>。为什么要加这样的判断？回头看看indexFor方法，经过取模运算后，不同的hashcode可以被散列在同一个槽中。通过这句代码可以将那些因为取模运算散列到同一个槽里的不同对象排除。</p>
<p>我们知道<strong>不同的对象(equals返回false)可以有相同的hashcode</strong>。相同的对象hashcode也必须相等吗？试想一下，如果两个对象相同，但是他们的hashcode不同，那么这两个对象很有可能被散列在不同的槽里，造成了同一个对象重复存储的问题。所以，我们又得出一个重要结论：<strong>相同的对象(equals返回true)hashcode一定相等</strong>。</p>
<p><code>e.hash == hash &amp;&amp; ((k = e.key) == key</code>：这段代码首先判断hashcode是否相等，然后判断关键码是否相等。注意，是判断<strong>关键码是否相等</strong>，直接比较内存地址，如果满足以上条件，那么可以断定两个关键码相同，是我们要找的记录。</p>
<p><code>key.equals(k)</code>：如果上述两个条件没有满足，并不能够断定这两个关键码相等，此刻要使用equals方法判断这两个关键码是否相同。如果相同，说明是我们要找的记录。</p>
<p><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code>这句代码中其实包含了一种短路思想，|| 之前的判断如果生效，那么之后的key.equals(k)就不会再执行。很明显内存地址的比较要比equals方法高效的多。这也是Hashmap提高查找效率的一个重要手段。</p>
<p>至此，我们应该对equals和hashcode有了一个相对清晰的认识：hashcode提高了查找指定对象的效率。euqals定义了两个对象之间是否在逻辑上相同。hashcode只在HashMap，HashSet等这样使用了散列思想的地方用到，而equals在判断两个对象之间是否相同时需要用到，比如排序等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析，我们知道了hashcode与equals的几个关键：</p>
<h4 id="1-不同的对象-equals返回false-可以有相同的hashcode"><a href="#1-不同的对象-equals返回false-可以有相同的hashcode" class="headerlink" title="1.不同的对象(equals返回false)可以有相同的hashcode"></a>1.<strong>不同的对象(equals返回false)可以有相同的hashcode</strong></h4><h4 id="2-相同的对象-equals返回true-hashcode一定相等"><a href="#2-相同的对象-equals返回true-hashcode一定相等" class="headerlink" title="2.相同的对象(equals返回true)hashcode一定相等"></a>2.<strong>相同的对象(equals返回true)hashcode一定相等</strong></h4><h4 id="3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）"><a href="#3-若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）" class="headerlink" title="3.若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义（对1、2的遵守）"></a>3.<strong>若重新定义了上面两种方法中的一种，那么另一种方法也需要重新定义</strong>（对1、2的遵守）</h4><p><a href="https://link.jianshu.com?t=http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java" target="_blank" rel="noopener">关于如何重写equals方法与hashCode方法</a></p>
<h2 id="equals与"><a href="#equals与" class="headerlink" title="equals与=="></a>equals与==</h2><p>“==” 比较的是两个对象的内存地址，是物理意义上的相等</p>
<p>equals比较的是两个对象逻辑意义上的相等，是逻辑意义上的相等</p>
<p>两个对象进行比较：</p>
<p><strong>== 返回true，则equals一定返回true</strong>；</p>
<p><strong>equals返回true，== 不一定返回true</strong>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>java默认的hashcode方法到底得到的是什么？</title>
    <url>/2020/06/07/java%E9%BB%98%E8%AE%A4%E7%9A%84hashcode%E6%96%B9%E6%B3%95%E5%88%B0%E5%BA%95%E5%BE%97%E5%88%B0%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>转载自<a href="https://blog.gavinzh.com/2018/08/23/what-is-hashcode-of-java/" target="_blank" rel="noopener">java默认的hashcode方法到底得到的是什么？</a></p>
<p>hashcode方法会影响jvm性能？听上去天方夜谭，实际上蕴藏着一些微小的原理，接下来让我们走进hashcode方法，一探native方法源头。</p>
<h2 id="默认实现是什么？"><a href="#默认实现是什么？" class="headerlink" title="默认实现是什么？"></a>默认实现是什么？</h2><p>调用hashCode方法默认返回的值被称为<strong>identity hash code（标识哈希码）</strong>，接下来我们会用标识哈希码来区分重写hashCode方法。如果一个类重写了hashCode方法，那么通过调用<code>System.identityHashCode(Object o)</code>方法获得标识哈希码。</p>
<p>在hashCode方法注释中，说hashCode一般是通过对象内存地址映射过来的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">As much as is reasonably practical, the hashCode method defined by</span><br><span class="line"> class &#123;@code Object&#125; does return distinct integers for distinct</span><br><span class="line"> objects. (This is typically implemented by converting the internal</span><br><span class="line"> address of the object into an integer, but this implementation</span><br><span class="line"> technique is not required by the</span><br><span class="line"> Java&lt;font size&#x3D;&quot;-2&quot;&gt;&lt;sup&gt;TM&lt;&#x2F;sup&gt;&lt;&#x2F;font&gt; programming language.)</span><br></pre></td></tr></table></figure>

<p>但是了解jvm的同学肯定知道，不管是<strong>标记复制算法</strong>还是<strong>标记整理算法</strong>，都会改变对象的内存地址。鉴于jvm重定位对象地址，但该hashCode又不能变化，那么该值一定是被保存在对象的某个地方了。</p>
<p>我们推测，很有可能是在第一次调用hashCode方法时获取当前内存地址，并将其保存在对象的某个地方，当下次调用时，只用从对象的某个地方获取值即可。但这样实际是有问题的，你想想，如果对象被归集到别的内存上了，那在对象以前的内存上创建的新对象其hashCode方法返回的值岂不是和旧对象的一样了？这倒没关系，java<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--" target="_blank" rel="noopener">规范</a>允许这样做。</p>
<p>以上都是我们的猜测，并没有实锤。我们来看一下源码吧，可恶，hashCode方法是一个本地方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="真正的hashCode方法"><a href="#真正的hashCode方法" class="headerlink" title="真正的hashCode方法"></a>真正的hashCode方法</h2><p>hashCode方法的实现依赖于jvm，不同的jvm有不同的实现，我们目前能看到jvm源码就是OpenJDK的源码，OpenJDK的源码大部分和Oracle的JVM源码一致。</p>
<p>OpenJDK定义hashCode的方法在<code>src/share/vm/prims/jvm.h</code>和<code>src/share/vm/prims/jvm.cpp</code>。</p>
<p>jvm.cpp:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">508</span> JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))</span><br><span class="line"><span class="number">509</span>   JVMWrapper(<span class="string">"JVM_IHashCode"</span>);</span><br><span class="line"><span class="number">510</span>   <span class="comment">// as implemented in the classic virtual machine; return 0 if object is NULL</span></span><br><span class="line"><span class="number">511</span>   <span class="keyword">return</span> handle == <span class="literal">NULL</span> ? <span class="number">0</span> : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;</span><br><span class="line"><span class="number">512</span> JVM_END</span><br></pre></td></tr></table></figure>

<p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp#l601" target="_blank" rel="noopener">ObjectSynchronizer :: FastHashCode（）</a> 也是通过调用<code>identity_hash_value_for</code>方法返回值的，<code>System.identityHashCode()</code>调用的也是这个方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">708</span> <span class="function"><span class="keyword">intptr_t</span> <span class="title">ObjectSynchronizer::identity_hash_value_for</span><span class="params">(Handle obj)</span> </span>&#123;</span><br><span class="line"><span class="number">709</span>   <span class="keyword">return</span> FastHashCode (Thread::current(), obj()) ;</span><br><span class="line"><span class="number">710</span> &#125;</span><br></pre></td></tr></table></figure>

<p>我们可能会认为 <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp#l601" target="_blank" rel="noopener">ObjectSynchronizer :: FastHashCode（）</a> 会判断当前的hash值是否为0，如果是0则生成一个新的hash值。实际上没那么简单，来看看其中的代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">685</span>   mark = monitor-&gt;header();</span><br><span class="line">...</span><br><span class="line"><span class="number">687</span>   hash = mark-&gt;hash();</span><br><span class="line"><span class="number">688</span>   <span class="keyword">if</span> (hash == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">689</span>     hash = get_next_hash(Self, obj);</span><br><span class="line">...</span><br><span class="line"><span class="number">701</span>   &#125;</span><br><span class="line">...</span><br><span class="line"><span class="number">703</span>   <span class="keyword">return</span> hash;</span><br></pre></td></tr></table></figure>

<p>上边的片段展示了hash值是如何生成的，可以看到hash值是存放在对象头中的，如果hash值不存在，则使用<code>get_next_hash</code>方法生成。</p>
<h2 id="真正的-identity-hash-code-生成"><a href="#真正的-identity-hash-code-生成" class="headerlink" title="真正的 identity hash code 生成"></a>真正的 identity hash code 生成</h2><p>在第二节中，我们终于找到了生成hash的最终函数 <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp#l555" target="_blank" rel="noopener">get_next_hash</a>，这个函数提供了6种生成hash值的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0. A randomly generated number.</span><br><span class="line">1. A function of memory address of the object.</span><br><span class="line">2. A hardcoded 1 (used for sensitivity testing.)</span><br><span class="line">3. A sequence.</span><br><span class="line">4. The memory address of the object, cast to int.</span><br><span class="line">5. Thread state combined with xorshift (https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Xorshift)</span><br></pre></td></tr></table></figure>

<p>那么默认用哪一个呢？根据<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/globals.hpp#l1127" target="_blank" rel="noopener">globals.hpp</a>，OpenJDK8默认采用第五种方法。而 <a href="http://hg.openjdk.java.net/jdk7u/jdk7u/hotspot/file/5b9a416a5632/src/share/vm/runtime/globals.hpp#l1100" target="_blank" rel="noopener">OpenJDK7</a> 和 <a href="http://hg.openjdk.java.net/jdk6/jdk6/hotspot/file/5cec449cc409/src/share/vm/runtime/globals.hpp#l1128" target="_blank" rel="noopener">OpenJDK6</a> 都是使用第一种方法，即 <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/os.cpp#l814" target="_blank" rel="noopener">随机数生成器</a>。</p>
<p>大家也看到了，JDK的注释算是欺骗了我们，明明在678版本上都是随机生成的值，为什么要引导说是内存地址映射呢？我理解可能以前就是通过第4种方法实现的。</p>
<h2 id="对象头格式"><a href="#对象头格式" class="headerlink" title="对象头格式"></a>对象头格式</h2><p>在上一节，我们知道了hash值是放在对象头里的，那就来了解一下对象头的结构吧。</p>
<p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/oops/markOop.hpp#l37" target="_blank" rel="noopener">markOop.hpp</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30 &#x2F;&#x2F; The markOop describes the header of an object.</span><br><span class="line">31 &#x2F;&#x2F;</span><br><span class="line">32 &#x2F;&#x2F; Note that the mark is not a real oop but just a word.</span><br><span class="line">33 &#x2F;&#x2F; It is placed in the oop hierarchy for historical reasons.</span><br><span class="line">34 &#x2F;&#x2F;</span><br><span class="line">35 &#x2F;&#x2F; Bit-format of an object header (most significant first, big endian layout below):</span><br><span class="line">36 &#x2F;&#x2F;</span><br><span class="line">37 &#x2F;&#x2F;  32 bits:</span><br><span class="line">38 &#x2F;&#x2F;  --------</span><br><span class="line">39 &#x2F;&#x2F;             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span><br><span class="line">40 &#x2F;&#x2F;             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span><br><span class="line">41 &#x2F;&#x2F;             size:32 ------------------------------------------&gt;| (CMS free block)</span><br><span class="line">42 &#x2F;&#x2F;             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span><br><span class="line">43 &#x2F;&#x2F;</span><br><span class="line">44 &#x2F;&#x2F;  64 bits:</span><br><span class="line">45 &#x2F;&#x2F;  --------</span><br><span class="line">46 &#x2F;&#x2F;  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span><br><span class="line">47 &#x2F;&#x2F;  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span><br><span class="line">48 &#x2F;&#x2F;  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span><br><span class="line">49 &#x2F;&#x2F;  size:64 -----------------------------------------------------&gt;| (CMS free block)</span><br><span class="line">50 &#x2F;&#x2F;</span><br><span class="line">51 &#x2F;&#x2F;  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span><br><span class="line">52 &#x2F;&#x2F;  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span><br><span class="line">53 &#x2F;&#x2F;  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span><br><span class="line">54 &#x2F;&#x2F;  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span><br></pre></td></tr></table></figure>

<p>它的格式在32位和64位上略有不同，64位有两种变体，具体取决于是否启用了压缩对象指针。</p>
<h2 id="对象头中偏向锁和hashcode的冲突"><a href="#对象头中偏向锁和hashcode的冲突" class="headerlink" title="对象头中偏向锁和hashcode的冲突"></a>对象头中偏向锁和hashcode的冲突</h2><p>在上一节我们看到，normal object和biased object分别存放的是hashcode和java的线程id。因此也就是说如果调用了本地方法hashCode，就会占用偏向锁对象使用的位置，偏向锁将会失效，晋升为轻量级锁。</p>
<p>这个过程我们可以看看<a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization" target="_blank" rel="noopener">这个图</a>：</p>
<p><img src="https://blog.gavinzh.com/usr/uploads/hexo/216/pasted-106.png" alt="upload successful"></p>
<p>这里我来简单解读一下，首先在jvm启动时，可以使用<code>-XX:+UseBiasedLocking=true</code>参数开启偏向锁。</p>
<p>接下来，如果偏向锁可用，那分配的对象中标记字格式为可包含线程ID，当未锁定时，线程ID为0，第一次获取锁时，线程会把自己的线程ID写到ThreadID字段内，这样，下一次获取锁时直接检查标记字中的线程ID和自身ID是否一致，如果一致就认为获取了锁，因此不需要再次获取锁。</p>
<p>假设这时有别的线程需要竞争锁了，此时该线程会通知持有偏向锁的线程释放锁，假设持有偏向锁的线程已经销毁，则将对象头设置为无锁状态，如果线程活着，则尝试切换，如果不成功，那么锁就会升级为轻量级锁。</p>
<p>这时有个问题来了，如果需要获取对象的identity hash code，偏向锁就会被禁用，然后给原先设置线程ID的位置写入hash值。</p>
<p>如果hash有值，或者偏向锁无法撤销，则会进入轻量级锁。轻量级锁竞争时，每个线程会先将hashCode值保存到自己的栈内存中，然后通过CAS尝试将自己新建的记录空间地址写入到对象头中，谁先写成功谁就拥有了该对象。</p>
<p>轻量级锁竞争失败的线程会自旋尝试获取锁一段时间，一段时间过后还没获取到锁，则升级为重量级锁，没获取锁的线程会被真正阻塞。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>OpenJDK默认的hashCode方法实现和对象内存地址无关，在版本6和7中，它是随机生成的数字，在版本8中，它是基于线程状态的数字。（<a href="https://www.azul.com/products/zing/virtual-machine/" target="_blank" rel="noopener">AZUL-ZING</a>的hashcode是基于地址的）</li>
<li>在Hotspot中，hash值会存在标记字中。</li>
<li>hashCode方法和<code>System.identityHashCode()</code>会让对象不能使用偏向锁，所以如果想使用偏向锁，那就最好重写hashCode方法。</li>
<li>如果大量对象跨线程使用，可以禁用偏向锁。</li>
<li>使用<code>-XX:hashCode=4</code>来修改默认的hash方法实现。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://srvaroa.github.io/jvm/java/openjdk/biased-locking/2017/01/30/hashCode.html" target="_blank" rel="noopener">https://srvaroa.github.io/jvm/java/openjdk/biased-locking/2017/01/30/hashCode.html</a></li>
<li><a href="https://www.cnblogs.com/javaminer/p/3892288.html" target="_blank" rel="noopener">https://www.cnblogs.com/javaminer/p/3892288.html</a></li>
<li><a href="https://www.cnblogs.com/charlesblc/p/5994162.html" target="_blank" rel="noopener">https://www.cnblogs.com/charlesblc/p/5994162.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>哲学家就餐问题</title>
    <url>/2020/06/09/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>转载整理自</p>
<p><a href="https://www.jianshu.com/p/99f10708b1e1" target="_blank" rel="noopener">哲学家就餐问题</a></p>
<p><a href="https://juejin.im/entry/59675880f265da6c2f0ac67e" target="_blank" rel="noopener">哲学家进餐-多线程同步经典问题</a></p>
<h2 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h2><p>死锁的四个必要条件：<br> （1） 互斥条件：一个资源每次只能被一个进程使用。<br> （2） 请求并保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br> （3） 不可剥夺条件: 进程已获得的资源，在末使用完之前，不能强行剥夺。<br> （4） 循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系</p>
<p>先写一个会造成死锁的哲学家问题。当所有哲学家同时决定进餐，拿起左边筷子时候，就发生了死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">5</span>;</span><br><span class="line">        Chopstick[] chopsticks = <span class="keyword">new</span> Chopstick[sum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">            chopsticks[i] = <span class="keyword">new</span> Chopstick();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Philosopher(chopsticks[i], chopsticks[(i + <span class="number">1</span>) % sum], i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筷子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chopstick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Chopstick left;</span><br><span class="line">    <span class="keyword">private</span> Chopstick right;</span><br><span class="line">    <span class="keyword">int</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(Chopstick left, Chopstick right, <span class="keyword">int</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//思考一段时间</span></span><br><span class="line">                <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);<span class="comment">//这样更容易发生死锁</span></span><br><span class="line">                    System.out.println(name + <span class="string">" get left"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                        System.out.println(name + <span class="string">" eat"</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);<span class="comment">//进餐一段时间</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="破坏死锁的循环等待条件"><a href="#破坏死锁的循环等待条件" class="headerlink" title="破坏死锁的循环等待条件"></a>破坏死锁的循环等待条件</h2><p>解决方案一：破坏死锁的<strong>循环等待条件</strong>。<br> 不再按左手右手顺序拿起筷子。选择一个固定的全局<strong>顺序获取</strong>，此处给筷子添加id，根据id先获取小的再获取大的，(不用关心编号的具体规则，只要保证编号全局唯一并且可排序)，不会出现死锁情况。</p>
<p>该方法适合获取锁的代码写的比较集中的情况，有利于<strong>维护这个全局顺序</strong>；若规模较大的程序，使用锁的地方比较零散，各处都遵守这个顺序就变得不太实际。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">5</span>;</span><br><span class="line">        Chopstick[] chopsticks = <span class="keyword">new</span> Chopstick[sum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">            chopsticks[i] = <span class="keyword">new</span> Chopstick(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Philosopher(chopsticks[i], chopsticks[(i + <span class="number">1</span>) % sum], i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筷子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chopstick</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Chopstick left;</span><br><span class="line">    <span class="keyword">private</span> Chopstick right;</span><br><span class="line">    <span class="keyword">int</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(Chopstick left, Chopstick right, <span class="keyword">int</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left.id &lt; right.id ? left : right;</span><br><span class="line">        <span class="keyword">this</span>.right = left.id &gt; right.id ? left : right;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//思考一段时间</span></span><br><span class="line">                <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">" get left"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                        System.out.println(name + <span class="string">" eat"</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);<span class="comment">//进餐一段时间</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="破坏死锁的请求与保持条件"><a href="#破坏死锁的请求与保持条件" class="headerlink" title="破坏死锁的请求与保持条件"></a>破坏死锁的请求与保持条件</h2><p>方法二：破坏死锁的<strong>请求与保持条件</strong>，使用lock的特性，<strong>为获取锁操作设置超时时间</strong>,当一段时间获取不到所有的资源时,就释放已获得的资源,重新开始请求资源。这样不会死锁（至少不会一直死锁）</p>
<p>该方法避免了无尽地死锁，但也不是很好的方案，因为该方案并不能避免死锁，它只是提供了从死锁中恢复的手段，并且受到活锁现象的影响，如果所有死锁线程同时超时，它们极有可能再次陷入死锁，虽然死锁没有永远持续下去，但<strong>对资源的争夺状态却没有得到任何改善</strong>（为每个线程设置不同的超时时间可以稍好的处理这种情况）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">50</span>;</span><br><span class="line">        Chopstick[] chopsticks = <span class="keyword">new</span> Chopstick[sum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">            chopsticks[i] = <span class="keyword">new</span> Chopstick();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Philosopher(chopsticks[i], chopsticks[(i + <span class="number">1</span>) % sum], i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筷子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock left, right;</span><br><span class="line">    <span class="keyword">int</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(ReentrantLock left, ReentrantLock right, <span class="keyword">int</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//思考一段时间</span></span><br><span class="line">                left.lock();</span><br><span class="line">                System.out.println(name + <span class="string">" get left"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock(<span class="number">1000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(name + <span class="string">" eat"</span>);</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);<span class="comment">//进餐一段时间</span></span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//没有获取到右手的筷子，放弃并继续思考</span></span><br><span class="line">                        System.out.println(name + <span class="string">" has not get right chopstick,give up"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用条件变量Condition"><a href="#使用条件变量Condition" class="headerlink" title="使用条件变量Condition"></a>使用条件变量Condition</h2><p>方法三：设置一个条件变量与锁关联。该方法只用一把锁，没有Chopstick类，将竞争从对筷子的争夺转换成了对状态的判断。仅当左右邻座都没有进餐时才可以进餐。提升了并发度。前面的方法出现情况是：只有一个哲学家进餐，其他人持有一根筷子在等待另外一根。这个方案中，当一个哲学家理论上可以进餐（邻座没有进餐）时，他就开始进餐。</p>
<p>思路是只使用一把锁，将竞争从对筷子的争夺转换成了对状态的判断，仅当哲学家的左右邻座都没有进餐时，才可以进餐。当一个哲学家饥饿时，首先锁住餐桌<code>table</code>，这样其他哲学家无法改变<code>table</code>状态，然后查看左右邻居是否正在进餐，如果没有，那么该哲学家开始进餐并解锁餐桌，否则调用await()以暂时解锁餐桌,等待条件满足后,再次尝试锁住餐桌<code>table</code>后开始进餐；当一个哲学家进餐结束并开始思考时，首先锁住餐桌将eating改为false，然后通知左右邻座可以进餐，最后解锁餐桌。如果他的左右邻居目前正在等待，那么他们将被唤醒，重新锁住餐桌，并判断是否开始进餐。</p>
<p>通过多次<code>newCondition()</code>可以获得多个<code>Condition</code>对象,可以通过<code>await()</code>,<code>signal()</code>等方法实现比较复杂的线程同步的功能。在这个解决方法中，当一个哲学家理论上可以进餐时，肯定就可以进餐，并发度显著提升。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">5</span>;</span><br><span class="line">        Philosopher[] philosophers = <span class="keyword">new</span> Philosopher[sum];</span><br><span class="line">        ReentrantLock table = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">            philosophers[i] = <span class="keyword">new</span> Philosopher(table, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">            philosophers[i].setLeft(philosophers[(i - <span class="number">1</span> + sum) % sum]);</span><br><span class="line">            philosophers[i].setRight(philosophers[(i + <span class="number">1</span>) % sum]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">            exec.execute(philosophers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> eating;</span><br><span class="line">    <span class="keyword">private</span> Philosopher left;</span><br><span class="line">    <span class="keyword">private</span> Philosopher right;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock table;</span><br><span class="line">    <span class="keyword">private</span> Condition condition;</span><br><span class="line">    <span class="keyword">int</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(ReentrantLock table, <span class="keyword">int</span> name)</span> </span>&#123;</span><br><span class="line">        eating = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.table = table;</span><br><span class="line">        condition = table.newCondition();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(Philosopher left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(Philosopher right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">think</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        table.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eating = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(name + <span class="string">" 开始思考"</span>);</span><br><span class="line">            left.condition.signal();</span><br><span class="line">            right.condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            table.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        table.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (left.eating || right.eating)</span><br><span class="line">                condition.await();</span><br><span class="line"></span><br><span class="line">            System.out.println(name + <span class="string">" 开始吃饭"</span>);</span><br><span class="line">            eating = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            table.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                think();</span><br><span class="line">                eat();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这一经典的问题，学习多线程并发模型的三种解决方案：</p>
<ol>
<li>多把锁时，对锁设置<strong>全局唯一的顺序</strong>，按序使用锁；(破坏循环等待条件)</li>
<li>设置线程<strong>获取锁的超时时间</strong>，防止无限制的死锁；(破坏请求与保持条件)</li>
<li>使用<strong>条件变量</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition Condition = lock.newCondition();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(!《条件为真》)</span><br><span class="line">		condition.await();</span><br><span class="line">	《使用共享资源》</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个条件变量需要与一把锁关联，线程在开始等待条件之前必须获取这把锁，获取锁后，线程检查所等待的条件是否已经为真，如果为真，线程将继续执行, 执行完毕后并解锁。条件变量的方法会使哲学家进餐问题的并发度显著提升。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>DDOS攻击的防范教程</title>
    <url>/2020/06/10/DDOS%E6%94%BB%E5%87%BB%E7%9A%84%E9%98%B2%E8%8C%83%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>转载自<a href="http://www.ruanyifeng.com/blog/2018/06/ddos.html" target="_blank" rel="noopener">DDOS攻击的防范教程</a></p>
<h2 id="一、DDOS-是什么？"><a href="#一、DDOS-是什么？" class="headerlink" title="一、DDOS 是什么？"></a>一、DDOS 是什么？</h2><p>首先，我来解释一下，DDOS 是什么。</p>
<p>举例来说，我开了一家餐厅，正常情况下，最多可以容纳30个人同时进餐。你直接走进餐厅，找一张桌子坐下点餐，马上就可以吃到东西。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018062602.jpg" alt="img"></p>
<p>很不幸，我得罪了一个流氓。他派出300个人同时涌进餐厅。这些人看上去跟正常的顾客一样，每个都说”赶快上餐”。但是，餐厅的容量只有30个人，根本不可能同时满足这么多的点餐需求，加上他们把门口都堵死了，里三层外三层，正常用餐的客人根本进不来，实际上就把餐厅瘫痪了。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018062603.jpg" alt="img"></p>
<p>这就是 DDOS 攻击，它在短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线。</p>
<p>DDOS 里面的 DOS 是 denial of service（停止服务）的缩写，表示这种攻击的目的，就是使得服务中断。最前面的那个 D 是 distributed （分布式），表示攻击不是来自一个地方，而是来自四面八方，因此更难防。你关了前门，他从后门进来；你关了后门，他从窗口跳起来。</p>
<h2 id="二、DDOS-的种类"><a href="#二、DDOS-的种类" class="headerlink" title="二、DDOS 的种类"></a>二、DDOS 的种类</h2><p>DDOS 不是一种攻击，而是一大类攻击的总称。它有几十种类型，新的攻击方法还在不断发明出来。网站运行的各个环节，都可以是攻击目标。只要把一个环节攻破，使得整个流程跑不起来，就达到了瘫痪服务的目的。</p>
<p>其中，比较常见的一种攻击是 cc 攻击。它就是简单粗暴地送来大量正常的请求，超出服务器的最大承受量，导致宕机。我遭遇的就是 cc 攻击，最多的时候全世界大概20多个 IP 地址轮流发出请求，每个地址的请求量在每秒200次~300次。我看访问日志的时候，就觉得那些请求像洪水一样涌来，一眨眼就是一大堆，几分钟的时间，日志文件的体积就大了100MB。说实话，这只能算小攻击，但是我的个人网站没有任何防护，服务器还是跟其他人共享的，这种流量一来立刻就下线了。</p>
<p>本文以下的内容都是针对 cc 攻击。</p>
<h2 id="三、备份网站"><a href="#三、备份网站" class="headerlink" title="三、备份网站"></a>三、备份网站</h2><p>防范 DDOS 的第一步，就是你要有一个备份网站，或者最低限度有一个临时主页。生产服务器万一下线了，可以立刻切换到备份网站，不至于毫无办法。</p>
<p>备份网站不一定是全功能的，如果能做到全静态浏览，就能满足需求。最低限度应该可以显示公告，告诉用户，网站出了问题，正在全力抢修。我的个人网站下线的时候，我就做了一个<a href="http://reverent-thompson-95d408.netlify.com/" target="_blank" rel="noopener">临时主页</a>，很简单的几行 <a href="https://github.com/ruanyf/website/blob/master/src/index.html" target="_blank" rel="noopener">HTML 代码</a>。</p>
<p>这种临时主页建议放到 <a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> 或者 <a href="https://www.netlify.com/" target="_blank" rel="noopener">Netlify</a>，它们的带宽大，可以应对攻击，而且都支持绑定域名，还能从源码自动构建。</p>
<h2 id="四、HTTP-请求的拦截"><a href="#四、HTTP-请求的拦截" class="headerlink" title="四、HTTP 请求的拦截"></a>四、HTTP 请求的拦截</h2><p>如果恶意请求有特征，对付起来很简单：直接拦截它就行了。</p>
<p>HTTP 请求的特征一般有两种：IP 地址和 User Agent 字段。比如，恶意请求都是从某个 IP 段发出的，那么把这个 IP 段封掉就行了。或者，它们的 User Agent 字段有特征（包含某个特定的词语），那就把带有这个词语的请求拦截。</p>
<p>拦截可以在三个层次做。</p>
<p><strong>（1）专用硬件</strong></p>
<p>Web 服务器的前面可以架设硬件防火墙，专门过滤请求。这种效果最好，但是价格也最贵。</p>
<p><strong>（2）本机防火墙</strong></p>
<p>操作系统都带有软件防火墙，Linux 服务器一般使用 <a href="https://wiki.archlinux.org/index.php/Iptables_(简体中文)" target="_blank" rel="noopener">iptables</a>。比如，拦截 IP 地址<code>1.2.3.4</code>的请求，可以执行下面的<a href="https://www.howtogeek.com/177621/the-beginners-guide-to-iptables-the-linux-firewall/" target="_blank" rel="noopener">命令</a>。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iptables -A INPUT -s 1.2.3.4 -j DROP</span><br></pre></td></tr></table></figure>
</blockquote>
<p>iptables 比较复杂，我也不太会用。它对服务器性能有一定影响，也防不住大型攻击。</p>
<p><strong>（3）Web 服务器</strong></p>
<p>Web 服务器也可以过滤请求。拦截 IP 地址<code>1.2.3.4</code>，nginx 的<a href="https://help.dreamhost.com/hc/en-us/articles/216456127-Blocking-IPs-with-Nginx" target="_blank" rel="noopener">写法</a>如下。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  deny 1.2.3.4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Apache 的<a href="https://stackoverflow.com/questions/3264233/apache-block-an-ip-address-from-accessing-the-website" target="_blank" rel="noopener">写法</a>是在<code>.htaccess</code>文件里面，加上下面一段。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;RequireAll&gt;</span><br><span class="line">    Require all granted</span><br><span class="line">    Require not ip 1.2.3.4</span><br><span class="line">&lt;/RequireAll&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果想要更精确的控制（比如自动识别并拦截那些频繁请求的 IP 地址），就要用到 <a href="https://en.wikipedia.org/wiki/Web_application_firewall" target="_blank" rel="noopener">WAF</a>。这里就不详细介绍了，nginx 这方面的设置可以参考<a href="https://www.nginx.com/blog/mitigating-ddos-attacks-with-nginx-and-nginx-plus/" target="_blank" rel="noopener">这里</a>和<a href="https://www.nginx.com/blog/rate-limiting-nginx/" target="_blank" rel="noopener">这里</a>。</p>
<p>Web 服务器的拦截非常消耗性能，尤其是 Apache。稍微大一点的攻击，这种方法就没用了。</p>
<h2 id="五、带宽扩容"><a href="#五、带宽扩容" class="headerlink" title="五、带宽扩容"></a>五、带宽扩容</h2><p>上一节的 HTTP 拦截有一个前提，就是请求必须有特征。但是，真正的 DDOS 攻击是没有特征的，它的请求看上去跟正常请求一样，而且来自不同的 IP 地址，所以没法拦截。这就是为什么 DDOS 特别难防的原因。</p>
<p>当然，这样的 DDOS 攻击的成本不低，普通的网站不会有这种待遇。不过，真要遇到了该怎么办呢，有没有根本性的防范方法呢？</p>
<p>答案很简单，就是设法把这些请求都消化掉。30个人的餐厅来了300人，那就想办法把餐厅扩大（比如临时再租一个门面，并请一些厨师），让300个人都能坐下，那么就不影响正常的用户了。对于网站来说，就是在短时间内急剧扩容，提供几倍或几十倍的带宽，顶住大流量的请求。这就是为什么云服务商可以提供防护产品，因为他们有大量冗余带宽，可以用来消化 DDOS 攻击。</p>
<p>一个朋友传授了一个方法，给我留下深刻印象。某云服务商承诺，每个主机保 5G 流量以下的攻击，他们就一口气买了5个。网站架设在其中一个主机上面，但是不暴露给用户，其他主机都是镜像，用来面对用户，DNS 会把访问量均匀分配到这四台镜像服务器。一旦出现攻击，这种架构就可以防住 20G 的流量，如果有更大的攻击，那就买更多的临时主机，不断扩容镜像。</p>
<h2 id="六、CDN"><a href="#六、CDN" class="headerlink" title="六、CDN"></a>六、CDN</h2><p>CDN 指的是网站的静态内容分发到多个服务器，用户就近访问，提高速度。因此，CDN 也是带宽扩容的一种方法，可以用来防御 DDOS 攻击。</p>
<p>网站内容存放在源服务器，CDN 上面是内容的缓存。用户只允许访问 CDN，如果内容不在 CDN 上，CDN 再向源服务器发出请求。这样的话，只要 CDN 够大，就可以抵御很大的攻击。不过，这种方法有一个前提，网站的大部分内容必须可以静态缓存。对于动态内容为主的网站（比如论坛），就要想别的办法，尽量减少用户对动态数据的请求。</p>
<p>上一节提到的镜像服务器，本质就是自己搭建一个微型 CDN。各大云服务商提供的<a href="https://baike.baidu.com/item/高防服务器" target="_blank" rel="noopener">高防 IP</a>，背后也是这样做的：网站域名指向高防 IP，它提供一个缓冲层，清洗流量，并对源服务器的内容进行缓存。</p>
<p>这里有一个关键点，一旦上了 CDN，千万不要泄露源服务器的 IP 地址，否则攻击者可以绕过 CDN 直接攻击源服务器，前面的努力都白费。搜一下”[绕过 CDN 获取真实 IP 地址](<a href="https://www.baidu.com/s?wd=cdn" target="_blank" rel="noopener">https://www.baidu.com/s?wd=cdn</a> 真实ip)”，你就会知道国内的黑产行业有多猖獗。</p>
<p><a href="https://www.cloudflare.com/" target="_blank" rel="noopener">cloudflare</a> 是一个免费 CDN 服务，并提供防火墙，高度推荐。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql与Oracle的区别</title>
    <url>/2020/06/10/Mysql%E4%B8%8EOracle%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>转载整理自</p>
<p><a href="https://www.zhihu.com/question/19866767" target="_blank" rel="noopener">SQL Server 和 Oracle 以及 MySQL 有哪些区别？</a></p>
<p><a href="https://blog.csdn.net/baidu_37107022/article/details/77043959" target="_blank" rel="noopener">Mysql与Oracle的区别</a></p>
<h2 id="一、并发性"><a href="#一、并发性" class="headerlink" title="一、并发性"></a>一、并发性</h2><p>并发性是oltp数据库最重要的特性，但并发涉及到资源的获取、共享与锁定。</p>
<p>mysql:<br>mysql以表级锁为主，对资源锁定的粒度很大，如果一个session对一个表加锁时间过长，会让其他session无法更新此表中的数据。<br>虽然InnoDB引擎的表可以用行级锁，但这个行级锁的机制依赖于表的索引，如果表没有索引，或者sql语句没有使用索引，那么仍然使用表级锁。</p>
<p>oracle:<br>oracle使用行级锁，对资源锁定的粒度要小很多，只是锁定sql需要的资源，并且加锁是在数据库中的数据行上，不依赖与索引。所以oracle对并发性的支持要好很多。</p>
<h2 id="二、一致性"><a href="#二、一致性" class="headerlink" title="二、一致性"></a>二、一致性</h2><p>oracle:<br>oracle支持serializable的隔离级别，可以实现最高级别的读一致性。每个session提交后其他session才能看到提交的更改。oracle通过在undo表空间中构造多版本数据块来实现读一致性，<br>每个session查询时，如果对应的数据块发生变化，oracle会在undo表空间中为这个session构造它查询时的旧的数据块。</p>
<p>mysql:<br>mysql没有类似oracle的构造多版本数据块的机制，只支持read commited的隔离级别。一个session读取数据时，其他session不能更改数据，但可以在表最后插入数据。<br>session更新数据时，要加上排它锁，其他session无法访问数据。</p>
<h2 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h2><p>oracle很早就完全支持事务。</p>
<p>mysql在innodb存储引擎的行级锁的情况下才支持事务。</p>
<h2 id="四、数据持久性"><a href="#四、数据持久性" class="headerlink" title="四、数据持久性"></a>四、数据持久性</h2><p>oracle<br>保证提交的数据均可恢复，因为oracle把提交的sql操作线写入了在线联机日志文件中，保持到了磁盘上，<br>如果出现数据库或主机异常重启，重启后oracle可以考联机在线日志恢复客户提交的数据。<br>mysql:<br>默认提交sql语句，但如果更新过程中出现db或主机重启的问题，也许会丢失数据。</p>
<h2 id="五、提交方式"><a href="#五、提交方式" class="headerlink" title="五、提交方式"></a>五、提交方式</h2><p>oracle默认不自动提交，需要用户手动提交。<br>mysql默认是自动提交。</p>
<h2 id="六、逻辑备份"><a href="#六、逻辑备份" class="headerlink" title="六、逻辑备份"></a>六、逻辑备份</h2><p>oracle逻辑备份时不锁定数据，且备份的数据是一致的。</p>
<p>mysql逻辑备份时要锁定数据，才能保证备份的数据是一致的，影响业务正常的dml使用。</p>
<h2 id="七、热备份"><a href="#七、热备份" class="headerlink" title="七、热备份"></a>七、热备份</h2><p>oracle有成熟的热备工具rman，热备时，不影响用户使用数据库。即使备份的数据库不一致，也可以在恢复时通过归档日志和联机重做日志进行一致的回复。<br>mysql:<br>myisam的引擎，用mysql自带的mysqlhostcopy热备时，需要给表加读锁，影响dml操作。<br>innodb的引擎，它会备份innodb的表和索引，但是不会备份.frm文件。用ibbackup备份时，会有一个日志文件记录备份期间的数据变化，因此可以不用锁表，不影响其他用户使用数据库。但此工具是收费的。<br>innobackup是结合ibbackup使用的一个脚本，他会协助对.frm文件的备份。</p>
<h2 id="八、sql语句的扩展和灵活性"><a href="#八、sql语句的扩展和灵活性" class="headerlink" title="八、sql语句的扩展和灵活性"></a>八、sql语句的扩展和灵活性</h2><p>mysql对sql语句有很多非常实用而方便的扩展，比如limit功能，insert可以一次插入多行数据，select某些管理数据可以不加from。<br>oracle在这方面感觉更加稳重传统一些。</p>
<h2 id="九、复制"><a href="#九、复制" class="headerlink" title="九、复制"></a>九、复制</h2><p>oracle:既有推或拉式的传统数据复制，也有dataguard的双机或多机容灾机制，主库出现问题是，可以自动切换备库到主库，但配置管理较复杂。<br>mysql:复制服务器配置简单，但主库出问题时，丛库有可能丢失一定的数据。且需要手工切换丛库到主库。</p>
<h2 id="十、性能诊断"><a href="#十、性能诊断" class="headerlink" title="十、性能诊断"></a>十、性能诊断</h2><p>oracle有各种成熟的性能诊断调优工具，能实现很多自动分析、诊断功能。比如awr、addm、sqltrace、tkproof等<br>mysql的诊断调优方法较少，主要有慢查询日志。</p>
<h2 id="十一、权限与安全"><a href="#十一、权限与安全" class="headerlink" title="十一、权限与安全"></a>十一、权限与安全</h2><p>mysql的用户与主机有关，感觉没有什么意义，另外更容易被仿冒主机及ip有可乘之机。<br>oracle的权限与安全概念比较传统，中规中矩。</p>
<h2 id="十二、分区表和分区索引"><a href="#十二、分区表和分区索引" class="headerlink" title="十二、分区表和分区索引"></a>十二、分区表和分区索引</h2><p>oracle的分区表和分区索引功能很成熟，可以提高用户访问db的体验。<br>mysql的分区表还不太成熟稳定。</p>
<h2 id="十三、管理工具"><a href="#十三、管理工具" class="headerlink" title="十三、管理工具"></a>十三、管理工具</h2><p>oracle有多种成熟的命令行、图形界面、web管理工具，还有很多第三方的管理工具，管理极其方便高效。<br>mysql管理工具较少，在linux下的管理工具的安装有时要安装额外的包（phpmyadmin， etc)，有一定复杂性。</p>
<h2 id="市场份额"><a href="#市场份额" class="headerlink" title="市场份额"></a>市场份额</h2><p><img src="https://pic3.zhimg.com/e3b780fc23cec291be3159fe91e4fc3b_r.jpg" alt="preview"></p>
<h2 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h2><p>关于“大型数据库”，并没有严格的界定，有说以数据量为准，有说以恢复时间为准。如果综合数据库应用场景来说，大型数据库应用有以下特点：海量数据、高吞吐量；复杂逻辑、高计算量，以及高可用性。从这点上来说，Oracle，DB2就是比较典型的大型数据库，Sybase SQL Server也算是吧。下面分别说明之前三种数据库的应用场景。</p>
<ol>
<li><h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3><p>Oracle的应用，主要在传统行业的数据化业务中，比如：银行、金融这样的对可用性、健壮性、安全性、实时性要求极高的业务；零售、物流这样对海量数据存储分析要求很高的业务。此外，高新制造业如芯片厂也基本都离不开Oracle；电商也有很多使用者，如京东（正在投奔Oracle）、阿里巴巴（计划去Oracle化）。而且由于Oracle对复杂计算、统计分析的强大支持，在互联网数据分析、数据挖掘方面的应用也越来越多。一个典型场景是这样的：<br>某电信公司（非国内）下属某分公司的数据中心，有4台Oracle Sun的大型服务器用来安装Solaris操作系统和Oracle并提供计算服务，3台Sun Storage磁盘阵列来提供Oracle数据存储，12台IBM小型机，一台Oracle Exadata服务器，一台500T的磁带机用来存储历史数据，San连接内网，使用Tuxedo中间件来保证扩展性和无损迁移。建立支持高并发的Oracle数据库，通过OLTP系统用来对海量数据实时处理、操作，建立高运算量的Oracle数据仓库，用OLAP系统用来分析营收数据及提供自动报表。总预算约750万美金。</p>
</li>
<li><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>MySQL基本是生于互联网，长于互联网。其应用实例也大都集中于互联网方向，MySQL的高并发存取能力并不比大型数据库差，同时价格便宜，安装使用简便快捷，深受广大互联网公司的喜爱。并且由于MySQL的开源特性，针对一些对数据库有特别要求的应用，可以通过修改代码来实现定向优化，例如SNS、LBS等互联网业务。一个典型的应用场景是：<br>某互联网公司，成立之初，仅有PC数台，通过LAMP架构迅速搭起网站框架。随着业务扩张、市场扩大，迅速发展成为6台Dell小型机的中型网站。现在花了三年，终于成为垂直领域的最大网站，计划中的数据中心，拥有Dell机架式服务器40台，总预算20万美金。</p>
</li>
<li><h3 id="MS-SQL-Server"><a href="#MS-SQL-Server" class="headerlink" title="MS SQL Server"></a>MS SQL Server</h3><p>windows生态系统的产品，好处坏处都很分明。好处就是，高度集成化，微软也提供了整套的软件方案，基本上一套win系统装下来就齐活了。因此，不那么缺钱，但很缺IT人才的中小企业，会偏爱 MS SQL Server 。例如，自建ERP系统、商业智能、垂直领域零售商、餐饮、事业单位等等。<br>1996年，Bill Gates亲自出手，从Borland挖来了大牛Anders，搞定了C#语言。微软02年搞定了<a href="http://ASP.NET。成熟的.NET、Silverlight技术，为" target="_blank" rel="noopener">http://ASP.NET。成熟的.NET、Silverlight技术，为</a> MS SQL Server赢得了部分互联网市场，其中就有曾经的全球最大社交网站MySpace，其发展历程很有代表性，可作为一个比较特别的例子【3】。其巅峰时有超过1.5亿的注册用户及每月400亿的访问量。应该算是MS SQL Server支撑的最大的数据应用了。</p>
</li>
</ol>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>其实要说执行的区别，主要还是架构的区别。正是架构导致了相同SQL在执行过程中的解释、优化、效率的差异。这里只做粗略说明，就不细说了：</p>
<ol>
<li>Oracle： 数据文件包括：控制文件、数据文件、重做日志文件、参数文件、归档文件、密码文件。这是根据文件功能行进行划分，并且所有文件都是二进制编码后的文件，对数据库算法效率有极大的提高。由于Oracle文件管理的统一性，就可以对SQL执行过程中的解析和优化，指定统一的标准：<br>RBO（基于规则的优化器）、CBO（基于成本的优化器）<br>通过优化器的选择，以及无敌的HINT规则，给与了SQL优化极大的自由，对CPU、内存、IO资源进行方方面面的优化。</li>
<li>MySQL：最大的一个特色，就是自由选择存储引擎。每个表都是一个文件，都可以选择合适的存储引擎。常见的引擎有 InnoDB、 MyISAM、 NDBCluster等。但由于这种开放插件式的存储引擎，比如要求数据库与引擎之间的松耦合关系。从而导致文件的一致性大大降低。在SQL执行优化方面，也就有着一些不可避免的瓶颈。在多表关联、子查询优化、统计函数等方面是软肋，而且只支持极简单的HINT。</li>
<li>SQL Server ：数据架构基本是纵向划分，分为：Protocol Layer（协议层）， Relational Engine（关系引擎）， Storage Engine（存储引擎）， SQLOS。SQL执行过程就是逐层解析的过程，其中Relational Engine中的优化器，是基于成本的（CBO），其工作过程跟Oracle是非常相似的。在成本之上也是支持很丰富的HINT，包括：连接提示、查询提示、表提示。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>How does the default hashCode() work?</title>
    <url>/2020/06/07/How%20does%20the%20default%20hashCode()%20work/</url>
    <content><![CDATA[<p>转载自<a href="https://srvaroa.github.io/jvm/java/openjdk/biased-locking/2017/01/30/hashCode.html" target="_blank" rel="noopener">How does the default hashCode() work?</a></p>
<p><a href="https://www.javazhiyin.com/55723.html" target="_blank" rel="noopener">参考译文</a></p>
<p><em>In which scratching the surface of <code>hashCode()</code> leads to a speleology trip through the JVM source reaching object layout, biased locking, and surprising performance implications of relying on the default <code>hashCode()</code>.</em></p>
<p><em>Abundant thanks to <a href="https://twitter.com/giltene" target="_blank" rel="noopener">Gil Tene</a> and <a href="https://twitter.com/duarte_nunes" target="_blank" rel="noopener">Duarte Nunes</a> reviewing drafts of this article and their very valuable insights, suggestions and edits. Any remaining errors are my own.</em></p>
<h2 id="A-trivial-mystery"><a href="#A-trivial-mystery" class="headerlink" title="A trivial mystery"></a>A trivial mystery</h2><p>Last week at work I submitted a trivial change to a class, an implementation of <code>toString()</code> so logs would be meaningful. To my surprise, the change caused a ~5% coverage drop in the class. I knew that all new code was covered by existing unit tests so, what could be wrong? Comparing coverage reports a sharper colleague noticed that the implementation of <code>hashCode()</code> was covered before the change but not after. Of course, that made sense: the default <code>toString()</code> calls <code>hashCode()</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After overriding <code>toString()</code>, our custom <code>hashCode()</code> was no longer being called. We were missing a test.</p>
<p>Everyone knew the default <code>toString()</code> but..</p>
<h2 id="What-is-the-default-implementation-of-hashCode"><a href="#What-is-the-default-implementation-of-hashCode" class="headerlink" title="What is the default implementation of hashCode()?"></a>What is the default implementation of <code>hashCode()</code>?</h2><p>The value returned by the default implementation of <code>hashCode()</code> is called <strong>identity hash code</strong> so I will use this term from now on to distinguish it from the hash provided by overriden implementations of <code>hashCode()</code>. FYI: even if a class overrides <code>hashCode()</code>, you can always get the identity hash code of an object <code>o</code> by calling <code>System.identityHashCode(o)</code>.</p>
<p>Common wisdom is that the identity hash code uses the integer representation of the memory address. That’s also what the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--" target="_blank" rel="noopener">J2SE JavaDocs for Object.hashCode()</a> imply:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">... is typically implemented by converting the internal address of</span><br><span class="line">the object into an integer, but this implementation technique is not</span><br><span class="line">required by the Java™ programming language.</span><br></pre></td></tr></table></figure>

<p>Still, this seems problematic as the method contract requires that:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Whenever it is invoked on the same object more than once during an</span><br><span class="line">execution of a Java application, the hashCode method must consistently</span><br><span class="line">return the same integer.</span><br></pre></td></tr></table></figure>

<p>Given that the JVM will relocate objects (e.g. during garbage collection cycles due to promotion or compaction), after we calculate an object’s identity hash we must be able to retain it in a way that survives object relocation.</p>
<p>A possibility could be to take the current memory position of the object on the first call to <code>hashCode()</code>, and save it somewhere along with the object, like the object’s header. That way, if the object is moved to a different memory location, it would carry the original hash with it. A caveat of this method is that it won’t prevent two objects from having the same identity hash, but that’s allowed by the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--" target="_blank" rel="noopener">spec</a>.</p>
<p>The best confirmation would be to to look at the source. Unfortunately, the default <code>java.lang.Object::hashCode()</code> <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/a71d26266469/src/share/classes/java/lang/Object.java#l100" target="_blank" rel="noopener">is a native function</a>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native int hashCode();</span><br></pre></td></tr></table></figure>

<p>Helmets on.</p>
<h2 id="Will-the-real-hashCode-please-stand-up"><a href="#Will-the-real-hashCode-please-stand-up" class="headerlink" title="Will the real hashCode() please stand up"></a>Will the real <code>hashCode()</code> please stand up</h2><p>Note that the identity <code>hashCode()</code> implementation <strong>is dependant on the JVM</strong>. Since I will only look at OpenJDK sources, you should assume this specific implementation whenever I talk about the JVM. All links refer to <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509" target="_blank" rel="noopener">changeset 5820:87ee5ee27509</a> of the <a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot" target="_blank" rel="noopener">Hotspot tree</a>, I assume that most of it will also be applicable to Oracle’s JVM, but things could (in fact, are) different in others (more about this later.)</p>
<p>OpenJDK defines entry points for <code>hashCode()</code> at <code>src/share/vm/prims/jvm.h</code> and <code>src/share/vm/prims/jvm.cpp</code>. The latter has:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">508 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))</span><br><span class="line">509   JVMWrapper(&quot;JVM_IHashCode&quot;);</span><br><span class="line">510   &#x2F;&#x2F; as implemented in the classic virtual machine; return 0 if object is NULL</span><br><span class="line">511   return handle &#x3D;&#x3D; NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;</span><br><span class="line">512 JVM_END</span><br></pre></td></tr></table></figure>

<p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp#l601" target="_blank" rel="noopener">ObjectSynchronizer::FastHashCode()</a> is also called from <code>identity_hash_value_for</code>, which is used from a few other call sites (e.g.: <code>System.identityHashCode()</code>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">708 intptr_t ObjectSynchronizer::identity_hash_value_for(Handle obj) &#123;</span><br><span class="line">709   return FastHashCode (Thread::current(), obj()) ;</span><br><span class="line">710 &#125;</span><br></pre></td></tr></table></figure>

<p>One might naively expect <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp#l601" target="_blank" rel="noopener">ObjectSynchronizer::FastHashCode()</a> to do something like:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (obj.hash() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    obj.set_hash(generate_new_hash());</span><br><span class="line">&#125;</span><br><span class="line">return obj.hash();</span><br></pre></td></tr></table></figure>

<p>But it turns out to be a hundred line function that seems to be far more complicated. At least we can spot a couple of if-not-exists-generate blocks like:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">685   mark &#x3D; monitor-&gt;header();</span><br><span class="line">...</span><br><span class="line">687   hash &#x3D; mark-&gt;hash();</span><br><span class="line">688   if (hash &#x3D;&#x3D; 0) &#123;</span><br><span class="line">689     hash &#x3D; get_next_hash(Self, obj);</span><br><span class="line">...</span><br><span class="line">701   &#125;</span><br><span class="line">...</span><br><span class="line">703   return hash;</span><br></pre></td></tr></table></figure>

<p>Which seems to confirm our hypothesis. Let’s ignore that <code>monitor</code> for now, and be satisfied that it gives us the object header. It is kept at <code>mark</code>, a pointer to an instance of <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/oops/markOop.hpp" target="_blank" rel="noopener">markOop</a>, which represents the <a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html#markWord" target="_blank" rel="noopener">mark word</a> that belongs in the low bits of the object header. So, tries to get a hash inside the mark word. If it’s not there, it’s generated using <code>get_next_hash</code>, saved, and returned.</p>
<h2 id="The-actual-identity-hash-generation"><a href="#The-actual-identity-hash-generation" class="headerlink" title="The actual identity hash generation"></a>The actual identity hash generation</h2><p>As we saw, this happens at <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp#l555" target="_blank" rel="noopener">get_next_hash</a>. This function offers six methods based on the value of some <code>hashCode</code> variable.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0. A randomly generated number.</span><br><span class="line">1. A function of memory address of the object.</span><br><span class="line">2. A hardcoded 1 (used for sensitivity testing.)</span><br><span class="line">3. A sequence.</span><br><span class="line">4. The memory address of the object, cast to int.</span><br><span class="line">5. Thread state combined with xorshift (https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Xorshift)</span><br></pre></td></tr></table></figure>

<p>So what’s the default method? OpenJDK 8 seems to default on 5 according to <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/globals.hpp#l1127" target="_blank" rel="noopener">globals.hpp</a>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1127   product(intx, hashCode, 5,                                                \</span><br><span class="line">1128           &quot;(Unstable) select hashCode generation algorithm&quot;)                \</span><br></pre></td></tr></table></figure>

<p>OpenJDK 9 <a href="http://hg.openjdk.java.net/jdk9/jdk9/hotspot/file/fc7e94cb7485/src/share/vm/runtime/globals.hpp#l1198" target="_blank" rel="noopener">keeps the same default</a>. Looking at previous versions, both <a href="http://hg.openjdk.java.net/jdk7u/jdk7u/hotspot/file/5b9a416a5632/src/share/vm/runtime/globals.hpp#l1100" target="_blank" rel="noopener">OpenJDK 7</a> and <a href="http://hg.openjdk.java.net/jdk6/jdk6/hotspot/file/5cec449cc409/src/share/vm/runtime/globals.hpp#l1128" target="_blank" rel="noopener">OpenJDK 6</a> use the first method, a <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/os.cpp#l814" target="_blank" rel="noopener">random number generator</a>.</p>
<p>So, unless I’m looking at the wrong place <strong>the default hashCode implementation in OpenJDK has nothing to do with the memory address</strong>, at least since version 6.</p>
<h2 id="Object-headers-and-synchronization"><a href="#Object-headers-and-synchronization" class="headerlink" title="Object headers and synchronization"></a>Object headers and synchronization</h2><p>Let’s go back a couple of points that we left unexamined. First, <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp#l601" target="_blank" rel="noopener">ObjectSynchronizer::FastHashCode()</a> seems overly complex, needing over 100 lines to perform what we though was a trivial get-or-generate operation. Second, who is this <code>monitor</code> and why does it have our object’s header?</p>
<p>The structure of the mark word is a good place to start making progress. In OpenJDK, it looks <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/oops/markOop.hpp#l37" target="_blank" rel="noopener">like this</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30 &#x2F;&#x2F; The markOop describes the header of an object.</span><br><span class="line">31 &#x2F;&#x2F;</span><br><span class="line">32 &#x2F;&#x2F; Note that the mark is not a real oop but just a word.</span><br><span class="line">33 &#x2F;&#x2F; It is placed in the oop hierarchy for historical reasons.</span><br><span class="line">34 &#x2F;&#x2F;</span><br><span class="line">35 &#x2F;&#x2F; Bit-format of an object header (most significant first, big endian layout below):</span><br><span class="line">36 &#x2F;&#x2F;</span><br><span class="line">37 &#x2F;&#x2F;  32 bits:</span><br><span class="line">38 &#x2F;&#x2F;  --------</span><br><span class="line">39 &#x2F;&#x2F;             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span><br><span class="line">40 &#x2F;&#x2F;             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span><br><span class="line">41 &#x2F;&#x2F;             size:32 ------------------------------------------&gt;| (CMS free block)</span><br><span class="line">42 &#x2F;&#x2F;             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span><br><span class="line">43 &#x2F;&#x2F;</span><br><span class="line">44 &#x2F;&#x2F;  64 bits:</span><br><span class="line">45 &#x2F;&#x2F;  --------</span><br><span class="line">46 &#x2F;&#x2F;  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span><br><span class="line">47 &#x2F;&#x2F;  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span><br><span class="line">48 &#x2F;&#x2F;  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span><br><span class="line">49 &#x2F;&#x2F;  size:64 -----------------------------------------------------&gt;| (CMS free block)</span><br><span class="line">50 &#x2F;&#x2F;</span><br><span class="line">51 &#x2F;&#x2F;  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span><br><span class="line">52 &#x2F;&#x2F;  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span><br><span class="line">53 &#x2F;&#x2F;  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span><br><span class="line">54 &#x2F;&#x2F;  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span><br></pre></td></tr></table></figure>

<p>The format is slightly different on 32 and 64 bits. The latter has two variants depending on whether <a href="https://wiki.openjdk.java.net/display/HotSpot/CompressedOops" target="_blank" rel="noopener">Compressed Object Pointers</a> are enabled. Both Oracle and OpenJDK 8 <strong>do</strong> by default.</p>
<p>Object headers may thus relate to a free block or an actual object, in which case there are multiple possible states. In the simplest, (“normal object”) the identity hash is stored directly in the low addresses of the header.</p>
<p>But in other states, we find a pointer to a <code>JavaThread</code> or a <code>PromotedObject</code>. The plot thickens: if we put the identity hash in a “normal object”, will someone take it away? Where? If the object is biased, where can we get/set the hash? What is a biased object?</p>
<p>Let’s try to answer those questions.</p>
<h2 id="Biased-locking"><a href="#Biased-locking" class="headerlink" title="Biased locking"></a>Biased locking</h2><p>Biased objects appear as a result of <a href="https://blogs.oracle.com/dave/entry/biased_locking_in_hotspot" target="_blank" rel="noopener">Biased Locking</a>. A (<a href="https://www.google.com/patents/US7814488" target="_blank" rel="noopener">patented</a>!) feature enabled by default from HotSpot 6 that tries to alleviate the cost of locking objects. Such operations are expensive because their implementation often relies on atomic CPU instructions (<a href="https://en.wikipedia.org/wiki/Compare-and-swap" target="_blank" rel="noopener">CAS</a>) in order to safely handle lock/unlock requests on the object from different threads. It was observed that in most applications, the majority of objects are only ever locked by one thread so paying the cost of the atomic operation was often a waste. To avoid it, JVMs with biased locking allow threads to try and “bias” an object towards themselves. While an object is biased, the lucky thread can lock/unlock the object without atomic instructions. As long as there are no threads contending for the same object, we’ll gain performance.</p>
<p>The <code>biased_lock</code> bit in the header indicates whether an object is biased by the thread pointed at by <code>JavaThread*</code>. The <code>lock</code> bits indicate whether the object is locked.</p>
<p>Precisely because OpenJDK’s implementation of biased locking requires writing a pointer in the mark word, it also needs to relocate the real mark word (which contains the identity hash.)</p>
<p>This could explain the additional complexity in <code>FastHashCode</code>. The header not only holds the identity hash code, but also locking state (like the pointer to the lock’s owner thread). So we need to consider all cases and find where the identity hash resides.</p>
<p>Let’s go read <code>FastHashCode</code>. The first thing we find is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">601 intptr_t ObjectSynchronizer::FastHashCode (Thread * Self, oop obj) &#123;</span><br><span class="line">602   if (UseBiasedLocking) &#123;</span><br><span class="line">610     if (obj-&gt;mark()-&gt;has_bias_pattern()) &#123;</span><br><span class="line">          ...</span><br><span class="line">617       BiasedLocking::revoke_and_rebias(hobj, false, JavaThread::current());</span><br><span class="line">          ...</span><br><span class="line">619       assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span><br><span class="line">620     &#125;</span><br><span class="line">621   &#125;</span><br></pre></td></tr></table></figure>

<p>Wait. It just <strong>revoked existing biases, and disabled biased locking on the object</strong> (the <code>false</code> means “don’t attempt rebias”). A few lines down, this is indeed an invariant:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">637   &#x2F;&#x2F; object should remain ineligible for biased locking</span><br><span class="line">638   assert (!mark-&gt;has_bias_pattern(), &quot;invariant&quot;) ;</span><br></pre></td></tr></table></figure>

<p>If I’m reading correctly, this means that <strong>simply asking for the identity hash code of an object will disable biased locking</strong>, which in turn forces any attempt to lock the object to use expensive atomic instructions. Even if there is only one thread.</p>
<p>Oh boy.</p>
<h2 id="Why-does-keeping-biased-locking-state-conflict-with-keeping-the-identity-hash-code"><a href="#Why-does-keeping-biased-locking-state-conflict-with-keeping-the-identity-hash-code" class="headerlink" title="Why does keeping biased locking state conflict with keeping the identity hash code?"></a>Why does keeping biased locking state conflict with keeping the identity hash code?</h2><p>To answer this question we must understand which are the possible locations of the mark word (that contains the identity hash) depending on the lock state of the object. The transitions are illustrated in this diagram from the <a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization" target="_blank" rel="noopener">HotSpot Wiki</a>:</p>
<p><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization" target="_blank" rel="noopener"><img src="https://srvaroa.github.io/assets/hotspot_object_states.gif" alt="img"></a></p>
<p>My (fallible) reasoning is the following.</p>
<p>For the 4 states at the top of the diagram, the OpenJDK will be able to use “thin” lock representations. In the simplest case (no locks) this means having the identity hash and other data directly in the object’s space for the mark word:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">46 &#x2F;&#x2F;  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span><br></pre></td></tr></table></figure>

<p>in more complex cases, it needs that space to keep a pointer to the “lock record”. The mark word will thus be “displaced” and put somewhere else.</p>
<p>While we have only one thread trying to lock the object, that pointer will actually refer to a memory location in the thread’s own stack. Which is twice good: it’s fast (no contention or coordination to access that memory location), and it suffices for the thread to identify that it owns the lock (because the memory location points to its own stack.)</p>
<p>But this won’t work in all cases. If we have contended objects (e.g. objects used on synchronized statements that many threads traverse) we will need a more complex structure that fits not only a copy of the object’s header (again, “displaced”), but also a <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/objectMonitor.hpp#l126" target="_blank" rel="noopener">list of waiters</a>. A similar need for a list of waiters appears if a thread executes <code>object.wait()</code>.</p>
<p>This richer data structure is the <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/objectMonitor.hpp" target="_blank" rel="noopener">ObjectMonitor</a>, which is referred to as a the “heavyweight” monitor in the diagram. The value left in the object’s header doesn’t point to a “displaced mark word” anymore, but to an actual object (the monitor). Accessing the identity hash code will now require “inflating the monitor”: chasing a pointer to an object and reading/mutating whichever field contains the displaced mark word. Which is more expensive and requires coordination.</p>
<p><code>FastHashCode</code> does have work to do.</p>
<p>Lines <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp#l640" target="_blank" rel="noopener">L640</a> to <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp#l680" target="_blank" rel="noopener">L680</a> deal with finding the header and checking for a cached identity hash. I believe these are a fast path that probe for cases that don’t need to inflate the monitor.</p>
<p>From <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp#l682" target="_blank" rel="noopener">L682</a> it needs to bite the bullet:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">682   &#x2F;&#x2F; Inflate the monitor to set hash code</span><br><span class="line">683   monitor &#x3D; ObjectSynchronizer::inflate(Self, obj);</span><br><span class="line"></span><br><span class="line">684   &#x2F;&#x2F; Load displaced header and check it has hash code</span><br><span class="line">685   mark &#x3D; monitor-&gt;header();</span><br><span class="line">...</span><br><span class="line">687   hash &#x3D; mark-&gt;hash();</span><br></pre></td></tr></table></figure>

<p>At this point, if the id. hash is there (<code>hash != 0</code>), the JVM can return. Otherwise we’ll get one from <code>get_next_hash</code> and safely store it in the displaced header kept by the <code>ObjectMonitor</code>.</p>
<p>This seems to offer a reasonable explanation to why calling <code>hashCode()</code> on an object of a class that doesn’t override the default implementation makes the object ineligible for biased locking:</p>
<ul>
<li>In order to keep the identity hash of an object consistent after relocation we need to store the hash in the object’s header.</li>
<li>Threads asking for the identity hash may not even care about locking the object, but in practise they will be sharing data structures used by the locking mechanism. This is a complex beast in itself that might be not only mutating, but also <strong>moving</strong> (displacing) the header contents.</li>
<li>Biased locking helped perform lock/unlock operations without atomic operations, and this was effective as long as only one thread locked the object because we could keep the lock state in the mark word. I’m not 100% sure here, but I understand that since other threads may ask for the identity hash, <strong>even if there is a single thread interested in the lock</strong>, the header word will be contended and require atomic operations to be handled correctly. Which defeats the whole point of biased locking.</li>
</ul>
<h2 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h2><ul>
<li>The default</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashCode()</span><br></pre></td></tr></table></figure>



<p>  implementation (identity hash code)</p>
<p>  has nothing to do with the object’s memory address</p>
<p>  , at least in OpenJDK. In versions 6 and 7 it is a randomly generated number. In 8 and, for now, 9, it is a number based on the thread state.</p>
<p>  Here</p>
<p>  is a test that yields the same conclusion.</p>
<ul>
<li>Proving that “implementation-dependent” warns are not aesthetic: <a href="https://www.azul.com/products/zing/virtual-machine/" target="_blank" rel="noopener">Azul’s Zing</a> <strong>does</strong> generate the identity hash from the object’s memory address.</li>
</ul>
<ul>
<li>In HotSpot, the result of the identity hash generation is generated once, and cached in the</li>
</ul>
<p>  mark word</p>
<p>  of the object’s header.</p>
<ul>
<li>Zing uses a different solution to keep it consistent despite object relocations, in which they delay storing the id. hash until the object relocates. At that point, it’s stored in a “pre-header”</li>
</ul>
<ul>
<li>In HotSpot, calling the default</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashCode()</span><br></pre></td></tr></table></figure>

<p>  , or</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.identityHashCode()</span><br></pre></td></tr></table></figure>



<p>  will make the object ineligible for biased locking.</p>
<ul>
<li>This implies that <strong>if you are synchronizing on objects that have no contention, you’d better override the default <code>hashCode()</code> implementation</strong> or you’ll miss out on JVM optimizations.</li>
</ul>
<ul>
<li>It is possible</li>
</ul>
<p>  to disable biased locking in HotSpot, on a per-object basis.</p>
<ul>
<li>This can be very useful. I’ve seen applications very heavy on contended producer/consumer queues where biased locking was causing more trouble than benefit, so we disabled the feature completely. Turns out, we could’ve done this only on specific objects/classes simply by calling System.identityHashCode() on them.</li>
</ul>
<ul>
<li><p>I have found no HotSpot flag that allows changing the default generator, so experimenting with other options might need to compile from source</p>
<p>.</p>
<ul>
<li>Admittedly, I didn’t look much. <a href="https://twitter.com/jmichaelras" target="_blank" rel="noopener">Michael Rasmussen</a> <a href="https://twitter.com/jmichaelras/status/827441456059187200" target="_blank" rel="noopener">kindly pointed out</a> that <strong>-XX:hashCode=2</strong> can be used to change the default. Thanks!</li>
</ul>
</li>
</ul>
<h2 id="Benchmarks"><a href="#Benchmarks" class="headerlink" title="Benchmarks"></a>Benchmarks</h2><p>I wrote a simple <a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="noopener">JMH</a> harness to verify those conclusions.</p>
<p>The benchmark (<a href="https://gist.github.com/srvaroa/aa1f6c273ea6ae215bbf43e481f7689e" target="_blank" rel="noopener">source</a>) does something equivalent to this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object.hashCode();</span><br><span class="line">while(true) &#123;</span><br><span class="line">    synchronized(object) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>One configuration (<code>withIdHash</code>) synchronizes on an object that uses the identity hash, so we expect that biased locking will be disabled as soon as <code>hashCode()</code> is invoked. A second configuration (<code>withoutIdHash</code>) implements a custom hash code so biased locking should not be disabled. Each configuration is ran first with one thread, then with two threads (these have the suffix “Contended”.)</p>
<p>By the way, we must enable <code>-XX:BiasedLockingStartupDelay=0</code> as otherwise the JVM will take 4s to trigger the optimisation distorting the results.</p>
<p>The first execution:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Benchmark                                       Mode  Cnt       Score      Error   Units</span><br><span class="line">BiasedLockingBenchmark.withIdHash              thrpt  100   35168,021 ±  230,252  ops&#x2F;ms</span><br><span class="line">BiasedLockingBenchmark.withoutIdHash           thrpt  100  173742,468 ± 4364,491  ops&#x2F;ms</span><br><span class="line">BiasedLockingBenchmark.withIdHashContended     thrpt  100   22478,109 ± 1650,649  ops&#x2F;ms</span><br><span class="line">BiasedLockingBenchmark.withoutIdHashContended  thrpt  100   20061,973 ±  786,021  ops&#x2F;ms</span><br></pre></td></tr></table></figure>

<p>We can see that the using a custom hash code makes the lock/unlock loop work 4x faster than the one using the identity hash code (which disables biased locking.) When two threads contend for the lock, biased locking is disabled anyway so there is no significative difference between both hash methods.</p>
<p>A second run disables biased locking (<code>-XX:-UseBiasedLocking</code>) in all configurations.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Benchmark                                       Mode  Cnt      Score      Error   Units</span><br><span class="line">BiasedLockingBenchmark.withIdHash              thrpt  100  37374,774 ±  204,795  ops&#x2F;ms</span><br><span class="line">BiasedLockingBenchmark.withoutIdHash           thrpt  100  36961,826 ±  214,083  ops&#x2F;ms</span><br><span class="line">BiasedLockingBenchmark.withIdHashContended     thrpt  100  18349,906 ± 1246,372  ops&#x2F;ms</span><br><span class="line">BiasedLockingBenchmark.withoutIdHashContended  thrpt  100  18262,290 ± 1371,588  ops&#x2F;ms</span><br></pre></td></tr></table></figure>

<p>The hash method no longer has any impact and <code>withoutIdHash</code> loses its advantage.</p>
<p>(All benchmarks were ran on a 2,7 GHz Intel Core i5.)</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>Whatever is not wild speculation and my weak reasoning trying to make sense of the JVM sources, comes from stitching together various sources about layout, biased locking, etc. The main ones are below:</p>
<ul>
<li><a href="https://blogs.oracle.com/dave/entry/biased_locking_in_hotspot" target="_blank" rel="noopener">https://blogs.oracle.com/dave/entry/biased_locking_in_hotspot</a></li>
<li><a href="http://fuseyism.com/openjdk/cvmi/java2vm.xhtml" target="_blank" rel="noopener">http://fuseyism.com/openjdk/cvmi/java2vm.xhtml</a></li>
<li><a href="http://www.dcs.gla.ac.uk/~jsinger/pdfs/sicsa_openjdk/OpenJDKArchitecture.pdf" target="_blank" rel="noopener">http://www.dcs.gla.ac.uk/~jsinger/pdfs/sicsa_openjdk/OpenJDKArchitecture.pdf</a></li>
<li><a href="https://www.infoq.com/articles/Introduction-to-HotSpot" target="_blank" rel="noopener">https://www.infoq.com/articles/Introduction-to-HotSpot</a></li>
<li><a href="http://blog.takipi.com/5-things-you-didnt-know-about-synchronization-in-java-and-scala/#comment-1006598967" target="_blank" rel="noopener">http://blog.takipi.com/5-things-you-didnt-know-about-synchronization-in-java-and-scala/#comment-1006598967</a></li>
<li><a href="http://www.azulsystems.com/blog/cliff/2010-01-09-biased-locking" target="_blank" rel="noopener">http://www.azulsystems.com/blog/cliff/2010-01-09-biased-locking</a></li>
<li><a href="https://dzone.com/articles/why-should-you-care-about-equals-and-hashcode" target="_blank" rel="noopener">https://dzone.com/articles/why-should-you-care-about-equals-and-hashcode</a></li>
<li><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/HotSpot/Synchronization</a></li>
<li><a href="https://mechanical-sympathy.blogspot.com.es/2011/11/biased-locking-osr-and-benchmarking-fun.html" target="_blank" rel="noopener">https://mechanical-sympathy.blogspot.com.es/2011/11/biased-locking-osr-and-benchmarking-fun.html</a>:</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>基于概率的数据结构:布隆过滤器</title>
    <url>/2020/06/07/%E5%9F%BA%E4%BA%8E%E6%A6%82%E7%8E%87%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<p>转载自<a href="https://hackernoon.com/probabilistic-data-structures-bloom-filter-5374112a7832" target="_blank" rel="noopener">Probabilistic Data structures: Bloom filter</a></p>
<p>If you have a glass-protected bookshelf, that will protect your books from dust and insects, but it will cost you more time to access the books when you need them. Because you first need to slide or open the glass and then can get the books. On the other hand, if it’s an open bookshelf, that will give you quicker access but you will lose the protection. Similarly, if you organize your books in lexicographic order of their name, you can easily search for a book if you know it’s name. But if your bookshelf has cases of different size and you organize your books based on their size, it will look nice, but can you find a book in a hurry? I don’t think so.</p>
<p>Data structures are nothing different. They are like the bookshelves of your application where you can organize your data. Different data structures will give you different facility and benefits. To properly use the power and accessibility of the data structures you need to know the trade-offs of using one.</p>
<p>When main-stream data structures like Lists, Maps, Sets, Trees etc. are mostly used for achieving certain results about whether the data exist or not, maybe along with their number of occurrences and such, Probabilistic data structures will give you memory-efficient, faster result with a cost of providing a ‘probable’ result instead of a ‘certain’ one. It might not seems intuitive to use such data structures for now, but I’ll try to convince you in this post that these type of data structures have their specific use cases and you might find them useful in certain scenarios.</p>
<p>In this post, I’ll talk about one of the most popular probabilistic data structures called <strong>‘Bloom filter’</strong>. In future, I’ll try to write about some others.</p>
<h3 id="Bloom-filter"><a href="#Bloom-filter" class="headerlink" title="Bloom filter"></a>Bloom filter</h3><p>Do you know how hash tables work? When you insert a new data in a simple array or list, the index, where this data would be inserted, is not determined from the value to be inserted. That means there is no direct relationship between the ‘key(index)’ and the ‘value(data)’. As a result, if you need to search for a value in the array you have to search in all of the indexes. Now, in hash tables, you determine the ‘key’ or ‘index’ by hashing the ‘value’. Then you put this value in that index in the list. That means the ‘key’ is determined from the ‘value’ and every time you need to check if the value exists in the list you just hash the value and search on that key. It’s pretty fast and will require <em>O(1)</em> searching time in <a href="https://en.wikipedia.org/wiki/Big_O_notation" target="_blank" rel="noopener">Big-O notation</a>.</p>
<p><img src="https://hackernoon.com/hn-images/1*BEkGh72F09juiD6wtg6q4A.png" alt="img"></p>
<p>Now, let’s consider that you have a huge list of weak passwords and it is stored on some remote server. It’s not possible to load them at once in the memory/RAM because of the size. Each time a user enters his/her password you want to check if it is one of the weak passwords and if it is, you want to give him/her a warning to change it to something stronger. What can you do? As you already have the list of the weak passwords, you can store them in a hash table or something like that and each time you want to match, you can check against it if the given password has any match. The matching might be fast but the cost of searching it on the disk or over the network on a remote server would make it slow. Don’t forget that you would need to do it for every password given by every user. How can we reduce the cost?</p>
<p>Well, Bloom filter can help us here. How? I’m going to answer it after explaining how a bloom filter works. OK?</p>
<p>By definition, Bloom filter can check for if a value is <strong>‘possibly in the set’</strong> or <strong>‘definitely not in the set’</strong>. The subtle difference between <strong>‘possibly’</strong> and <strong>‘definitely not’ —</strong> is very crucial here. This <em>‘possibly in the set’</em> is exactly why it is called <strong>probabilistic</strong>. Using smart words it means that <a href="https://en.wikipedia.org/wiki/False_positives_and_false_negatives" target="_blank" rel="noopener">false positive</a> is possible <em>(there can be cases where it falsely thinks that the element is positive)</em> but false negative is impossible. Don’t be impatient, we are explaining what does it actually mean, shortly.</p>
<p>The bloom filter essentially consists of a bit-vector or bit-list<em>(a list containing only either 0 or 1-bit value)</em> of length <strong>m</strong>, initially all values set to 0, as shown below.</p>
<p><img src="https://hackernoon.com/hn-images/1*VssbV2VQmWn8CHlhfA-oNw.png" alt="img"></p>
<p>Image Credit: <a href="http://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/" target="_blank" rel="noopener">GeeksforGeeks</a></p>
<p>To add an item to the bloom filter, we feed it to <strong>k</strong> different hash functions and set the bits to ‘1’ at the resulting positions. As you can see, in hash tables we would’ve used a single hash function and as a result get only a single index as output. But in the case of the bloom filter, we would use multiple hash functions, which would give us multiple indexes.</p>
<p><img src="https://hackernoon.com/hn-images/1*xm1aM4Hwevn8tizTSe7LKA.png" alt="img"></p>
<p>Image Credit: <a href="http://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/" target="_blank" rel="noopener">GeeksforGeeks</a></p>
<p>As you can see in the above example, for the given input ‘geeks’ our 3 hash functions will give 3 different output — 1, 4 and 7. We’ve marked them.</p>
<p><img src="https://hackernoon.com/hn-images/1*WpJpIEfjWkKPnR6GGbbVvQ.png" alt="img"></p>
<p>Image Credit: <a href="http://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/" target="_blank" rel="noopener">GeeksforGeeks</a></p>
<p>For another input ‘nerd’, the hash functions give us 3, 4 and 5. You might’ve noticed that the index ‘4’ is already marked by the previous ‘geeks’ input. Hold your thought, this point is interesting and we’re going to discuss it shortly.</p>
<p>We’ve already populated our bit vector with two inputs, now we can check for a value for its existence. How can we do that?<br>Easy. Just as we would’ve done it in a hash table. We would hash the ‘searched input’ with our 3 hash functions and see what are the resulting indexes hold.</p>
<p><img src="https://hackernoon.com/hn-images/1*Fg3dBnWiip3Sbz3_XkKn7w.png" alt="img"></p>
<p>Image Credit: <a href="http://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/" target="_blank" rel="noopener">GeeksforGeeks</a></p>
<p>So, searching for ‘cat’, our hash functions are giving us 1, 3 and 7 this time. And we can see that all of the indexes are already marked as 1. That means we can say, <em>“maybe ‘cat’ is already inserted on our list”</em>. But it didn’t. So, what’s went wrong?<br>Actually, nothing went wrong. The thing is, this is the case of a <strong>‘false positive’</strong>. Bloom filter is telling us that it seems that maybe ‘cat’ was inserted before, because the indexes should’ve been marked by ‘cat’ are already marked (though by other different data).<br>So, if that’s the case, how it is helpful? Well, let’s consider if ‘cat’ would’ve given us the output of 1, 6, 7 instead of 1, 3, 7, what would happen then? We can see that among 3 indexes, 6 is ‘0’, that means it wasn’t marked by any of the previous inputs. That means obviously ‘cat’ never inserted before, if it was, there was no chance of 6 to be ‘0’, right? That’s how bloom filter can tell <strong>‘certainly’</strong> if a data is not on the list.</p>
<p>So, in a nutshell:</p>
<ul>
<li>If we search for a value and see any of the hashed indexes for this value is ‘0’ then, the value is definitely not on the list.</li>
<li>If all of the hashed indexes is ‘1’ then ‘maybe’ the searched value is on the list.</li>
</ul>
<p>Does it start making sense? A little maybe?</p>
<p>Fine, now, back to the ‘password’ example we were talking earlier. If we implement our weak password checking with this type of bloom filter, you can see that initially, we would mark our bloom filter with our list of passwords, which will give us a bit vector with some indexes marked as ‘1’ and others left as 0. As the size of the bloom filter won’t be very large and will be a fixed size, it can easily be stored in the memory and also on the client side if necessary. That’s why bloom filter is very space-efficient. Where a hash table requires being of arbitrary size based on the input data, the bloom filters can work well with a fixed size.<br>So, every time a user enters their password, we will feed it to our hash functions and check it against our bit vector. If the password is strong enough, the bloom filter will show us that the password is certainly not in the ‘weak password list’ and we don’t have to do any more query. But if the password seems weak and gives us a ‘positive’ (might be false positive) result we will then send it to our server and check our actual list to confirm.</p>
<p>As you can see, most of the time we don’t even need to make a request to our server or read from disk to check the list, this will be a significant improvement in speed of the application. In case, if we don’t want to store the bit-vector at the client side, we can still load it in the server memory and that will at least saves some disk lookup time. Also consider that, if your bloom filters false positive rate is 1%(we will talk about the error rate in details later), that means among the costly round-trips to the server or the disk, only 1% of the query will be returned with false result, other 99% won’t go in vain.<br>Not bad, huh?</p>
<p><img src="https://hackernoon.com/hn-images/1*MYeocwtT6dtNYnihEh6tUA.png" alt="img"></p>
<p>Nice visual simulation about how bloom filters work. Image Credit: <a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">WikiPedia</a></p>
<h4 id="Bloom-filter-operations"><a href="#Bloom-filter-operations" class="headerlink" title="Bloom filter operations"></a>Bloom filter operations</h4><p>The basic bloom filter supports two operations: <strong>test</strong> and <strong>add</strong>.</p>
<p><strong>Test</strong> is used to check whether a given element is in the set or not.</p>
<p><strong>Add</strong> simply adds an element to the set.</p>
<p>Now a little quiz for you.</p>
<p>Based on what we’ve discussed so far, is it possible to <strong>Remove</strong> an item from the bloom filter? If yes, then how?</p>
<p>Take a 2 minutes break and think about the solution.</p>
<p>Got anything? Nothing? Let me help you a bit. Let’s bring back the bit-vector after inserting ‘geeks’ and ‘nerd’ in it.</p>
<p><img src="https://hackernoon.com/hn-images/1*xm1aM4Hwevn8tizTSe7LKA.png" alt="img"></p>
<p>Image Credit: <a href="http://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/" target="_blank" rel="noopener">GeeksforGeeks</a></p>
<p><img src="https://hackernoon.com/hn-images/1*WpJpIEfjWkKPnR6GGbbVvQ.png" alt="img"></p>
<p>Image Credit: <a href="http://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/" target="_blank" rel="noopener">GeeksforGeeks</a></p>
<p>Now we want to remove ‘geeks’ from it. So, if we remove 1, 4, 7 from the bit vector, as they are marked by ‘geeks’, and convert them to ‘0’, what will happen? You can easily see that, next time if we search for ‘nerd’, as the index ‘4’ will show ‘0’, it will definitely tell us that ‘nerd’ is not on the list, though it actually is. That means removal is impossible without introducing false negatives.</p>
<p>So, what’s the solution?</p>
<p>The solution is we can’t support Remove operation in this simple bloom filters. But if we really need to have a Removal functionality we can use a variation of the bloom filter known as <strong>‘Counting bloom filter’</strong>. The idea is simple. Instead of storing a single bit of values, we will store an integer value and our bit vector will then be an integer vector. This will increase the size and costs more space to gives us the Removal functionality. Instead of just marking a bit value to ‘1’ when inserting a value, we will increment the integer value by 1. To check if an element exists, check if the corresponding indexes after hashing the element is greater than 0.<br>If you are having a hard time to understand how a ‘Counting bloom filter’ can give us ‘deletion’ feature, I’ll suggest you take a pen and a paper and simulate our bloom filter as a counting filter and then try a deletion on it. Hopefully, you’ll get it easily. If you failed, try again. If you failed again then please leave a comment and I’ll try to describe it.</p>
<h4 id="Bloom-filter-size-and-number-of-Hash-functions"><a href="#Bloom-filter-size-and-number-of-Hash-functions" class="headerlink" title="Bloom filter size and number of Hash functions"></a>Bloom filter size and number of Hash functions</h4><p>You might already understand that if the size of the bloom filter is too small, soon enough all of the bit fields will turn into ‘1’ and then our bloom filter will return ‘false positive’ for every input. So, the size of the bloom filter is a very important decision to be made. A larger filter will have less false positives, and a smaller one more. So, we can tune our bloom filter to how much precise we need it to be based on the ‘false positive error rate’.<br>Another important parameter is ‘how many hash functions we will use’. The more hash functions we use, the slower the bloom filter will be, and the quicker it fills up. If we have too few, however, we may suffer too many false positives.</p>
<p><img src="https://hackernoon.com/hn-images/1*sSuuWFeLpwVZIPuNSoAiyQ.png" alt="img"></p>
<p>Image Credit: <a href="https://engineering.semantics3.com/use-the-bloom-filter-luke-b59fd0839fc4" target="_blank" rel="noopener">Abishek Bhat’s article about bloom filter</a></p>
<p>You can see from the above graph that, increasing the number of hash functions, <strong>k</strong>, will drastically reduce the error rate, <strong>p</strong>.</p>
<p>We can calculate the false positive error rate, <strong><em>p\</em></strong>, based on the size of the filter, <strong><em>m\</em></strong>, the number of hash functions, <strong><em>k\</em></strong>, and the number of elements inserted, <strong><em>n\</em></strong>, with the formula:</p>
<p><img src="https://hackernoon.com/hn-images/1*4QvZrOV7d9XgQXqVaIOGPg.png" alt="img"></p>
<p>Seems like WTF? Don’t worry, we would actually mostly need to decide what our <strong><em>m\</em></strong> and <strong><em>k\</em></strong> would be. So, if we set an error tolerance value <strong><em>p\</em></strong> and the number of elements <strong><em>n\</em></strong> by ourselves we can use the following formulas to calculate these parameters:</p>
<p><img src="https://hackernoon.com/hn-images/1*eDTlEUQCLRB8wL96GileXA.png" alt="img"></p>
<p>Another important point I also need to mention here. As the sole purpose of using bloom filter is to search faster, we can’t use slow hash functions, right? Cryptographic hash functions such as Sha-1, MD5 won’t be good choice for bloom filters as they are a bit slow. So, the better choices from the faster hash function implementations would be <a href="https://sites.google.com/site/murmurhash/" target="_blank" rel="noopener">murmur</a>, the <a href="http://isthe.com/chongo/tech/comp/fnv/" target="_blank" rel="noopener">fnv</a> series of hashes, Jenkins hashes and <a href="http://www.google.com/codesearch/url?ct=ext&url=http://www.concentric.net/~Ttwang/tech/inthash.htm&usg=AFQjCNEBOwEAd_jb5vYSckmG7OxrkeQhLA" target="_blank" rel="noopener">HashMix</a>.</p>
<h4 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h4><p>Bloom filter is all about testing Membership in a set. The classic example of using bloom filters is to reduce expensive disk (or network) lookups for non-existent keys. As we can see that bloom filters can search for a key in O(k) constant time, where k is the number of hash functions, it will be very fast to test non-existence of a key.</p>
<p>If the element is not in the bloom filter, then we know for sure we don’t need to perform the expensive lookup. On the other hand, if it <em>is</em> in the bloom filter, we perform the lookup, and we can expect it to fail some proportion of the time (the false positive rate).</p>
<p>For some more concrete examples:</p>
<ul>
<li>You’ve seen in our given example that we could’ve use it to warn the user for weak passwords.</li>
<li>You can use bloom filter to <a href="https://medium.com/@nathankrishnan/using-a-bloom-filter-to-prevent-users-of-your-ios-app-from-accessing-malicious-sites-7ad555a69598" target="_blank" rel="noopener">prevent your users</a> from <a href="https://stackoverflow.com/a/14403897/4230330" target="_blank" rel="noopener">accessing malicious sites</a>.</li>
<li>Instead of making a query to an SQL database to check if a user with a certain email exists, you could first use a bloom filter for an inexpensive lookup check. If the email doesn’t exist, great! If it does exist, you might have to make an extra query to the database. You can do the same to <a href="http://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/" target="_blank" rel="noopener">search for if a ‘Username is already taken’</a>.</li>
<li>You can keep a bloom filter based on the IP address of the visitors to your website to check if a user to your website is a ‘returning user’ or a ‘new user’. Some false positive value for ‘returning user’ won’t hurt you, right?</li>
<li>You can also make a <a href="http://codekata.com/kata/kata05-bloom-filters/" target="_blank" rel="noopener">Spell-checker by using bloom filter</a> to track the dictionary words.</li>
<li>Want to know how Medium used bloom filter to decide if a user already read post? Read this <a href="https://blog.medium.com/what-are-bloom-filters-1ec2a50c68ff" target="_blank" rel="noopener">mind-blowing, freaking awesome article</a> about it.</li>
</ul>
<p>Do you still think that you won’t ever need bloom filter? Well, we don’t use all of the algorithms we’ve learned in our everyday life. But maybe someday it might save your arse. Who knows? Learning a new thing never hurts, right?</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL事务隔离级别和锁</title>
    <url>/2020/06/07/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E9%94%81/</url>
    <content><![CDATA[<p>转载,整理自</p>
<p>1.<a href="https://www.ibm.com/developerworks/cn/opensource/os-mysql-transaction-isolation-levels-and-locks/index.html" target="_blank" rel="noopener">MySQL 事务隔离级别和锁</a></p>
<p>2.<a href="https://blog.csdn.net/puhaiyang/article/details/72284702" target="_blank" rel="noopener">对mysql乐观锁、悲观锁、共享锁、排它锁、行锁、表锁概念的理解</a></p>
<p>3.<a href="https://blog.csdn.net/hh1sdfsf56456/article/details/79449714" target="_blank" rel="noopener">mysql乐观锁总结和实践：用version或者时间戳</a></p>
<h2 id="事务及其特性"><a href="#事务及其特性" class="headerlink" title="事务及其特性"></a>事务及其特性</h2><p>数据库事务（简称:事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。事务的使用是数据库管理系统区别文件系统的重要特征之一。</p>
<p>事务拥有四个重要的特性：<strong>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</strong>，人们习惯称之为 ACID 特性。下面我逐一对其进行解释。</p>
<ul>
<li><p>原子性（Atomicity）</p>
<p>事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。例如，如果一个事务需要新增 100 条记录，但是在新增了 10 条记录之后就失败了，那么数据库将回滚对这 10 条新增的记录。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</p>
</li>
<li><p>一致性（Consistency）</p>
<p>指事务将数据库从一种状态转变为另一种一致的的状态。事务开始前和结束后，数据库的完整性约束没有被破坏。例如工号带有唯一属性，如果经过一个修改工号的事务后，工号变的非唯一了，则表明一致性遭到了破坏。</p>
</li>
<li><p>隔离性（Isolation）</p>
<p>要求每个读写事务的对象对其他事务的操作对象能互相分离，即该事务提交前对其他事务不可见。 也可以理解为多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。例如一个用户在更新自己的个人信息的同时，是不能看到系统管理员也在更新该用户的个人信息（此时更新事务还未提交）。</p>
<p>注：MySQL 通过锁机制来保证事务的隔离性。</p>
</li>
<li><p>持久性（Durability）</p>
<p>事务一旦提交，则其结果就是永久性的。即使发生宕机的故障，数据库也能将数据恢复，也就是说事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。这只是从事务本身的角度来保证，排除 RDBMS（关系型数据库管理系统，例如 Oracle、MySQL 等）本身发生的故障。</p>
<p>注：MySQL 使用 <code>redo log</code> 来保证事务的持久性。</p>
</li>
</ul>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>SQL 标准定义的四种隔离级别被 ANSI（美国国家标准学会）和 ISO/IEC（国际标准）采用，每种级别对事务的处理能力会有不同程度的影响。</p>
<p>我们分别对四种隔离级别从并发程度由高到低进行描述，并用代码进行演示，数据库环境为 MySQL 5.7。</p>
<h3 id="READ-UNCOMMITTED（读未提交）"><a href="#READ-UNCOMMITTED（读未提交）" class="headerlink" title="READ UNCOMMITTED（读未提交）"></a>READ UNCOMMITTED（读未提交）</h3><p>该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为<strong>脏读</strong>。</p>
<ol>
<li><p>准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，再准备一张测试表<code>test</code>，写入一条测试数据并调整隔离级别为<code>READ UNCOMMITTED</code>，任意一个终端执行即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @@session.transaction_isolation = <span class="string">'READ-UNCOMMITTED'</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>登录 mysql 终端 1，开启一个事务，将 ID 为1的记录更新为2。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> <span class="keyword">id</span> = <span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- 此时看到一条ID为2的记录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>登录 mysql 终端 2，开启一个事务后查看表中的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- 此时看到一条 ID 为 2 的记录</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>最后一步读取到了 mysql 终端 1 中未提交的事务（没有 commit 提交动作），即产生了<strong>脏读</strong>，<strong>大部分业务场景都不允许脏读</strong>出现，<strong>但</strong>是此隔离级别下数据库的<strong>并发是最好的</strong>。</p>
<h3 id="READ-COMMITTED（读提交）"><a href="#READ-COMMITTED（读提交）" class="headerlink" title="READ COMMITTED（读提交）"></a>READ COMMITTED（读提交）</h3><p>一个事务可以读取另一个已提交的事务，这次事务内多次读取会得到不一样的结果，此现象称为<strong>不可重复读(也称虚读)</strong>问题，Oracle 和 SQL Server 的默认隔离级别。</p>
<ol>
<li><p>准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，再准备一张测试表<code>test</code>，写入一条测试数据并调整隔离级别为<code>READ COMMITTED</code>，任意一个终端执行即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @@session.transaction_isolation = <span class="string">'READ-COMMITTED'</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录 mysql 终端 1，开启一个事务，将 ID 为1的记录更新为2，并确认记录数变更过来。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> <span class="keyword">id</span> = <span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- 此时看到一条记录为 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>登录 mysql 终端 2，开启一个事务后，查看表中的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- 此时看一条 ID 为 1 的记录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>登录 mysql 终端 1，提交事务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换到 mysql 终端 2。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- 此时看到一条 ID 为 2 的记录</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>mysql 终端 2 在开启了一个事务之后，在第一次读取 <code>test</code> 表（此时 mysql 终端 1 的事务还未提交）时 ID 为 <code>1</code>，在第二次读取 <code>test</code> 表（此时 mysql 终端 1 的事务已经提交）时 ID 已经变为 <code>2</code>，说明在此隔离级别下已经<strong>读取到已提交的事务。</strong></p>
<h3 id="REPEATABLE-READ（可重复读）"><a href="#REPEATABLE-READ（可重复读）" class="headerlink" title="REPEATABLE READ（可重复读）"></a>REPEATABLE READ（可重复读）</h3><p>该隔离级别是 <strong>MySQL 默认的隔离级别</strong>，在同一个事务里，<code>select</code> 的结果是事务开始时时间点的状态，因此，同样的 <code>select</code> 操作读到的结果会是一致的，但是，会有<strong>幻读</strong>现象。MySQL 的 InnoDB 引擎可以通过 <code>next-key locks</code> 机制（参考下文<a href="https://www.ibm.com/developerworks/cn/opensource/os-mysql-transaction-isolation-levels-and-locks/index.html#1行锁的算法outline" target="_blank" rel="noopener">“行锁的算法”</a>一节）来避免幻读。</p>
<ol>
<li><p>准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，准备一张测试表<code>test</code>并调整隔离级别为<code>REPEATABLE READ</code>，任意一个终端执行即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @@session.transaction_isolation = <span class="string">'REPEATABLE-READ'</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录 mysql 终端 1，开启一个事务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- 无记录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>登录 mysql 终端 2，开启一个事务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- 无记录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>切换到 mysql 终端 1，增加一条记录并提交。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换到 msyql 终端 2。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">--此时查询还是无记录</span></span><br></pre></td></tr></table></figure>

<p>通过这一步可以证明，在该隔离级别下已经<strong>读取不到别的已提交的事务</strong>，如果想看到 mysql 终端 1 提交的事务，在 mysql 终端 2 将当前事务提交后再次查询就可以读取到 mysql 终端 1 提交的事务。我们接着实验，看看在该隔离级别下是否会存在别的问题。</p>
</li>
<li><p>此时接着在 mysql 终端 2 插入一条数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'b'</span>); <span class="comment">-- 此时报主键冲突的错误</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>也许到这里您心里可能会有疑问，明明在第 5 步没有数据，为什么在这里会报错呢？其实这就是该隔离级别下可能产生的问题，MySQL 称之为<strong>幻读</strong>。注意我在这里强调的是 MySQL 数据库，Oracle 数据库对于幻读的定义可能有所不同。</p>
<h3 id="SERIALIZABLE（序列化）"><a href="#SERIALIZABLE（序列化）" class="headerlink" title="SERIALIZABLE（序列化）"></a>SERIALIZABLE（序列化）</h3><p>在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 <strong>InnoDB 引擎会给读操作隐式加一把读共享锁</strong>，从而<strong>避免了脏读、不可重读复读和幻读</strong>问题。</p>
<ol>
<li><p>准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，分别登入 mysql，准备一张测试表 test 并调整隔离级别为<code>SERIALIZABLE</code>，任意一个终端执行即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @@session.transaction_isolation = <span class="string">'SERIALIZABLE'</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录 mysql 终端 1，开启一个事务，并写入一条数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录 mysql 终端 2，开启一个事务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- 此时会一直卡住</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>立马切换到 mysql 终端 1,提交事务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>一旦事务提交，msyql 终端 2 会立马返回 ID 为 1 的记录，否则会一直卡住，直到超时，其中超时参数是由 <code>innodb_lock_wait_timeout</code> 控制。由于每条 <code>select</code> 语句都会加锁，所以该隔离级别的数据库并发能力最弱，但是有些资料表明该结论也不一定对，如果感兴趣，您可以自行做个压力测试。</p>
<p>表 1 总结了各个隔离级别下产生的一些问题。</p>
<center>表 1. 各个隔离级别下产生的一些问题</center>

<table>
<thead>
<tr>
<th align="left"><strong>隔离级别</strong></th>
<th align="left"><strong>脏读</strong>(读到可能会回滚的数据)</th>
<th align="left">(一个事务内)<strong>不可重复读</strong></th>
<th align="left"><strong>幻读</strong>(读到数据不够新?)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读未提交</td>
<td align="left">可以出现</td>
<td align="left">可以出现</td>
<td align="left">可以出现</td>
</tr>
<tr>
<td align="left">读提交</td>
<td align="left">不允许出现</td>
<td align="left">可以出现</td>
<td align="left">可以出现</td>
</tr>
<tr>
<td align="left">可重复读</td>
<td align="left">不允许出现</td>
<td align="left">不允许出现</td>
<td align="left">可以出现</td>
</tr>
<tr>
<td align="left">序列化</td>
<td align="left">不允许出现</td>
<td align="left">不允许出现</td>
<td align="left">不允许出现</td>
</tr>
</tbody></table>
<h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>脏读指在一个事务处理过程里读取了另一个未提交的事务中的数据，读取数据不一致。<br>事务A对数据进行增删改操作，但未提交，另一事务B可以读取到未提交的数据。如果事务A这时候回滚了，则第二个事务B读取的即为脏数据。</p>
<p>举例：当一个事务正在多次修改某个数据，而在这个事务中多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。<br>例如：用户A向用户B转账100元，对应SQL命令如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money = money + <span class="number">100</span> <span class="keyword">where</span> <span class="keyword">name</span>=’B’;  <span class="comment">--(此时A通知B)</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money = money - <span class="number">100</span> <span class="keyword">where</span> <span class="keyword">name</span>=’A’;</span><br></pre></td></tr></table></figure>

<p>当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p>
<h2 id="不可重复读-虚读"><a href="#不可重复读-虚读" class="headerlink" title="不可重复读(虚读)"></a>不可重复读(虚读)</h2><p>所谓的虚读，也就是大家经常说的不可重复读，是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。<strong>这是由于查询时系统中其他事务修改的提交而引起的。</strong>比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。<br>一种更易理解的说法是：在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的修改，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。</p>
<h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.</p>
<p>一般解决幻读的方法是增加范围锁RangeS，<strong>锁定检锁范围为只读</strong>，这样就避免了幻读。简单来说，幻读是由插入或者删除引起的。</p>
<h2 id="不可重复读（虚读）和幻读比较"><a href="#不可重复读（虚读）和幻读比较" class="headerlink" title="不可重复读（虚读）和幻读比较"></a>不可重复读（虚读）和幻读比较</h2><p>两者都表现为两次读取的结果不一致.</p>
<p>大致的区别在于不可重复读是由于另一个事务对数据的更改(<code>update</code>)所造成的，而幻读是由于另一个事务插入(<code>insert</code>)或删除(<code>delete</code>)引起的。</p>
<p>但如果你从控制的角度来看, 两者的区别就比较大：<br>对于前者, 只需要锁住满足条件的记录<br>对于后者, 要锁住满足条件及其相近的记录</p>
<h2 id="MySQL-中的锁"><a href="#MySQL-中的锁" class="headerlink" title="MySQL 中的锁"></a>MySQL 中的锁</h2><p>锁也是数据库管理系统区别文件系统的重要特征之一。锁机制使得在对数据库进行并发访问时，可以保障数据的完整性和一致性。对于锁的实现，各个数据库厂商的实现方法都会有所不同。本文讨论 MySQL 中的 InnoDB 引擎的锁。</p>
<h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><h5 id="悲观锁-行锁"><a href="#悲观锁-行锁" class="headerlink" title="悲观锁(行锁)"></a>悲观锁(行锁)</h5><p>InnoDB 实现了两种类型的行级锁,属于悲观锁的范畴：</p>
<ul>
<li><p><strong>共享锁</strong>（也称为 S 锁,读锁）：允许事务读取一行数据。</p>
<p>可以使用 SQL 语句 <code>select * from tableName where … lock in share mode;</code> 手动加 S 锁。</p>
</li>
<li><p><strong>排他锁</strong>（也称为 X 锁,写锁,独占锁）：允许事务删除或更新一行数据。</p>
<p>可以使用 SQL 语句 <code>select * from tableName where … for update</code>; 手动加 X 锁。</p>
</li>
</ul>
<p>S 锁和 S 锁是<strong>兼容</strong>的，X 锁和其它锁都<strong>不兼容</strong>.</p>
<p>举个例子，事务 T1 获取了一个行 r1 的 S 锁，另外事务 T2 可以立即获得行 r1 的 S 锁，此时 T1 和 T2 共同获得行 r1 的 S 锁，此种情况称为<strong>锁兼容</strong>，但是另外一个事务 T2 此时如果想获得行 r1 的 X 锁，则必须等待 T1 对行 r 锁的释放，此种情况也成为<strong>锁冲突</strong>。</p>
<p>为了实现多粒度的锁机制，InnoDB 还有两种内部使用的<strong>意向锁</strong>，由 InnoDB 自动添加，且都是<strong>表级别的锁</strong>。</p>
<ul>
<li><strong>意向共享锁</strong>（IS）：事务即将给表中的各个行设置共享锁S，事务给数据行加 S 锁前必须获得该表的 IS 锁。</li>
<li><strong>意向排他锁</strong>（IX）：事务即将给表中的各个行设置排他锁X，事务给数据行加 X 锁前必须获得该表 IX 锁。</li>
</ul>
<p>意向锁的主要目的是为了使得<strong>行锁</strong>和<strong>表锁</strong>共存。表 2 列出了行级锁(S,X)和表级意向锁(IS,IX)的兼容性。</p>
<center>表 2. 行级锁和表级意向锁的兼容性</center>

<table>
<thead>
<tr>
<th align="left"><strong>锁类型</strong></th>
<th align="left"><strong>X</strong></th>
<th align="left"><strong>IX</strong></th>
<th align="left"><strong>S</strong></th>
<th align="left"><strong>IS</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>X</strong></td>
<td align="left">冲突</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
</tr>
<tr>
<td align="left"><strong>IX</strong></td>
<td align="left">冲突</td>
<td align="left">兼容</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
</tr>
<tr>
<td align="left"><strong>S</strong></td>
<td align="left">冲突</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
</tr>
<tr>
<td align="left"><strong>IS</strong></td>
<td align="left">冲突</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
</tr>
</tbody></table>
<h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p><strong>乐观锁不是数据库自带的</strong>，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不加锁，而在进行更新后，再去判断是否有冲突了(CAS操作)。</p>
<p>一般来说有以下2种方式：</p>
<ol>
<li><p>使用<strong>数据版本（Version）</strong>记录机制实现</p>
<p>这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p>
</li>
<li><p>使用<strong>时间戳（Timestamp）</strong>记录机制实现</p>
<p>乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</p>
</li>
</ol>
<p>举例：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。</p>
<p>下单操作包括3步骤：</p>
<p>1.查询出商品信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> (<span class="keyword">status</span>,<span class="keyword">status</span>,<span class="keyword">version</span>) <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125;</span></span><br></pre></td></tr></table></figure>

<p>2.根据商品信息生成订单</p>
<p>3.修改商品status为2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t_goods </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125; and version=#&#123;version&#125;;</span></span><br></pre></td></tr></table></figure>

<p>除了自己手动实现乐观锁之外，现在网上许多框架已经封装好了乐观锁的实现，如hiberate实现的乐观锁。</p>
<h3 id="行锁的算法"><a href="#行锁的算法" class="headerlink" title="行锁的算法"></a>行锁的算法</h3><p>InnoDB 存储引擎使用三种行锁的算法用来满足相关事务隔离级别的要求。</p>
<ul>
<li><p>Record Locks</p>
<p>该锁为索引记录上的锁，如果表中没有定义索引，InnoDB 会默认为该表创建一个隐藏的聚簇索引，并使用该索引锁定记录。</p>
</li>
<li><p>Gap Locks</p>
<p>该锁会锁定一个范围，但是不括记录本身。可以通过修改隔离级别为 <code>READ COMMITTED</code> 或者配置 <code>innodb_locks_unsafe_for_binlog</code> 参数为 <code>ON</code>。</p>
</li>
<li><p>Next-key Locks</p>
<p>该锁就是 Record Locks 和 Gap Locks 的组合，即锁定一个范围并且锁定该记录本身。<strong>InnoDB 使用 Next-key Locks 解决幻读问题</strong>。需要注意的是，如果索引有唯一属性，则 InnnoDB 会自动将 Next-key Locks 降级为 Record Locks。举个例子，如果一个索引有 1, 3, 5 三个值，则该索引锁定的区间为 <code>(-∞,1], (1,3], (3,5], (5,+ ∞)</code>。</p>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁</strong>是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p>InnoDB 引擎采取的是 <code>wait-for graph</code> 等待图的方法来自动检测死锁，如果发现死锁会自动回滚一个事务。</p>
<p>下面我们通过一个示例来了解死锁。</p>
<ol>
<li><p>准备两个终端，在此命名为 mysql 终端 1 和 mysql 终端 2，分别登入 mysql，再准备一张测试表<code>test</code>写入两条测试数据，并调整隔离级别为<code>SERIALIZABLE</code>，任意一个终端执行即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @@session.transaction_isolation = <span class="string">'REPEATABLE-READ'</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="number">1</span>),(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>登录 mysql 终端 1，开启一个事务，手动给 ID 为1的记录加 X 锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">   <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录 mysql 终端 2，开启一个事务，手动给 ID 为2的记录加 X 锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">   <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换到 mysql 终端 1，手动给 ID 为2的记录加 X 锁，此时会一直卡住，因为此时在等待第 3 步中 X 锁的释放，直到超时，超时时间由<code>innodb_lock_wait_timeout</code>控制。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在锁超时前立刻切换到 mysql 终端 2，手动给 ID 为1的记录加 X 锁，此时又会等待第 2 步中 X 所的释放，两个终端都在等待资源的释放，所以 InnoDB 引擎会立马检测到死锁产生，自动回滚一个事务，以防止死锁一直占用资源。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">   ERROR 1213 (40001): Deadlock found when trying to get <span class="keyword">lock</span>; try restarting transaction</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>此时，通过 <code>show engine innodb status\G</code> 命令可以看到 <code>LATEST DETECTED DEADLOCK</code> 相关信息，即表明有死锁发生；或者通过配置 <code>innodb_print_all_deadlocks</code>（MySQL 5.6.2 版本开始提供）参数为 <code>ON</code> 将死锁相关信息打印到 MySQL 的错误日志。</p>
<h3 id="锁的优化建议"><a href="#锁的优化建议" class="headerlink" title="锁的优化建议"></a>锁的优化建议</h3><p>锁如果利用不好，会给业务造成大量的卡顿现象，在了解了锁相关的一些知识点后，我们可以有意识的去避免锁带来的一些问题。</p>
<ol>
<li>合理设计索引，让 InnoDB 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他 Query 的执行。</li>
<li>尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录。</li>
<li>尽量控制事务的大小，减少锁定的资源量和锁定时间长度。</li>
<li>在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少 MySQL 因为实现事务隔离级别所带来的附加成本。</li>
</ol>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>通过阅读本文，可以让您对数据库的事务还有事务的隔离级别有个基本的了解，同时也介绍了 MySQL 中 InnoDB 引擎中一些锁相关的知识，从而可以让您利用关系型数据库系统设计一个更为健壮的业务模型。</p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul>
<li>查看<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html" target="_blank" rel="noopener"> MySQL 官方文档</a>，获取更多关于 MySQL 事务和锁相关的最新信息。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>智力题-转载</title>
    <url>/2020/05/16/%E6%99%BA%E5%8A%9B%E9%A2%98-%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<p>目录： </p>
<p>  1.赛马找最快&lt;腾讯高频&gt; </p>
<p>  2.砝码称轻重 </p>
<p>  3.药瓶毒白鼠&lt;腾讯&gt; </p>
<p>  4.绳子两头烧 </p>
<p>  5.犯人猜颜色 </p>
<p>  6.猴子搬香蕉 </p>
<p>  7.高楼扔鸡蛋&lt;谷歌&gt; </p>
<p>  8.轮流拿石子&lt;头条&gt; </p>
<p>  9.蚂蚁走树枝 </p>
<p>   10.海盗分金币&lt;不常见&gt;  </p>
<p>   11.三个火枪手  </p>
<p>   12.囚犯拿豆子  </p>
<p>13.学生猜生日&lt;笔试高频&gt;</p>
<h2 id="1-赛马找最快-lt-腾讯高频题-gt"><a href="#1-赛马找最快-lt-腾讯高频题-gt" class="headerlink" title="1. 赛马找最快&lt;腾讯高频题&gt;"></a><strong>1. 赛马找最快&lt;腾讯高频题&gt;</strong></h2><p>  **<br>**   </p>
<p>  一般有这么几种问法： </p>
<p>   25匹马5条跑道找最快的3匹马，需要跑几次？答案：7  </p>
<p>   64匹马8条跑道找最快的4匹马，需要跑几次？答案：11  </p>
<p>   25匹马5条跑道找最快的5匹马，需要跑几次？答案：最少8次最多9次  </p>
<p>  接下来我们看看详细解法： </p>
<h3 id="25匹马5条跑道找最快的3匹马，需要跑几次？"><a href="#25匹马5条跑道找最快的3匹马，需要跑几次？" class="headerlink" title="25匹马5条跑道找最快的3匹马，需要跑几次？"></a><strong>25</strong>匹马<strong>5</strong>条跑道找最快的<strong>3</strong>匹马，需要跑几次？</h3><p>  <img src="https://uploadfiles.nowcoder.com/files/20190917/7563541_1568691598838_720994-20181030103143923-1280332452.png" alt="img">  </p>
<p>   将25匹马分成ABCDE5组，假设每组的排名就是A1&gt;A2&gt;A3&gt;A4&gt;A5,用边相连，这里比赛5次  </p>
<p>   第6次，每组的第一名进行比赛，可以找出最快的马，这里假设A1&gt;B1&gt;C1&gt;D1&gt;E1  </p>
<p>   D1，E1肯定进不了前3，直接排除掉  </p>
<p>   第7次，B1 C1 A2 B2 A3比赛，可以找出第二，第三名  </p>
<p>   所以最少比赛需要7次  </p>
<h3 id="64匹马8条跑道找最快的4匹马，需要跑几次？"><a href="#64匹马8条跑道找最快的4匹马，需要跑几次？" class="headerlink" title="64匹马8条跑道找最快的4匹马，需要跑几次？"></a>64匹马8条跑道找最快的4匹马，需要跑几次？</h3><p>  第一步<br> 全部马分为8组，每组8匹，每组各跑一次，然后淘汰掉每组的后四名，如下图（需要比赛8场） </p>
<p>  <img src="https://uploadfiles.nowcoder.com/files/20190917/7563541_1568691598560_24_4WV2U6UWKG3PXRT.png" alt="img">  </p>
<p>  第二步<br> 取每组第一名进行一次比赛，然后淘汰最后四名所在组的所有马，如下图（需要比赛1场） </p>
<p>  <img src="https://uploadfiles.nowcoder.com/files/20190917/7563541_1568691598554_24_8P9WKWKVGGEPHJ6.png" alt="img">  </p>
<p>  这个时候总冠军已经诞生，它就是A1，蓝<strong><em>域（它不需要比赛了），而其他可能跑得最快的三匹马只可能是下图中的黄</em></strong>域了（A2,A3,A4,B1,B2,B3,C1,C2,D1，共9匹马） </p>
<p>  <img src="https://uploadfiles.nowcoder.com/files/20190917/7563541_1568691598535_24_Z8Y5GCU8G2AZA9W.png" alt="img">  </p>
<p>  第三步<br> 只要从上面的9匹马中找出跑得最快的三匹马就可以了，但是现在只要8个跑道，怎么办？那就随机选出8匹马进行一次比赛吧（需要比赛一场） </p>
<p>  第四步<br> 上面比赛完，选出了前三名，但是9匹马中还有一匹马没跑呢，它可能是一个潜力股啊，那就和前三名比一比吧，这四匹马比一场，选出前三名。最后加上总冠军，跑得最快的四匹马诞生了！！！（需要一场比赛） </p>
<p>  最后，一共需要比赛的场次：8 + 1 + 1 + 1 = 11 场 </p>
<p>  来源：<a href="https://blog.csdn.net/u013829973/article/details/80787928" target="_blank" rel="noopener">https://blog.csdn.net/u013829973/article/details/80787928</a>  </p>
<h3 id="25匹马5条跑道找最快的5匹马，需要跑几次？"><a href="#25匹马5条跑道找最快的5匹马，需要跑几次？" class="headerlink" title="25匹马5条跑道找最快的5匹马，需要跑几次？"></a><strong>25</strong>匹马<strong>5</strong>条跑道找最快的<strong>5</strong>匹马，需要跑几次？</h3><p>  (1) 首先将25匹马分成5组，并分别进行5场比赛之后得到的名次排列如下： </p>
<p>  A组： [A1 A2 A3  A4 A5] </p>
<p>  B组： [B1 B2 B3  B4 B5] </p>
<p>  C组： [C1 C2 C3 C4 C5] </p>
<p>  D组： [D1 D2 D3 D4 D5] </p>
<p>  E组： [E1 E2 E3  E4 E5] </p>
<p>  其中，每个小组最快的马为[A1、B1、C1、D1、E1]。 </p>
<p>  (2) 将[A1、B1、C1、D1、E1]进行第6场，选出第1名的马，不妨设 A1&gt;B1&gt;C1&gt;D1&gt;E1. 此时第1名的马为A1。 </p>
<p>  (3) 将[A2、B1、C1、D1、E1]进行第7场，此时选择出来的必定是第2名的马，不妨假设为B1。因为这5匹马是除去A1之外每个小组当前最快的马。 </p>
<p>  (3) 进行第8场，选择[A2、B2、C1、D1、E1]角逐出第3名的马。 </p>
<p>  (4) 依次类推，第9，10场可以分别决出第4，5名的吗。 </p>
<p>  因此，依照这种竞标赛排序思想，需要10场比赛是一定可以取出前5名的。 </p>
<p>  <strong>仔细想一下，如果需要减少比赛场次，就一定需要在某一次比赛中同时决出2个名次，而且每一场比赛之后，有一些不可能进入前5名的马可以提前出局。</strong> 当然要做到这一点，就必须小心选择每一场比赛的马匹。我们在上面的方法基础上进一步思考这个问题，希望能够得到解决。 </p>
<p>  (1) 首先利用5场比赛角逐出每个小组的排名次序是绝对必要的。 </p>
<p>  (2) 第6场比赛选出第1名的马也是必不可少的。假如仍然是A1马(A1&gt;B1&gt;C1&gt;D1&gt;E1)。那么此时我们可以得到一个重要的结论：有一些马在前6场比赛之后就决定出局的命运了(下面粉色字体标志出局)。  </p>
<p>  A组： [A1 A2 A3  A4 A5] </p>
<p>  B组： [B1 B2 B3  B4 B5 ] </p>
<p>  C组： [C1 C2 C3  C4 C5 ] </p>
<p>  D组： [D1 D2 D3 D4 D5 ] </p>
<p>  E组： [E1  E2 E3  E4 E5 ] </p>
<p>  (3) 第7场比赛是关键，能否同时决出第2，3名的马呢？我们首先做下分析： </p>
<p>  在上面的方法中，第7场比赛[A2、B1、C1、D1、E1]是为了决定第2名的马。但是在第6场比赛中我们已经得到(B1&gt;C1&gt;D1&gt;E1)，试问？有B1在的比赛，C1、D1、E1还有可能争夺第2名吗？ 当然不可能，也就是说第2名只能在A2、B1中出现。实际上只需要2条跑道就可以决出第2名，剩下C1、D1、E1的3条跑道都只能用来凑热闹的吗？ </p>
<p>   能够优化的关键出来了，我们是否能够通过剩下的3个跑道来决出第3名呢？当然可以，我们来进一步分析第3名的情况？  </p>
<p>  ● 如果A2&gt;B1(即第2名为A2)，那么根据第6场比赛中的(B1&gt;C1&gt;D1&gt;E1)。 可以断定第3名只能在A3和B1中产生。  </p>
<p>  ● 如果B1&gt;A2(即第2名为B1)，那么可以断定的第3名只能在A2, B2,C1 中产生。  </p>
<p>  好了，结论也出来了，只要我们把[A2、B1、A3、B2、C1]作为第7场比赛的马，那么这场比赛的第2，3名一定是整个25匹马中的第2，3名。 </p>
<p>  我们在这里列举出第7场的2，3名次的所有可能情况： </p>
<p>  ① 第2名=A2，第3名=A3 </p>
<p>  ② 第2名=A2，第3名=B1 </p>
<p>  ③ 第2名=B1，第3名=A2 </p>
<p>  ④ 第2名=B1，第3名=B2 </p>
<p>  ⑤ 第2名=B1，第3名=C1 </p>
<p>  (4) 第8场比赛很复杂，我们要根据第7场的所有可能的比赛情况进行分析。 </p>
<p>  ① 第2名=A2，第3名=A3。那么此种情况下第4名只能在A4和B1中产生。 </p>
<p>  ● 如果第4名=A4，那么第5名只能在A5、B1中产生。 </p>
<p>  ● 如果第4名=B1，那么第5名只能在A4、B2、C1中产生。 </p>
<p>  不管结果如何，此种情况下，第4、5名都可以在第8场比赛中决出。其中比赛马匹为[A4、A5、B1、B2、C1]  </p>
<p>  ② 第2名=A2，第3名=B1。那么此种情况下第4名只能在A3、B2、C1中产生。 </p>
<p>  ● 如果第4名=A3，那么第5名只能在A4、B2、C1中产生。 </p>
<p>  ● 如果第4名=B2，那么第5名只能在A3、B3、C1中产生。 </p>
<p>  ● 如果第4名=C1，那么第5名只能在A3、B2、C2、D1中产生。 </p>
<p>  那么，第4、5名需要在马匹[A3、B2、B3、C1、A4、C2、D1]七匹马中产生，则必须比赛两场才行，也就是到第9场角逐出全部的前5名。  </p>
<p>  ③ 第2名=B1，第3名=A2。那么此种情况下第4名只能在A3、B2、C1中产生。 </p>
<p>  情况和②一样，必须角逐第9场 </p>
<p>  ④ 第2名=B1，第3名=B2。 那么此种情况下第4名只能在A2、B3、C1中产生。 </p>
<p>  ● 如果第4名=A2，那么第5名只能在A3、B3、C1中产生。 </p>
<p>  ● 如果第4名=B3，那么第5名只能在A2、B4、C1中产生。 </p>
<p>  ● 如果第4名=C1，那么第5名只能在A2、B3、C2、D1中产生。 </p>
<p>  那么，第4、5名需要在马匹[A2、B3、B4、C1、A3、C2、D1]七匹马中产 生，则必须比赛两场才行，也就是到第9场角逐出全部的前5名。  </p>
<p>  ⑤ 第2名=B1，第3名=C1。那么此种情况下第4名只能在A2、B2、C2、D1中产生。 </p>
<p>  ● 如果第4名=A2，那么第5名只能在A3、B2、C2、D1中产生。 </p>
<p>  ● 如果第4名=B2，那么第5名只能在A2、B3、C2、D1中产生。 </p>
<p>  ● 如果第4名=C2，那么第5名只能在A2、B2、C3、D1中产生。 </p>
<p>  ● 如果第4名=D1，那么第5名只能在A2、B2、C2、D2、E2中产生。 </p>
<p>  那么，第4、5名需要在马匹[A2、B2、C2、D1、A3、B3、C3、D2、E1]九匹马中 产 生，因此也必须比赛两场，也就是到第9长决出胜负。  </p>
<p>  总结：最好情况可以在第8场角逐出前5名，最差也可以在第9场搞定。  </p>
<p>  来源：iteye.com/blog/hxraid-662643  </p>
<h2 id="2-砝码称轻重"><a href="#2-砝码称轻重" class="headerlink" title="2. 砝码称轻重"></a><strong>2. 砝码称轻重</strong></h2><p>  这一类的题目有很多  这里只举几个经典的： </p>
<p>  \1. 有一个天平，九个砝码，其中一个砝码比另八个要轻一些，问至少要用天平称几次才能将轻的那个找出来？ 答案：2次  </p>
<p>  \2. 十组砝码每组十个，每个砝码都是10g重，但是现在其中有一组砝码每个都只有9g重，现有一个能显示克数的秤，最少称几次能找到轻的那组？ 答案：1次  </p>
<h3 id="有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？"><a href="#有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？" class="headerlink" title="有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？"></a><strong>有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？</strong></h3><p>  <strong>至少2次：第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个；<br> 第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个；<br> 答：至少称2次．</strong>  </p>
<p>​    </p>
<h3 id="有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？"><a href="#有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？" class="headerlink" title="有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？"></a><strong>有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？</strong></h3><p>  <strong>将砝码分组1~10，第一组拿一个，第二组拿两个以此类推。。第十组拿十个放到秤上称出克数x，则y = 550 - x，第y组就是轻的那组</strong>  </p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="3-药瓶毒白鼠"><a href="#3-药瓶毒白鼠" class="headerlink" title="3. 药瓶毒白鼠"></a><strong>3. 药瓶毒白鼠</strong></h2><p>  有1000个一模一样的瓶子，其中有999瓶是普通的水，有1瓶是毒药。任何喝下毒药的生命都会在一星期之后死亡。现在你只有10只小白鼠和1个星期的时间，如何检验出哪个瓶子有毒药？ </p>
<p>  答案： </p>
<p>  1、将10只老鼠剁成馅儿，分到1000个瓶盖中，每个瓶盖倒入适量相应瓶子的液体，置于户外，并每天补充适量相应的液体，观察一周，看哪个瓶盖中的肉馅没有腐烂或生蛆。（最好不要这样回答） </p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>  首先一共有1000瓶，2的10次方是1024，刚好大于1000，也就是说，1000瓶药品可以使用10位二进制数就可以表示。从第一个开始： </p>
<p>  第一瓶 ：    00 0000 0001 </p>
<p>  第二瓶：    00 0000 0010 </p>
<p>  第三瓶：    00 0000 0011 </p>
<p>  …… </p>
<p>  第999瓶：    11 1111 0010 </p>
<p>  第1000瓶：   11 1111 0011 </p>
<p>  需要十只老鼠，如果按顺序编号，ABCDEFGHIJ分别代表从低位到高位每一个位。 每只老鼠对应一个二进制位，如果该位上的数字为1，则给老鼠喝瓶里的药。 </p>
<p>  观察，若死亡的老鼠编号为：ACFGJ，一共死去五只老鼠，则对应的编号为  10 0110 0101，则有毒的药品为该编号的药品，转为十进制数为：613号。（这才是正解，当然前提是老鼠还没被撑死） </p>
<h2 id="4-绳子两头烧"><a href="#4-绳子两头烧" class="headerlink" title="4. 绳子两头烧"></a><strong>4. 绳子两头烧</strong></h2><p>  现有若干不均匀的绳子，烧完这根绳子需要一个小时，问如何准确计时15分钟，30分钟，45分钟，75分钟。。。 </p>
<h3 id="15：对折之后两头烧-要求对折之后绑的够紧，否则看45分钟解法"><a href="#15：对折之后两头烧-要求对折之后绑的够紧，否则看45分钟解法" class="headerlink" title="15：对折之后两头烧(要求对折之后绑的够紧，否则看45分钟解法)"></a>15：对折之后两头烧(要求对折之后绑的够紧，否则看45分钟解法)</h3><h3 id="30：两头烧-45：两根，一根两头烧一根一头烧，两头烧完过了30分钟，立即将第二根另一头点燃，到烧完又过15分钟，加起来45分钟-75：-30-45"><a href="#30：两头烧-45：两根，一根两头烧一根一头烧，两头烧完过了30分钟，立即将第二根另一头点燃，到烧完又过15分钟，加起来45分钟-75：-30-45" class="headerlink" title="30：两头烧  45：两根，一根两头烧一根一头烧，两头烧完过了30分钟，立即将第二根另一头点燃，到烧完又过15分钟，加起来45分钟  75：=30+45"></a>30：两头烧  45：两根，一根两头烧一根一头烧，两头烧完过了30分钟，立即将第二根另一头点燃，到烧完又过15分钟，加起来45分钟  75：=30+45</h3><p>  。。。 </p>
<h2 id="5-犯人猜颜色"><a href="#5-犯人猜颜色" class="headerlink" title="5. 犯人猜颜色"></a><strong>5. 犯人猜颜色</strong></h2><p>​    </p>
<p>  一百个犯人站成一纵列，每人头上随机带上黑色或白色的帽子，各人不知道自己帽子的颜色，但是能看见自己前面所有人帽子的颜色．<br> 然后从最后一个犯人开始，每人只能用同一种声调和音量说一个字：”黑”或”白”，<br> 如果说中了自己帽子的颜色，就存活，说错了就拉出去斩了，<br> 说的答案所有犯人都能听见，<br> 是否说对，其他犯人不知道，<br> 在这之前，所有犯人可以聚在一起商量策略，<br> 问如果犯人都足够聪明而且反应足够快，100个人最大存活率是多少？  </p>
<p>  答案：这是一道经典推理题  </p>
<p>  1、最后一个人如果看到奇数顶黑帽子报“黑”否则报“白”，他可能死  </p>
<p>  2、其他人记住这个值（实际是黑帽奇偶数），在此之后当再听到黑时，黑帽数量减一  </p>
<p>  3、从倒数第二人开始，就有两个信息：记住的值与看到的值，相同报“白”，不同报“黑”  </p>
<p>  99人能100%存活，1人50%能活 </p>
<p>  除此以外，此题还有变种：每个犯人只能看见前面一个人帽子颜色又能最多存活多少人？ </p>
<p>  答案：在上题基础上，限制了条件，这时上次的方法就不管用了，此时只能约定偶数位犯人说他前一个人的帽子颜色，奇数犯人获取信息100%存活，偶数犯人50几率存活。 </p>
<h2 id="6-猴子搬香蕉"><a href="#6-猴子搬香蕉" class="headerlink" title="6. 猴子搬香蕉"></a><strong>6. 猴子搬香蕉</strong></h2><p>  一个小猴子边上有100根香蕉，它要走过50米才能到家，每次它最多搬50根香蕉，（多了就被压死了），它每走 </p>
<p>  1米就要吃掉一根，请问它最多能把多少根香蕉搬到家里。（提示：他可以把香蕉放下往返的走，但是必须保证它每走一米都能有香蕉吃。也可以走到n米时，放下一些香蕉，拿着n根香蕉走回去重新搬50根。） </p>
<p>  答案：这种试题通常有一个迷惑点，让人看不懂题目的意图。此题迷惑点在于：走一米吃一根香蕉，一共走50米，那不是把50根香蕉吃完了吗？如果要回去搬另外50根香蕉，则往回走的时候也要吃香蕉，这样每走一米需要吃掉三根香蕉，走50米岂不是需要150根香蕉？ </p>
<p>  其实不然，本题关键点在于：猴子搬箱子的过程其实分为两个阶段，第一阶段：来回搬，当香蕉数目大于50根时，猴子每搬一米需要吃掉三根香蕉。第二阶段：香蕉数《=50，直接搬回去。每走一米吃掉1根。 </p>
<p>  我们分析第一阶段：假如把100根香蕉分为两箱。一箱50根。 </p>
<p>  第一步，把A箱搬一米，吃一根。 </p>
<p>  第二步，往回走一米，吃一根。 </p>
<p>  第三步，把B箱搬一米，吃一根。 </p>
<p>  这样，把所有香蕉搬走一米需要吃掉三根香蕉。 </p>
<p>  这样走到第几米的时候，香蕉数刚好小于50呢？ </p>
<p>  100-(n<em>3)&lt;50 &amp;&amp; 100-(n-1</em>3)&gt;50 </p>
<p>  走到16米的时候，吃掉48根香蕉，剩52根香蕉。这步很有意思，它可以直接搬50往前走，也可以再来回搬一次，但结果都是一样的。到17米的时候，猴子还有49根香蕉。这时猴子就轻松啦。直接背着走就行。 </p>
<p>  第二阶段： </p>
<p>  走一米吃一根。 </p>
<p>  把剩下的50-17=33米走完。还剩49-33=16根香蕉。 </p>
<h2 id="7-高楼扔鸡蛋"><a href="#7-高楼扔鸡蛋" class="headerlink" title="7. 高楼扔鸡蛋"></a><strong>7. 高楼扔鸡蛋</strong></h2><p>  有2个鸡蛋，从100层楼上往下扔，以此来测试鸡蛋的硬度。比如鸡蛋在第9层没有摔碎，在第10层摔碎了，那么鸡蛋不会摔碎的临界点就是9层。 </p>
<p>  问：如何用最少的尝试次数，测试出鸡蛋不会摔碎的临界点？ </p>
<p>  首先要说明的是这道题你要是一上来就说出正确答案，那说明你的智商不是超过160就是你做过这题。 </p>
<p>  所以建议你循序渐进的回答，一上来就说最优解可能结果不会让你和面试官满意。 </p>
<p>  答案： </p>
<p>  1.暴力法  </p>
<p>  举个栗子，最笨的测试方法，是什么样的呢？把其中一个鸡蛋，从第1层开始往下扔。如果在第1层没碎，换到第2层扔；如果在第2层没碎，换到第3层扔…….如果第59层没碎，换到第60层扔；如果第60层碎了，说明不会摔碎的临界点是第59层。 </p>
<p>  在最坏情况下，这个方法需要扔100次。 </p>
<ol start="2">
<li><p>二分法  </p>
<p>采用类似于二分查找的方法，把鸡蛋从一半楼层（50层）往下扔。 </p>
<p>如果第一枚鸡蛋，在50层碎了，第二枚鸡蛋，就从第1层开始扔，一层一层增长，一直扔到第49层。 </p>
<p>如果第一枚鸡蛋在50层没碎了，则继续使用二分法，在剩余楼层的一半（75层）往下扔…… </p>
<p>这个方法在最坏情况下，需要尝试50次。 </p>
<p>3.均匀法  </p>
<p>如何让第一枚鸡蛋和第二枚鸡蛋的尝试次数，尽可能均衡呢？ </p>
<p>很简单，做一个平方根运算，100的平方根是10。 </p>
<p>因此，我们尝试每10层扔一次，第一次从10层扔，第二次从20层扔，第三次从30层……一直扔到100层。 </p>
<p>这样的最好情况是在第10层碎掉，尝试次数为 1 + 9 = 10次。 </p>
<p>最坏的情况是在第100层碎掉，尝试次数为 10 + 9 = 19次。 </p>
</li>
</ol>
<p>  不过，这里有一个小小的优化点，我们可以从15层开始扔，接下来从25层、35层扔……一直到95层。 </p>
<p>  这样最坏情况是在第95层碎掉，尝试次数为 9 + 9 = 18次。 </p>
<p>  4.最优解法  </p>
<p>  最优解法是反向思考的经典：如果最优解法在最坏情况下需要扔X次，那第一次在第几层扔最好呢？ </p>
<p>  答案是：从X层扔 </p>
<p>  假设最优的尝试次数的x次，为什么第一次扔就要选择第x层呢？ </p>
<p>  这里的解释会有些烧脑，请小伙伴们坐稳扶好： </p>
<p>  <strong>假设第一次扔在第x+1层：</strong>  </p>
<p>  如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x层。 </p>
<p>  这样一来，我们总共尝试了x+1次，和假设尝试x次相悖。由此可见，第一次扔的楼层必须小于x+1层。 </p>
<p>  <strong>假设第一次扔在第x-1层：</strong>  </p>
<p>  如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x-2层。 </p>
<p>  这样一来，我们总共尝试了x-2+1 = x-1次，虽然没有超出假设次数，但似乎有些过于保守。 </p>
<p>  <strong>假设第一次扔在第x层：</strong>  </p>
<p>  如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x-1层。 </p>
<p>  这样一来，我们总共尝试了x-1+1 = x次，刚刚好没有超出假设次数。 </p>
<p>  因此，要想尽量楼层跨度大一些，又要保证不超过假设的尝试次数x，那么第一次扔鸡蛋的最优选择就是第x层。 </p>
<p>  那么算最坏情况，第二次你只剩下x-1次机会，按照上面的说法，你第二次尝试的位置必然是X+（X-1）； </p>
<p>  以此类推我们可得： </p>
<p>  x + (x-1) + (x-2) + … + 1 = 100 </p>
<p>  这个方程式不难理解： </p>
<p>  左边的多项式是各次扔鸡蛋的楼层跨度之和。由于假设尝试x次，所以这个多项式共有x项。 </p>
<p>  右边是总的楼层数100。 </p>
<p>  下面我们来解这个方程： </p>
<p>  x + (x-1) + (x-2) + … + 1 = 100 转化为 </p>
<p>  (x+1)*x/2 = 100 </p>
<p>  最终x向上取整，得到 x = 14 </p>
<p>  因此，最优解在最坏情况的尝试次数是14次，第一次扔鸡蛋的楼层也是14层。 </p>
<p>  最后，让我们把第一个鸡蛋没碎的情况下，所尝试的楼层数完整列举出来： </p>
<p>  14，27， 39， 50， 60， 69， 77， 84， 90， 95， 99， 100 </p>
<p>  举个栗子验证下： </p>
<p>  假如鸡蛋不会碎的临界点是65层，那么第一个鸡蛋扔出的楼层是14，27，50，60，69。这时候啪的一声碎了。 </p>
<p>  第二个鸡蛋继续，从61层开始，61，62，63，64，65，66，啪的一声碎了。 </p>
<p>  因此得到不会碎的临界点65层，总尝试次数是 6 + 6 = 12 &lt; 14 。 </p>
<p>  下面是我个人的理解：这个更像是优化版的均匀法，均匀法让你第二次尝试不超过10，但是第一次的位置无法保证（最多要9次，最好一次），这个由于每多一次尝试，楼层间隔就-1，最终使得第一次与第二次的和完全均匀（最差情况）。 </p>
<p>  但是核心思路是逆向思考，因为即使理解了需要两次的和均匀也很难得到第一次要在哪层楼扔。 </p>
<p>  一旦理解了这种方法，多少层楼你都不会怕啦~ </p>
<p>  来源：<a href="https://blog.csdn.net/qq_38316721/article/details/81351297" target="_blank" rel="noopener">https://blog.csdn.net/qq_38316721/article/details/81351297</a>  </p>
<h2 id="8-轮流拿石子-lt-头条问过-gt"><a href="#8-轮流拿石子-lt-头条问过-gt" class="headerlink" title="8. 轮流拿石子&lt;头条问过&gt;"></a><strong>8. 轮流拿石子&lt;头条问过&gt;</strong></h2><p>  问题：一共有N颗石子（或者其他乱七八糟的东西），每次最多取M颗最少取1颗，A，B轮流取，谁最后会获胜？（假设他们每次都取最优解）。 </p>
<p>  答案：简单的巴什博奕：<a href="https://www.cnblogs.com/StrayWolf/p/5396427.html" target="_blank" rel="noopener">https://www.cnblogs.com/StrayWolf/p/5396427.html</a>  </p>
<p>  问题：有若干堆石子，每堆石子的数量是有限的，二个人依次从这些石子堆中拿取任意的石子，至少一个（不能不取），最后一个拿光石子的人胜利。  </p>
<p>  答案：较复杂的尼姆博弈：<a href="https://blog.csdn.net/BBHHTT/article/details/80199541" target="_blank" rel="noopener">https://blog.csdn.net/BBHHTT/article/details/80199541</a>  </p>
<h2 id="9-蚂蚁走树枝"><a href="#9-蚂蚁走树枝" class="headerlink" title="9. 蚂蚁走树枝"></a><strong>9. 蚂蚁走树枝</strong></h2><p>  问题：放N只蚂蚁在一条长度为M树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。 </p>
<p>  答案：这个其实就一个诀窍：蚂蚁相碰就往反方向走，可以直接看做没有发生任何事：大家都相当于独立的 </p>
<p>  A蚂蚁与B蚂蚁相碰后你可以看做没有发生这次碰撞，这样无论是求时间还是距离都很简单了。 </p>
<h2 id="10-海盗分金币"><a href="#10-海盗分金币" class="headerlink" title="10. 海盗分金币"></a><strong>10. 海盗分金币</strong></h2><p>   问题：5个海盗抢到了100枚金币，每一颗都一样的大小和价值。  </p>
<p>   他们决定这么分：  </p>
<ol>
<li><p>​     抽签决定自己的号码（1，2，3，4，5）    </p>
</li>
<li><p>​     首先，由1号提出分配方案，然后大家5人进行表决，当半数以上的人同意时（不包括半数，这是重点），按照他的提案进行分配，否则将被扔入大海喂鲨鱼。    </p>
</li>
<li><p>​     如果1号死后，再由2号提出分配方案，然后大家4人进行表决，当且仅当半超过半数的人同意时，按照他的提案进行分配，否则将被扔入大海喂鲨鱼。    </p>
</li>
<li><p>​     依次类推……    </p>
<p>假设每一位海盗都足够聪明，并且利益至上，能多分一枚金币绝不少分，那么1号海盗该怎么分金币才能使自己分到最多的金币呢？  </p>
<p>答案：  </p>
<p>从后向前推，如果1至3号强盗都喂了<a href="https://baike.baidu.com/item/鲨鱼/40174" target="_blank" rel="noopener">鲨鱼</a>，只剩4号和5号的话，5号一定投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号惟有支持3号才能保命。  </p>
</li>
</ol>
<p>   3号知道这一点，就会提出“100，0，0”的分配方案，对4号、5号一毛不拔而将全部金币归为已有，因为他知道4号一无所获但还是会投赞成票，再加上自己一票，他的方案即可通过。  </p>
<p>   不过，2号推知3号的方案，就会提出“98，0，1，1”的方案，即放弃3号，而给予4号和5号各一枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望他出局而由3号来分配。这样，2号将拿走98枚金币。  </p>
<p>   同样，2号的方案也会被1号所洞悉，1号并将提出（97，0，1，2，0）或（97，0，1，0，2）的方案，即放弃2号，而给3号一枚金币，同时给4号（或5号）2枚金币。由于1号的这一方案对于3号和4号（或5号）来说，相比2号分配时更优，他们将投1号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入囊中。这无疑是1号能够获取最大收益的方案了！答案是：1号强盗分给3号1枚金币，分给4号或5号强盗2枚，自己独得97枚。分配方案可写成（97，0，1，2，0）或（97，0，1，0，2）。  </p>
<p>   此题还有变种：就是只需要一半人同意即可，不需要一半人以上同意方案就可以通过，在其他条件不变的情况下，1号该怎么分配才能获得最多的金币？  </p>
<p>   答案：类似的推理过程  </p>
<p>   4号：4号提出的方案的时候肯定是最终方案，因为不管5号同意不同意都能通过，所以4号5号不必担心自己被投入大海。那此时5号获得的金币为0，4号获得的金币为100。  </p>
<p>   5号：因为4号提方案的时候 ，自己获取的金币为0 。所以只要4号之前的人分配给自己的金币大于0就同意该方案。  </p>
<p>   4号：如果3号提的方案一定能获得通过（原因：3号给5号的金币大于0， 5号就同意 因此就能通过），那自己获得的金币就为0，所以只要2号让自己获得的金币大于0就会同意。  </p>
<p>   3号：因为到了自己提方案的时候可以给5号一金币，自己的方案就能通过，但考虑到2号提方案的时候给4号一个金币，2号的方案就会通过，那自己获得的金币就为0。所以只要1号让自己获得的金币大于0就会同意。  </p>
<p>   2号：因为到了自己提方案的时候只要给4号一金币，就能获得通过，根本就不用顾及3 号 5号同意不同意，所以不管1号怎么提都不会同意。  </p>
<p>   1号：2号肯定不会同意。但只要给3号一块金币，5号一块金币（因为5号如果不同意，那么4号分配的时候，他什么都拿不到）就能获得通过。  </p>
<p>   所以答案是 98，0，1，0，1。  </p>
<p>   类似的问题也可用类似的推理，并不难  </p>
<h2 id="11-三个火枪手"><a href="#11-三个火枪手" class="headerlink" title="11. 三个火枪手"></a><strong>11. 三个火枪手</strong></h2><p>   问题：彼此痛恨的甲、乙、丙三个枪手准备决斗。甲枪法最好，十发八中；乙枪法次之，十发六中；丙枪法最差，十发四中。如果三人同时***，并且每人每轮只发一枪；那么枪战后，谁活下来的机会大一些？   </p>
<p>   答案：   </p>
<p>​     一般人认为甲的枪法好，活下来的可能性大一些。但合乎推理的结论是，枪法最糟糕的丙活下来的几率最大。    </p>
<p>​     那么我们先来分析一下各个枪手的策略。    </p>
<p>​     如同田忌赛马一般，枪手甲一定要对枪手乙先***。因为乙对甲的威胁要比丙对甲的威胁更大，甲应该首先干掉乙，这是甲的最佳策略。    </p>
<p>​     同样的道理，枪手乙的最佳策略是第一枪瞄准甲。乙一旦将甲干掉，乙和丙进行对决，乙胜算的概率自然大很多。    </p>
<p>​     枪手丙的最佳策略也是先对甲***。乙的枪法毕竟比甲差一些，丙先把甲干掉再与乙进行对决，丙的存活概率还是要高一些。    </p>
<p>​     我们根据分析来计算一下三个枪手在上述情况下的存活几率：<br> 第一轮：甲射乙，乙射甲，丙射甲。<br> 甲的活率为24%（40% X 60%）    </p>
<p>​     乙的活率为20%(100% - 80%)    </p>
<p>​     丙的活率为100%（无人射丙）。    </p>
<p>​     由于丙100％存活率，因此根据上轮甲乙存活的情况来计算三人第二轮的存活几率：    </p>
<p>​     情况1：甲活乙死（24% X 80% = 19.2%）<br> 甲射丙，丙射甲：甲的活率为60%，丙的活率为20%。<br> 情况2：乙活甲死（20% X 76% = 15.2%）<br> 乙射丙，丙射乙：乙的活率为60%，丙的活率为40%。<br> 情况3：甲乙同活（24% X 20% = 4.8%）<br> 重复第一轮。<br> 情况4：甲乙同死（76% X 80% = 60.8%）<br> 枪战结束。    </p>
<p>​     据此来计算三人活率：<br> 甲的活率为(19.2% X 60%) + (4.8% X 24%) = 12.672%<br> 乙的活率为(15.2% X 60%) + (4.8% X 20%) = 10.08%<br> 丙的活率为(19.2% X 20%) + (15.2% X 40%) + (4.8% X 100%) + (60.8% X 100%) = 75.52%    </p>
<p>​     通过对两轮枪战的详细概率计算，我们发现枪法最差的丙存活的几率最大，枪法较好的甲和乙的存活几率却远低于丙的存活几率。    </p>
<p>   来自：<a href="https://www.zhihu.com/question/288093713/answer/482192781" target="_blank" rel="noopener">https://www.zhihu.com/question/288093713/answer/482192781</a>   </p>
<h2 id="12-囚犯拿豆子"><a href="#12-囚犯拿豆子" class="headerlink" title="12. 囚犯拿豆子"></a><strong>12. 囚犯拿豆子</strong></h2><p>   问题：有5个囚犯被***，他们请求上诉，于是法官愿意给他们一个机会。   </p>
<p>   犯人抽签分好顺序，按序每人从100粒豆子中随意抓取，最多可以全抓，最少可以不抓，可以和别人抓的一样多。   </p>
<p>   最终，抓的最多的和最少的要被处死。   </p>
<p>​      </p>
<p>   1、他们都是非常聪明且自私的人。  </p>
<p>   2、他们的原则是先求保命。如果不能保命，就拉人陪葬。  </p>
<p>   3、100颗不必都分完。  </p>
<p>   4、若有重复的情况，则也算最大或最小，一并处死（中间重复不算）。  </p>
<p>   假设每个犯人都足够聪明，但每个犯人并不知道其他犯人足够聪明。那么，谁活下来的可能性最大？   </p>
<p>   答案：   </p>
<p>​     不存在“谁活下来的可能性比较大”的问题。实际情况是5个人都要死。答案看起来很扯淡，但推理分析后却发现十分符合逻辑。    </p>
<p>​<br>​    </p>
<p>​     根据题意，一号知道有五个人抓豆子，为保性命，他只要让豆子在20颗以内就可以了。但是他足够聪明的话他一定拿20颗，因为无论多拿一颗：2,3,4号的人一定会拿20颗最后死的人就会是最多的1号和最少的5号  还是少拿一颗：2,3,4号拿20个后，5号选择也拿20个拉上1234号垫背。（下面会说为什么多拿少拿也只会相差一颗）    </p>
<p>​     2号是知道1号抓了几颗豆子(20)的。那么，对于2号来说，只有2种选择：与1号一样多，或者不一样多。我们就从这里入手。    </p>
<p>​     情况一，假如2号选择与1号的豆子数不一样多，也就是说2号选择比1号多或者比1号少。    </p>
<p>​     我们先要证明，如果2号选择比1号多或者比1号少，那么他一定会选择比1号只多1颗或者只少1颗。    </p>
<p>​     要证明这个并不算太难。因为每个囚犯的第一选择是先求保命，要保命就要尽量使自己的豆子数既不是最多也不是最少。当2号决定选择比1号多的时候，他已经可以保证自己不是最少，为了尽量使自己不是最多，当然比1号多出来的数量越小越好。因为这个数量如果与一号相差大于1的话，那么3号就有机会抓到的居中数，相差越大，二号成为最多的可能性也就越大。反之，当2号决定选择比1号少的时候，也是同样的道理，他会选择只比1号少1颗。既然2号只会会选择比1号多1颗或者比1号少1颗，那么1、2号的豆子数一定是2个连续的自然数，和一定是2n+1（其中1个人是n,另1人是n+1）。    </p>
<p>​     轮到3号的时候，他可以从剩下的豆子数知道1、2号的数量和，也就不难计算出n的值。而3号也只有2个选择：n颗或者n+1颗。为什么呢？这与上面的证明是一样的道理，保命原则，取最接近的数量，这里不再赘述。    </p>
<p>​     不过，3号选择的时候会有一个特殊情况，在这一情况下，他一定会选择较小的n，而不是较大的n+1。这一特殊情况就是，当3号知道自己选择了n后(已保证自己不是最多)，剩下的豆子数由于数量有限，4、5号中一定有人比n要少，这样自己一定可以活下来。计算的话就是 [100-(3n+1)]/2&lt;=n ，不难算出，在这个特殊情况下，n&gt;=20。也就是说，当1、2号选择了20或21颗的时候，3号只要选择20颗，就可以保证自己活下来。    </p>
<p>​     这样一来剩下的豆子只剩39颗，4、5号至少有一人少于20颗的（这个人当然是后选的5号），这样死的将是5号和1、2号中选21颗的那个人。当然，1号、2号肯定不会有人选择21这一“倒霉”的数字（因为他们都是聪明人），这样的话，上述“特殊情况（即3号选择n）”就不会发生了。    </p>
<p>​     综上所述，2345这四个人不难从剩下的豆子数知道前面几个人的数量总和，也就不难进而计算出n的值，而这样一来他们也只有n或者n+1这两种选择。最后的5号也是不难算出n的。在前4个人只选择了2个数字(n和n+1)的情况下，5号已是必死无疑，这时,根据“死也要拉几个垫背”的条件，5号会选择n或n+1，选择5个人一起完蛋。    </p>
<p>​<br>​    </p>
<p>​     情况二，如果2号选择了与1号不一样多的话，最终结果是5个人一起死，那么2号只有选择与1号一样多了。    </p>
<p>​     那么1、2号的和就是2n，而3号如果选择n+1或者n -1的话，就又回到第一点的情况去了(前3个人的和是3m+1或3m+2)，于是3号也只能选择n ，当然，4号还是只能选n，最后的结果仍旧是5个人一起完蛋。    </p>
<p>​<br>​    </p>
<p>​     “最后处死抓的最多和最少的囚犯”严格执行这句话的话，除非有人舍己为人，死二留三。但这是足够聪明且自私的囚犯，所以这五个聪明人的下场是全死，这道题只不过是找了一个处死所有人的借口罢了. . . . . .    </p>
<p>​<br>​    </p>
<p>​     变种问题：如果每个囚犯都知道其他囚犯足够聪明，事情会怎么发展？    </p>
<p>​     答案：    </p>
<p>​     这样的情况下囚犯一也会像我们一样推导出前面的结论，那么根据自私的规定，他会直接拿完100个，大家一起完蛋(反正结局已定)    </p>
<h2 id="13-学生猜生日-lt-笔试高频-gt"><a href="#13-学生猜生日-lt-笔试高频-gt" class="headerlink" title="13. 学生猜生日&lt;笔试高频&gt;"></a><strong>13. 学生猜生日&lt;笔试高频&gt;</strong></h2><p>   这种题目笔试中出现的次数比较多，用排除法比较好解决  </p>
<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>   小明和小强都是张老师的学生，张老师的生日是M月N日,  </p>
<p>   2人都知道张老师的生日是下列10组中的一天，张老师把M值告诉了小明,  </p>
<p>   把N值告诉了小强，张老师问他们知道他的生日是那一天吗?  </p>
<p>   3月4日 3月5日 3月8日  </p>
<p>   6月4日 6月7日  </p>
<p>   9月1日 9月5日  </p>
<p>   12月1日 12月2日 12月8日  </p>
<p>   小明说:如果我不知道的话，小强肯定也不知道.  </p>
<p>   小强说:本来我也不知道，但是现在我知道了.  </p>
<p>   小明说:哦，那我也知道了.  </p>
<p>   请根据以上对话推断出张老师的生日是哪一天?  </p>
<p>   答案：9月1日  </p>
<p>   排除法：  </p>
<p>   1.小明肯定小强不知道是哪天，排除所有月份里有单独日的月份：6月和12月&lt;因为如果小强的M是2或者7的话，小强就知道了，所以把6月7日与12月2日排除&gt;，所以小明拿到的是3或者9  </p>
<p>   2.小强本来不知道，所以小强拿到的不是2或者7，但是小强现在知道了，说明把6月与12月排除后，小强拿到的是1,4,8中的一个&lt;这里小强肯定没拿到5，否则他不会知道是哪天的&gt;  </p>
<p>   3.小明现在也知道了，说明小明拿到的不是3，否则他不会知道是3月4日还是3月8日的，所以小明拿到的是9才能唯一确定生日  </p>
<p>   综上，答案是9月1日  </p>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.</h3><p>   小明和小强是赵老师的学生，张老师的生日是M月N日，张老师  </p>
<p>   把M值告诉小明，N值告诉小强  </p>
<p>   给他们六个选项  </p>
<p>   3月1日 3月3日 7月3日 7月5日   </p>
<p>   9月1日 11月7日  </p>
<p>   小明说:我猜不出来  </p>
<p>   小强说:本来我也猜不出来，但是现在我知道了  </p>
<p>   问:张老师生日多少  </p>
<p>   答案：3月1日  </p>
<p>   排除法：  </p>
<p>   1.小明说猜不出来，说明小明拿到的不是单独出现的9或者11，说明老师生日只能是3月或者7月  </p>
<p>   2.小强原本不知道，说明小强拿到的不是单独出现的5或者7，说明老是生日是1日或3日  </p>
<p>   3.小强现在知道了，说明小强拿到的是1，因为如果拿到的是3，那么小强就不知道是3月3日还是7月3日了  </p>
<p>   综上，老师生日是3月1日</p>
<p>作者：代码不规范，测试两行泪<br>链接：<a href="https://www.nowcoder.com/discuss/262595" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/262595</a><br>来源：牛客网</p>
]]></content>
      <categories>
        <category>逻辑思维</category>
      </categories>
  </entry>
  <entry>
    <title>深入浅出RPC原理</title>
    <url>/2020/06/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARPC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>远程过程调用(Remote Procedure Call，简称RPC)，在微服务大行其道的今天，得到了广泛的应用。因此，在分布式系统服务群中开发应用，了解RPC一些原理和实现架构，还是很有必要的。本文，将从大的框架层面来聊聊RPC原理和实现。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>远程过程调用RPC，就是客户端基于某种传输协议通过网络向服务提供端请求服务处理，然后获取返回数据(对于ONE WAY模式则不返还响应结果)；而这种调用对于客户端而言，和调用本地服务一样方便，开发人员不需要了解具体底层网络传输协议。简单讲，就是本地调用的逻辑处理的过程放在的远程的机器上，而不是本地服务代理来处理。</p>
<p>目前，Java界的RPC中间件百家争鸣，国内开源的就有阿里的Dubbo(当当二次开发的DubboX)，新浪Motan；国外跨语言的有Facebook的Thrift， Google的gRpc等。</p>
<h2 id="LPC-amp-IPC"><a href="#LPC-amp-IPC" class="headerlink" title="LPC &amp; IPC"></a>LPC &amp; IPC</h2><p>既然存在RPC这种远程过程调用，必然会有与之对应的本地过程调用了。本地过程调用在不同的操作系统中，叫法不同，使用方式也不太一样。在Windows编程中，称为LPC；在linux编程中，更习惯称之为IPC，即进程间通信。</p>
<p>但是，不管如何，其本质上就是本地机器上的不同进程之间通信协作的调用方式。</p>
<p>服务端开发，一般我们基于Linux，所以这里简单介绍下Linux环境下 IPC实现方式：</p>
<ul>
<li>管道</li>
<li>共享内存</li>
<li>信号量</li>
<li>Socket套接字</li>
</ul>
<p>除此之外，还有消息队列和信号两种实现进程间通信的方式。</p>
<p>信号很容易理解，比如我们在控制台输入的<code>CTRL + C</code>来向执行的进程发送kill信号来结束该进程。对于信号，一般我们再终端交互窗口中使用比较多，在服务端开发中很少涉及。</p>
<p>Linux提供的消息队列和各种分布式MQ不同，它是在内核中使用链表结构来保持消息的队列，然后其他进程从内核的消息队列中获取消息。目前，Linux官方不太推荐使用，将渐渐被淘汰。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道命令，在我们的<code>linux shell</code>中经常使用，一般，我们使用<code>|</code>操作符来保证两个命令之间的数据通信。比如，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep java | xargs echo</span><br></pre></td></tr></table></figure>

<p>管道命令，其实内部实现就是使用的linux管道接口，每个命令其实是一个进程，各个进程的标准输出STDOUT，作为下一个进程的标准输入STDIN。</p>
<p>Linux管道包含：匿名管道和命名管道。</p>
<ul>
<li><p>匿名管道：只能父子进程间通信。使用pipe()方法来创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int pipe(int filedis[2]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数filedis返回两个文件描述符：filedes[0]为读而打开，filedes[1]为写而打开。filedes[1]的输出是filedes[0]的输入</p>
</blockquote>
</li>
<li><p>命名管道：可以在单台机器内的任何一组进程间进行通信。一般我们使用mkfifo()来创建命名管道：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname,<span class="keyword">mode_t</span> mode)</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>成功返回0，失败返回-1。成功返回之后，pathname其实就可以看着一个管道文件操作(当然并没有真实文件在磁盘存在)，对于文件操作的方法例如open,read,write都适用于fifo命名通道。</p>
</blockquote>
</li>
</ul>
<h3 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h3><p>Linux中的信号量和Java中的信号量一样，其主要用处是同步协作。</p>
<p>信号量其实就是一个比较特殊的变量，然后对它的操作都是原子进行的，并且一般只提供两种方法：P和V操作(在java中为wait()和notify())。</p>
<ul>
<li>P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行；</li>
<li>V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1。</li>
</ul>
<p>linux对外提供的API接口方法如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct sem &#123;</span><br><span class="line">  short sempid;&#x2F;* pid of last operaton *&#x2F;</span><br><span class="line">  ushort semval;&#x2F;* current value *&#x2F;</span><br><span class="line">  ushort semncnt;&#x2F;* num procs awaiting increase in semval *&#x2F;</span><br><span class="line">  ushort semzcnt;&#x2F;* num procs awaiting semval &#x3D; 0 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">　　 #include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">　　 #include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">　　 #include &lt;sys&#x2F;sem.h&gt;</span><br><span class="line">&#x2F;&#x2F;首先获取一个信号量,只有该方法可以才能直接使用key，其他方法必须先semget然后才能使用信号量</span><br><span class="line">　　 int semget(key_t key, int nsems, int flag);</span><br><span class="line">&#x2F;&#x2F;对信号量进行操作，直接控制信号量信息，比如删除信号量</span><br><span class="line">int semctl(int semid, int semnum, int cmd, union semun arg);</span><br><span class="line">&#x2F;&#x2F;改变信号量的值，P,V操作都是通过该方法</span><br><span class="line">int semop(int sem_id, struct sembuf *sem_opa, size_t num_sem_ops);</span><br></pre></td></tr></table></figure>

<p>信号量的主要作用就是同步，所以我们一般是使用共享内存方式完成进程间通信，而在此过程中通过信号量来完成多进程间的同步协调机制。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>由于同一台机器的硬件设备一般对于同一个系统来说，都是共享的。所以使用内存来完成进程间通信开发的思路，必然是很容易想到的，但是未必容易做到。</p>
<p>众所周知，进程和线程最大的区别就是一些资源是否隔离。也就是说，不同的进程，其内存资源使用是隔离独立的，每个进程有自己的一套内存地址映射逻辑，也即是系统是无法直接从不同进程的相同虚拟内存地址找到共同的物理内存地址的，这样，就无法像线程一样，简单把数据对象设置为<code>static</code>然后线程间就可以共享获取了。</p>
<p>因此，Linux对外提供了共享内存的方法来完成进程间通信。</p>
<p>共享内存是最有效的进程间通信方式。其对外提供的API如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">　   #include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">　　 #include &lt;sys&#x2F;shm.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建共享内存空间，大小为size</span><br><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line">&#x2F;&#x2F;所有需要使用共享内存通信的进程，映射到自身的内存地址空间中</span><br><span class="line">void *shmat(int shmid, void *addr, int flag);</span><br><span class="line">&#x2F;&#x2F;从当前进程地址空间中分离该共享内存</span><br><span class="line">int shmdt(const void *shmaddr);</span><br><span class="line">&#x2F;&#x2F;控制共享内存的，比如删除该共享内存空间等</span><br><span class="line">int shmctl(int shm_id, int command, struct shmid_ds *buf);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上面的方法可以很显然的看出，进程间的内存地址空间是独立隔离的(内核地址空间由于虚拟地址和物理地址是一致的，所以在进程间这块地址空间也是一致的，不过我们操作的都是用户空间的内存，所以不考虑这块)。当我们想要共享操作，必须要把物理内存分别绑定到对应进程的地址空间，才能共享操作。</p>
<p>使用的时候，很简单。<code>shmat</code>方法返回一个<code>void *</code>就可以强转某个指定的struct，然后直接操作该对象结构体即可。由于共享，所以需要考虑多线程同步安全问题。</p>
</blockquote>
<h3 id="Socket套接字"><a href="#Socket套接字" class="headerlink" title="Socket套接字"></a>Socket套接字</h3><p>从上面的几个API方法可以看到都是利用单机同用一套资源，然后各自进程的资源之间通过内核方式或者内存方式协作完成单机多进程间通信。</p>
<p>此外，还有一种方式来完成进程间通信，就是套接字socket。Socket一般情况下是用在不同的两台机器的不同进程之间通信的，当Socket创建时的类型为 <code>AF_LOCAL或AF_UNIX</code>时，则是本地进程通信了(当然你也可以直接使用网络套接字，如果你觉得走下网络更酷，或者以后便于服务分离)。</p>
<p>关于Socket的API介绍，这里就省略了。服务端/客户端模式的介绍和示例相对很常见，也很容易开发和理解。</p>
<p>从使用网络套接字Socket来实现进程间通信这个角度来说，其和RPC并没有什么不同了，所以有些文献分类时，说广义来讲RPC也应该包括LPC(IPC),因为从大的来讲，单机进程通信其实算是远程过程调用的一种特殊简化的方式而已。</p>
<p>当然，本文还是觉得还是区别开比较通用，也便于理解。</p>
<blockquote>
<p>如在Socket介绍的那样，本地过程调用很多情况下都是依赖操作系统对外提供的API来协调操作某个共享资源来完成进程间的数据交换。</p>
<p>如果不依赖单机共享资源，就只有Socket接口。因此，如果要扩展到分布式环境下的进程间通信，那就只能使用网络套接字来完成。</p>
</blockquote>
<p>说完单机的服务调用，在互联网时代，自然要讲web服务(Web Service)了。</p>
<h2 id="Web-Service技术"><a href="#Web-Service技术" class="headerlink" title="Web Service技术"></a>Web Service技术</h2><blockquote>
<p><code>Web Service</code>一般有两种定义：</p>
<ol>
<li>特指 W3C组织制定的<code>web service</code>规范技术。其包括SOAP(一个基于XML的可扩展消息信封格式，需同时绑定一个网络传输协议。这个协议通常是HTTP或HTTPS，但也可能是SMTP或XMPP)、WSDL(一个XML格式文档，用以描述服务端口访问方式和使用协议的细节。通常用来辅助生成服务器和客户端代码及配置信息)和UDDI(一个用来发布和搜索WEB服务的协议，应用程序可借由此协议在设计或运行时找到目标WEB服务)。从上面三个定义就可以看出，这种规范技术是一个重量级的协议。</li>
<li>泛指网络系统对外提供web服务所使用的技术。这里，我们主要是基于该定义来理解。</li>
</ol>
</blockquote>
<p>一般而言，技术体系，必然是服务于架构体系的。不同的架构，所约定的技术结构设计还是有些区别的。</p>
<p>因此，要了解web服务技术，必然要先了解其服务于哪个架构体系；也就是说，先去了解技术产生的架构背景。</p>
<h3 id="SOA-amp-微服务"><a href="#SOA-amp-微服务" class="headerlink" title="SOA &amp; 微服务"></a>SOA &amp; 微服务</h3><p>在分布式网络服务架构体系中，最火的莫过于 SOA(面向服务架构，Service-Oriented Architecture)和微服务。</p>
<p>嗯，一般将服务化架构，必然会扯到<code>全家桶</code>设计升级的故事。</p>
<p>简化版是这样子的：</p>
<ul>
<li>在很久很久以前，网络应用也是单机部署的，所有的业务代码全部都在一个大项目内，然后更改一个逻辑就需要重启部署应用，停止对外服务。</li>
<li>然后，这样子肯定不行的，就有了多机部署，通过Nginx或者其他代理/均衡软件来分发请求到相同服务的不同机器上，当其中一台机器停机部署时，请求全部打到其他机器上去。但是这个时候，所有机器上的代码还是一套。</li>
<li>后来，机器不断升级，但是业务不断变多，项目代码越来越大，更改一个地方编译打包部署时间非常长，于是，我们就把一些独立隔离开的业务代码分成多个项目。但是，实现业务逻辑的时候，必然有一些功能和数据是多个业务都会用到的，简单以前的代码copy过来，数据就直接操作数据库。但是，当有个公用的功能需要更改时，就发现所有相关业务都需要更改，并且数据库上的操作，还会带来其他同步兼容等等问题。</li>
<li>于是，就出现了SOA，也就是基于服务的架构设计理念。SOA的设计理念，就是把所有的服务都对外以HTTP或者其他协议方式对外暴露，绝对<code>不允许</code>相同的服务在不同的业务系统独立一套，然后共用底层数据库。服务化的设计系统，所有拆分的业务，彼此之间都通过暴露的服务接口通信，操作对方的数据。这样，各个业务系统之间开始独立自主的向着美好的方向发展了。</li>
<li>再后来，单个业务发展的越来越好，提供的功能也越来越多，这样一个业务系统的代码也变得很大了，开发人员也越来越多。于是乎，单个业务系统内部就存在问题了，当然，我们也可以拆分成不同的业务系统来开发发展。但是，单个业务系统，很多的公用逻辑都是一些业务细节，并不好独立成业务系统；此外，单个业务系统开发人员都很容易交流，因此，对于内部业务系统的架构设计，就出现了<code>微服务Micro-Service</code>了。我们把单个业务系统中一些功能细节的结构封装成服务，大的对外业务系统，组装各个微服务的接口数据，然后提供SOA服务。</li>
</ul>
<p>因此，SOA其实和微服务，从我的视角来看，其实就是 业务外部和内部服务的不同架构设计而已，其技术框架很大程度上都可以通用。其区别如下图：</p>
<p><img src="https://ketao1989.github.io/images/2016/12/soa_ms.jpg" alt="SOA和微服务"></p>
<p>从上面发展历程可以看到，SOA一般使用SOAP或者REST方式来提供服务，这样外部业务系统可以使用通用网络协议来处理请求和响应，而微服务，还可以有一些私有的协议方式来提供服务，例如基于自定义协议的RPC框架。RPC使得调用服务简单，但是需要一些其他耗时间的交流协调工作，这适合微服务的场景，但是不一定适合SOA场景了。</p>
<h3 id="web服务技术结构"><a href="#web服务技术结构" class="headerlink" title="web服务技术结构"></a>web服务技术结构</h3><p>先给出一个web服务的技术体系结构图：</p>
<p><img src="https://ketao1989.github.io/images/2016/12/web_service.png" alt="web服务技术体系"></p>
<p><code>web service</code>被W3C设立规范之初，SOAP方案就被提出来。但是，随着服务化技术和架构的发展，SOAP多少有点过于复杂，因此就出现了简化版的REST方案。此后，由于分布式服务应用越来越大，对性能和易用性上面要求越来越大，因此就出现了RPC框架(很多时候，RPC并不被当做一种web service方案。在绝大部分博客中，介绍web service 只会讨论 SOAP和REST，主要是其基本上都是基于SOA来介绍服务方案)。</p>
<h4 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h4><p>SOAP，全称为 Simple Object Access Protocol，也就是 简单对象访问协议。跟着<code>web service</code>一起出来的，说明历史悠久，不过感觉现在也慢慢要淘汰了。</p>
<p>SOAP，是基于XML数据格式来交换数据的；其内部定义了一套复杂完善的XML标签，标签中包含了调用的远程过程、参数、返回值和出错信息等等，通信双方根据这套标签来解析数据或者请求服务。与SOAP相关的配套协议是WSDL (Web Service Description Language)，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，类似我们现在聊服务治理中的服务发现功能。</p>
<p>因此，SOAP服务整体流程是：首先，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。</p>
<h4 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h4><p>REST，全称 REpresentational State Transfort，也就是 表示性状态转移。由于SOAP方案过于庞大复杂，在很多简单的web服务应用场景中，轻量级的REST就出现替代SOAP方案了。</p>
<p>和SOAP相比，REST只是对URI做了一些规范，数据才有JSON格式，底层传输使用HTTP/HTTPS来通信，因此，所有web服务器都可以快速支持该方案；开发人员也可以快速学习和使用。</p>
<h4 id="SOAP-amp-REST"><a href="#SOAP-amp-REST" class="headerlink" title="SOAP &amp; REST"></a>SOAP &amp; REST</h4><p>从命名来看，SOAP是一种协议，而REST只是一种方案。协议的设计很多时候，从上而下一整套都是新的，需要设计开发专门的工具支持；而方案相对就是基于目前以后的工具来做一些设计和约束，这就是为什么REST快速替换了SOAP的地位。</p>
<p>REST特点：</p>
<ul>
<li>由于数据返回格式是自定义的，绝大部分使用JSON，这种数据结构节省带宽，并且前端JavaScript能天生支持。</li>
<li>无状态，基于HTTP协议，所以只能适应无状态场景。</li>
</ul>
<p>SOAP特点：</p>
<ul>
<li>协议有安全性的一些规范。</li>
<li>基于xml的标签约束，而且也不要去底层是HTTP传输，所以支持有状态的场景。</li>
</ul>
<h3 id="RPC家族"><a href="#RPC家族" class="headerlink" title="RPC家族"></a>RPC家族</h3><p>RPC家族中，RMI是Java制定的远程通信协议。而后，基本上RPC框架都或多或少有RMI的影子(当然，其实主要是RPC本身的实现方式就是这样子了-_-)。RMI既然是Java的标准RPC组件，那必然其他编程语言就无法使用了；因此，Thrift这种基于IDL来跨语言的RPC组件就出现了。Thrift的使用者，只需要按照Thrift官方规定的方式来写API结构，然后生成对应语言的API接口，继而就可以跨语言完成远程过程调用了。但是，作为服务化的组件，如果没有服务治理来完成大规模应用集群中服务调用管理工作，则运维工作则是非常繁重的，因此类似dubbo这种包含服务治理的RPC组件出现了。</p>
<p>下面，就来介绍RPC组件。</p>
<h2 id="RPC介绍"><a href="#RPC介绍" class="headerlink" title="RPC介绍"></a>RPC介绍</h2><blockquote>
<p>RMI作为Java自带的官方RPC组件，单独介绍；然后我们来看看通用RPC实现结构。</p>
</blockquote>
<h3 id="RMI介绍"><a href="#RMI介绍" class="headerlink" title="RMI介绍"></a>RMI介绍</h3><p>RMI，全称是Remote Method Invocation，也就是远程方法调用。在JDK 1.2的时候，引入到Java体系的。当应用比较小，性能要求不高的情况下，使用RMI还是挺方便快捷的。</p>
<p>下面先看看RMI的调用流程。</p>
<p><img src="https://ketao1989.github.io/images/2016/12/rmi.png" alt="RMI服务调用流程"></p>
<p>其中，有些概念需要说明：</p>
<blockquote>
<p>stub(桩)：stub实际上就是远程过程在客户端上面的一个代理proxy。当我们的客户端代码调用API接口提供的方法的时候，RMI生成的stub代码块会将请求数据序列化，交给远程服务端处理，然后将结果反序列化之后返回给客户端的代码。这些处理过程，对于客户端来说，基本是透明无感知的。</p>
<p>remote：这层就是底层网络处理了，RMI对用户来说，屏蔽了这层细节。stub通过remote来和远程服务端进行通信。</p>
<p>skeleton(骨架)：和stub相似，skeleton则是服务端生成的一个代理proxy。当客户端通过stub发送请求到服务端，则交给skeleton来处理，其会根据指定的服务方法来反序列化请求，然后调用具体方法执行，最后将结果返回给客户端。</p>
<p>registry(服务发现)：rmi服务，在服务端实现之后需要注册到rmi server上，然后客户端从指定的rmi地址上lookup服务，调用该服务对应的方法即可完成远程方法调用。registry是个很重要的功能，当服务端开发完服务之后，要对外暴露，如果没有服务注册，则客户端是无从调用的，即使服务端的服务就在那里。</p>
</blockquote>
<p>下面给出一个简单的Java示例来show code下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口必须继承RMI的Remote</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RmiService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须有RemoteException，才是RMI方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UnicastRemoteObject会生成一个代理proxy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmiServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">RmiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RmiServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端server启动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmiServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RmiService service = <span class="keyword">new</span> RmiServiceImpl();</span><br><span class="line">            <span class="comment">//在本地创建和暴露一个注册服务实例，端口为9999</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">//注册service服务到上面创建的注册实例上</span></span><br><span class="line">            Naming.rebind(<span class="string">"rmi://127.0.0.1:9999/service1"</span>,service);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"------------server start-----------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端调用rmi服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmiClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据注册的服务地址来查找服务，然后就可以调用API对应的方法了</span></span><br><span class="line">            RmiService service = (RmiService)Naming.lookup(<span class="string">"rmi://localhost:9999/service1"</span>);</span><br><span class="line">            System.out.println(service.hello(<span class="string">"RMI"</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面一些核心的代码已经在注释中给了说明。</p>
</blockquote>
<h3 id="通用RPC架构"><a href="#通用RPC架构" class="headerlink" title="通用RPC架构"></a>通用RPC架构</h3><p>一般，远程过程调用RPC就是本地动态代理隐藏通信细节，通过组件序列化请求，走网络到服务端，执行真正的服务代码，然后将结果返回给客户端，反序列化数据给调用方法的过程。</p>
<p>RPC具体调用流程如下所示： <img src="https://ketao1989.github.io/images/2016/12/rpc.png" alt="RPC调用流程"></p>
<p>通用的RPC组件一般包括以下一些模块：</p>
<blockquote>
<ol>
<li>serviceClient：这个模块主要是封装服务端对外提供的API，让客户端像使用本地API接口一样调用远程服务。一般，我们使用动态代理机制，当客户端调用api的方法时，serviceClient会走代理逻辑，去远程服务器请求真正的执行方法，然后将响应结果作为本地的api方法执行结果返回给客户端应用。类似RMI的stub模块。</li>
<li>processor：在服务端存在很多方法，当客户端请求过来，服务端需要定位到具体对象的具体方法，然后执行该方法，这个功能就由processor模块来完成。一般这个操作需要使用反射机制来获取用来执行真实处理逻辑的方法，当然，有的RPC直接在server初始化的时候，将一定规则写进Map映射中，这样直接获取对象即可。类似RMI的skeleton模块。</li>
<li>protocol：协议层，这是每个RPC组件的核心技术所在。一般，协议层包括编码/解码，或者说序列化和反序列化工作；当然，有的时候编解码不仅仅是对象序列化的工作，还有一些通信相关的字节流的额外解析部分。序列化工具有：hessian，protobuf，avro,thrift，json系，xml系等等。在RMI中这块是直接使用JDK自身的序列化组件。</li>
<li>transport：传输层，主要是服务端和客户端网络通信相关的功能。这里和下面的IO层区分开，主要是因为传输层处理server/client的网络通信交互，而不涉及具体底层处理连接请求和响应相关的逻辑。</li>
<li>I/O：这个模块主要是为了提高性能可能采用不同的IO模型和线程模型，当然，一般我们可能和上面的transport层联系的比较紧密，统一称为remote模块。</li>
</ol>
</blockquote>
<p>此外，还有业务代码自己去实现的client和server层。client当需要远程调用服务时，会首先初始化一个API接口代理对象，然后调用某个代理方法。server在对外暴露服务时，需要首先实现对应API接口内部的方法，当请求过来时，通过反射找到对应的实例对象，执行对应的业务代码。</p>
<h3 id="简单RPC组件实现"><a href="#简单RPC组件实现" class="headerlink" title="简单RPC组件实现"></a>简单RPC组件实现</h3><p>介绍完RPC相关结构和概念之后，给一个简单的RPC组件示例来对各个模块进行code级别的说明。</p>
<blockquote>
<p>以下代码仅仅是了解RPC各个模块功能的示例，对性能和异常等情况未考虑全面，生产环境不适用。</p>
</blockquote>
<h4 id="protocol模块代码"><a href="#protocol模块代码" class="headerlink" title="protocol模块代码"></a>protocol模块代码</h4><blockquote>
<p>协议层主要包括编解码和序列化部分。编解码就是我们对传输通信的远程调用请求接口和方法参数等数据按照我们规定的格式进行组装编码，然后在接收的一方负责把数据解码成原始的对象，然后找到需要执行的接口和方法。序列化/反序列化，则是将数据对象，按照一定的映射关系转换成字节流，供网络传输，接收的一方首先将流映射为对象数据。</p>
<p>有的时候，序列化/反序列化组件会包含编解码部分。此外，编解码和序列化工作先后关系也不一定。一般高性能RPC，序列化工具十分强大和通用，所以编解码部分会放在序列化之后，主要是解码的时候，可以不完成反序列化就对流进行一些处理工作，比如映射、分发等。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 很明显，这里使用JSON来序列化和反序列化RPC调用传递的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ServiceProtocol protocol = <span class="keyword">new</span> ServiceProtocol();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将对象序列化为字符串字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encode(Object o) &#123;</span><br><span class="line">        <span class="keyword">return</span> JsonUtils.encode(o).getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化成字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">decode</span><span class="params">(<span class="keyword">byte</span>[] data, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JsonUtils.decode(<span class="keyword">new</span> String(data), clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编解码模型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolModel</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String clazz;</span><br><span class="line">        <span class="keyword">private</span> String method;</span><br><span class="line">        <span class="keyword">private</span> String[] argTypes;</span><br><span class="line">        <span class="keyword">private</span> Object[] args;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// setter getter方法省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例中的代码使用JSON来序列化/反序列化工作。由于JSON序列化组件比较弱，所以这边需要将执行调用方法相关的请求数据进行编码成<code>ProtocolModel</code>对象。</p>
<h4 id="remote模块代码"><a href="#remote模块代码" class="headerlink" title="remote模块代码"></a>remote模块代码</h4><blockquote>
<p>remote模块是提供服务端和客户端通信的功能。因此，在服务端需要起一个端口来监听外部的请求，在客户端则负责发送请求，接收响应数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端通信组件，客户端和外部服务端数据交互时使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientRemoter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ClientRemoter client = <span class="keyword">new</span> ClientRemoter();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">byte</span>[] getDataRemote(<span class="keyword">byte</span>[] requestData) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket()) &#123;</span><br><span class="line">             socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">9999</span>));</span><br><span class="line">             socket.getOutputStream().write(requestData);</span><br><span class="line">             socket.getOutputStream().flush();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10240</span>];</span><br><span class="line">             <span class="keyword">int</span> len = socket.getInputStream().read(data);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> Arrays.copyOfRange(data, <span class="number">0</span>, len);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端起一个端口监听服务，绑定到相关processor处理器上。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerRemoter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executor =</span><br><span class="line">        Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ServerSocket server = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        System.out.println(<span class="string">"-----------start server----------------"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> Socket socket = server.accept();</span><br><span class="line">                executor.execute(<span class="keyword">new</span> MyRunnable(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            server.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> (InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10240</span>];</span><br><span class="line">                <span class="keyword">int</span> len = is.read(data);</span><br><span class="line"></span><br><span class="line">                ServiceProtocol.ProtocolModel model = ServiceProtocol.protocol</span><br><span class="line">                    .decode(Arrays.copyOfRange(data, <span class="number">0</span>, len), ServiceProtocol.ProtocolModel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                Object object = ServiceProcessor.processor.process(model);</span><br><span class="line">                os.write(ServiceProtocol.protocol.encode(object));</span><br><span class="line">                os.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// close socket...</span></span><br><span class="line">           &#125;        &#125;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>简单处理，直接让网络一次获取所有的数据，假设一次请求和响应的数据大小小于10K。</p>
<p>在server端的remote中，启动服务之前是需要绑定对外提供的服务的，也就是服务server启动，其内部需要指定序列化、服务处理器等逻辑。</p>
</blockquote>
<p>通用RPC的通信层，是非常复杂的，其需要考虑各种网络环境导致的数据半包，分包和粘包情况，需要考虑高性能NIO组件，多线程处理超时，连接复用等等。</p>
<h4 id="processor模块代码"><a href="#processor模块代码" class="headerlink" title="processor模块代码"></a>processor模块代码</h4><blockquote>
<p>服务端接口方法定位处理器。作为一个组件，显然不应该在业务代码中嵌入一些非业务逻辑。processor会根据序列化完了之后的请求数据来定位具体的处理逻辑，然后调用对应的业务代码来处理获取返回结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ServiceProcessor &#123;</span><br><span class="line"></span><br><span class="line">    public static final ServiceProcessor processor &#x3D; new ServiceProcessor();</span><br><span class="line"></span><br><span class="line">    private static final ConcurrentMap&lt;String, Object&gt; PROCESSOR_INSTANCE_MAP &#x3D; new ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public boolean publish(Class clazz, Object obj) &#123;</span><br><span class="line">        return PROCESSOR_INSTANCE_MAP.putIfAbsent(clazz.getName(), obj) !&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object process(ServiceProtocol.ProtocolModel model) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz &#x3D; Class.forName(model.getClazz());</span><br><span class="line"></span><br><span class="line">            Class[] types &#x3D; new Class[model.getArgTypes().length];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; types.length; i++) &#123;</span><br><span class="line">                types[i] &#x3D; Class.forName(model.getArgTypes()[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Method method &#x3D; clazz.getMethod(model.getMethod(), types);</span><br><span class="line"></span><br><span class="line">            Object obj &#x3D; PROCESSOR_INSTANCE_MAP.get(model.getClazz());</span><br><span class="line">            if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return method.invoke(obj, model.getArgs());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PROCESSOR_INSTANCE_MAP publish这个逻辑，在Spring环境中，一般通过xml配置自动注入进来，然后从context中获取对应的实例。但是，不管怎样，底层其实都是一个map来维护映射关系。</p>
</blockquote>
<p>如上文介绍的那样，经过解码获取到的调用对象，然后通过java反射机制，执行指定的方法获取结果。</p>
<h4 id="serviceClient模块代码"><a href="#serviceClient模块代码" class="headerlink" title="serviceClient模块代码"></a>serviceClient模块代码</h4><blockquote>
<p>其实，这块叫做serviceProxyClient比较直接点。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ServiceProxyClient &#123;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T getInstance(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return (T) Proxy.newProxyInstance(clazz.getClassLoader(), new Class[] &#123;clazz&#125;, new ServiceProxy(clazz));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class ServiceProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">        private Class clazz;</span><br><span class="line"></span><br><span class="line">        public ServiceProxy(Class clazz) &#123;</span><br><span class="line">            this.clazz &#x3D; clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">            ServiceProtocol.ProtocolModel model &#x3D; new ServiceProtocol.ProtocolModel();</span><br><span class="line">            model.setClazz(clazz.getName());</span><br><span class="line">            model.setMethod(method.getName());</span><br><span class="line">            model.setArgs(args);</span><br><span class="line"></span><br><span class="line">            String[] argType &#x3D; new String[method.getParameterTypes().length];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; argType.length; i++) &#123;</span><br><span class="line">                argType[i] &#x3D; method.getParameterTypes()[i].getName();</span><br><span class="line">            &#125;</span><br><span class="line">            model.setArgTypes(argType);</span><br><span class="line"></span><br><span class="line">            byte[] req &#x3D; ServiceProtocol.protocol.encode(model);</span><br><span class="line">            byte[] rsp &#x3D; ClientRemoter.client.getDataRemote(req);</span><br><span class="line">            return ServiceProtocol.protocol.decode(rsp, method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ProxyClient</code>就是对客户端调用API时透明化底层序列化和网络操作相关细节。所以，在proxyClient内部，我们可以看到它封装代理了这块调用逻辑，业务代码直接使用<code>getInstance</code>方法就可以获取对象实例，然后按照正常使用api方法来执行调用逻辑，获取结果。</p>
<blockquote>
<p>如果使用spring框架的话，可以进一步封装成一个bean，然后客户端业务代码只需要在xml中配置一下，就可以通过注解annotation等方式注入进来。</p>
</blockquote>
<h4 id="server业务接口实现代码"><a href="#server业务接口实现代码" class="headerlink" title="server业务接口实现代码"></a>server业务接口实现代码</h4><blockquote>
<p>这里给出接口对外发布和测试</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface RpcService &#123;</span><br><span class="line">    String sayHi(String name);</span><br><span class="line">&#125;</span><br><span class="line">public class RpcServiceImpl implements RpcService &#123;</span><br><span class="line">    public String sayHi(String name) &#123;</span><br><span class="line">        return &quot;Hello,&quot; + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 服务端测试main执行代码</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ServerDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 发布接口</span><br><span class="line">        ServiceProcessor.processor.publish(RpcService.class,new RpcServiceImpl());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 启动server</span><br><span class="line">        ServerRemoter remoter &#x3D; new ServerRemoter();</span><br><span class="line">        remoter.startServer(9999);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上，我们构造了一个<code>RpcService</code>接口对外提供sayHi的服务。在main方法中，我们首先需要对外发布这个接口和对应的实现类对象。在一些框架中，这些对外暴露的接口，都是通过xml配置或者annotation来发布的。然后，我们就可以启动server服务，对外提供RPC服务。</p>
</blockquote>
<h4 id="6-client调用测试代码"><a href="#6-client调用测试代码" class="headerlink" title="6. client调用测试代码"></a>6. client调用测试代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ClientDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;----------start invoke----------------&quot;);</span><br><span class="line">        RpcService service &#x3D; ServiceProxyClient.getInstance(RpcService.class);</span><br><span class="line">        System.out.println(service.sayHi(&quot;RPC World&quot;));</span><br><span class="line">        System.out.println(&quot;----------end invoke----------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看我们的测试代码非常简单，当要远程调用某个接口方法时，只需要getInstance该接口类代理对象，然后就像调用本地方法一直执行方法执行和结果处理。</p>
</blockquote>
<h2 id="RPC技术深入"><a href="#RPC技术深入" class="headerlink" title="RPC技术深入"></a>RPC技术深入</h2><p>上文简单的介绍了RPC模块各个部分，并且实现了一个简单的RPC组件。这一部分，我们要介绍在生产环节下RPC需要使用的一些技术点。</p>
<h3 id="RPC序列化"><a href="#RPC序列化" class="headerlink" title="RPC序列化"></a>RPC序列化</h3><blockquote>
<p>将RPC序列化和编解码分开，是因为个人觉得，虽然在很多时候，编解码其实就是序列化操作，但是有的时候，我们会自定义一些数据结构来封装业务数据对象，然后再序列化成二进制流。此外，在协议层，我们可能也会对普通序列化完了之后，还会对传输头进行编码工作。因此，为了更好的说明，这里分开来。</p>
</blockquote>
<p>序列化，说的简单，就是将对象转换成二进制流，也就是<code>byte[]</code>，而反序列化就是讲二进制流转换成对象。使用序列化/反序列化，主要是我们想把内存对象数据，持久化到文件fd或者通过网络传输到其他地方，而这只能使用二进制流来呈现。此外，由于RPC是通过网络通信的，所以序列化工具的性能和二进制流的大小，都是直接影响整体处理能力的关键因素。</p>
<p>目前基于Java的序列化工具，主要有：</p>
<ul>
<li>JDK Serializable工具</li>
<li>Hessian工具</li>
<li>Kryo工具</li>
<li>JSON工具</li>
</ul>
<h4 id="JDK内置序列化工具"><a href="#JDK内置序列化工具" class="headerlink" title="JDK内置序列化工具"></a>JDK内置序列化工具</h4><p>JDK自带的序列化工作不需要引入任何第三方包就可以直接使用，我们仅仅只需要实现<code>java.io.Serializable</code>接口。然后，我们在需要序列化/反序列化的时候，直接使用<code>ObjectInputStream</code>/<code>ObjectOutStream</code>来readObject将流反序列化成对象或者writeObject将对象序列化成流。</p>
<p>很多时候，我们并不使用原生的JDK序列化工具进行序列化，主要原因是因为其序列化后的二进制流太大，并且序列化耗时也比较长。但是，其最大的优点就是原生支持，快速使用，引入成本低，此外，其支持java所有类型，所以在有些RPC组件中，其作为默认序列化工具。</p>
<blockquote>
<p>使用JDK自带的序列化工具，尤其需要注意<code>serialVersionUID</code>这个静态变量，在反序列化的时候，会根据这个变量来判断两个类是否一样，如果修改了该变量，那么将无法兼容来的二进制数据的反序列化操作。</p>
<p>此外，你可以通过在类中增加writeObject 和 readObject 方法可以实现自定义序列化。</p>
</blockquote>
<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JdkSerialiable &#123;</span><br><span class="line">    public static void serial(Blog blog) throws Exception &#123;</span><br><span class="line">        ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream os &#x3D; new ObjectOutputStream(baos);</span><br><span class="line">        os.writeObject(blog);</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream is &#x3D; new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));</span><br><span class="line">        Blog blog1 &#x3D; (Blog) is.readObject();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(blog1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Hessian工具"><a href="#Hessian工具" class="headerlink" title="Hessian工具"></a>Hessian工具</h4><p>Hessian,其实是一个开源的轻量级RPC组件。从上面分析RPC通用结构，可以看到很多RPC为了性能会自己实现序列化/反序列化工具，比如Thrift，而hessian也是如此。hessian2的性能相对JDK来说，提高了很多，而且序列化完了之后的流也小了很多。由于hessian已经生产实践了很长时间，所以其还是很值得使用的。</p>
<p>hessian在处理序列化的时候，会根据对象的数据类型采用不同的序列化策略，比如有些直接使用JavaSerializer，有些事自己来实现对应类型的序列化方法，其实就是如上面所介绍的那样，实现对应类型的<code>writeObject</code>和<code>readObject</code>方法。</p>
<p>我们只是使用hessian工具来完成序列化和反序列化工作，如果你需要自己实现一个自定义序列化工具，那么可以参考hessian的实现方式。</p>
<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HessianSerialibale &#123;</span><br><span class="line"></span><br><span class="line">    public static void serial(Blog blog) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        Hessian2Output os &#x3D; new Hessian2Output(baos);</span><br><span class="line">        os.writeObject(blog);</span><br><span class="line">        os.close();</span><br><span class="line">        Hessian2Input is &#x3D; new Hessian2Input(new ByteArrayInputStream(baos.toByteArray()));</span><br><span class="line">        Blog blog1 &#x3D; (Blog) is.readObject();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(blog1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>尤其需要说明，在上面的测试代码中，如果不将os close掉，则一直会报错，告诉<code>java.io.EOFException: readObject: unexpected end of file</code>.</p>
<p>此外，处理性能上的优势，hessian还可以在<code>serialVersionUID</code>被后期更改的时候，反序列化也没有问题。这是因为，hessian不依赖UID来匹配类型，而且hessian在序列化完了之后的二进制流里面，会保留每个field对应的一些属性信息，虽然这些信息会增加一点流大小，但是对反序列化工作很有帮助。</p>
</blockquote>
<h4 id="Kryo工具"><a href="#Kryo工具" class="headerlink" title="Kryo工具"></a>Kryo工具</h4><blockquote>
<p>关于Kryo的性能对比，可以参考<a href="http://developer.51cto.com/art/201506/480273.htm" target="_blank" rel="noopener">各种 Java 的序列化库的性能比较测试结果</a>。</p>
</blockquote>
<p>Kryo是一个快速高效的Java对象序列化框架，其在java的序列化上的性能指标甚至优于google著名的序列化框架protobuf，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。总之，Kryo性能非常霸道。</p>
<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class KryoSerializable &#123;</span><br><span class="line"></span><br><span class="line">    public static void serial(Blog blog)throws Exception&#123;</span><br><span class="line">        Kryo kryo &#x3D; new Kryo();</span><br><span class="line">        ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        Output output &#x3D; new Output(baos);</span><br><span class="line">        kryo.writeClassAndObject(output, blog);</span><br><span class="line">        output.close();</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bais &#x3D; new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        Input input &#x3D; new Input(bais);</span><br><span class="line">        Blog blog1 &#x3D; (Blog) kryo.readClassAndObject(input);</span><br><span class="line">        input.close();</span><br><span class="line">        System.out.println(blog1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于Kryo工具生成的字节码中是不包含field元数据信息的，这样的话，在兼容性上就很难处理了。比如我现在对一个对象增加一个字段属性，但是这样子的话，老的所有序列化二进制流就无法被正常反序列化成对象了。在很多场景下，这都是无法容忍的。</p>
</blockquote>
<h4 id="JSON工具"><a href="#JSON工具" class="headerlink" title="JSON工具"></a>JSON工具</h4><blockquote>
<p>JSON工具进行序列化和反序列化在上文已经进行了说明，并且RPC示例代码就是使用这种方式。其性能上跟hessian差不多，并且反序列化兼容会很，但是其有个比较大的缺点，就是很多类型，可能JSON工具无法支持，并且其是基于String然后再转成二进制流的，所以流的大小，可能并没有想象的那么好。</p>
</blockquote>
<h3 id="RPC协议编解码"><a href="#RPC协议编解码" class="headerlink" title="RPC协议编解码"></a>RPC协议编解码</h3><blockquote>
<p>除了序列化，在编码的上/下游还需要对二进制流或者对象做一些额外的处理，而这些处理本身和二进制流化没有太大关系。</p>
</blockquote>
<p>比如dubbo给出的处理流程，可以清晰的看出序列化和编码之间的区别(个人觉得广义的编码应该包括序列化那部分)如下：</p>
<p><img src="https://ketao1989.github.io/images/2016/12/dubbo_codec.png" alt="dubbo线程处理流程"></p>
<p>每个RPC组件，基本上都是直接基于Socket来开发通信层功能，但是在网络传输的数据由于网络链路和协议的问题，会出现半包，分包和粘包情况。这样就需要设计编解码协议头来解码网络流，如上dubbo视图。</p>
<p>下面我们来看下dubbo的协议编码格式(具体参考：<a href="http://dubbo.io/Developer+Guide-zh.htm#DeveloperGuide-zh-远程通讯细节" target="_blank" rel="noopener">远程通讯细节</a>)：</p>
<p><img src="https://ketao1989.github.io/images/2016/12/dubbo_protocol.png" alt="dubbo协议头"></p>
<p>Dubbo协议头分析：</p>
<blockquote>
<p>协议头固定长度<code>16</code>个字节，也就是128位。这样，当我们解码流的时候，会首先提取前16byte来解析。</p>
<p>先来看看MAGIC设计：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; magic header.</span><br><span class="line">protected static final short    MAGIC              &#x3D; (short) 0xdabb;</span><br><span class="line">protected static final byte     MAGIC_HIGH         &#x3D; Bytes.short2bytes(MAGIC)[0];</span><br><span class="line">protected static final byte     MAGIC_LOW          &#x3D; Bytes.short2bytes(MAGIC)[1];</span><br></pre></td></tr></table></figure>

<p><code>SerializationID</code>表示序列化类型ID，Dubbo支持多种序列化工具，比如hessian，jdk，fastjson等，所以需要在协议头里面指定序列化方式，这样在解码完了之后才能知道内容使用哪种工具反序列化。</p>
<p><code>event</code>表示事件，比如这个请求是<code>heartbeat</code>。<code>two way</code>表示请求是否是需要交互返回数据的请求。<code>req/res</code>表示该数据是请求还是响应。<code>status</code>表示状态位，当响应数据的时候，根据该字段判断是否成功。</p>
<p><code>id</code>表示请求id。这个ID真的真的很重要！！！这个id是请求客户端生成的唯一id，保证在服务运行期内id不会重复。此外，在阿里内部的RPC组件HSF最开始是将id放在data数据内，这样只有在反序列化的时候，才能拿到ReqId，但是有些时候ReqId对应的RPC请求可能由于超时或者已经被处理，导致客户端对于这种case直接丢弃就可以。因此，将id放在head里面，则直接解码的时候就可以拿到ReqId去check，而不需要额外反序列化工作。</p>
<p><code>data length</code>则表示正文内容的长度。解码是通过该字段来判断消息正文字节流的整个完整包，这样反序列化就可以进行正确的转换对象了。</p>
</blockquote>
<h3 id="RPC路由和负载均衡"><a href="#RPC路由和负载均衡" class="headerlink" title="RPC路由和负载均衡"></a>RPC路由和负载均衡</h3><blockquote>
<p>路由策略，是完成单个机器对于服务方调用链路的选择策略,然后把客户端的服务请求传输到具体的某台服务端的机器上。负载均衡是完成路由的一种实现方式，其将前端请求根据一定算法策略来分发到不同机器上，使得集群中机器资源得到充分均衡的利用，此外还可以将不可用机器剔出请求列表。但是，显然路由除了负载均衡之外，还有其他方式。</p>
<p>我们知道，现在的服务后台都是多台机器部署的服务集群，在这些集群在请求的入口，一般会有负责负载均衡的机器部署，来完成请求的合理分发。RPC的结构也是客户端和服务端模式，但是其结构中我们发现是没有中间代理server层的，所以对于客户端在集群中的远程服务调用，就需要客户端自己来完成负载均衡的逻辑了。</p>
<p>除负载均衡之外，我们还会存在其他路由加强方式。比如，我们有多个机房都部署服务的时候，我需要优先选择同机房内的服务调用。</p>
</blockquote>
<p>一般定义类似如下的接口，然后根据自己的需求实现自己的负载均衡/路由策略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ILoadBalanceStrategy &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从众多连接池子中选择其中一个池子.</span><br><span class="line">     *</span><br><span class="line">     * @param invokeConns 客户端维持的和各个服务端维持的连接池对象列表</span><br><span class="line">     * @param invocation 本次客户端调用服务端相关的信息</span><br><span class="line">     * @return 返回和其中一个服务端维持链接的连接池对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public InvokeConn select(List&lt;InvokeConn&gt; invokeConns, Invocation invocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般RPC组件中，会实现两个通用的负载均衡策略。随机和轮询。具体实现可以参考：<a href="https://github.com/ketao1989/ourea/tree/master/ourea-core/src/main/java/com/taocoder/ourea/core/loadbalance" target="_blank" rel="noopener">https://github.com/ketao1989/ourea/tree/master/ourea-core/src/main/java/com/taocoder/ourea/core/loadbalance</a></p>
</blockquote>
<p><em>再谈谈维护可用服务列表：</em></p>
<p>一般我们会在客户端和服务端之间维持长连接，然后通过心跳机制来确保服务端是否在线提供服务。此外，对一些没有维护长连接或者可选择不建立长连接的RPC组件来说，只能通过注册服务机制来监听服务端是否下线。</p>
<p>如果调用比较频繁的服务来说，客户端可以在服务连接未成功的情况下，将该机器从服务连接列表中剔除，放在<code>暂时不可用机器列表</code>，然后起一个定时任务，当机器暂存5s后，再放到可用列表尝试请求服务调用。</p>
<p>关于心跳请求的定时任务，可以参考使用Netty提供的<code>HashedWheelTimer</code><a href="https://zacard.net/2016/12/02/netty-hashedwheeltimer/" target="_blank" rel="noopener">netty源码解读之时间轮算法实现-HashedWheelTimer</a>，其提供了在不要求高精度触发定时任务的场景下，性能非常高。</p>
<p><em>最后，再聊聊服务调用路由：</em></p>
<p>服务路由，这里特指除负载均衡之外的一些服务寻址策略。和负载均衡不同的是，这里的路由策略是单个机器根据自身特点做出的服务方选择策略，而负载均衡策略则是基于整个集群中所有机器的普适策略。如上所言，我们的多机房部署，再拿到集群机器列表之后，我们还需要维持一个本机房的机器列表(一般，对服务集群列表进行按IP前缀规则来过滤)，这样当我们选择调用机器的时候，会优先从本机房获取连接，如果没有才会按照负载均衡来获取服务调用连接。</p>
<p>此外，对于一些完善的RPC框架，可能还会支持动态可配置路由规则。比如，我们可以按照机器ip来配置，某些客户端调用只能路由到某些服务端机器上。对于线上测试问题跟踪而言，可以很好的根据服务调用链路，来查看日志解决问题。</p>
<h3 id="RPC超时管理"><a href="#RPC超时管理" class="headerlink" title="RPC超时管理"></a>RPC超时管理</h3><p>作为一个健康的服务，一定需要超时机制。相当多的服务不可用问题，都是因为客户端没有超时机制，导致服务端抖动的一段时间内，客户端一直处于占用连接等待响应的阶段，耗尽服务端资源，最后导致服务端集群雪崩。所以在请求网络服务的时候，增加超时设置是多么重要(当然，连接使用现在最大连接数的连接池也非常重要)。</p>
<p>RPC的调用实现，一般会有一个IO线程池来处理RPC调用，也就是我们的业务线程会将调用请求交给RPC线程来处理，返回一个future对象。远程调用处理完成之后，RPC线程会将结果填充到<code>futrue</code>对象内部，然后告知调用方调用完成，可以使用<code>futrue.get</code>来获取返回数据。如下所示：</p>
<p><img src="https://ketao1989.github.io/images/2016/12/timeout.png" alt="RPC客户端调用处理"></p>
<p>从上图可以看出，<code>超时1</code>我们可以直接使用<code>futrue.get</code>特性来设置和处理超时问题。<code>超时2</code>指的是服务端执行的超时，比如我们客户端调用的时间是1s，但是服务端可能会超过1s，而这个时候客户端其实已经超时丢弃这次请求，但是服务端还一直执行直到完成返回，这个时候服务端需要序列化对象然后传输到客户端，但是这个流程其实可以简化的。</p>
<p>因此，服务端的超时管理，是当服务端业务逻辑执行完成之后(这期间实现超时中断比较难)，比较执行时间和客户端设置的超时时间，如果接近，则打包服务端超时错误信息返回给客户端即可。这样可以节省序列化数据时间(直接使用序列化好了的数据返回)，已经减少网络传输时间。</p>
<h3 id="RPC-服务发现"><a href="#RPC-服务发现" class="headerlink" title="RPC 服务发现"></a>RPC 服务发现</h3><p>在对外http服务里，我们有一个配套的支撑基础组件叫做DNS，其根据域名找到某几个外网ip地址。然后，请求打到网站内部，一般首先到nginx群，nginx也会根据url规则找到配置好的一组ip地址，此外，nginx根据healthcheck来检查http服务是否可用。但是，使用nginx时，我们通常需要把ip地址离线配置到nginx上。</p>
<p>我们提供的RPC服务都是集群部署，所以我们需要在客户端维持一个服务调用地址列表。所以，我们也需要类似DNS功能的服务。 但是，我们不想我们的RPC服务集群有机器迁移或者增加时，所需要离线给客户端配置，这就是说，我们还需要实时更新集群机器列表的功能。</p>
<p>这，就是RPC服务发现模块需要解决的问题。</p>
<p>一般，服务发现主要包括2部分：</p>
<ol>
<li>服务地址存储；</li>
<li>服务状态感知。</li>
</ol>
<h4 id="服务地址存储"><a href="#服务地址存储" class="headerlink" title="服务地址存储"></a>服务地址存储</h4><p>服务地址存储，首先需要一个组件来存放服务机器列表等RPC服务数据，提供存储服务的组件有很多，比如：zookeeper，redis，mysql等等。然后，在服务端正常启动可以提供服务之后，需要将自己的服务地址，比如ip，port，以及服务信息，比如接口，版本号等信息，提交到存储服务机器上。然后，客户端在启动的时候，从存储服务的机器上，根据接口，版本等服务信息来拿到提供对应服务的RPC地址列表，客户端根据这个列表就可以开始调用远程服务了。</p>
<p>此外，为了服务治理，比如我们需要知道哪些客户端调用了我们对外提供的服务，就需要客户端在启动的时候，把自己的地址数据和调用的服务信息提交到存储服务上去。</p>
<p>对于提供比较完善的服务治理功能，还可以提供后台操作界面，让某些服务端机器手动操作上/下线，这样让通过RPC调用的客户端不将流量打到下线的服务器上。</p>
<p>简单的服务发现，RPC方和存储组件之间的交互如下：</p>
<p><img src="https://ketao1989.github.io/images/2016/12/find.png" alt="RPC服务发现结果"></p>
<h4 id="服务状态感知"><a href="#服务状态感知" class="headerlink" title="服务状态感知"></a>服务状态感知</h4><p>这里的服务感知，包括客户端感知服务端状态，以及存储服务感知RPC参与方的状态。</p>
<p>正常情况下，我们从存储组件那里拿到服务端地址后，自己来处理路由策略，然后选择一个服务端建立连接，执行远程调用。在执行的过程中，如果有服务不可用，我们可以从我们的服务列表中，将它剔除。但是，如果服务增加机器或者服务机器迁移了呢？这就需要我们及时了解服务端集群的整体机器状态。两种方式：</p>
<ol>
<li>客户端其一个定时调度任务，周期去存储组件处拉取最新的服务集群地址列表，但是这个周期粒度比较难控制。</li>
<li>客户端和存储组件建立一个长连接，当存储组件发现有服务集群状态发生变更，推送给客户端。但是，这又要求存储组件具有推送功能。</li>
</ol>
<p>目前有这个功能的存储组件，主要有zookeeper和redis，此外，也可以自己实现一个简单可靠的服务发现中间件，对外提供推送存储服务。</p>
<p>我们在服务启动的时候，会告知存储组件我们对外提供服务的地址信息和客户端的地址信息；在服务已知操作的服务下线的时候，会将存储组件中存储的服务相关信息清除掉。但是，显然，在服务下线或者客户端下线的时候，都存在没有清除存储信息就宕机的情况，这个时候就需要存储组件需要有感知各个参与方的状态了。</p>
<p>一般，我们会让RPC两方都和存储组件保持连接，然后通过心跳等方式来探测对方是否下线。</p>
<p>目前提供这个功能的存储组件，主要有zookeeper和redis。当然，你也可以实现一个，可以和所有注册服务和查找服务的server保持长连接。由于，可能有大量的机器建立长连接，所以服务器性能一定要高。</p>
<blockquote>
<p>基于zookeeper实现服务发现功能的代码，可以参考：<a href="https://github.com/ketao1989/ourea" target="_blank" rel="noopener">https://github.com/ketao1989/ourea</a></p>
</blockquote>
<h3 id="RPC-多线程IO模型"><a href="#RPC-多线程IO模型" class="headerlink" title="RPC 多线程IO模型"></a>RPC 多线程IO模型</h3><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>RPC其实是一个说简单简单，说复杂复杂的组件。就如上文写的一个简单的RPC示例，其本身就是一个具备RPC功能的组件。但是，在深入篇中，可以看到每一个模块都可以深入优化，以及支持模块化插件话设计开发。</p>
<p>本文从单机到集群，从本地调用到远程调用的渐进过度。然后再从一个满足RPC结构图的简单示例开始，代码介绍每个模块，进而深入成熟RPC框架所需要考虑和优化的各个技术点。</p>
<p>本文的目的，旨在对RPC整体结构和各个模块进行介绍和深入，然后根据这些点，可以去分析开源的RPC框架或者自己写一个RPC组件。</p>
<p>在本文中，很多点都是一边学习，一边总结，所以知识有限，如有问题，欢迎交流。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><p><a href="https://yq.aliyun.com/articles/8931" target="_blank" rel="noopener">linux内存管理浅析</a></p>
</li>
<li><p><a href="http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1601_clark-trs/1601_clark.html" target="_blank" rel="noopener">微服务、SOA 和 API：是敌是友？</a></p>
</li>
<li><p><a href="http://tech.meituan.com/serialization_vs_deserialization.html" target="_blank" rel="noopener">序列化和反序列化</a></p>
</li>
</ol>
<hr>
<p>本文转载自</p>
<p><a href="https://ketao1989.github.io/2016/12/10/rpc-theory-in-action/" target="_blank" rel="noopener">深入浅出RPC原理</a></p>
<p>遵循CC 4.0 BY-SA版权协议</p>
<hr>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
</search>
