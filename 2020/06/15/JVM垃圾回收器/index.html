<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言在之前的几篇博客中，我们大致介绍了，常见的 垃圾回收算法 及 JVM 中常见的分类回收算法。这些都是从算法和规范上分析 Java 中的垃圾回收，属于方法论。在 JVM 中，垃圾回收的具体实现是由 垃圾回收器（Garbage Collector）负责的。 正文概述在了解 垃圾回收器 之前，首先得了解一下垃圾回收器的几个名词。 1. 吞吐量CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM垃圾回收器">
<meta property="og:url" content="http://yoursite.com/2020/06/15/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/index.html">
<meta property="og:site_name" content="Eric&#39;s Blogs">
<meta property="og:description" content="前言在之前的几篇博客中，我们大致介绍了，常见的 垃圾回收算法 及 JVM 中常见的分类回收算法。这些都是从算法和规范上分析 Java 中的垃圾回收，属于方法论。在 JVM 中，垃圾回收的具体实现是由 垃圾回收器（Garbage Collector）负责的。 正文概述在了解 垃圾回收器 之前，首先得了解一下垃圾回收器的几个名词。 1. 吞吐量CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b876b28f6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b87f0e86b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b885c24bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bb0960af8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b8a61ea51?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bd1ebf8c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b88cda952?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b8a60fa35?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bb00da43d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bb5454a60?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="article:published_time" content="2020-06-15T00:03:11.000Z">
<meta property="article:modified_time" content="2020-06-19T12:26:30.165Z">
<meta property="article:author" content="EricMa">
<meta property="article:tag" content="GC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b876b28f6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">

<link rel="canonical" href="http://yoursite.com/2020/06/15/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM垃圾回收器 | Eric's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Eric's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Better Code, Better Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/15/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM垃圾回收器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-15 08:03:11" itemprop="dateCreated datePublished" datetime="2020-06-15T08:03:11+08:00">2020-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-19 20:26:30" itemprop="dateModified" datetime="2020-06-19T20:26:30+08:00">2020-06-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在之前的几篇博客中，我们大致介绍了，常见的 <strong>垃圾回收算法</strong> 及 <code>JVM</code> 中常见的分类回收算法。这些都是从算法和规范上分析 <code>Java</code> 中的垃圾回收，属于方法论。在 <code>JVM</code> 中，垃圾回收的具体实现是由 <strong>垃圾回收器</strong>（<code>Garbage Collector</code>）负责的。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在了解 <strong>垃圾回收器</strong> 之前，首先得了解一下垃圾回收器的几个名词。</p>
<h3 id="1-吞吐量"><a href="#1-吞吐量" class="headerlink" title="1. 吞吐量"></a>1. 吞吐量</h3><p><code>CPU</code> 用于运行用户代码的时间与 <code>CPU</code> 总消耗时间的比值。比如说虚拟机总运行了 <code>100</code> 分钟，<strong>用户代码</strong> 时间 <code>99</code> 分钟，<strong>垃圾回收</strong> 时间 <code>1</code> 分钟，那么吞吐量就是 <code>99%</code>。</p>
<blockquote>
<p>吞吐量 = 运行用户代码时间/（运行用户代码时间 + 垃圾回收时间）</p>
</blockquote>
<h3 id="2-停顿时间"><a href="#2-停顿时间" class="headerlink" title="2. 停顿时间"></a>2. 停顿时间</h3><p><strong>停顿时间</strong> 指垃圾回收器正在运行时，<strong>应用程序</strong> 的 <strong>暂停时间</strong>。对于 <strong>独占回收器</strong> 而言，停顿时间可能会比较长。使用 <strong>并发回收器</strong> 时，由于垃圾回收器和应用程序 <strong>交替运行</strong>，程序的 <strong>停顿时间</strong> 会变短，但是，由于其 <strong>效率</strong> 很可能不如独占垃圾回收器，故系统的 <strong>吞吐量</strong> 可能会较低。</p>
<h3 id="3-GC的名词"><a href="#3-GC的名词" class="headerlink" title="3. GC的名词"></a>3. GC的名词</h3><h4 id="3-1-新生代GC（Minor-GC）"><a href="#3-1-新生代GC（Minor-GC）" class="headerlink" title="3.1. 新生代GC（Minor GC）"></a>3.1. 新生代GC（Minor GC）</h4><p>指发生在 <strong>新生代</strong> 的垃圾回收动作，因为 <code>Java</code> 对象大多都具备 <strong>朝生夕死</strong> 的特性，所以 <code>Minor GC</code> 通常 <strong>非常频繁</strong>，一般回收速度也比较快。</p>
<h4 id="3-2-老年代GC（Major-GC）"><a href="#3-2-老年代GC（Major-GC）" class="headerlink" title="3.2. 老年代GC（Major GC）"></a>3.2. 老年代GC（Major GC）</h4><p>指发生在 <strong>老年代</strong> 的垃圾回收动作，出现了 <code>Major GC</code>，经常会伴随至少一次的 <code>Minor GC</code>（发生这种情况，那么 <strong>整个堆</strong> 都 <code>GC</code> 一遍，通常称为 <code>Full GC</code>）。<code>Major GC</code> 的速度一般会比 <code>Minor GC</code> 慢 <code>10</code> 倍以上。</p>
<h3 id="4-并发与并行"><a href="#4-并发与并行" class="headerlink" title="4. 并发与并行"></a>4. 并发与并行</h3><h4 id="4-1-串行（Parallel）"><a href="#4-1-串行（Parallel）" class="headerlink" title="4.1. 串行（Parallel）"></a>4.1. 串行（Parallel）</h4><p><strong>单线程</strong> 进行垃圾回收工作，但此时 <strong>用户线程</strong> 仍然处于 <strong>等待状态</strong>。</p>
<h4 id="4-2-并发（Concurrent）"><a href="#4-2-并发（Concurrent）" class="headerlink" title="4.2. 并发（Concurrent）"></a>4.2. 并发（Concurrent）</h4><p>这里的并发指 <strong>用户线程</strong> 与 <strong>垃圾回收线程</strong> 交替执行。</p>
<h4 id="4-3-并行（Parallel）"><a href="#4-3-并行（Parallel）" class="headerlink" title="4.3. 并行（Parallel）"></a>4.3. 并行（Parallel）</h4><p>这里的并行指 <strong>用户线程</strong> 和多条 <strong>垃圾回收线程</strong> 分别在不同 <code>CPU</code> 上同时工作。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="1-根搜索算法"><a href="#1-根搜索算法" class="headerlink" title="1. 根搜索算法"></a>1. 根搜索算法</h3><p><strong>根搜索算法</strong> 是从 <strong>离散数学</strong> 中的图论引入的，程序把所有引用关系看作一张图，从一个节点 <code>GC ROOT</code> 开始，寻找对应的 <strong>引用节点</strong>，找到这个节点后，继续寻找 <strong>这个节点</strong> 的 <strong>引用节点</strong>。当所有的引用节点寻找完毕后，<strong>剩余的节点</strong> 则被认为是 <strong>没有被引用到</strong> 的节点，即 <strong>无用</strong> 的节点。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b876b28f6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>上图 <strong>红色</strong> 为无用的节点，可以被 <strong>回收</strong>。目前 <code>Java</code> 中可以作为 <code>GC ROOT</code> 的对象有：</p>
<ol>
<li><strong>虚拟机栈</strong> 中引用的对象（本地变量表）；</li>
<li><strong>方法区</strong> 中 <strong>静态变量</strong> 引用的对象；</li>
<li><strong>方法区</strong> 中 <strong>常量</strong> 引用的对象；</li>
<li><strong>本地方法栈</strong> 中引用的对象（<code>Native</code> 对象）。</li>
</ol>
<blockquote>
<p>基本所有 <code>GC</code> 算法都引用 <strong>根搜索算法</strong> 这种概念。</p>
</blockquote>
<h3 id="2-标记-清除算法"><a href="#2-标记-清除算法" class="headerlink" title="2. 标记 - 清除算法"></a>2. 标记 - 清除算法</h3><p><strong>标记-清除算法</strong> 从 <strong>根集合</strong> 进行扫描，对 <strong>存活的对象</strong> 进行 <strong>标记</strong>。标记完毕后，再扫描整个空间中 <strong>未被标记</strong> 的对象进行 <strong>直接回收</strong>，如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b87f0e86b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><strong>标记-清除算法</strong> 不需要进行 <strong>对象的移动</strong>，并且仅对 <strong>不存活</strong> 的对象进行处理，在 <strong>存活</strong> 的对象 <strong>比较多</strong> 的情况下 <strong>极为高效</strong>。但由于 <strong>标记-清除算法</strong> 直接回收不存活的对象，并没有对还存活的对象进行 <strong>整理</strong>，因此会导致 <strong>内存碎片</strong>。</p>
<h3 id="3-复制算法"><a href="#3-复制算法" class="headerlink" title="3. 复制算法"></a>3. 复制算法</h3><p><strong>复制算法</strong> 将内存划分为 <strong>两个区间</strong>，使用此算法时，所有 <strong>动态分配</strong> 的对象都只能分配在 <strong>其中一个</strong> 区间（<strong>活动区间</strong>），而 <strong>另外一个</strong> 区间（<strong>空间区间</strong>）则是 <strong>空闲</strong> 的。</p>
<p><strong>复制算法</strong> 同样从 <strong>根集合</strong> 扫描，将 <strong>存活</strong> 的对象 <strong>复制</strong> 到 <strong>空闲区间</strong>。当扫描完毕活动区间后，会的将 <strong>活动区间</strong> 一次性全部 <strong>回收</strong>。此时原本的 <strong>空闲区间</strong> 变成了 <strong>活动区间</strong>。下次 <code>GC</code> 时候又会重复刚才的操作，以此循环。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b885c24bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><strong>复制算法</strong> 在存活对象 <strong>比较少</strong> 的时候，极为高效，但是带来的成本是 <strong>牺牲一半的内存空间</strong> 用于进行 <strong>对象的移动</strong>。所以 <strong>复制算法</strong> 的使用场景，必须是对象的 <strong>存活率非常低</strong> 才行。最重要的是，我们需要克服 <code>50%</code> 的 <strong>内存浪费</strong>。</p>
<h3 id="4-标记-整理算法"><a href="#4-标记-整理算法" class="headerlink" title="4. 标记 - 整理算法"></a>4. 标记 - 整理算法</h3><p><strong>标记-整理算法</strong> 采用 <strong>标记-清除算法</strong> 一样的方式进行对象的 <strong>标记</strong>，但在回收 <strong>不存活的对象</strong> 占用的空间后，会将所有 <strong>存活的对象</strong> 往 左端空闲空间 <strong>移动</strong>，并更新对应的指针。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bb0960af8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><strong>标记-整理</strong> 是在 <strong>标记-清除</strong> 之上，又进行了 <strong>对象的移动排序整理</strong>，因此 <strong>成本更高</strong>，但却解决了 <strong>内存碎片</strong> 的问题。</p>
<blockquote>
<p><code>JVM</code> 为了 <strong>优化内存</strong> 的回收，使用了 <strong>分代回收</strong> 的方式。对于 <strong>新生代内存</strong> 的回收（<code>Minor GC</code>）主要采用 <strong>复制算法</strong>。而对于 <strong>老年代内存</strong> 的回收（<code>Major GC</code>），大多采用 <strong>标记-整理算法</strong>。</p>
</blockquote>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="1-垃圾回收器分类标准"><a href="#1-垃圾回收器分类标准" class="headerlink" title="1. 垃圾回收器分类标准"></a>1. 垃圾回收器分类标准</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b8a61ea51?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="2-七种垃圾回收器概述"><a href="#2-七种垃圾回收器概述" class="headerlink" title="2. 七种垃圾回收器概述"></a>2. 七种垃圾回收器概述</h3><p>在 <code>JVM</code> 中，具体实现有 <code>Serial</code>、<code>ParNew</code>、<code>Parallel Scavenge</code>、<code>CMS</code>、<code>Serial Old（MSC）</code>、<code>Parallel Old</code>、<code>G1</code> 等。在下图中，你可以看到 <strong>不同垃圾回收器</strong> 适合于 <strong>不同的内存区域</strong>，如果两个垃圾回收器之间 <strong>存在连线</strong>，那么表示两者可以 <strong>配合使用</strong>。</p>
<p>如果当 <strong>垃圾回收器</strong> 进行垃圾清理时，必须 <strong>暂停</strong> 其他所有的 <strong>工作线程</strong>，直到它完全收集结束。我们称这种需要暂停工作线程才能进行清理的策略为 <code>Stop-the-World</code>。以上回收器中，   <code>Serial</code>、<code>ParNew</code>、<code>Parallel Scavenge</code>、<code>Serial Old</code>、<code>Parallel Old</code> 均采用的是 <code>Stop-the-World</code> 的策略。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bd1ebf8c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>图中有 <code>7</code> 种不同的 <strong>垃圾回收器</strong>，它们分别用于不同分代的垃圾回收。</p>
<ul>
<li><strong>新生代回收器</strong>：Serial、ParNew、Parallel Scavenge</li>
<li><strong>老年代回收器</strong>：Serial Old、Parallel Old、CMS</li>
<li><strong>整堆回收器</strong>：G1</li>
</ul>
<p>两个 <strong>垃圾回收器</strong> 之间有连线表示它们可以 <strong>搭配使用</strong>，可选的搭配方案如下：</p>
<table>
<thead>
<tr>
<th align="left">新生代</th>
<th align="left">老年代</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Serial</td>
<td align="left">Serial Old</td>
</tr>
<tr>
<td align="left">Serial</td>
<td align="left">CMS</td>
</tr>
<tr>
<td align="left">ParNew</td>
<td align="left">Serial Old</td>
</tr>
<tr>
<td align="left"><strong>ParNew</strong></td>
<td align="left"><strong>CMS</strong></td>
</tr>
<tr>
<td align="left">Parallel Scavenge</td>
<td align="left">Serial Old</td>
</tr>
<tr>
<td align="left"><strong>Parallel Scavenge</strong></td>
<td align="left"><strong>Parallel Old</strong></td>
</tr>
<tr>
<td align="left">G1</td>
<td align="left">G1</td>
</tr>
</tbody></table>
<h3 id="3-单线程垃圾回收器"><a href="#3-单线程垃圾回收器" class="headerlink" title="3. 单线程垃圾回收器"></a>3. 单线程垃圾回收器</h3><h4 id="3-1-Serial（-XX-UseSerialGC）"><a href="#3-1-Serial（-XX-UseSerialGC）" class="headerlink" title="3.1. Serial（-XX:+UseSerialGC）"></a>3.1. Serial（-XX:+UseSerialGC）</h4><p><code>Serial</code> 回收器是最基本的 <strong>新生代</strong> 垃圾回收器，是 <strong>单线程</strong> 的垃圾回收器。由于垃圾清理时，<code>Serial</code> <strong>回收器</strong> 不存在 <strong>线程间的切换</strong>，因此，特别是在单 <code>CPU</code> 的环境下，它的 <strong>垃圾清除效率</strong> 比较高。对于 <code>Client</code> 运行模式的程序，选择 <code>Serial</code> 回收器是一个不错的选择。</p>
<p><code>Serial</code> <strong>新生代回收器</strong> 采用的是 <strong>复制算法</strong>。</p>
<h4 id="3-2-Serial-Old（-XX-UseSerialGC）"><a href="#3-2-Serial-Old（-XX-UseSerialGC）" class="headerlink" title="3.2. Serial Old（-XX:+UseSerialGC）"></a>3.2. Serial Old（-XX:+UseSerialGC）</h4><p><code>Serial Old</code> 回收器是 <code>Serial</code> 回收器的 <strong>老生代版本</strong>，属于 <strong>单线程回收器</strong>，它使用 <strong>标记-整理</strong> 算法。对于 <code>Server</code> 模式下的虚拟机，在 <code>JDK1.5</code> 及其以前，它常与 <code>Parallel Scavenge</code> 回收器配合使用，达到较好的 <strong>吞吐量</strong>，另外它也是 <code>CMS</code> 回收器在 <code>Concurrent Mode Failure</code> 时的 <strong>后备方案</strong>。</p>
<p><code>Serial</code> 回收器和 <code>Serial Old</code> 回收器的执行效果如下：</p>
<blockquote>
<p><code>Serial Old</code> <strong>老年代回收器</strong> 采用的是 <strong>标记 - 整理算法</strong>。</p>
</blockquote>
<h3 id="4-多线程垃圾回收器（吞吐量优先）"><a href="#4-多线程垃圾回收器（吞吐量优先）" class="headerlink" title="4. 多线程垃圾回收器（吞吐量优先）"></a>4. 多线程垃圾回收器（吞吐量优先）</h3><h4 id="4-1-ParNew（-XX-UseParNewGC）"><a href="#4-1-ParNew（-XX-UseParNewGC）" class="headerlink" title="4.1. ParNew（-XX:+UseParNewGC）"></a>4.1. ParNew（-XX:+UseParNewGC）</h4><p><code>ParNew</code> 回收器是在 <code>Serial</code> 回收器的基础上演化而来的，属于 <code>Serial</code> 回收器的 <strong>多线程版本</strong>，同样运行在 <strong>新生代区域</strong>。在实现上，两者共用很多代码。在不同运行环境下，根据 <code>CPU</code> 核数，开启 <strong>不同的线程数</strong>，从而达到 <strong>最优</strong> 的垃圾回收效果。对于那些 <code>Server</code> 模式的应用程序，如果考虑采用 <code>CMS</code> 作为 <strong>老生代回收器</strong> 时，<code>ParNew</code> 回收器是一个不错的选择。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b88cda952?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<blockquote>
<p><code>ParNew</code> <strong>新生代回收器</strong> 采用的是 <strong>复制算法</strong>。</p>
</blockquote>
<h4 id="4-2-Parallel-Scavenge（-XX-UseParallelGC）"><a href="#4-2-Parallel-Scavenge（-XX-UseParallelGC）" class="headerlink" title="4.2. Parallel Scavenge（-XX:+UseParallelGC）"></a>4.2. Parallel Scavenge（-XX:+UseParallelGC）</h4><p>和 <code>ParNew</code> 回收一样，<code>Parallel Scavenge</code> 回收器也是运行在 <strong>新生代区域</strong>，属于 <strong>多线程</strong> 的回收器。但不同的是，<code>ParNew</code> 回收器是通过控制 <strong>垃圾回收</strong> 的 <strong>线程数</strong> 来进行参数调整，而 <code>Parallel Scavenge</code> 回收器更关心的是 <strong>程序运行的吞吐量</strong>。即一段时间内，<strong>用户代码</strong> 运行时间占 <strong>总运行时间</strong> 的百分比。</p>
<blockquote>
<p><code>Parallel Scavenge</code> <strong>新生代回收器</strong> 采用的是 <strong>复制算法</strong>。</p>
</blockquote>
<h4 id="4-3-Parallel-Old（-XX-UseParallelOldGC）"><a href="#4-3-Parallel-Old（-XX-UseParallelOldGC）" class="headerlink" title="4.3. Parallel Old（-XX:+UseParallelOldGC）"></a>4.3. Parallel Old（-XX:+UseParallelOldGC）</h4><p><code>Parallel Old</code> 回收器是 <code>Parallel Scavenge</code> 回收器的 <strong>老生代版本</strong>，属于 <strong>多线程回收器</strong>，采用 <strong>标记-整理算法</strong>。<code>Parallel Old</code> 回收器和 <code>Parallel Scavenge</code> 回收器同样考虑了 <strong>吞吐量优先</strong> 这一指标，非常适合那些 <strong>注重吞吐量</strong> 和 <code>CPU</code> <strong>资源敏感</strong> 的场合。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7b8a60fa35?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<blockquote>
<p><code>Parallel Old</code> <strong>老年代回收器</strong> 采用的是 <strong>标记 - 整理算法</strong>。</p>
</blockquote>
<h3 id="5-其他的回收器（停顿时间优先）"><a href="#5-其他的回收器（停顿时间优先）" class="headerlink" title="5. 其他的回收器（停顿时间优先）"></a>5. 其他的回收器（停顿时间优先）</h3><h4 id="5-1-CMS（-XX-UseConcMarkSweepGC）"><a href="#5-1-CMS（-XX-UseConcMarkSweepGC）" class="headerlink" title="5.1. CMS（-XX:+UseConcMarkSweepGC）"></a>5.1. CMS（-XX:+UseConcMarkSweepGC）</h4><p><code>CMS（Concurrent Mark Sweep）</code> 回收器是在 <strong>最短回收停顿时间</strong> 为前提的回收器，属于 <strong>多线程回收器</strong>，采用 <strong>标记-清除算法</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bb00da43d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>相比之前的回收器，<code>CMS</code> 回收器的运作过程比较复杂，分为四步：</p>
<ol>
<li><strong>初始标记（CMS initial mark）</strong></li>
</ol>
<p><strong>初始标记</strong> 仅仅是标记 <code>GC Roots</code> 内 <strong>直接关联</strong> 的对象。这个阶段 <strong>速度很快</strong>，需要 <code>Stop the World</code>。</p>
<ol start="2">
<li><strong>并发标记（CMS concurrent mark）</strong></li>
</ol>
<p><strong>并发标记</strong> 进行的是 <code>GC Tracing</code>，从 <code>GC Roots</code> 开始对堆进行 <strong>可达性分析</strong>，找出 <strong>存活对象</strong></p>
<ol start="3">
<li><strong>重新标记（CMS remark）</strong></li>
</ol>
<p><strong>重新标记</strong> 阶段为了 <strong>修正</strong> 并发期间由于 <strong>用户进行运作</strong> 导致的 <strong>标记变动</strong> 的那一部分对象的 <strong>标记记录</strong>。这个阶段的 <strong>停顿时间</strong> 一般会比 <strong>初始标记阶段</strong> 稍长一些，但远比 <strong>并发标记</strong> 的时间短，也需要 <code>Stop The World</code>。</p>
<ol start="4">
<li><strong>并发清除（CMS concurrent sweep）</strong></li>
</ol>
<p><strong>并发清除</strong> 阶段会清除垃圾对象。</p>
<blockquote>
<p><strong>初始标记</strong>（<code>CMS initial mark</code>）和 <strong>重新标记</strong>（<code>CMS remark</code>）会导致 <strong>用户线程</strong> 卡顿，<code>Stop the World</code> 现象发生。</p>
</blockquote>
<p>在整个过程中，<code>CMS</code> 回收器的 <strong>内存回收</strong> 基本上和 <strong>用户线程</strong> 并发执行，如下所示：</p>
<p>由于 <code>CMS</code> 回收器 <strong>并发收集</strong>、<strong>停顿低</strong>，因此有些地方成为 <strong>并发低停顿回收器</strong>（<code>Concurrent Low Pause Sweep Collector</code>）。</p>
<p><code>CMS</code> 回收器的缺点：</p>
<ol>
<li><strong>CMS回收器对CPU资源非常依赖</strong></li>
</ol>
<p><code>CMS</code> 回收器过分依赖于 <strong>多线程环境</strong>，默认情况下，开启的 <strong>线程数</strong> 为<code>（CPU 的数量 + 3）/ 4</code>，当 <code>CPU</code> 数量少于 <code>4</code> 个时，<code>CMS</code> 对 <strong>用户查询</strong> 的影响将会很大，因为他们要分出一半的运算能力去 <strong>执行回收器线程</strong>；</p>
<ol start="2">
<li><strong>CMS回收器无法清除浮动垃圾</strong></li>
</ol>
<p>由于 <code>CMS</code> 回收器 <strong>清除已标记的垃圾</strong> （处于最后一个阶段）时，<strong>用户线程</strong> 还在运行，因此会有新的垃圾产生。但是这部分垃圾 <strong>未被标记</strong>，在下一次 <code>GC</code> 才能清除，因此被成为 <strong>浮动垃圾</strong>。</p>
<p>由于 <strong>内存回收</strong> 和 <strong>用户线程</strong> 是同时进行的，内存在被 <strong>回收</strong> 的同时，也在被 <strong>分配</strong>。当 <strong>老生代</strong> 中的内存使用超过一定的比例时，系统将会进行 <strong>垃圾回收</strong>；当 <strong>剩余内存</strong> 不能满足程序运行要求时，系统将会出现 <code>Concurrent Mode Failure</code>，临时采用 <code>Serial Old</code> 算法进行 <strong>清除</strong>，此时的 <strong>性能</strong> 将会降低。</p>
<ol start="3">
<li><strong>垃圾收集结束后残余大量空间碎片</strong></li>
</ol>
<p><code>CMS</code> 回收器采用的 <strong>标记清除算法</strong>，本身存在垃圾收集结束后残余 <strong>大量空间碎片</strong> 的缺点。<code>CMS</code> 配合适当的 <strong>内存整理策略</strong>，在一定程度上可以解决这个问题。</p>
<h4 id="5-2-G1回收器（垃圾区域Region优先）"><a href="#5-2-G1回收器（垃圾区域Region优先）" class="headerlink" title="5.2. G1回收器（垃圾区域Region优先）"></a>5.2. G1回收器（垃圾区域Region优先）</h4><p><code>G1</code> 是 <code>JDK 1.7</code> 中正式投入使用的用于取代 <code>CMS</code> 的 <strong>压缩回收器</strong>。它虽然没有在物理上隔断 <strong>新生代</strong> 与 <strong>老生代</strong>，但是仍然属于 <strong>分代垃圾回收器</strong>。<code>G1</code> 仍然会区分 <strong>年轻代</strong> 与 <strong>老年代</strong>，年轻代依然分有 <code>Eden</code> 区与 <code>Survivor</code> 区。</p>
<p><code>G1</code> 首先将 <strong>堆</strong> 分为 <strong>大小相等</strong> 的  <code>Region</code>，避免 <strong>全区域</strong> 的垃圾回收。然后追踪每个 <code>Region</code> 垃圾 <strong>堆积的价值大小</strong>，在后台维护一个 <strong>优先列表</strong>，根据允许的回收时间优先回收价值最大的 <code>Region</code>。同时 <code>G1</code>采用 <code>Remembered Set</code> 来存放 <code>Region</code> 之间的 <strong>对象引用</strong> ，其他回收器中的 <strong>新生代</strong> 与 <strong>老年代</strong> 之间的对象引用，从而避免 <strong>全堆扫描</strong>。<code>G1</code> 的分区示例如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16502c7bb5454a60?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>这种使用 <code>Region</code> 划分 <strong>内存空间</strong> 以及有 <strong>优先级</strong> 的区域回收方式，保证 <code>G1</code> 回收器在有限的时间内可以获得尽可能 <strong>高的回收效率</strong>。</p>
<p><code>G1</code> 和 <code>CMS</code> 运作过程有很多相似之处，整个过程也分为 <code>4</code> 个步骤：</p>
<ol>
<li><strong>初始标记（CMS initial mark）</strong></li>
</ol>
<p><strong>初始标记</strong> 仅仅是标记 <code>GC Roots</code> 内 <strong>直接关联</strong> 的对象。这个阶段 <strong>速度很快</strong>，需要 <code>Stop the World</code>。</p>
<ol start="2">
<li><strong>并发标记（CMS concurrent mark）</strong></li>
</ol>
<p><strong>并发标记</strong> 进行的是 <code>GC Tracing</code>，从 <code>GC Roots</code> 开始对堆进行 <strong>可达性分析</strong>，找出 <strong>存活对象</strong>。</p>
<ol start="3">
<li><strong>重新标记（CMS remark）</strong></li>
</ol>
<p><strong>重新标记</strong> 阶段为了 <strong>修正</strong> 并发期间由于 <strong>用户进行运作</strong> 导致的 <strong>标记变动</strong> 的那一部分对象的 <strong>标记记录</strong>。这个阶段的 <strong>停顿时间</strong> 一般会比 <strong>初始标记阶段</strong> 稍长一些，但远比 <strong>并发标记</strong> 的时间短，也需要 <code>Stop The World</code>。</p>
<ol start="4">
<li><strong>筛选回收</strong></li>
</ol>
<p>首先对各个 <code>Region</code> 的 <strong>回收价值</strong> 和 <strong>成本</strong> 进行排序，根据用户所期望的 <code>GC</code> <strong>停顿时间</strong> 来制定回收计划。这个阶段可以与用户程序一起 <strong>并发执行</strong>，但是因为只回收一部分 <code>Region</code>，时间是用户可控制的，而且停顿 <strong>用户线程</strong> 将大幅提高回收效率。</p>
<blockquote>
<p>与其它 <code>GC</code> 回收相比，<code>G1</code> 具备如下 <code>4</code> 个特点：</p>
</blockquote>
<ul>
<li><strong>并行与并发</strong></li>
</ul>
<p>使用多个 <code>CPU</code> 来缩短 <code>Stop-the-World</code> 的 <strong>停顿时间</strong>，部分其他回收器需要停顿 <code>Java</code> 线程执行的 <code>GC</code> 动作，<code>G1</code> 回收器仍然可以通过 <strong>并发的方式</strong> 让 <code>Java</code> 程序继续执行。</p>
<ul>
<li><strong>分代回收</strong></li>
</ul>
<p>与其他回收器一样，<strong>分代概念</strong> 在 <code>G1</code> 中依然得以保留。虽然 <code>G1</code> 可以不需要 <strong>其他回收器配合</strong> 就能独立管理 <strong>整个GC堆</strong>，但它能够采用 <strong>不同的策略</strong> 去处理 <strong>新创建的对象</strong> 和 <strong>已经存活</strong> 一段时间、<strong>熬过多次</strong> <code>GC</code> 的旧对象，以获取更好的回收效果。<strong>新生代</strong> 和 <strong>老年代</strong> 不再是 <strong>物理隔离</strong>，是多个 <strong>大小相等</strong> 的独立 <code>Region</code>。</p>
<ul>
<li><strong>空间整合</strong></li>
</ul>
<p>与 <code>CMS</code> 的 <strong>标记—清理</strong> 算法不同，<code>G1</code> 从 <strong>整体</strong> 来看是基于 <strong>标记—整理</strong> 算法实现的回收器。从 <strong>局部</strong>（两个 <code>Region</code> 之间）上来看是基于 <strong>复制算法</strong> 实现的。</p>
<p>但无论如何，这 <strong>两种算法</strong> 都意味着 <code>G1</code> 运作期间 <strong>不会产生内存空间碎片</strong>，回收后能提供规整的可用内存。这种特性有利于程序长时间运行，<strong>分配大对象</strong> 时不会因为无法找到 <strong>连续内存空间</strong> 而提前触发 <strong>下一次</strong> <code>GC</code>。</p>
<ul>
<li><strong>可预测的停顿</strong></li>
</ul>
<p>这是 <code>G1</code> 相对于 <code>CMS</code> 的另一大优势，<strong>降低停顿时间</strong> 是 <code>G1</code> 和 <code>CMS</code> 共同的关注点。<code>G1</code> 除了追求 <strong>低停顿</strong> 外，还能建立 <strong>可预测</strong> 的 <strong>停顿时间模型</strong>，能让使用者明确指定在一个 <strong>长度</strong> 为 <code>M</code> 毫秒的 <strong>时间片段</strong> 内，消耗在 <strong>垃圾回收</strong> 上的时间不得超过 <code>N</code> 毫秒。（后台维护的 <strong>优先列表</strong>，优先回收 <strong>价值大</strong> 的 <code>Region</code>）。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社</p>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5b651200f265da0fa00a38d7" target="_blank" rel="noopener">JVM垃圾回收器</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/GC/" rel="tag"># GC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E9%83%A8%E7%B1%BB/" rel="prev" title="深入理解Java内部类">
      <i class="fa fa-chevron-left"></i> 深入理解Java内部类
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/15/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/" rel="next" title="Java异常处理机制总结">
      Java异常处理机制总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#正文"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">2.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-吞吐量"><span class="nav-number">2.1.1.</span> <span class="nav-text">1. 吞吐量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-停顿时间"><span class="nav-number">2.1.2.</span> <span class="nav-text">2. 停顿时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-GC的名词"><span class="nav-number">2.1.3.</span> <span class="nav-text">3. GC的名词</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-新生代GC（Minor-GC）"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">3.1. 新生代GC（Minor GC）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-老年代GC（Major-GC）"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">3.2. 老年代GC（Major GC）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-并发与并行"><span class="nav-number">2.1.4.</span> <span class="nav-text">4. 并发与并行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-串行（Parallel）"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">4.1. 串行（Parallel）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-并发（Concurrent）"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">4.2. 并发（Concurrent）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-并行（Parallel）"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">4.3. 并行（Parallel）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收算法"><span class="nav-number">2.2.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-根搜索算法"><span class="nav-number">2.2.1.</span> <span class="nav-text">1. 根搜索算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-标记-清除算法"><span class="nav-number">2.2.2.</span> <span class="nav-text">2. 标记 - 清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-复制算法"><span class="nav-number">2.2.3.</span> <span class="nav-text">3. 复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-标记-整理算法"><span class="nav-number">2.2.4.</span> <span class="nav-text">4. 标记 - 整理算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收器"><span class="nav-number">2.3.</span> <span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-垃圾回收器分类标准"><span class="nav-number">2.3.1.</span> <span class="nav-text">1. 垃圾回收器分类标准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-七种垃圾回收器概述"><span class="nav-number">2.3.2.</span> <span class="nav-text">2. 七种垃圾回收器概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-单线程垃圾回收器"><span class="nav-number">2.3.3.</span> <span class="nav-text">3. 单线程垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-Serial（-XX-UseSerialGC）"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">3.1. Serial（-XX:+UseSerialGC）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-Serial-Old（-XX-UseSerialGC）"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">3.2. Serial Old（-XX:+UseSerialGC）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-多线程垃圾回收器（吞吐量优先）"><span class="nav-number">2.3.4.</span> <span class="nav-text">4. 多线程垃圾回收器（吞吐量优先）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-ParNew（-XX-UseParNewGC）"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">4.1. ParNew（-XX:+UseParNewGC）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-Parallel-Scavenge（-XX-UseParallelGC）"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">4.2. Parallel Scavenge（-XX:+UseParallelGC）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-Parallel-Old（-XX-UseParallelOldGC）"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">4.3. Parallel Old（-XX:+UseParallelOldGC）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-其他的回收器（停顿时间优先）"><span class="nav-number">2.3.5.</span> <span class="nav-text">5. 其他的回收器（停顿时间优先）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-CMS（-XX-UseConcMarkSweepGC）"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">5.1. CMS（-XX:+UseConcMarkSweepGC）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-G1回收器（垃圾区域Region优先）"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">5.2. G1回收器（垃圾区域Region优先）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">3.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EricMa"
      src="/images/eric.png">
  <p class="site-author-name" itemprop="name">EricMa</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">197</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Eric-Ma-C" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Eric-Ma-C" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chaoma@zju.edu.cn" title="E-Mail → mailto:chaoma@zju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EricMa</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">712k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
