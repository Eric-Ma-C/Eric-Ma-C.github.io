<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Eric&#39;s Blogs">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Eric&#39;s Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="EricMa">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Eric's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Eric's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Better Code, Better Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/01/%E5%B8%B8%E7%94%A8%E7%9A%84http%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%BB%A5%E5%8F%8A%E5%93%8D%E5%BA%94%E5%A4%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/01/%E5%B8%B8%E7%94%A8%E7%9A%84http%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%BB%A5%E5%8F%8A%E5%93%8D%E5%BA%94%E5%A4%B4/" class="post-title-link" itemprop="url">常用的http请求头以及响应头</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-02 05:50:52 / 修改时间：13:56:25" itemprop="dateCreated datePublished" datetime="2020-08-02T05:50:52+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、常用的http请求头"><a href="#一、常用的http请求头" class="headerlink" title="一、常用的http请求头"></a>一、常用的http请求头</h3><h3 id="1-Accept"><a href="#1-Accept" class="headerlink" title="1.Accept"></a><strong>1.Accept</strong></h3><ul>
<li><strong>Accept: text/html</strong> 浏览器可以接受服务器回发的类型为 text/html。</li>
<li><strong>Accept: */*</strong>  代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)。</li>
</ul>
<h3 id="2-Accept-Encoding"><a href="#2-Accept-Encoding" class="headerlink" title="2.Accept-Encoding"></a>2.Accept-Encoding</h3><ul>
<li><strong>Accept-Encoding: gzip, deflate</strong> 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）。</li>
</ul>
<h3 id="3-Accept-Language"><a href="#3-Accept-Language" class="headerlink" title="3.Accept-Language"></a>3.Accept-Language</h3><ul>
<li><strong>Accept-Language:zh-CN,zh;q=0.9</strong> 浏览器申明自己接收的语言。</li>
</ul>
<h3 id="4-Connection"><a href="#4-Connection" class="headerlink" title="4.Connection"></a>4.Connection</h3><ul>
<li><strong>Connection: keep-alive</strong> 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</li>
<li><strong>Connection: close</strong> 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</li>
</ul>
<h3 id="5-Host（发送请求时，该报头域是必需的）"><a href="#5-Host（发送请求时，该报头域是必需的）" class="headerlink" title="5.Host（发送请求时，该报头域是必需的）"></a>5.Host（发送请求时，该报头域是必需的）</h3><ul>
<li><strong>Host:<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></strong> 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。</li>
</ul>
<h3 id="6-Referer"><a href="#6-Referer" class="headerlink" title="6.Referer"></a>6.Referer</h3><ul>
<li><strong>Referer:<a href="https://www.baidu.com/?tn=62095104_8_oem_dg" target="_blank" rel="noopener">https://www.baidu.com/?tn=62095104_8_oem_dg</a></strong> 当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。</li>
</ul>
<h3 id="7-User-Agent"><a href="#7-User-Agent" class="headerlink" title="7.User-Agent"></a>7.User-Agent</h3><ul>
<li><strong>User-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36</strong> 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。</li>
</ul>
<h3 id="8-Cache-Control"><a href="#8-Cache-Control" class="headerlink" title="8.Cache-Control"></a>8.Cache-Control</h3><ul>
<li><strong>Cache-Control:private</strong> 默认为private 响应只能够作为私有的缓存，不能再用户间共享</li>
<li><strong>`\</strong>Cache-Control:public** `**响应会被缓存，并且在多用户间共享。正常情况, 如果要求HTTP认证,响应会自动设置为 private.</li>
<li><strong>Cache-Control:must-revalidate</strong> 响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。</li>
<li><strong>Cache-Control:no-cache</strong> 响应不会被缓存,而是实时向服务器端请求资源。</li>
<li><strong>Cache-Control:max-age=10</strong> 设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。</li>
<li><strong><code>Cache-Control:no-store</code></strong>在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。</li>
</ul>
<h3 id="9-Cookie"><a href="#9-Cookie" class="headerlink" title="9.Cookie"></a>9.Cookie</h3><p>Cookie是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如cookie会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然cookie里面的数据不仅仅是上述范围，还有很多信息可以存储是cookie里面，比如sessionid等。</p>
<h3 id="10-Range（用于断点续传）"><a href="#10-Range（用于断点续传）" class="headerlink" title="10.Range（用于断点续传）"></a>10.Range（用于断点续传）</h3><ul>
<li><strong>Range:bytes=0-5</strong> 指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。</li>
</ul>
<h2 id="二、常用的http响应头"><a href="#二、常用的http响应头" class="headerlink" title="二、常用的http响应头"></a>二、常用的http响应头</h2><h3 id="1-Cache-Control（对应请求中的Cache-Control）"><a href="#1-Cache-Control（对应请求中的Cache-Control）" class="headerlink" title="1.Cache-Control（对应请求中的Cache-Control）"></a>1.Cache-Control（对应请求中的Cache-Control）</h3><ul>
<li><strong>Cache-Control:private</strong> 默认为private  响应只能够作为私有的缓存，不能再用户间共享</li>
<li><strong><em>\</em>Cache-Control:public**</strong> 浏览器和缓存服务器都可以缓存页面信息。</li>
<li><strong>Cache-Control:must-revalidate</strong>  对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时。</li>
<li><strong>Cache-Control:no-cache</strong>  浏览器和缓存服务器都不应该缓存页面信息。</li>
<li><strong>Cache-Control:max-age=10</strong> 是通知浏览器10秒之内不要烦我，自己从缓冲区中刷新。</li>
<li><strong>Cache-Control:no-store</strong> 请求和响应的信息都不应该被存储在对方的磁盘系统中。</li>
</ul>
<h3 id="2-Content-Type"><a href="#2-Content-Type" class="headerlink" title="2.Content-Type"></a>2.Content-Type</h3><ul>
<li><strong>Content-Type：text/html;charset=UTF-8</strong> 告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。</li>
</ul>
<h3 id="3-Content-Encoding"><a href="#3-Content-Encoding" class="headerlink" title="3.Content-Encoding"></a>3.Content-Encoding</h3><ul>
<li><strong>Content-Encoding:gzip</strong> 告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。</li>
</ul>
<h3 id="4-Date"><a href="#4-Date" class="headerlink" title="4.Date"></a>4.Date</h3><ul>
<li><strong>Date: Tue, 03 Apr 2018 03:52:28 GMT</strong> 这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。</li>
</ul>
<h3 id="5-Server"><a href="#5-Server" class="headerlink" title="5.Server"></a>5.Server</h3><ul>
<li><strong>Server：Tengine/1.4.6</strong> 这个是服务器和相对应的版本，只是告诉客户端服务器信息<strong>。</strong></li>
</ul>
<h3 id="6-Transfer-Encoding"><a href="#6-Transfer-Encoding" class="headerlink" title="6.Transfer-Encoding"></a>6.Transfer-Encoding</h3><ul>
<li><strong>Transfer-Encoding：chunked</strong> 这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。</li>
</ul>
<h3 id="7-Expires"><a href="#7-Expires" class="headerlink" title="7.Expires"></a>7.Expires</h3><ul>
<li><strong>Expires:Sun, 1 Jan 2000 01:00:00 GMT</strong> 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有Cache-Control：max-age=*这个响应头准确的，因为max-age=date中的date是个相对时间，不仅更好理解，也更准确。</li>
</ul>
<h3 id="8-Last-Modified"><a href="#8-Last-Modified" class="headerlink" title="8.Last-Modified"></a>8.Last-Modified</h3><ul>
<li><strong>Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</strong> 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</li>
</ul>
<h3 id="9-Connection"><a href="#9-Connection" class="headerlink" title="9.Connection"></a>9.Connection</h3><ul>
<li><strong>Connection：keep-alive</strong> 这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。</li>
</ul>
<h3 id="10-Etag"><a href="#10-Etag" class="headerlink" title="10.Etag"></a><strong>10.Etag</strong></h3><ul>
<li><strong>ETag: “737060cd8c284d8af7ad3082f209582d”</strong> 就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。</li>
</ul>
<h3 id="11-Refresh"><a href="#11-Refresh" class="headerlink" title="11.Refresh"></a>11.Refresh</h3><ul>
<li><strong>Refresh: 5; url=<a href="http://baidu.com" target="_blank" rel="noopener">http://baidu.com</a></strong> 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。</li>
</ul>
<h3 id="12-Access-Control-Allow-Origin"><a href="#12-Access-Control-Allow-Origin" class="headerlink" title="12.Access-Control-Allow-Origin"></a>12.Access-Control-Allow-Origin</h3><ul>
<li><strong>Access-Control-Allow-Origin: *</strong>  <em>号代表所有网站可以跨域资源共享，如果当前字段为</em>那么Access-Control-Allow-Credentials就不能为true</li>
<li><strong>Access-Control-Allow-Origin: <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></strong> 指定哪些网站可以跨域资源共享</li>
</ul>
<h3 id="13-Access-Control-Allow-Methods"><a href="#13-Access-Control-Allow-Methods" class="headerlink" title="13.Access-Control-Allow-Methods"></a>13.Access-Control-Allow-Methods</h3><ul>
<li><strong>Access-Control-Allow-Methods：GET,POST,PUT,DELETE</strong> 允许哪些方法来访问</li>
</ul>
<h3 id="14-Access-Control-Allow-Credentials"><a href="#14-Access-Control-Allow-Credentials" class="headerlink" title="14.Access-Control-Allow-Credentials"></a>14.Access-Control-Allow-Credentials</h3><ul>
<li><strong>Access-Control-Allow-Credentials: true</strong> 是否允许发送cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。如果access-control-allow-origin为*，当前字段就不能为true</li>
</ul>
<h3 id="15-Content-Range"><a href="#15-Content-Range" class="headerlink" title="15.Content-Range"></a><strong>15.Content-Range</strong></h3><ul>
<li><strong>Content-Range: bytes 0-5/7877</strong> 指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。</li>
</ul>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/6844903745004765198" target="_blank" rel="noopener">常用的http请求头以及响应头</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/01/Cookie%20%E5%92%8C%20Session%20%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/01/Cookie%20%E5%92%8C%20Session%20%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Cookie 和 Session 关系和区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-02 02:26:29 / 修改时间：10:27:37" itemprop="dateCreated datePublished" datetime="2020-08-02T02:26:29+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在技术面试中，经常被问到“Cookie和Session的区别”，大家都知道一些，Session比Cookie安全，Session是存储在服务器端的，Cookie是存储在客户端的，然而如果让你更详细地说明，恐怕就不怎么清楚了。</p>
<p>本文分别对Cookie与Session做一个介绍和总结，并分别对两个知识点进行对比分析，让大家对Cookie和Session有更深入的了解。</p>
<h2 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP"></a>什么是HTTP</h2><p>首先要先介绍什么是HTTP</p>
<p><strong>HTTP</strong>:超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p>
<p>HTTP 是无状态协议，说明它不能以状态来区分和管理请求和响应。也就是说，服务器单从网络连接上无从知道客户身份。</p>
<p>可是怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621eec70c0418a2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1.Cookie"></a>1.Cookie</h2><h3 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h3><p>Cookie翻译过来是‘ 小甜饼’，Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，实际上Cookie是服务器在<strong>本地机器</strong>上存储的一小段文本，并随着每次请求发送到服务器。</p>
<p><strong>Cookie技术通过请求和响应报文中写入Cookie信息来控制客户端的状态。</strong></p>
<p>Cookie会根据响应报文里的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下客户端再向服务端发起请求时，客户端会自动在请求报文中加入Cookie值之后发送出去.</p>
<p>之后服务端发现客户端发送过来的Cookie后，会检查是那个客户端发送过来的请求，然后对服务器上的记录，最后得到了之前的状态信息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621f0b5f29d7f7c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>客户端保存了Cookie之后的发起请求</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621f13fade59484?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621f407b4b82236?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>上图很清晰地展示了发生Cookie 交互的情景，HTTP 请求报文和响应报文的内容如图所示。</p>
<p>第一可以很明显的可出首部字段内没有Cookie的相关信息，其次也能看到set-Cookie里的信息，这就是服务器端生撑的Cookei信息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621f4051a540bbb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>看之后请求，请求报文里都自动发送Cookie信息了。</p>
<h3 id="set-Cookie的字段的属性"><a href="#set-Cookie的字段的属性" class="headerlink" title="set-Cookie的字段的属性"></a>set-Cookie的字段的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: logcookie&#x3D;3qjj; expires&#x3D;Wed, 13-Mar-2019 12:08:53 GMT; Max-Age&#x3D;31536000; path&#x3D;&#x2F;;</span><br><span class="line"> domain&#x3D;fafa.com;secure; HttpOnly;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>



<p>以上面的set-cookie的例子，说一下set-cookie的属性</p>
<p>1.<code>logcookie=3qjj</code> 赋予Cookie的名称和值，logcookie是名字 ，3qjj是值</p>
<p>2.expires 是设置cookie有效期。当省略expires属性时，Cookie仅在关闭浏览器之前有效。可以通过覆盖已过期的Cookie，设置这个Cookie的过期时间是过去的时间，实现对客户端Cookie 的实质性删除操作。</p>
<p>3.path 是限制指定Cookie 的发送范围的文件目录。不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱有期待。</p>
<p>4.domain 通过domain属性指定的域名可以做到与结尾匹配一致。比如，指定domain是fafa.com，除了fafa.com那么<a href="http://www.fafa.com等都可以发送Cookie。" target="_blank" rel="noopener">www.fafa.com等都可以发送Cookie。</a></p>
<p>5.secure 设置web页面只有在HTTPS安全连接时，才可以发送Cookie。HHTP则不可以进行回收。</p>
<p>6.HttpOnly 它使JavaScript 脚本无法获得Cookie，通过上述设置，通常从Web 页面内还可以对Cookie 进行读取操作。但使用JavaScript 的document.cookie 就无法读取附加HttpOnly 属性后的Cookie 的内容了</p>
<h2 id="2-Session管理和Cookie应用"><a href="#2-Session管理和Cookie应用" class="headerlink" title="2.Session管理和Cookie应用"></a>2.Session管理和Cookie应用</h2><h3 id="什么是Session"><a href="#什么是Session" class="headerlink" title="什么是Session"></a>什么是Session</h3><p>上面我讲到服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用。</p>
<p> PHP中的Session在默认情况下是使用客户端的Cookie来保存Session ID的，所以当客户端的cookie出现问题的时候就会影响Session了。必须注意的是：Session不一定必须依赖Cookie，这也是Session相比Cookie的高明之处。当客户端的Cookie被禁用或出现问题时，PHP会自动把Session ID附着在URL中，这样再通过Session ID就能跨页使用Session变量了。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621f6d2880ac3ab?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img">1.客户端把信息放入报文的实体部分，通常是以POST 方法把请求发送给服务器。</p>
<p>2.服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的信息进行验证，然后把用户的认证状态与Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段Set-Cookie 内写入Session ID（如PHPSESSID=l128ogl…）。你可以把Session ID 想象成一种用以区分不同用户的唯一Id。</p>
<p>步骤三：客户端接收到从服务器端发来的Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID 也随之发送到服务器。服务器端可通过验证接收到的Session ID 验证状态。</p>
<h2 id="3-Cookie与Session的区别"><a href="#3-Cookie与Session的区别" class="headerlink" title="3.Cookie与Session的区别"></a>3.Cookie与Session的区别</h2><ol>
<li>cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的；</li>
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；</li>
<li>单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；</li>
</ol>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/6844903575684907016" target="_blank" rel="noopener">Cookie 和 Session 关系和区别</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/01/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20RESTful%20%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/01/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20RESTful%20%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/" class="post-title-link" itemprop="url">如何理解 RESTful 的幂等性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-02 02:16:03 / 修改时间：10:23:45" itemprop="dateCreated datePublished" datetime="2020-08-02T02:16:03+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个HTTP方法是<strong>幂等</strong>的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener"><code>GET</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD" target="_blank" rel="noopener"><code>HEAD</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/PUT" target="_blank" rel="noopener"><code>PUT</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/DELETE" target="_blank" rel="noopener"><code>DELETE</code></a> 等方法都是<strong>幂等</strong>的，而 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener"><code>POST</code></a> 方法不是。所有的 <a href="https://developer.mozilla.org/en-US/docs/Glossary/safe" target="_blank" rel="noopener">safe</a> 方法(指不修改资源的 HTTP 方法)也都是幂等的。</p>
<p>幂等性只与后端服务器的实际状态有关，而每一次请求接收到的状态码不一定相同。例如，第一次调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/DELETE" target="_blank" rel="noopener"><code>DELETE</code></a> 方法有可能返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200" target="_blank" rel="noopener"><code>200</code></a>，但是后续的请求可能会返回<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/404" target="_blank" rel="noopener"><code>404</code></a>。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/DELETE" target="_blank" rel="noopener"><code>DELETE</code></a> 的言外之意是，开发者<strong>不应该使用<code>DELETE</code>方法实现具有删除最后条目功能的 RESTful API</strong>。</p>
<p>需要注意的是，服务器不一定会确保请求方法的幂等性，有些应用可能会错误地打破幂等性约束。</p>
<p><code>GET /pageX HTTP/1.1</code>是幂等的。连续调用多次，客户端接收到的结果都是一样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /pageX HTTP/1.1   </span><br><span class="line">GET /pageX HTTP/1.1   </span><br><span class="line">GET /pageX HTTP/1.1   </span><br><span class="line">GET /pageX HTTP/1.1</span><br></pre></td></tr></table></figure>

<p><code>POST /add_row HTTP/1.1</code>不是幂等的。如果调用多次，就会增加多行记录：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /add_row HTTP/1.1</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 2nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 3rd row</span><br></pre></td></tr></table></figure>

<p><code>DELETE /idX/delete HTTP/1.1</code>是幂等的，即便是不同请求之间接收到的状态码不一样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</span><br></pre></td></tr></table></figure>

<h2 id="安全方法"><a href="#安全方法" class="headerlink" title="安全方法"></a>安全方法</h2><p>安全方法是指不修改资源的 HTTP 方法。譬如，当使用 GET 或者 HEAD 作为资源 URL，都必须不去改变资源。然而，这并不全准确。意思是：它不改变资源的 表示形式。对于安全方法，它仍然可能改变服务器上的内容或资源，但这必须不导致不同的表现形式。</p>
<p>这表示下述是不对的，因为它实际上将删除博客文章：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;blog&#x2F;1234&#x2F;delete HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<p>安全方法是那些可以被缓存、对资源无损预加载的方法。</p>
<h2 id="幂等性分析"><a href="#幂等性分析" class="headerlink" title="幂等性分析"></a>幂等性分析</h2><p>HTTP幂等方法，是指无论调用多少次都不会有不同结果的 HTTP 方法。不管你调用一次，还是调用一百次，一千次，结果都是相同的。</p>
<p>还是以之前的博文的例子为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET     &#x2F;tickets       # 获取ticket列表</span><br><span class="line">GET     &#x2F;tickets&#x2F;12    # 查看某个具体的ticket</span><br><span class="line">POST    &#x2F;tickets       # 新建一个ticket</span><br><span class="line">PUT     &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br><span class="line">PATCH   &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br><span class="line">DELETE  &#x2F;tickets&#x2F;12    # 删除ticekt 12</span><br></pre></td></tr></table></figure>

<h3 id="HTTP-GET方法"><a href="#HTTP-GET方法" class="headerlink" title="HTTP GET方法"></a>HTTP GET方法</h3><p>HTTP GET方法，用于获取资源，不管调用多少次接口，结果都不会改变，所以是幂等的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET     &#x2F;tickets       # 获取ticket列表</span><br><span class="line">GET     &#x2F;tickets&#x2F;12    # 查看某个具体的ticket</span><br></pre></td></tr></table></figure>

<p>只是查询数据，不会影响到资源的变化，因此我们认为它幂等。</p>
<p>值得注意，幂等性指的是作用于结果而非资源本身。怎么理解呢？例如，这个HTTP GET方法可能会每次得到不同的返回内容，但并不影响资源。</p>
<p>可能你会问有这种情况么？当然有咯。例如，我们有一个接口获取当前时间，我们就应该设计成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET     &#x2F;service_time # 获取服务器当前时间</span><br></pre></td></tr></table></figure>

<p>它本身不会对资源本身产生影响，因此满足幂等性。</p>
<h3 id="HTTP-POST方法"><a href="#HTTP-POST方法" class="headerlink" title="HTTP POST方法"></a>HTTP POST方法</h3><p>HTTP POST方法是一个非幂等方法，因为调用多次，都将产生新的资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST    &#x2F;tickets       # 新建一个ticket</span><br></pre></td></tr></table></figure>

<p>因为它会对资源本身产生影响，每次调用都会有新的资源产生，因此不满足幂等性。</p>
<h3 id="HTTP-PUT方法"><a href="#HTTP-PUT方法" class="headerlink" title="HTTP PUT方法"></a>HTTP PUT方法</h3><p>HTTP PUT方法是不是幂等的呢？我们来看下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT     &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br></pre></td></tr></table></figure>

<p>因为它直接把实体部分的数据替换到服务器的资源，我们多次调用它，只会产生一次影响，但是有相同结果的 HTTP 方法，所以满足幂等性。</p>
<h3 id="HTTP-PATCH方法"><a href="#HTTP-PATCH方法" class="headerlink" title="HTTP PATCH方法"></a>HTTP PATCH方法</h3><p>HTTP PATCH方法是非幂等的。HTTP POST方法和HTTP PUT方法可能比较好理解，但是HTTP PATCH方法只是更新部分资源，怎么是非幂等的呢?</p>
<p>因为，PATCH提供的实体则需要根据程序或其它协议的定义，解析后在服务器上执行，以此来修改服务器上的资源。换句话说，PATCH请求是会执行某个程序的，如果重复提交，程序可能执行多次，对服务器上的资源就可能造成额外的影响，这就可以解释它为什么是非幂等的了。</p>
<p>可能你还不能理解这点。我们举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATCH   &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br></pre></td></tr></table></figure>

<p>此时，我们服务端对方法的处理是，当调用一次方法，更新部分字段，将这条ticket记录的操作记录加一，这次，每次调用的资源是不是变了呢，所以它是有可能是非幂等的操作。</p>
<h3 id="HTTP-DELETE方法"><a href="#HTTP-DELETE方法" class="headerlink" title="HTTP DELETE方法"></a>HTTP DELETE方法</h3><p>HTTP DELETE方法用于删除资源，会将资源删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE  &#x2F;tickets&#x2F;12    # 删除ticekt 12</span><br></pre></td></tr></table></figure>

<p>调用一次和多次对资源产生影响是相同的，所以也满足幂等性。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="部分-HTTP-方法概览"><a href="#部分-HTTP-方法概览" class="headerlink" title="(部分) HTTP 方法概览"></a>(部分) HTTP 方法概览</h3><table>
<thead>
<tr>
<th align="left">HTTP Method</th>
<th align="left">Idempotent</th>
<th align="left">Safe</th>
</tr>
</thead>
<tbody><tr>
<td align="left">OPTIONS</td>
<td align="left">yes</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">GET</td>
<td align="left">yes</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">HEAD</td>
<td align="left">yes</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">PUT</td>
<td align="left">yes</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">POST</td>
<td align="left">no</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="left">yes</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">PATCH</td>
<td align="left">no</td>
<td align="left">no</td>
</tr>
</tbody></table>
<h2 id="如何设计符合幂等性的高质量RESTful-API"><a href="#如何设计符合幂等性的高质量RESTful-API" class="headerlink" title="如何设计符合幂等性的高质量RESTful API"></a>如何设计符合幂等性的高质量RESTful API</h2><h3 id="HTTP-GET方法-vs-HTTP-POST方法"><a href="#HTTP-GET方法-vs-HTTP-POST方法" class="headerlink" title="HTTP GET方法 vs HTTP POST方法"></a>HTTP GET方法 vs HTTP POST方法</h3><p>也许，你会想起一个面试题。HTTP请求的GET与POST方式有什么区别？你可能会回答到：GET方式通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。但是，我们现在从RESTful的资源角度来看待问题，HTTP GET方法是幂等的，所以它适合作为查询操作，HTTP POST方法是非幂等的，所以用来表示新增操作。</p>
<p>但是，也有例外，我们有的时候可能需要把查询方法改造成HTTP POST方法。比如，超长（1k）的GET URL使用POST方法来替代，因为GET受到URL长度的限制。虽然，它不符合幂等性，但是它是一种折中的方案。</p>
<h3 id="HTTP-POST方法-vs-HTTP-PUT方法"><a href="#HTTP-POST方法-vs-HTTP-PUT方法" class="headerlink" title="HTTP POST方法 vs HTTP PUT方法"></a>HTTP POST方法 vs HTTP PUT方法</h3><p>对于HTTP POST方法和TTP PUT方法，我们一般的理解是POST表示创建资源，PUT表示更新资源。当然，这个是正确的理解。</p>
<p>但是，实际上，两个方法都用于创建资源，更为本质的差别是在幂等性。HTTP POST方法是非幂等，所以用来表示创建资源，HTTP PUT方法是幂等的，因此表示更新资源更加贴切。</p>
<h3 id="HTTP-PUT方法-vs-HTTP-PATCH方法"><a href="#HTTP-PUT方法-vs-HTTP-PATCH方法" class="headerlink" title="HTTP PUT方法 vs HTTP PATCH方法"></a>HTTP PUT方法 vs HTTP PATCH方法</h3><p>此时，你看会有另外一个问题。HTTP PUT方法和HTTP PATCH方法，都是用来表述更新资源，它们之间有什么区别呢？我们一般的理解是PUT表示更新全部资源，PATCH表示更新部分资源。首先，这个是我们遵守的第一准则。根据上面的描述，PATCH方法是非幂等的，因此我们在设计我们服务端的RESTful API的时候，也需要考虑。如果，我们想要明确的告诉调用者我们的资源是幂等的，我的设计更倾向于使用HTTP PUT方法。</p>
<hr>
<p>本文整理自</p>
<p><a href="">如何理解 RESTful 的幂等性</a></p>
<p>[RESTful 手册](<a href="https://sofish.github.io/restcookbook/http" target="_blank" rel="noopener">https://sofish.github.io/restcookbook/http</a> methods/idempotency/)</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/幂等" target="_blank" rel="noopener">幂等</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%9A%84KMP%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/21/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%9A%84KMP%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">字符串匹配的KMP算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-21 13:39:55 / 修改时间：21:43:31" itemprop="dateCreated datePublished" datetime="2020-07-21T13:39:55+08:00">2020-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">程序设计</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="http://en.wikipedia.org/wiki/String_searching_algorithm" target="_blank" rel="noopener">字符串匹配</a>是计算机的基本任务之一。</p>
<p>举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”？</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050101.jpg" alt="img"></p>
<p>许多算法可以完成这个任务，<a href="http://en.wikipedia.org/wiki/Knuth–Morris–Pratt_algorithm" target="_blank" rel="noopener">Knuth-Morris-Pratt算法</a>（简称KMP）是最常用的之一。它以三个发明者命名，起头的那个K就是著名科学家Donald Knuth。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050102.jpg" alt="img"></p>
<p>这种算法不太容易理解，网上有很多<a href="http://www.google.com/search?q=Knuth-Morris-Pratt+algorithm" target="_blank" rel="noopener">解释</a>，但读起来都很费劲。直到读到<a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="noopener">Jake Boxer</a>的文章，我才真正理解这种算法。下面，我用自己的语言，试图写一篇比较好懂的KMP算法解释。</p>
<p>1.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050103.png" alt="img"></p>
<p>首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。</p>
<p>2.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050104.png" alt="img"></p>
<p>因为B与A不匹配，搜索词再往后移。</p>
<p>3.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050105.png" alt="img"></p>
<p>就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。</p>
<p>4.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050106.png" alt="img"></p>
<p>接着比较字符串和搜索词的下一个字符，还是相同。</p>
<p>5.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png" alt="img"></p>
<p>直到字符串有一个字符，与搜索词对应的字符不相同为止。</p>
<p>6.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050108.png" alt="img"></p>
<p>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p>
<p>7.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png" alt="img"></p>
<p>一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。</p>
<p>8.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png" alt="img"></p>
<p>怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。</p>
<p>9.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png" alt="img"></p>
<p>已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：</p>
<blockquote>
<p>　　移动位数 = 已匹配的字符数 - 对应的部分匹配值</p>
</blockquote>
<p>因为 6 - 2 等于4，所以将搜索词向后移动4位。</p>
<p>10.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050110.png" alt="img"></p>
<p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。</p>
<p>11.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050111.png" alt="img"></p>
<p>因为空格与A不匹配，继续后移一位。</p>
<p>12.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050112.png" alt="img"></p>
<p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。</p>
<p>13.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050113.png" alt="img"></p>
<p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。</p>
<p>14.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050114.png" alt="img"></p>
<p>下面介绍《部分匹配表》是如何产生的。</p>
<p>首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p>
<p>15.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png" alt="img"></p>
<p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，</p>
<blockquote>
<p>　　－　“A”的前缀和后缀都为空集，共有元素的长度为0；</p>
<p>　　－　“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</p>
<p>　　－　“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</p>
<p>　　－　“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</p>
<p>　　－　“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</p>
<p>　　－　“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</p>
<p>　　－　“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</p>
</blockquote>
<p>16.</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050112.png" alt="img"></p>
<p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p>
<hr>
<p>本文整理自</p>
<p><a href="[http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html](http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html)">字符串匹配的KMP算法</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/21/%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">堆外内存的回收机制分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-21 12:46:02 / 修改时间：20:48:47" itemprop="dateCreated datePublished" datetime="2020-07-21T12:46:02+08:00">2020-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>JVM启动时分配的内存，称为堆内存，与之相对的，在代码中还可以使用堆外内存，比如Netty，广泛使用了堆外内存，但是这部分的内存并不归JVM管理，GC算法并不会对它们进行回收，所以在使用堆外内存时，要格外小心，防止内存一直得不到释放，造成线上故障。</p>
<h3 id="堆外内存的申请和释放"><a href="#堆外内存的申请和释放" class="headerlink" title="堆外内存的申请和释放"></a>堆外内存的申请和释放</h3><p>JDK的<code>ByteBuffer</code>类提供了一个接口<code>allocateDirect(int capacity)</code>进行堆外内存的申请，底层通过<code>unsafe.allocateMemory(size)</code>实现，接下去看看在JVM层面是如何实现的。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2184951-13c6c6ebf2cecc82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>可以发现，最底层是通过<code>malloc</code>方法申请的，但是这块内存需要进行手动释放，JVM并不会进行回收，幸好<code>Unsafe</code>提供了另一个接口<code>freeMemory</code>可以对申请的堆外内存进行释放。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2184951-abe6aff129c546fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1180/format/webp" alt="img"></p>
<h3 id="堆外内存的回收机制"><a href="#堆外内存的回收机制" class="headerlink" title="堆外内存的回收机制"></a>堆外内存的回收机制</h3><p>如果每次申请堆外内存，都需要在代码中显示的释放，对于Java这门语言的设计来说，显然不够合理，既然JVM不会管理这些堆外内存，它们是如何回收的呢？</p>
<h4 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h4><p>JDK中使用<code>DirectByteBuffer</code>对象来表示堆外内存，每个<code>DirectByteBuffer</code>对象在初始化时，都会创建一个对用的<code>Cleaner</code>对象，这个<code>Cleaner</code>对象会在合适的时候执行<code>unsafe.freeMemory(address)</code>，从而回收这块堆外内存。</p>
<p>当初始化一块堆外内存时，对象的引用关系如下：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2184951-4f810a6be523de33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>其中<code>first</code>是<code>Cleaner</code>类的静态变量，<code>Cleaner</code>对象在初始化时会被添加到<code>Clener</code>链表中，和<code>first</code>形成引用关系，<code>ReferenceQueue</code>是用来保存需要回收的<code>Cleaner</code>对象。</p>
<p>如果该<code>DirectByteBuffer</code>对象在一次GC中被回收了</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2184951-510161812431ac12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>此时，只有<code>Cleaner</code>对象唯一保存了堆外内存的数据（开始地址、大小和容量），在下一次FGC时，把该<code>Cleaner</code>对象放入到<code>ReferenceQueue</code>中，并触发<code>clean</code>方法。</p>
<p><code>Cleaner</code>对象的<code>clean</code>方法主要有两个作用：<br> 1、把自身从<code>Clener</code>链表删除，从而在下次GC时能够被回收<br> 2、释放堆外内存</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Paranoia</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span>.freeMemory(address);</span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果JVM一直没有执行FGC的话，无效的<code>Cleaner</code>对象就无法放入到ReferenceQueue中，从而堆外内存也一直得不到释放，内存岂不是会爆？</p>
<p>其实在初始化<code>DirectByteBuffer</code>对象时，如果当前堆外内存的条件很苛刻时，会主动调用<code>System.gc()</code>强制执行FGC。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2184951-39f8c22847e7c11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1086/format/webp" alt="img"></p>
<p>不过很多线上环境的JVM参数有<code>-XX:+DisableExplicitGC</code>，导致了<code>System.gc()</code>等于一个空函数，根本不会触发FGC，这一点在使用Netty框架时需要注意是否会出问题。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://www.jianshu.com/p/35cf0f348275" target="_blank" rel="noopener">堆外内存的回收机制分析</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/finalize%20%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/21/finalize%20%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">finalize 方法详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-21 11:52:20 / 修改时间：19:54:13" itemprop="dateCreated datePublished" datetime="2020-07-21T11:52:20+08:00">2020-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JVM-的一些知识"><a href="#JVM-的一些知识" class="headerlink" title="JVM 的一些知识"></a>JVM 的一些知识</h1><p>在说明finalize()的用法之前要树立有关于java垃圾回收器几个观点:</p>
<ul>
<li>对象可以不被垃圾回收</li>
</ul>
<p>java的垃圾回收遵循一个特点, 就是能不回收就不会回收.只要程序的内存没有达到即将用完的地步, 对象占用的空间就不会被释放。</p>
<p>因为如果程序正常结束了,而且垃圾回收器没有释放申请的内存, 那么随着程序的正常退出, 申请的内存会自动交还给操作系统;</p>
<p>而且垃圾回收本身就需要付出代价, 是有一定开销的, 如果不使用,就不会存在这一部分的开销。</p>
<ul>
<li>垃圾回收只能回收内存</li>
</ul>
<p>而且只能回收内存中由java创建对象方式(堆)创建的对象所占用的那一部分内存, 无法回收其他资源, 比如文件操作的句柄, 数据库的连接等等。</p>
<ul>
<li>垃圾回收不是C++中的析构</li>
</ul>
<p>两者不是对应关系, 因为第一点就指出了垃圾回收的发生是不确定的, 而C++中析构函数是由程序员控制(delete) 或者离开器作用域时自动调用发生, 是在确定的时间对对象进行销毁并释放其所占用的内存。</p>
<ul>
<li>调用垃圾回收器(GC)不一定保证垃圾回收器的运行</li>
</ul>
<h1 id="finalize的作用"><a href="#finalize的作用" class="headerlink" title="finalize的作用"></a>finalize的作用</h1><p>finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</p>
<p>finalize()与C++中的析构函数不是对应的。</p>
<p>C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性。</p>
<p>finalize() 的功能: 一旦垃圾回收器准备释放对象所占的内存空间, 如果对象覆盖了finalize()并且函数体内不能是空的, 就会首先调用对象的finalize(), 然后在下一次垃圾回收动作发生的时候真正收回对象所占的空间。</p>
<p>finalize() 有一个特点就是: JVM始终只调用一次. 无论这个对象被垃圾回收器标记为什么状态, finalize()始终只调用一次. 但是程序员在代码中主动调用的不记录在这之内。</p>
<h1 id="finalize函数的调用机制"><a href="#finalize函数的调用机制" class="headerlink" title="finalize函数的调用机制"></a>finalize函数的调用机制</h1><p>java虚拟机规范并没有硬性规定垃圾回收该不该搞，以及该如何搞。所以这里提到的调用机制不能保证适合所有jvm。</p>
<h2 id="何时被调用？"><a href="#何时被调用？" class="headerlink" title="何时被调用？"></a>何时被调用？</h2><p>finalize啥时候才会被调用捏？</p>
<p>一般来说，要等到JVM开始进行垃圾回收的时候，它才有可能被调用。</p>
<p>而JVM进行垃圾回收的时间点是非常不确定的，依赖于各种运行时的环境因素。</p>
<p>正是由于finalize函数调用时间点的不确定，导致了后面提到的某些缺点。</p>
<h2 id="谁来调用？"><a href="#谁来调用？" class="headerlink" title="谁来调用？"></a>谁来调用？</h2><p>常见的JVM会通过GC的垃圾回收线程来进行finalize函数的调用。</p>
<p>由于垃圾回收线程比较重要（人家好歹也是JVM的一个组成部分嘛），为了防止finalize函数抛出的异常影响到垃圾回收线程的运作，垃圾回收线程会在调用每一个finalize函数时进行try catch，如果捕获到异常，就直接丢弃，然后接着处理下一个失效对象的finalize函数。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>不建议用finalize方法完成“非内存资源”的清理工作</p>
<h2 id="不建议使用的原因"><a href="#不建议使用的原因" class="headerlink" title="不建议使用的原因"></a>不建议使用的原因</h2><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><p>一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法</p>
<p>System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们</p>
<p>Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行</p>
<p>finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行</p>
<p>对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的</p>
<p>finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为)</p>
<h2 id="适合的场景"><a href="#适合的场景" class="headerlink" title="适合的场景"></a>适合的场景</h2><p>finalize()主要使用的方面:</p>
<p>根据垃圾回收器的第2点可知, java垃圾回收器只能回收创建在堆中的java对象, 而对于不是这种方式创建的对象则没有方法处理, 这就需要使用finalize()对这部分对象所占的资源进行释放. 使用到这一点的就是JNI本地对象, 通过JNI来调用本地方法创建的对象只能通过finalize()保证使用之后进行销毁,释放内存</p>
<p>充当保证使用之后释放资源的最后一道屏障, 比如使用数据库连接之后未断开,并且由于程序员的个人原因忘记了释放连接, 这时就只能依靠finalize()函数来释放资源.</p>
<p>《thinking in java》中所讲到的“终结条件”验证, 通过finalize()方法来试图找出程序的漏洞</p>
<p>尽管finalize()可以主动调用, 但是最好不要主动调用, 因为在代码中主动调用之后, 如果JVM再次调用, 由于之前的调用已经释放过资源了,所以二次释放资源就有可能出现导致出现空指针等异常, 而恰好这些异常是没有被捕获的, 那么就造成对象处于被破坏的状态, 导致该对象所占用的某一部分资源无法被回收而浪费.</p>
<h2 id="尽量避免使用finalize"><a href="#尽量避免使用finalize" class="headerlink" title="尽量避免使用finalize():"></a>尽量避免使用finalize():</h2><p>finalize()不一定会被调用, 因为java的垃圾回收器的特性就决定了它不一定会被调用</p>
<p>就算finalize()函数被调用, 它被调用的时间充满了不确定性, 因为程序中其他线程的优先级远远高于执行 finalize() 函数线程的优先级。</p>
<p>也许等到finalize()被调用, 数据库的连接池或者文件句柄早就耗尽了。</p>
<p>如果一种未被捕获的异常在使用finalize方法时被抛出，这个异常不会被捕获，finalize方法的终结过程也会终止，造成对象出于破坏的状态。被破坏的对象又很可能导致部分资源无法被回收, 造成浪费。</p>
<p>finalize()和垃圾回收器的运行本身就要耗费资源, 也许会导致程序的暂时停止。</p>
<h2 id="禁止使用的原因"><a href="#禁止使用的原因" class="headerlink" title="禁止使用的原因"></a>禁止使用的原因</h2><h3 id="1-调用时间不确定—有资源浪费的风险"><a href="#1-调用时间不确定—有资源浪费的风险" class="headerlink" title="1.调用时间不确定—有资源浪费的风险"></a>1.调用时间不确定—有资源浪费的风险</h3><p>前面已经介绍了调用机制。</p>
<p>同学们应该认清“finalize的调用时机是很不确定的”这样一个事实。</p>
<p>所以，假如你把某些稀缺资源放到finalize()中释放，可能会导致该稀缺资源等上很久很久很久以后才被释放。</p>
<p>这可是资源的浪费啊！另外，某些类对象所携带的资源（比如某些JDBC的类）可能本身就很耗费内存，这些资源的延迟释放会造成很大的性能问题。</p>
<h3 id="2-可能不被调用—-有资源泄露的风险"><a href="#2-可能不被调用—-有资源泄露的风险" class="headerlink" title="2. 可能不被调用—-有资源泄露的风险"></a>2. 可能不被调用—-有资源泄露的风险</h3><p>很多同学以为finalize()总是会被调用，其实不然。</p>
<p>在某些情况下，finalize()压根儿不被调用。</p>
<p>比如在JVM退出的当口，内存中那些对象的finalize函数可能就不会被调用了。</p>
<p>估计有同学在打“runFinalizersOnExit”的主意，来确保所有的finalize在JVM退出前被调用。</p>
<p>很可惜也很遗憾，该方法从JDK 1.2开始，就已经被废弃了。即使该方法不被废弃，也是有很大的线程安全隐患滴！ 　　</p>
<p>从上述可以看出，一旦你依赖finalize()来帮你释放资源，那可是很不妙啊（有资源泄漏的危险）！</p>
<p>很多时候，资源泄露导致的性能问题更加严重，万万不可小看。</p>
<h3 id="3-对象可能在finalize函数调用时复活"><a href="#3-对象可能在finalize函数调用时复活" class="headerlink" title="3. 对象可能在finalize函数调用时复活"></a>3. 对象可能在finalize函数调用时复活</h3><p>本来，只有当某个对象已经失效（没有引用），垃圾回收器才会调用该对象的finalize函数。但是，万一碰上某个变态的程序员，在finalize()函数内部再把对象自身的引用（也就是this）重新保存在某处，也就相当于把自己复活了（因为这个对象重新有了引用，不再处于失效状态）。 为了防止发生这种诡异的事情，垃圾回收器只能在每次调用完finalize()之后再次去检查该对象是否还处于失效状态。这无形中又增加了JVM的开销。随便提一下。由于JDK的文档中规定了，JVM对于每一个类对象实例最多只会调用一次finalize()。所以，对于那些诈尸的实例，当它们真正死亡时，finalize()反而不会被调用了。这看起来是不是很奇怪？</p>
<h3 id="4-要记得自己做异常捕获"><a href="#4-要记得自己做异常捕获" class="headerlink" title="4. 要记得自己做异常捕获"></a>4. 要记得自己做异常捕获</h3><p>刚才在介绍finalize()调用机制时提到，一旦有异常抛出到finalize函数外面，会被垃圾回收线程捕获并丢弃。</p>
<p>也就是说，异常被忽略掉了（异常被忽略的危害，“这里”有提到）。</p>
<p>为了防止这种事儿，凡是finalize()中有可能抛出异常的代码，你都得写上try catch语句，自己进行捕获。</p>
<h3 id="5-小心线程安全"><a href="#5-小心线程安全" class="headerlink" title="5. 小心线程安全"></a>5. 小心线程安全</h3><p>由于调用finalize()的是垃圾回收线程，和你自己代码的线程不是同一个线程；</p>
<p>甚至不同对象的finalize()可能会被不同的垃圾回收线程调用（比如使用“并行收集器”的时候）。</p>
<p>所以，当你在finalize()里面访问某些数据的时候，还得时刻留心线程安全的问题。</p>
<h1 id="finalize-的执行过程-生命周期"><a href="#finalize-的执行过程-生命周期" class="headerlink" title="finalize 的执行过程(生命周期)"></a>finalize 的执行过程(生命周期)</h1><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。</p>
<p>否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。</p>
<p>执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</p>
<h2 id="具体的finalize流程："><a href="#具体的finalize流程：" class="headerlink" title="具体的finalize流程："></a>具体的finalize流程：</h2><p>对象可由两种状态，涉及到两类状态空间。</p>
<p>一是终结状态空间 <code>F = {unfinalized, finalizable, finalized}</code>；</p>
<p>二是可达状态空间 <code>R = {reachable, finalizer-reachable, unreachable}</code>。</p>
<p>各状态含义如下：</p>
<p>unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的</p>
<p>finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。</p>
<p>正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行</p>
<p>finalized: 表示GC已经对该对象执行过finalize方法</p>
<p>reachable: 表示GC Roots引用可达</p>
<p>finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达</p>
<p>unreachable：对象不可通过上面两种途径可达</p>
<ul>
<li>状态变迁图</li>
</ul>
<p><img src="https://images0.cnblogs.com/blog/705813/201502/071653276729233.gif" alt="状态变迁图"></p>
<h2 id="变迁说明"><a href="#变迁说明" class="headerlink" title="变迁说明"></a>变迁说明</h2><p>新建对象首先处于[reachable, unfinalized]状态(A)</p>
<p>随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态</p>
<p>若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。</p>
<p>在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N)</p>
<p>处于finalizable状态的对象不能同时是unreahable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因</p>
<p>程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。</p>
<p>程序员手动调用多少次不影响JVM的行为</p>
<p>若JVM检测到finalized状态的对象变成unreachable，回收其内存(I)</p>
<p>若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O）</p>
<p>注：System.runFinalizersOnExit()等方法可以使对象即使处于reachable状态，JVM仍对其执行finalize方法</p>
<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><h2 id="对象复活"><a href="#对象复活" class="headerlink" title="对象复活"></a>对象复活</h2><p> [java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GC</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GC SAVE_HOOK = <span class="keyword">null</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> GC();  </span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;  </span><br><span class="line">        System.gc();  </span><br><span class="line">        Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK) &#123; <span class="comment">//此时对象应该处于(reachable, finalized)状态  </span></span><br><span class="line">            System.out.println(<span class="string">"Yes , I am still alive"</span>);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">"No , I am dead"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;  </span><br><span class="line">        System.gc();  </span><br><span class="line">        Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"Yes , I am still alive"</span>);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">"No , I am dead"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.finalize();  </span><br><span class="line">        System.out.println(<span class="string">"execute method finalize()"</span>);  </span><br><span class="line">        SAVE_HOOK = <span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试案例2"><a href="#测试案例2" class="headerlink" title="测试案例2"></a>测试案例2</h2><p> [java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> A a; </span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">    B b; </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.b = b; </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"A finalize"</span>); </span><br><span class="line">        C.a = <span class="keyword">this</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123; </span><br><span class="line">    String name; </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">        <span class="keyword">this</span>.age = age; </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"B finalize"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">" is "</span> + age; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        A a = <span class="keyword">new</span> A(<span class="keyword">new</span> B(<span class="string">"allen"</span>, <span class="number">20</span>)); </span><br><span class="line">        a = <span class="keyword">null</span>; </span><br><span class="line">   </span><br><span class="line">        System.gc(); </span><br><span class="line">        Thread.sleep(<span class="number">5000</span>); </span><br><span class="line">        System.out.println(C.a.b); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的理解:为方便起见, 把a,b两个变量所指的内存空间就叫做a和b</p>
<p> [java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a &#x3D; new A(new B(&quot;allen&quot; , 20)); &#x2F;&#x2F;此时a和b都是reachable, unfinalized状态</span><br><span class="line">a &#x3D; null;</span><br></pre></td></tr></table></figure>

<p>这之后, a和b的状态会在某一个时刻变成unreachable, unfinalized(但是b变成了unreachable还是f-reachable我不是很确定, 如果大家知道,欢迎补充^_^) 或者a和b直接变成f-reachable, unfianlized。</p>
<p>然后在某个时刻,GC检测到a和b处于unfinalized状态, 就将他们添加到F-queue,并将状态改为f-reachable finalizable.</p>
<p>之后分两种情况: 第一: GC从F-queue中首先取出a, 并被某个线程执行了finalize(), 也就相当于被某个活动的线程持有, a状态变成了reachable, finalized. 此时由于a被c对象所引用,所以之后不会变成unreachable finalized而被销毁(重生) 与此同时, b由于一直被a所引用, 所以b的状态变成了reachable, finalizable. 然后在某个时刻被从F-queue取出, 变成reachable, finalized状态</p>
<p>第二: GC从F-queue中首先取出b,并被某个线程执行了finalize(), 状态变成reachable finalized. 然后a也类似, 变成reachable finalized状态, 并被c引用, 重生</p>
<h3 id="对象重生的代码2"><a href="#对象重生的代码2" class="headerlink" title="对象重生的代码2"></a>对象重生的代码2</h3><p> [java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GC</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> GC();</span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK)   <span class="comment">//此时对象应该处于(reachable, finalized)状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Yes , I am still alive"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"No , I am dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Yes , I am still alive"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"No , I am dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"execute method finalize()"</span>);</span><br><span class="line">        SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本文整理自</p>
<p><a href="https://houbb.github.io/2019/04/16/java-base-03-finalize-03" target="_blank" rel="noopener">finalize 方法详解</a></p>
<p><a href="https://stackoverflow.com/questions/2506488/when-is-the-finalize-method-called-in-java" target="_blank" rel="noopener">when-is-the-finalize-method-called-in-java</a></p>
<p><a href="https://www.cnblogs.com/Smina/p/7189427.html" target="_blank" rel="noopener">java finalize方法总结、GC执行finalize的过程</a></p>
<p><a href="https://www.jb51.net/article/125728.htm" target="_blank" rel="noopener">Java禁止使用finalize方法</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/http%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/21/http%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">http报文结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-21 11:38:22 / 修改时间：19:39:39" itemprop="dateCreated datePublished" datetime="2020-07-21T11:38:22+08:00">2020-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="01-输入网址按下回车发生了什么？"><a href="#01-输入网址按下回车发生了什么？" class="headerlink" title="01-输入网址按下回车发生了什么？"></a>01-输入网址按下回车发生了什么？</h4><p><img src="https://user-gold-cdn.xitu.io/2020/5/24/17244fa70cc56814?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>1、浏览器从地址栏的输入中获得服务器的IP地址和端口号；（如果使用的是域名，会先使用域名解析功能解析出对呀的IP地址）</p>
<p>2、浏览器用TCP的三次握手与服务器建立连接；</p>
<p>3、浏览器向服务器发送拼好的报文；</p>
<p>4、服务器收到报文后处理请求，同样拼好报文再发给浏览器；</p>
<p>5、浏览器解析报文，渲染输出页面。</p>
<h4 id="02-HTTP报文结构"><a href="#02-HTTP报文结构" class="headerlink" title="02-HTTP报文结构"></a>02-HTTP报文结构</h4><p>HTTP协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p>
<ol>
<li>起始行（start line）：描述请求或响应的基本信息；</li>
<li>头部字段集合（header）：使用key-value形式更详细的说明报文；</li>
<li>消息正文（entity）：实际传输的数据，它不一定是文本，可以是图片、视频等二进制数据。</li>
</ol>
<p>这其中前两部分起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”，但与“header”对应，很多时候就直接称为“body”。</p>
<p>HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。</p>
<p>所以，一个完整的 HTTP 报文就像是下图的这个样子，注意在 header 和 body 之间有一个“空行”。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/24/17244f92f62076d8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h5 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h5><p>请求报文里的起始行也就是请求行，它简要的描述了客户端想要如何操作服务器端的资源：</p>
<p>请求行由三部分构成：</p>
<ol>
<li>请求方法：是一个动词，如GET/POST，表示对资源的操作；</li>
<li>请求目标：通常是一个URI，标记了请求方法要操作的资源；</li>
<li>版本号：表示报文使用的HTTP协议版本。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/24/17244fb1a5ddfb97?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h5 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h5><p>响应报文里的起始行也就是状态行，意思是服务器响应的状态：</p>
<p>状态行也是由三部分构成：</p>
<ol>
<li>版本号：表示报文使用的HTTP协议版本；</li>
<li>状态码：一个三位数，用代码的形式表示处理的结果；</li>
<li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/24/17244fb6158fa757?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h5 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h5><p>请求行或状态行再加上头部字段集合就构成了HTTP报文里完整的请求头或响应头。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/24/17244fbdc7c900ed?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/24/17244fc08e313dcd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>头部字段是key-value的形式，key和value之间用”：“分隔，最后用CRLF换行表示字段结束。HTTP头字段非常灵活，不仅可以使用标准里Host、Connection等已有头，也可以任意添加自定义头，这就是HTTP协议带来了无限的扩展可能。</p>
<p>不过使用头字段需要注意下面几点：</p>
<p>1、字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</p>
<p>2、字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</p>
<p>3、字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</p>
<p>4、字段的顺序是没有意义的，可以任意排列不影响语义；</p>
<p>5、字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。</p>
<h5 id="常用头字段"><a href="#常用头字段" class="headerlink" title="常用头字段"></a>常用头字段</h5><p>HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：</p>
<p>1、通用字段：在请求头和响应头里都可以出现；</p>
<p>2、请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</p>
<p>3、响应字段：仅能出现在响应头里，补充说明响应报文的信息；</p>
<p>4、实体字段：它实际上属于通用字段，但专门描述 body 的额外信息</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段说明</th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td>请求字段，只能出现在请求头里，且是唯一一个HTTP1.1规范里要求必须出现的字段。</td>
</tr>
<tr>
<td>User-Agent</td>
<td>请求字段，只出现请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。</td>
</tr>
<tr>
<td>Date</td>
<td>通用字段，但通常出现在响应头里，表示HTTP报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。</td>
</tr>
<tr>
<td>Server</td>
<td>响应字段，只能出现在响应头里，她告诉客户端当前正在提供Web服务的软件名称和版本号。</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体字段，表示报文里body的长度，也就是请求头或响应头空行后面数据的长度。</td>
</tr>
</tbody></table>
<h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p>Q：试着解释下浏览器在点击页面链接后发生了哪些事情？</p>
<p>Q：如果是一个不存在的域名，那么浏览器的工作流程会是怎么样的呢？</p>
<p>Q：如果拼HTTP报文的时候，在头字段后多加了一个CRLF，导致出现了一个空行，会发生什么？</p>
<p>Q：讲头字段时说”：“后的空格可以有多个，那为什么绝大多数情况下都只使用一个空格呢？</p>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5ec9fa02e51d4578a67968cc" target="_blank" rel="noopener">http报文结构</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/Netty%20%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/21/Netty%20%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D/" class="post-title-link" itemprop="url">Netty 的零拷贝</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-21 11:29:03 / 修改时间：19:33:00" itemprop="dateCreated datePublished" datetime="2020-07-21T11:29:03+08:00">2020-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>维基百科中对 <code>Zero-copy</code> 的解释是</p>
<blockquote>
<p>零拷贝技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。</p>
</blockquote>
<p>维基百科里提到的零拷贝是在硬件和操作系统层面的，而本文主要介绍的是Netty在应用层面的优化。不过需要注意的是，零拷贝并非字面意义上的没有内存拷贝，而是避免多余的拷贝操作，即使是系统层的零拷贝也有从设备到内存，内存到设备的数据拷贝过程。</p>
<p>Netty 的零拷贝体现在以下几个方面</p>
<ul>
<li><code>ByteBuf</code> 的 <code>slice</code> 操作并不会拷贝一份新的 <code>ByteBuf</code> 内存空间，而是直接借用原来的 <code>ByteBuf</code> ，只是独立地保存读写索引。</li>
<li>Netty 提供了 <code>CompositeByteBuf</code> 类，可以将多个 <code>ByteBuf</code> 组合成一个逻辑上的 <code>ByteBuf</code> 。</li>
<li>Netty 的 <code>FileRegion</code> 中包装了 <code>NIO</code> 的 <code>FileChannel.transferTo()</code>方法，该方法在底层系统支持的情况下会调用 <code>sendfile</code> 方法，从而在传输文件时避免了用户态的内存拷贝。</li>
<li>Netty 的 <code>PooledDirectByteBuf</code> 等类中封装了 <code>NIO</code> 的 <code>DirectByteBuffer</code> ，而 <code>DirectByteBuffer</code> 是直接在 jvm 堆外分配的内存，省去了堆外内存向堆内存拷贝的开销。</li>
</ul>
<p>下面来简单介绍下这几种方式。</p>
<h2 id="slice-分片"><a href="#slice-分片" class="headerlink" title="slice 分片"></a>slice 分片</h2><p>以下以 <code>AbstractUnpooledSlicedByteBuf</code> 为例讲解 <code>slice</code> 的零拷贝原理，至于内存池化的实现 <code>PooledSlicedByteBuf</code> ，因为内存池要通过引用计数来控制内存的释放，所以代码里会出现很多与本文主题无关的逻辑，这里就不拿来举栗子了。</p>
<p>​                        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切片ByteBuf的构造函数，其中字段adjustment为切片ByteBuf相对于被切片ByteBuf的偏移</span></span><br><span class="line"><span class="comment">// 量，两个ByteBuf共用一块内存空间,字段buffer为实际存储数据的ByteBuf</span></span><br><span class="line">AbstractUnpooledSlicedByteBuf(ByteBuf buffer, <span class="keyword">int</span> index, <span class="keyword">int</span> length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length);</span><br><span class="line">    checkSliceOutOfBounds(index, length, buffer);<span class="comment">//检查slice是否越界</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (buffer <span class="keyword">instanceof</span> AbstractUnpooledSlicedByteBuf) &#123;</span><br><span class="line">        <span class="comment">// 如果被切片ByteBuf也是AbstractUnpooledSlicedByteBuf对象</span></span><br><span class="line">        <span class="keyword">this</span>.buffer = ((AbstractUnpooledSlicedByteBuf) buffer).buffer;</span><br><span class="line">        adjustment = ((AbstractUnpooledSlicedByteBuf) buffer).adjustment + index;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer <span class="keyword">instanceof</span> DuplicatedByteBuf) &#123;</span><br><span class="line">        <span class="comment">// 如果被切片ByteBuf为DuplicatedByteBuf对象，则</span></span><br><span class="line">        <span class="comment">// 用unwrap得到实际存储数据的ByteBuf赋值buffer</span></span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer.unwrap();</span><br><span class="line">        adjustment = index;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果被切片ByteBuf为一般ByteBuf对象，则直接赋值buffer</span></span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">        adjustment = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initLength(length);</span><br><span class="line">    writerIndex(length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上为 <code>AbstractUnpooledSlicedByteBuf</code> 类的构造函数，比较简单，就不详细介绍了。</p>
<p>下面来看看 <code>AbstractUnpooledSlicedByteBuf</code> 对 <code>ByteBuf</code> 接口的实现代码，以 <code>getBytes</code> 方法为例：</p>
<p>​                        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, ByteBuffer dst)</span> </span>&#123;</span><br><span class="line">    checkIndex0(index, dst.remaining());<span class="comment">//检查是否越界</span></span><br><span class="line">    unwrap().getBytes(idx(index), dst);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">unwrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index + adjustment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 <code>AbstractUnpooledSlicedByteBuf</code> 重载的 <code>getBytes</code> 方法，可以看到 <code>AbstractUnpooledSlicedByteBuf</code> 是直接在封装的 <code>ByteBuf</code> 上取的字节，但是重新计算了索引，加上了相对偏移量。</p>
<h2 id="CompositeByteBuf"><a href="#CompositeByteBuf" class="headerlink" title="CompositeByteBuf"></a>CompositeByteBuf</h2><p>在有些场景里，我们的数据会分散在多个 <code>ByteBuf</code> 上，但是我们又希望将这些 <code>ByteBuf</code> 聚合在一个 <code>ByteBuf</code> 里处理。这里最直观的想法是将所有 <code>ByteBuf</code> 的数据拷贝到一个 <code>ByteBuf</code> 上，但是这样会有大量的内存拷贝操作，产生很大的CPU开销。</p>
<p>而 <code>CompositeByteBuf</code> 可以很好地解决这个问题，正如名字一样，这是一个复合 <code>ByteBuf</code> ，内部由很多的 <code>ByteBuf</code> 组成，但 <code>CompositeByteBuf</code> 给它们做了一层封装，可以直接以 <code>ByteBuf</code> 的接口操作它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Precondition is that &#123;<span class="doctag">@code</span> buffer != null&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">addComponent0</span><span class="params">(<span class="keyword">boolean</span> increaseWriterIndex, <span class="keyword">int</span> cIndex, ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> buffer != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查新增的component的索引是否合法</span></span><br><span class="line">        checkComponentIndex(cIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// buffer的长度</span></span><br><span class="line">        <span class="keyword">int</span> readableBytes = buffer.readableBytes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// No need to consolidate - just add a component to the list.</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">        <span class="comment">// 统一为大端ByteBuf</span></span><br><span class="line">        Component c = <span class="keyword">new</span> Component(buffer.order(ByteOrder.BIG_ENDIAN).slice());</span><br><span class="line">        <span class="keyword">if</span> (cIndex == components.size()) &#123;</span><br><span class="line">            <span class="comment">// 如果索引等于components的大小，则加在components尾部</span></span><br><span class="line">            wasAdded = components.add(c);</span><br><span class="line">            <span class="keyword">if</span> (cIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果components中只有一个元素</span></span><br><span class="line">                c.endOffset = readableBytes;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果components中有多个元素</span></span><br><span class="line">                Component prev = components.get(cIndex - <span class="number">1</span>);</span><br><span class="line">                c.offset = prev.endOffset;</span><br><span class="line">                c.endOffset = c.offset + readableBytes;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果新的ByteBuf是插在components中间</span></span><br><span class="line">            components.add(cIndex, c);</span><br><span class="line">            wasAdded = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (readableBytes != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果components的大小不为0,则依次更新cIndex之后的</span></span><br><span class="line">                <span class="comment">// 所有components的offset和endOffset</span></span><br><span class="line">                updateComponentOffsets(cIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (increaseWriterIndex) &#123;</span><br><span class="line">            <span class="comment">// 如果要更新writerIndex</span></span><br><span class="line">            writerIndex(writerIndex() + buffer.readableBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cIndex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!wasAdded) &#123;</span><br><span class="line">            <span class="comment">// 如果没添加成功，则释放ByteBuf</span></span><br><span class="line">            buffer.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是添加一个新的 <code>ByteBuf</code> 的逻辑，核心是 <code>offset</code> 和 <code>endOffset</code> ，分别指代一个   <code>ByteBuf</code> 在 <code>CompositeByteBuf</code> 中开始和结束的索引，它们唯一标记了这个 <code>ByteBuf</code> 在 <code>CompositeByteBuf</code> 中的位置。</p>
<p>弄清楚了这个，我们会发现上面的代码无外乎做了两件事：</p>
<ol>
<li>把 <code>ByteBuf</code> 封装成 <code>Component</code> 加到 <code>components</code> 合适的位置上</li>
<li>使 <code>components</code> 里的每个 <code>Component</code> 的 <code>offset</code> 和 <code>endOffset</code> 值都正确</li>
</ol>
<p>下面来看看 <code>CompositeByteBuf</code> 对 <code>ByteBuf</code> 接口的实现代码，同样以 <code>getBytes</code> 方法为例：</p>
<p>​                        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, ByteBuf dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查索引是否越界</span></span><br><span class="line">    checkDstIndex(index, length, dstIndex, dst.capacity());</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用二分搜索查找index对应的Component在components中的索引</span></span><br><span class="line">    <span class="keyword">int</span> i = toComponentIndex(index);</span><br><span class="line">    <span class="comment">// 循环读直至length为0</span></span><br><span class="line">    <span class="keyword">while</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Component c = components.get(i);</span><br><span class="line">        ByteBuf s = c.buf;</span><br><span class="line">        <span class="keyword">int</span> adjustment = c.offset;</span><br><span class="line">        <span class="comment">// 取length和ByteBuf剩余字节数中的较小值</span></span><br><span class="line">        <span class="keyword">int</span> localLength = Math.min(length, s.capacity() - (index - adjustment));</span><br><span class="line">        <span class="comment">// 开始索引为index - c.offset，而不是0</span></span><br><span class="line">        s.getBytes(index - adjustment, dst, dstIndex, localLength);</span><br><span class="line">        index += localLength;</span><br><span class="line">        dstIndex += localLength;</span><br><span class="line">        length -= localLength;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the index for the given offset</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">toComponentIndex</span><span class="params">(<span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    checkIndex(offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> low = <span class="number">0</span>, high = components.size(); low &lt;= high;) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + high &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Component c = components.get(mid);</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= c.endOffset) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &lt; c.offset) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"should not reach here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>CompositeByteBuf</code> 在处理 <code>index</code> 时是先将其转换成对应 <code>Component</code> 在 <code>components</code> 中的索引，以及在 <code>Component</code> 中的偏移，然后从这个 <code>Component</code> 的这个偏移开始，往后循环取字节，直到读完。</p>
<p>NOTE：这里有个小trick，因为 <code>components</code> 是有序排列的，所以 <code>toComponentIndex</code> 做索引转换时没有直接遍历，而是用的二分查找。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://segmentfault.com/a/1190000011769315" target="_blank" rel="noopener">Netty 之 Zero-copy 的实现（上）</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/18/%E4%B8%BA%E5%95%A5HashMap%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%80%E5%AE%9A%E6%98%AF2%E7%9A%84n%E6%AC%A1%E6%96%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/18/%E4%B8%BA%E5%95%A5HashMap%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%80%E5%AE%9A%E6%98%AF2%E7%9A%84n%E6%AC%A1%E6%96%B9/" class="post-title-link" itemprop="url">为啥HashMap的长度一定是2的n次方</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-18 13:34:12 / 修改时间：21:36:52" itemprop="dateCreated datePublished" datetime="2020-07-18T13:34:12+08:00">2020-07-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先你应当记住的：<strong>不管你传不传参数，不管你传入的长度为多少，在你用HashMap的时候，他的长度都是2的n次方，且最大长度为2的30次方</strong></p>
<h1 id="最大长度"><a href="#最大长度" class="headerlink" title="最大长度"></a>最大长度</h1><p>在HashMap的源码中，最大长度这个常量值是这样定义的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="line">     * by either of the constructors with arguments.</span><br><span class="line">     * MUST be a power of two &lt;&#x3D; 1&lt;&lt;30.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这个值用在哪里呢？</p>
<ul>
<li>resize()函数，这个是用来扩容的</li>
<li>tableSizeFor()，这个也是用来扩容的</li>
<li>构造函数中</li>
<li>putEntries()，存放一组HashMap元素时，不是存放单个</li>
</ul>
<h1 id="为什么table长度一定是2的n次方"><a href="#为什么table长度一定是2的n次方" class="headerlink" title="为什么table长度一定是2的n次方"></a>为什么table长度一定是2的n次方</h1><p>注意，源码中他们采用了<strong>延迟初始化操作</strong>，也就是table只有在用到的时候才初始化，如果你不对他进行<code>put</code>等操作的话，table的长度永远为”零”</p>
<p>主要有两个函数保证了他的长度为2的n次方</p>
<ul>
<li>tableSizeFor()</li>
<li>resize()</li>
</ul>
<p>至于计算过程以及加载过程，请参考我的这篇文章：<em><a href="https://github.com/leosanqing/Java-Notes/blob/master/hashMap/table长度到底是多少.md" target="_blank" rel="noopener">table的长度到底是多少</a></em></p>
<p>这篇文章我从源码分析table的创建过程，包括上面提到的函数的调用，看了这个你一定明白为啥<code>table</code>的长度一定是2的n次方</p>
<p>当然我针对hashMap写的一部分源码的中文注释github上也有：<a href="https://github.com/leosanqing/StructAndAlgorithm/blob/master/Struct/hashMapDemo/src/MyHashMap.java" target="_blank" rel="noopener">HashMap源码中文注释</a></p>
<h1 id="2的n次有什么好处"><a href="#2的n次有什么好处" class="headerlink" title="2的n次有什么好处"></a>2的n次有什么好处</h1><ul>
<li>计算方便</li>
<li>hash分布更均匀</li>
</ul>
<h2 id="分布均匀"><a href="#分布均匀" class="headerlink" title="分布均匀"></a>分布均匀</h2><p><strong>如果不是2的n次方，那么有些位置上是永远不会被用到</strong>(我觉得比较牵强,前提是使用&amp;优化%)</p>
<p>具体可以参考这篇博文，他用例子讲述了为什么，<a href="https://blog.csdn.net/zjcjava/article/details/78495416" target="_blank" rel="noopener">为啥长度要是2的n次方</a></p>
<h2 id="计算方便"><a href="#计算方便" class="headerlink" title="计算方便"></a>计算方便</h2><ul>
<li>当容量一定是2^n时，h &amp; (length - 1) == h % length</li>
<li>扩容后计算新位置，非常方便，相比 JDK1.7</li>
</ul>
<h3 id="JDK-1-8改动"><a href="#JDK-1-8改动" class="headerlink" title="JDK 1.8改动"></a>JDK 1.8改动</h3><p>在 JDK1.8 中，HashMap有了挺大的改动，包括</p>
<ul>
<li>元素迁移算法(旧的到新的数组)</li>
<li>使用红黑树</li>
<li>链表为尾插法</li>
</ul>
<p>其中我重点讲下元素迁移算法，JDK1.8的时候</p>
<p>首先看下java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将原来数组中的所有元素都 copy进新的数组</span></span><br><span class="line"><span class="keyword">if</span>(oldTab != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; j++) &#123;</span><br><span class="line">        Entry e;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((e = oldTab[j]) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 说明还没有成链，数组上只有一个</span></span><br><span class="line">            <span class="keyword">if</span>(e.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 重新计算 数组索引 值</span></span><br><span class="line">                newTable[e.h &amp; (newCap-<span class="number">1</span>)] = e;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否为树结构</span></span><br><span class="line">            <span class="comment">//else if (e instanceof TreeNode)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不是树，只是链表,即长度还没有大于 8 进化成树</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 扩容后，如果元素的 index 还是原来的。就使用这个lo前缀的</span></span><br><span class="line">                Entry loHead=<span class="keyword">null</span>, loTail =<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 扩容后  元素index改变，那么就使用 hi前缀开头的</span></span><br><span class="line">                Entry hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                Entry next;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    <span class="comment">//这个非常重要，也比较难懂，</span></span><br><span class="line">                    <span class="comment">// 将它和原来的长度进行相与，就是判断他的原来的hash的上一个  bit 位是否为 1。</span></span><br><span class="line">                    <span class="comment">//以此来判断他是在相同的索引还是table长度加上原来的索引</span></span><br><span class="line">                    <span class="keyword">if</span>((e.h &amp; oldCap) == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// 如果 loTail == null ,说明这个 位置上是第一次添加，没有哈希冲突</span></span><br><span class="line">                        <span class="keyword">if</span>(loTail == <span class="keyword">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(hiTail == <span class="keyword">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e ;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(loTail != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTable[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 新的index 等于原来的 index+oldCap</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTable[j+oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们看到上面源码的最后一句，<code>newTable[j+oldCap] = hiHead;</code>意思就是哪怕我们的元素从旧的数组迁移到新的数组，我们也不需要重新计算他的hash和新数组长度相与的值，只需要直接将现在的<code>索引值+原来数组的长度</code>即可</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/6/169f2ac1fb1a2d06?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<blockquote>
<p>蓝色的表示不需要移动的，绿色的表示需要重新计算索引的，我们看到，他只是加了16(原来的数组table长度)</p>
</blockquote>
<h2 id="计算索引需要"><a href="#计算索引需要" class="headerlink" title="计算索引需要"></a>计算索引需要</h2><p>我们注意到上面的源代码中，判断扩容后元素位置需不需要改变的时候，我们使用到了这个判断</p>
<p><code>if((e.h &amp; oldCap) == 0)</code>，</p>
<blockquote>
<p>如果为0，那么就不需要改变，使用旧的索引即可；如果为1，那么就需要使用新的索引</p>
</blockquote>
<p>为啥会这样呢？</p>
<ul>
<li><strong>如果元素的索引要变那么   <code>hash&amp;(newTable.length-1)</code>一定是和 <code>hash&amp;(oldTable.length-1)+oldTable.length</code>相等</strong></li>
<li><strong>因为table的长度一定是2的n次方，也就是oldCap 一定是2的n次方，也就是说 oldCap有且只有一位是1，而且这个位置在最高位；</strong></li>
</ul>
<p>我们来举个例子：</p>
<p>我们假设元素的hash值的后12位是 110111010111，数组原来的长度为16，扩容后数组长度为32 </p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/6/169f2ac200f75065?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><strong>你可以试下下次扩容时，扩容到64时，索引变不变化。当然答案是不会变化，因为元素的hash值在那个位置为 0</strong></p>
<h3 id="对比1-7扩容"><a href="#对比1-7扩容" class="headerlink" title="对比1.7扩容"></a>对比1.7扩容</h3><p>我们来对比JDK1.7 的方式，他如果要扩容，并且扩容后计算元素的索引的话要使用 <code>indexFor函数</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Returns index for hash code h. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";  </span></span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>也就是要把元素的hash值重新再和新的数组长度-1 再相与一次，会比较麻烦而且不优雅，完全没有我看到1.8计算方式的那种惊艳感。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5ca89b1ee51d4560932c7705" target="_blank" rel="noopener">为啥HashMap的长度一定是2的n次方</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/18/%E4%B8%BA%E4%BB%80%E4%B9%88hashmap%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA8%E6%97%B6%E5%8F%98%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/18/%E4%B8%BA%E4%BB%80%E4%B9%88hashmap%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA8%E6%97%B6%E5%8F%98%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">为什么hashmap链表的长度为8时变成红黑树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-18 13:28:35 / 修改时间：21:32:52" itemprop="dateCreated datePublished" datetime="2020-07-18T13:28:35+08:00">2020-07-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为什么链表的长度为8是变成红黑树？为什么为6时又变成链表？</p>
<p>   因为，大部分的文章都是分析链表是怎么转换成红黑树的，但是并没有说明为什么当链表长度为8的时候才做转换动作。本人第一反应也是一样，只能初略的猜测是因为时间和空间的权衡</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">首先</span><br><span class="line">当链表长度为6时 查询的平均长度为 n&#x2F;2&#x3D;3</span><br><span class="line">红黑树为 log(6)&#x3D;2.6</span><br><span class="line">    </span><br><span class="line">为8时 ： 链表  8&#x2F;2&#x3D;4   </span><br><span class="line">         红黑树   log(8)&#x3D;3</span><br></pre></td></tr></table></figure>
<p>  根据两者的函数图也可以知道随着bin中的数量越多那么红黑树花的时间远远比链表少，所以我觉得这也是原因之一。为7的时候两者应该是 链表花的时间小于红黑树的，但是为什么不是在7的时候转成链表呢，我觉得可能是因为把7当做一个链表和红黑树的过渡点。</p>
<p>事实上真的是因为考虑到时间复杂度所以才把是在8的时候进行转成红黑树吗？其实这并不是真正的原因</p>
<p>至于为什么阈值是8，我想，去源码中找寻答案应该是最可靠的途径。</p>
<p>8这个阈值定义在HashMap中，如下所示，这段注释只说明了8是bin（bin就是bucket，即HashMap中hashCode值一样的元素保存的地方）从链表转成树的阈值，但是并没有说明为什么是8：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>我们继续往下看，在HashMap中有一段Implementation notes，笔者摘录了几段重要的描述，第一段如下所示，大概含义是当bin变得很大的时候，就会被转换成TreeNodes中的bin，其结构和TreeMap相似，也就是红黑树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This map usually acts as a binned (bucketed) hash table, but</span><br><span class="line">when bins get too large, they are transformed into bins of TreeNodes,</span><br><span class="line">each structured similarly to those in java.util.TreeMap</span><br></pre></td></tr></table></figure>
<p>继续往下看，TreeNodes占用空间是普通Nodes的两倍，所以只有当bin包含足够多的节点时才会转成TreeNodes，而是否足够多就是由TREEIFY_THRESHOLD的值决定的。当bin中节点数变少时，又会转成普通的bin。并且我们查看源码的时候发现，链表长度达到8就转成红黑树，当长度降到6就转成普通bin。</p>
<p>这样就解析了为什么不是一开始就将其转换为TreeNodes，而是需要一定节点数才转为TreeNodes，说白了就是trade-off，空间和时间的权衡：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="line">use them only when bins contain enough nodes to warrant use</span><br><span class="line">(see TREEIFY_THRESHOLD). And when they become too small (due to</span><br><span class="line">removal or resizing) they are converted back to plain bins.  In</span><br><span class="line">usages with well-distributed user hashCodes, tree bins are</span><br><span class="line">rarely used.  Ideally, under random hashCodes, the frequency of</span><br><span class="line">nodes in bins follows a Poisson distribution</span><br><span class="line">(http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Poisson_distribution) with a</span><br><span class="line">parameter of about 0.5 on average for the default resizing</span><br><span class="line">threshold of 0.75, although with a large variance because of</span><br><span class="line">resizing granularity. Ignoring variance, the expected</span><br><span class="line">occurrences of list size k are (exp(-0.5)*pow(0.5, k)&#x2F;factorial(k)). </span><br><span class="line">The first values are:</span><br><span class="line">0:    0.60653066</span><br><span class="line">1:    0.30326533</span><br><span class="line">2:    0.07581633</span><br><span class="line">3:    0.01263606</span><br><span class="line">4:    0.00157952</span><br><span class="line">5:    0.00015795</span><br><span class="line">6:    0.00001316</span><br><span class="line">7:    0.00000094</span><br><span class="line">8:    0.00000006</span><br><span class="line">more: less than 1 in ten million</span><br></pre></td></tr></table></figure>
<p>这段内容还说到：<strong>当hashCode离散性很好的时候，树型bin用到的概率非常小</strong>，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过<strong>理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布</strong>，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。</p>
<p>通俗点将就是put进去的key进行计算hashCode时 只要选择计算hash值的算法足够好(hash碰撞率极低)，从而遵循泊松分布，使得桶中挂载的bin的数量等于8的概率非常小，从而转换为红黑树的概率也小，反之则概率大。</p>
<p>所以，之所以选择8，不是拍脑袋决定的，而是根据概率统计决定的。由此可见，发展30年的Java每一项改动和优化都是非常严谨和科学的。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://blog.csdn.net/qq_27409289/article/details/92759730" target="_blank" rel="noopener">为什么hashmap链表的长度为8时变成红黑树</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EricMa"
      src="/images/eric.png">
  <p class="site-author-name" itemprop="name">EricMa</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">229</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Eric-Ma-C" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Eric-Ma-C" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chaoma@zju.edu.cn" title="E-Mail → mailto:chaoma@zju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EricMa</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">864k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
