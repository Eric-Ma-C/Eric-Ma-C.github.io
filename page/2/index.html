<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Eric&#39;s Blogs">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Eric&#39;s Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="EricMa">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Eric's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Eric's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Better Code, Better Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/21/%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">堆外内存的回收机制分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-21 12:46:02 / 修改时间：20:48:47" itemprop="dateCreated datePublished" datetime="2020-07-21T12:46:02+08:00">2020-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>JVM启动时分配的内存，称为堆内存，与之相对的，在代码中还可以使用堆外内存，比如Netty，广泛使用了堆外内存，但是这部分的内存并不归JVM管理，GC算法并不会对它们进行回收，所以在使用堆外内存时，要格外小心，防止内存一直得不到释放，造成线上故障。</p>
<h3 id="堆外内存的申请和释放"><a href="#堆外内存的申请和释放" class="headerlink" title="堆外内存的申请和释放"></a>堆外内存的申请和释放</h3><p>JDK的<code>ByteBuffer</code>类提供了一个接口<code>allocateDirect(int capacity)</code>进行堆外内存的申请，底层通过<code>unsafe.allocateMemory(size)</code>实现，接下去看看在JVM层面是如何实现的。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2184951-13c6c6ebf2cecc82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>可以发现，最底层是通过<code>malloc</code>方法申请的，但是这块内存需要进行手动释放，JVM并不会进行回收，幸好<code>Unsafe</code>提供了另一个接口<code>freeMemory</code>可以对申请的堆外内存进行释放。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2184951-abe6aff129c546fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1180/format/webp" alt="img"></p>
<h3 id="堆外内存的回收机制"><a href="#堆外内存的回收机制" class="headerlink" title="堆外内存的回收机制"></a>堆外内存的回收机制</h3><p>如果每次申请堆外内存，都需要在代码中显示的释放，对于Java这门语言的设计来说，显然不够合理，既然JVM不会管理这些堆外内存，它们是如何回收的呢？</p>
<h4 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h4><p>JDK中使用<code>DirectByteBuffer</code>对象来表示堆外内存，每个<code>DirectByteBuffer</code>对象在初始化时，都会创建一个对用的<code>Cleaner</code>对象，这个<code>Cleaner</code>对象会在合适的时候执行<code>unsafe.freeMemory(address)</code>，从而回收这块堆外内存。</p>
<p>当初始化一块堆外内存时，对象的引用关系如下：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2184951-4f810a6be523de33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>其中<code>first</code>是<code>Cleaner</code>类的静态变量，<code>Cleaner</code>对象在初始化时会被添加到<code>Clener</code>链表中，和<code>first</code>形成引用关系，<code>ReferenceQueue</code>是用来保存需要回收的<code>Cleaner</code>对象。</p>
<p>如果该<code>DirectByteBuffer</code>对象在一次GC中被回收了</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2184951-510161812431ac12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>此时，只有<code>Cleaner</code>对象唯一保存了堆外内存的数据（开始地址、大小和容量），在下一次FGC时，把该<code>Cleaner</code>对象放入到<code>ReferenceQueue</code>中，并触发<code>clean</code>方法。</p>
<p><code>Cleaner</code>对象的<code>clean</code>方法主要有两个作用：<br> 1、把自身从<code>Clener</code>链表删除，从而在下次GC时能够被回收<br> 2、释放堆外内存</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Paranoia</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span>.freeMemory(address);</span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果JVM一直没有执行FGC的话，无效的<code>Cleaner</code>对象就无法放入到ReferenceQueue中，从而堆外内存也一直得不到释放，内存岂不是会爆？</p>
<p>其实在初始化<code>DirectByteBuffer</code>对象时，如果当前堆外内存的条件很苛刻时，会主动调用<code>System.gc()</code>强制执行FGC。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2184951-39f8c22847e7c11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1086/format/webp" alt="img"></p>
<p>不过很多线上环境的JVM参数有<code>-XX:+DisableExplicitGC</code>，导致了<code>System.gc()</code>等于一个空函数，根本不会触发FGC，这一点在使用Netty框架时需要注意是否会出问题。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://www.jianshu.com/p/35cf0f348275" target="_blank" rel="noopener">堆外内存的回收机制分析</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/finalize%20%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/21/finalize%20%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">finalize 方法详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-21 11:52:20 / 修改时间：19:54:13" itemprop="dateCreated datePublished" datetime="2020-07-21T11:52:20+08:00">2020-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JVM-的一些知识"><a href="#JVM-的一些知识" class="headerlink" title="JVM 的一些知识"></a>JVM 的一些知识</h1><p>在说明finalize()的用法之前要树立有关于java垃圾回收器几个观点:</p>
<ul>
<li>对象可以不被垃圾回收</li>
</ul>
<p>java的垃圾回收遵循一个特点, 就是能不回收就不会回收.只要程序的内存没有达到即将用完的地步, 对象占用的空间就不会被释放。</p>
<p>因为如果程序正常结束了,而且垃圾回收器没有释放申请的内存, 那么随着程序的正常退出, 申请的内存会自动交还给操作系统;</p>
<p>而且垃圾回收本身就需要付出代价, 是有一定开销的, 如果不使用,就不会存在这一部分的开销。</p>
<ul>
<li>垃圾回收只能回收内存</li>
</ul>
<p>而且只能回收内存中由java创建对象方式(堆)创建的对象所占用的那一部分内存, 无法回收其他资源, 比如文件操作的句柄, 数据库的连接等等。</p>
<ul>
<li>垃圾回收不是C++中的析构</li>
</ul>
<p>两者不是对应关系, 因为第一点就指出了垃圾回收的发生是不确定的, 而C++中析构函数是由程序员控制(delete) 或者离开器作用域时自动调用发生, 是在确定的时间对对象进行销毁并释放其所占用的内存。</p>
<ul>
<li>调用垃圾回收器(GC)不一定保证垃圾回收器的运行</li>
</ul>
<h1 id="finalize的作用"><a href="#finalize的作用" class="headerlink" title="finalize的作用"></a>finalize的作用</h1><p>finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</p>
<p>finalize()与C++中的析构函数不是对应的。</p>
<p>C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性。</p>
<p>finalize() 的功能: 一旦垃圾回收器准备释放对象所占的内存空间, 如果对象覆盖了finalize()并且函数体内不能是空的, 就会首先调用对象的finalize(), 然后在下一次垃圾回收动作发生的时候真正收回对象所占的空间。</p>
<p>finalize() 有一个特点就是: JVM始终只调用一次. 无论这个对象被垃圾回收器标记为什么状态, finalize()始终只调用一次. 但是程序员在代码中主动调用的不记录在这之内。</p>
<h1 id="finalize函数的调用机制"><a href="#finalize函数的调用机制" class="headerlink" title="finalize函数的调用机制"></a>finalize函数的调用机制</h1><p>java虚拟机规范并没有硬性规定垃圾回收该不该搞，以及该如何搞。所以这里提到的调用机制不能保证适合所有jvm。</p>
<h2 id="何时被调用？"><a href="#何时被调用？" class="headerlink" title="何时被调用？"></a>何时被调用？</h2><p>finalize啥时候才会被调用捏？</p>
<p>一般来说，要等到JVM开始进行垃圾回收的时候，它才有可能被调用。</p>
<p>而JVM进行垃圾回收的时间点是非常不确定的，依赖于各种运行时的环境因素。</p>
<p>正是由于finalize函数调用时间点的不确定，导致了后面提到的某些缺点。</p>
<h2 id="谁来调用？"><a href="#谁来调用？" class="headerlink" title="谁来调用？"></a>谁来调用？</h2><p>常见的JVM会通过GC的垃圾回收线程来进行finalize函数的调用。</p>
<p>由于垃圾回收线程比较重要（人家好歹也是JVM的一个组成部分嘛），为了防止finalize函数抛出的异常影响到垃圾回收线程的运作，垃圾回收线程会在调用每一个finalize函数时进行try catch，如果捕获到异常，就直接丢弃，然后接着处理下一个失效对象的finalize函数。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>不建议用finalize方法完成“非内存资源”的清理工作</p>
<h2 id="不建议使用的原因"><a href="#不建议使用的原因" class="headerlink" title="不建议使用的原因"></a>不建议使用的原因</h2><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><p>一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法</p>
<p>System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们</p>
<p>Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行</p>
<p>finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行</p>
<p>对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的</p>
<p>finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为)</p>
<h2 id="适合的场景"><a href="#适合的场景" class="headerlink" title="适合的场景"></a>适合的场景</h2><p>finalize()主要使用的方面:</p>
<p>根据垃圾回收器的第2点可知, java垃圾回收器只能回收创建在堆中的java对象, 而对于不是这种方式创建的对象则没有方法处理, 这就需要使用finalize()对这部分对象所占的资源进行释放. 使用到这一点的就是JNI本地对象, 通过JNI来调用本地方法创建的对象只能通过finalize()保证使用之后进行销毁,释放内存</p>
<p>充当保证使用之后释放资源的最后一道屏障, 比如使用数据库连接之后未断开,并且由于程序员的个人原因忘记了释放连接, 这时就只能依靠finalize()函数来释放资源.</p>
<p>《thinking in java》中所讲到的“终结条件”验证, 通过finalize()方法来试图找出程序的漏洞</p>
<p>尽管finalize()可以主动调用, 但是最好不要主动调用, 因为在代码中主动调用之后, 如果JVM再次调用, 由于之前的调用已经释放过资源了,所以二次释放资源就有可能出现导致出现空指针等异常, 而恰好这些异常是没有被捕获的, 那么就造成对象处于被破坏的状态, 导致该对象所占用的某一部分资源无法被回收而浪费.</p>
<h2 id="尽量避免使用finalize"><a href="#尽量避免使用finalize" class="headerlink" title="尽量避免使用finalize():"></a>尽量避免使用finalize():</h2><p>finalize()不一定会被调用, 因为java的垃圾回收器的特性就决定了它不一定会被调用</p>
<p>就算finalize()函数被调用, 它被调用的时间充满了不确定性, 因为程序中其他线程的优先级远远高于执行 finalize() 函数线程的优先级。</p>
<p>也许等到finalize()被调用, 数据库的连接池或者文件句柄早就耗尽了。</p>
<p>如果一种未被捕获的异常在使用finalize方法时被抛出，这个异常不会被捕获，finalize方法的终结过程也会终止，造成对象出于破坏的状态。被破坏的对象又很可能导致部分资源无法被回收, 造成浪费。</p>
<p>finalize()和垃圾回收器的运行本身就要耗费资源, 也许会导致程序的暂时停止。</p>
<h2 id="禁止使用的原因"><a href="#禁止使用的原因" class="headerlink" title="禁止使用的原因"></a>禁止使用的原因</h2><h3 id="1-调用时间不确定—有资源浪费的风险"><a href="#1-调用时间不确定—有资源浪费的风险" class="headerlink" title="1.调用时间不确定—有资源浪费的风险"></a>1.调用时间不确定—有资源浪费的风险</h3><p>前面已经介绍了调用机制。</p>
<p>同学们应该认清“finalize的调用时机是很不确定的”这样一个事实。</p>
<p>所以，假如你把某些稀缺资源放到finalize()中释放，可能会导致该稀缺资源等上很久很久很久以后才被释放。</p>
<p>这可是资源的浪费啊！另外，某些类对象所携带的资源（比如某些JDBC的类）可能本身就很耗费内存，这些资源的延迟释放会造成很大的性能问题。</p>
<h3 id="2-可能不被调用—-有资源泄露的风险"><a href="#2-可能不被调用—-有资源泄露的风险" class="headerlink" title="2. 可能不被调用—-有资源泄露的风险"></a>2. 可能不被调用—-有资源泄露的风险</h3><p>很多同学以为finalize()总是会被调用，其实不然。</p>
<p>在某些情况下，finalize()压根儿不被调用。</p>
<p>比如在JVM退出的当口，内存中那些对象的finalize函数可能就不会被调用了。</p>
<p>估计有同学在打“runFinalizersOnExit”的主意，来确保所有的finalize在JVM退出前被调用。</p>
<p>很可惜也很遗憾，该方法从JDK 1.2开始，就已经被废弃了。即使该方法不被废弃，也是有很大的线程安全隐患滴！ 　　</p>
<p>从上述可以看出，一旦你依赖finalize()来帮你释放资源，那可是很不妙啊（有资源泄漏的危险）！</p>
<p>很多时候，资源泄露导致的性能问题更加严重，万万不可小看。</p>
<h3 id="3-对象可能在finalize函数调用时复活"><a href="#3-对象可能在finalize函数调用时复活" class="headerlink" title="3. 对象可能在finalize函数调用时复活"></a>3. 对象可能在finalize函数调用时复活</h3><p>本来，只有当某个对象已经失效（没有引用），垃圾回收器才会调用该对象的finalize函数。但是，万一碰上某个变态的程序员，在finalize()函数内部再把对象自身的引用（也就是this）重新保存在某处，也就相当于把自己复活了（因为这个对象重新有了引用，不再处于失效状态）。 为了防止发生这种诡异的事情，垃圾回收器只能在每次调用完finalize()之后再次去检查该对象是否还处于失效状态。这无形中又增加了JVM的开销。随便提一下。由于JDK的文档中规定了，JVM对于每一个类对象实例最多只会调用一次finalize()。所以，对于那些诈尸的实例，当它们真正死亡时，finalize()反而不会被调用了。这看起来是不是很奇怪？</p>
<h3 id="4-要记得自己做异常捕获"><a href="#4-要记得自己做异常捕获" class="headerlink" title="4. 要记得自己做异常捕获"></a>4. 要记得自己做异常捕获</h3><p>刚才在介绍finalize()调用机制时提到，一旦有异常抛出到finalize函数外面，会被垃圾回收线程捕获并丢弃。</p>
<p>也就是说，异常被忽略掉了（异常被忽略的危害，“这里”有提到）。</p>
<p>为了防止这种事儿，凡是finalize()中有可能抛出异常的代码，你都得写上try catch语句，自己进行捕获。</p>
<h3 id="5-小心线程安全"><a href="#5-小心线程安全" class="headerlink" title="5. 小心线程安全"></a>5. 小心线程安全</h3><p>由于调用finalize()的是垃圾回收线程，和你自己代码的线程不是同一个线程；</p>
<p>甚至不同对象的finalize()可能会被不同的垃圾回收线程调用（比如使用“并行收集器”的时候）。</p>
<p>所以，当你在finalize()里面访问某些数据的时候，还得时刻留心线程安全的问题。</p>
<h1 id="finalize-的执行过程-生命周期"><a href="#finalize-的执行过程-生命周期" class="headerlink" title="finalize 的执行过程(生命周期)"></a>finalize 的执行过程(生命周期)</h1><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。</p>
<p>否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。</p>
<p>执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</p>
<h2 id="具体的finalize流程："><a href="#具体的finalize流程：" class="headerlink" title="具体的finalize流程："></a>具体的finalize流程：</h2><p>对象可由两种状态，涉及到两类状态空间。</p>
<p>一是终结状态空间 <code>F = {unfinalized, finalizable, finalized}</code>；</p>
<p>二是可达状态空间 <code>R = {reachable, finalizer-reachable, unreachable}</code>。</p>
<p>各状态含义如下：</p>
<p>unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的</p>
<p>finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。</p>
<p>正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行</p>
<p>finalized: 表示GC已经对该对象执行过finalize方法</p>
<p>reachable: 表示GC Roots引用可达</p>
<p>finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达</p>
<p>unreachable：对象不可通过上面两种途径可达</p>
<ul>
<li>状态变迁图</li>
</ul>
<p><img src="https://images0.cnblogs.com/blog/705813/201502/071653276729233.gif" alt="状态变迁图"></p>
<h2 id="变迁说明"><a href="#变迁说明" class="headerlink" title="变迁说明"></a>变迁说明</h2><p>新建对象首先处于[reachable, unfinalized]状态(A)</p>
<p>随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态</p>
<p>若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。</p>
<p>在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N)</p>
<p>处于finalizable状态的对象不能同时是unreahable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因</p>
<p>程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。</p>
<p>程序员手动调用多少次不影响JVM的行为</p>
<p>若JVM检测到finalized状态的对象变成unreachable，回收其内存(I)</p>
<p>若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O）</p>
<p>注：System.runFinalizersOnExit()等方法可以使对象即使处于reachable状态，JVM仍对其执行finalize方法</p>
<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><h2 id="对象复活"><a href="#对象复活" class="headerlink" title="对象复活"></a>对象复活</h2><p> [java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GC</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GC SAVE_HOOK = <span class="keyword">null</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> GC();  </span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;  </span><br><span class="line">        System.gc();  </span><br><span class="line">        Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK) &#123; <span class="comment">//此时对象应该处于(reachable, finalized)状态  </span></span><br><span class="line">            System.out.println(<span class="string">"Yes , I am still alive"</span>);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">"No , I am dead"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;  </span><br><span class="line">        System.gc();  </span><br><span class="line">        Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"Yes , I am still alive"</span>);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">"No , I am dead"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.finalize();  </span><br><span class="line">        System.out.println(<span class="string">"execute method finalize()"</span>);  </span><br><span class="line">        SAVE_HOOK = <span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试案例2"><a href="#测试案例2" class="headerlink" title="测试案例2"></a>测试案例2</h2><p> [java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> A a; </span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">    B b; </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.b = b; </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"A finalize"</span>); </span><br><span class="line">        C.a = <span class="keyword">this</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123; </span><br><span class="line">    String name; </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">        <span class="keyword">this</span>.age = age; </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"B finalize"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">" is "</span> + age; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        A a = <span class="keyword">new</span> A(<span class="keyword">new</span> B(<span class="string">"allen"</span>, <span class="number">20</span>)); </span><br><span class="line">        a = <span class="keyword">null</span>; </span><br><span class="line">   </span><br><span class="line">        System.gc(); </span><br><span class="line">        Thread.sleep(<span class="number">5000</span>); </span><br><span class="line">        System.out.println(C.a.b); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的理解:为方便起见, 把a,b两个变量所指的内存空间就叫做a和b</p>
<p> [java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a &#x3D; new A(new B(&quot;allen&quot; , 20)); &#x2F;&#x2F;此时a和b都是reachable, unfinalized状态</span><br><span class="line">a &#x3D; null;</span><br></pre></td></tr></table></figure>

<p>这之后, a和b的状态会在某一个时刻变成unreachable, unfinalized(但是b变成了unreachable还是f-reachable我不是很确定, 如果大家知道,欢迎补充^_^) 或者a和b直接变成f-reachable, unfianlized。</p>
<p>然后在某个时刻,GC检测到a和b处于unfinalized状态, 就将他们添加到F-queue,并将状态改为f-reachable finalizable.</p>
<p>之后分两种情况: 第一: GC从F-queue中首先取出a, 并被某个线程执行了finalize(), 也就相当于被某个活动的线程持有, a状态变成了reachable, finalized. 此时由于a被c对象所引用,所以之后不会变成unreachable finalized而被销毁(重生) 与此同时, b由于一直被a所引用, 所以b的状态变成了reachable, finalizable. 然后在某个时刻被从F-queue取出, 变成reachable, finalized状态</p>
<p>第二: GC从F-queue中首先取出b,并被某个线程执行了finalize(), 状态变成reachable finalized. 然后a也类似, 变成reachable finalized状态, 并被c引用, 重生</p>
<h3 id="对象重生的代码2"><a href="#对象重生的代码2" class="headerlink" title="对象重生的代码2"></a>对象重生的代码2</h3><p> [java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GC</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> GC();</span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK)   <span class="comment">//此时对象应该处于(reachable, finalized)状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Yes , I am still alive"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"No , I am dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Yes , I am still alive"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"No , I am dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"execute method finalize()"</span>);</span><br><span class="line">        SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本文整理自</p>
<p><a href="https://houbb.github.io/2019/04/16/java-base-03-finalize-03" target="_blank" rel="noopener">finalize 方法详解</a></p>
<p><a href="https://stackoverflow.com/questions/2506488/when-is-the-finalize-method-called-in-java" target="_blank" rel="noopener">when-is-the-finalize-method-called-in-java</a></p>
<p><a href="https://www.cnblogs.com/Smina/p/7189427.html" target="_blank" rel="noopener">java finalize方法总结、GC执行finalize的过程</a></p>
<p><a href="https://www.jb51.net/article/125728.htm" target="_blank" rel="noopener">Java禁止使用finalize方法</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/http%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/21/http%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">http报文结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-21 11:38:22 / 修改时间：19:39:39" itemprop="dateCreated datePublished" datetime="2020-07-21T11:38:22+08:00">2020-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="01-输入网址按下回车发生了什么？"><a href="#01-输入网址按下回车发生了什么？" class="headerlink" title="01-输入网址按下回车发生了什么？"></a>01-输入网址按下回车发生了什么？</h4><p><img src="https://user-gold-cdn.xitu.io/2020/5/24/17244fa70cc56814?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>1、浏览器从地址栏的输入中获得服务器的IP地址和端口号；（如果使用的是域名，会先使用域名解析功能解析出对呀的IP地址）</p>
<p>2、浏览器用TCP的三次握手与服务器建立连接；</p>
<p>3、浏览器向服务器发送拼好的报文；</p>
<p>4、服务器收到报文后处理请求，同样拼好报文再发给浏览器；</p>
<p>5、浏览器解析报文，渲染输出页面。</p>
<h4 id="02-HTTP报文结构"><a href="#02-HTTP报文结构" class="headerlink" title="02-HTTP报文结构"></a>02-HTTP报文结构</h4><p>HTTP协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p>
<ol>
<li>起始行（start line）：描述请求或响应的基本信息；</li>
<li>头部字段集合（header）：使用key-value形式更详细的说明报文；</li>
<li>消息正文（entity）：实际传输的数据，它不一定是文本，可以是图片、视频等二进制数据。</li>
</ol>
<p>这其中前两部分起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”，但与“header”对应，很多时候就直接称为“body”。</p>
<p>HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。</p>
<p>所以，一个完整的 HTTP 报文就像是下图的这个样子，注意在 header 和 body 之间有一个“空行”。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/24/17244f92f62076d8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h5 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h5><p>请求报文里的起始行也就是请求行，它简要的描述了客户端想要如何操作服务器端的资源：</p>
<p>请求行由三部分构成：</p>
<ol>
<li>请求方法：是一个动词，如GET/POST，表示对资源的操作；</li>
<li>请求目标：通常是一个URI，标记了请求方法要操作的资源；</li>
<li>版本号：表示报文使用的HTTP协议版本。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/24/17244fb1a5ddfb97?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h5 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h5><p>响应报文里的起始行也就是状态行，意思是服务器响应的状态：</p>
<p>状态行也是由三部分构成：</p>
<ol>
<li>版本号：表示报文使用的HTTP协议版本；</li>
<li>状态码：一个三位数，用代码的形式表示处理的结果；</li>
<li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/24/17244fb6158fa757?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h5 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h5><p>请求行或状态行再加上头部字段集合就构成了HTTP报文里完整的请求头或响应头。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/24/17244fbdc7c900ed?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/24/17244fc08e313dcd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>头部字段是key-value的形式，key和value之间用”：“分隔，最后用CRLF换行表示字段结束。HTTP头字段非常灵活，不仅可以使用标准里Host、Connection等已有头，也可以任意添加自定义头，这就是HTTP协议带来了无限的扩展可能。</p>
<p>不过使用头字段需要注意下面几点：</p>
<p>1、字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</p>
<p>2、字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</p>
<p>3、字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</p>
<p>4、字段的顺序是没有意义的，可以任意排列不影响语义；</p>
<p>5、字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。</p>
<h5 id="常用头字段"><a href="#常用头字段" class="headerlink" title="常用头字段"></a>常用头字段</h5><p>HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：</p>
<p>1、通用字段：在请求头和响应头里都可以出现；</p>
<p>2、请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</p>
<p>3、响应字段：仅能出现在响应头里，补充说明响应报文的信息；</p>
<p>4、实体字段：它实际上属于通用字段，但专门描述 body 的额外信息</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段说明</th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td>请求字段，只能出现在请求头里，且是唯一一个HTTP1.1规范里要求必须出现的字段。</td>
</tr>
<tr>
<td>User-Agent</td>
<td>请求字段，只出现请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。</td>
</tr>
<tr>
<td>Date</td>
<td>通用字段，但通常出现在响应头里，表示HTTP报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。</td>
</tr>
<tr>
<td>Server</td>
<td>响应字段，只能出现在响应头里，她告诉客户端当前正在提供Web服务的软件名称和版本号。</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体字段，表示报文里body的长度，也就是请求头或响应头空行后面数据的长度。</td>
</tr>
</tbody></table>
<h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p>Q：试着解释下浏览器在点击页面链接后发生了哪些事情？</p>
<p>Q：如果是一个不存在的域名，那么浏览器的工作流程会是怎么样的呢？</p>
<p>Q：如果拼HTTP报文的时候，在头字段后多加了一个CRLF，导致出现了一个空行，会发生什么？</p>
<p>Q：讲头字段时说”：“后的空格可以有多个，那为什么绝大多数情况下都只使用一个空格呢？</p>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5ec9fa02e51d4578a67968cc" target="_blank" rel="noopener">http报文结构</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/Netty%20%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/21/Netty%20%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D/" class="post-title-link" itemprop="url">Netty 的零拷贝</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-21 11:29:03 / 修改时间：19:33:00" itemprop="dateCreated datePublished" datetime="2020-07-21T11:29:03+08:00">2020-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>维基百科中对 <code>Zero-copy</code> 的解释是</p>
<blockquote>
<p>零拷贝技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。</p>
</blockquote>
<p>维基百科里提到的零拷贝是在硬件和操作系统层面的，而本文主要介绍的是Netty在应用层面的优化。不过需要注意的是，零拷贝并非字面意义上的没有内存拷贝，而是避免多余的拷贝操作，即使是系统层的零拷贝也有从设备到内存，内存到设备的数据拷贝过程。</p>
<p>Netty 的零拷贝体现在以下几个方面</p>
<ul>
<li><code>ByteBuf</code> 的 <code>slice</code> 操作并不会拷贝一份新的 <code>ByteBuf</code> 内存空间，而是直接借用原来的 <code>ByteBuf</code> ，只是独立地保存读写索引。</li>
<li>Netty 提供了 <code>CompositeByteBuf</code> 类，可以将多个 <code>ByteBuf</code> 组合成一个逻辑上的 <code>ByteBuf</code> 。</li>
<li>Netty 的 <code>FileRegion</code> 中包装了 <code>NIO</code> 的 <code>FileChannel.transferTo()</code>方法，该方法在底层系统支持的情况下会调用 <code>sendfile</code> 方法，从而在传输文件时避免了用户态的内存拷贝。</li>
<li>Netty 的 <code>PooledDirectByteBuf</code> 等类中封装了 <code>NIO</code> 的 <code>DirectByteBuffer</code> ，而 <code>DirectByteBuffer</code> 是直接在 jvm 堆外分配的内存，省去了堆外内存向堆内存拷贝的开销。</li>
</ul>
<p>下面来简单介绍下这几种方式。</p>
<h2 id="slice-分片"><a href="#slice-分片" class="headerlink" title="slice 分片"></a>slice 分片</h2><p>以下以 <code>AbstractUnpooledSlicedByteBuf</code> 为例讲解 <code>slice</code> 的零拷贝原理，至于内存池化的实现 <code>PooledSlicedByteBuf</code> ，因为内存池要通过引用计数来控制内存的释放，所以代码里会出现很多与本文主题无关的逻辑，这里就不拿来举栗子了。</p>
<p>​                        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切片ByteBuf的构造函数，其中字段adjustment为切片ByteBuf相对于被切片ByteBuf的偏移</span></span><br><span class="line"><span class="comment">// 量，两个ByteBuf共用一块内存空间,字段buffer为实际存储数据的ByteBuf</span></span><br><span class="line">AbstractUnpooledSlicedByteBuf(ByteBuf buffer, <span class="keyword">int</span> index, <span class="keyword">int</span> length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length);</span><br><span class="line">    checkSliceOutOfBounds(index, length, buffer);<span class="comment">//检查slice是否越界</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (buffer <span class="keyword">instanceof</span> AbstractUnpooledSlicedByteBuf) &#123;</span><br><span class="line">        <span class="comment">// 如果被切片ByteBuf也是AbstractUnpooledSlicedByteBuf对象</span></span><br><span class="line">        <span class="keyword">this</span>.buffer = ((AbstractUnpooledSlicedByteBuf) buffer).buffer;</span><br><span class="line">        adjustment = ((AbstractUnpooledSlicedByteBuf) buffer).adjustment + index;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer <span class="keyword">instanceof</span> DuplicatedByteBuf) &#123;</span><br><span class="line">        <span class="comment">// 如果被切片ByteBuf为DuplicatedByteBuf对象，则</span></span><br><span class="line">        <span class="comment">// 用unwrap得到实际存储数据的ByteBuf赋值buffer</span></span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer.unwrap();</span><br><span class="line">        adjustment = index;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果被切片ByteBuf为一般ByteBuf对象，则直接赋值buffer</span></span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">        adjustment = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initLength(length);</span><br><span class="line">    writerIndex(length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上为 <code>AbstractUnpooledSlicedByteBuf</code> 类的构造函数，比较简单，就不详细介绍了。</p>
<p>下面来看看 <code>AbstractUnpooledSlicedByteBuf</code> 对 <code>ByteBuf</code> 接口的实现代码，以 <code>getBytes</code> 方法为例：</p>
<p>​                        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, ByteBuffer dst)</span> </span>&#123;</span><br><span class="line">    checkIndex0(index, dst.remaining());<span class="comment">//检查是否越界</span></span><br><span class="line">    unwrap().getBytes(idx(index), dst);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">unwrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index + adjustment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 <code>AbstractUnpooledSlicedByteBuf</code> 重载的 <code>getBytes</code> 方法，可以看到 <code>AbstractUnpooledSlicedByteBuf</code> 是直接在封装的 <code>ByteBuf</code> 上取的字节，但是重新计算了索引，加上了相对偏移量。</p>
<h2 id="CompositeByteBuf"><a href="#CompositeByteBuf" class="headerlink" title="CompositeByteBuf"></a>CompositeByteBuf</h2><p>在有些场景里，我们的数据会分散在多个 <code>ByteBuf</code> 上，但是我们又希望将这些 <code>ByteBuf</code> 聚合在一个 <code>ByteBuf</code> 里处理。这里最直观的想法是将所有 <code>ByteBuf</code> 的数据拷贝到一个 <code>ByteBuf</code> 上，但是这样会有大量的内存拷贝操作，产生很大的CPU开销。</p>
<p>而 <code>CompositeByteBuf</code> 可以很好地解决这个问题，正如名字一样，这是一个复合 <code>ByteBuf</code> ，内部由很多的 <code>ByteBuf</code> 组成，但 <code>CompositeByteBuf</code> 给它们做了一层封装，可以直接以 <code>ByteBuf</code> 的接口操作它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Precondition is that &#123;<span class="doctag">@code</span> buffer != null&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">addComponent0</span><span class="params">(<span class="keyword">boolean</span> increaseWriterIndex, <span class="keyword">int</span> cIndex, ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> buffer != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查新增的component的索引是否合法</span></span><br><span class="line">        checkComponentIndex(cIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// buffer的长度</span></span><br><span class="line">        <span class="keyword">int</span> readableBytes = buffer.readableBytes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// No need to consolidate - just add a component to the list.</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">        <span class="comment">// 统一为大端ByteBuf</span></span><br><span class="line">        Component c = <span class="keyword">new</span> Component(buffer.order(ByteOrder.BIG_ENDIAN).slice());</span><br><span class="line">        <span class="keyword">if</span> (cIndex == components.size()) &#123;</span><br><span class="line">            <span class="comment">// 如果索引等于components的大小，则加在components尾部</span></span><br><span class="line">            wasAdded = components.add(c);</span><br><span class="line">            <span class="keyword">if</span> (cIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果components中只有一个元素</span></span><br><span class="line">                c.endOffset = readableBytes;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果components中有多个元素</span></span><br><span class="line">                Component prev = components.get(cIndex - <span class="number">1</span>);</span><br><span class="line">                c.offset = prev.endOffset;</span><br><span class="line">                c.endOffset = c.offset + readableBytes;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果新的ByteBuf是插在components中间</span></span><br><span class="line">            components.add(cIndex, c);</span><br><span class="line">            wasAdded = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (readableBytes != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果components的大小不为0,则依次更新cIndex之后的</span></span><br><span class="line">                <span class="comment">// 所有components的offset和endOffset</span></span><br><span class="line">                updateComponentOffsets(cIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (increaseWriterIndex) &#123;</span><br><span class="line">            <span class="comment">// 如果要更新writerIndex</span></span><br><span class="line">            writerIndex(writerIndex() + buffer.readableBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cIndex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!wasAdded) &#123;</span><br><span class="line">            <span class="comment">// 如果没添加成功，则释放ByteBuf</span></span><br><span class="line">            buffer.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是添加一个新的 <code>ByteBuf</code> 的逻辑，核心是 <code>offset</code> 和 <code>endOffset</code> ，分别指代一个   <code>ByteBuf</code> 在 <code>CompositeByteBuf</code> 中开始和结束的索引，它们唯一标记了这个 <code>ByteBuf</code> 在 <code>CompositeByteBuf</code> 中的位置。</p>
<p>弄清楚了这个，我们会发现上面的代码无外乎做了两件事：</p>
<ol>
<li>把 <code>ByteBuf</code> 封装成 <code>Component</code> 加到 <code>components</code> 合适的位置上</li>
<li>使 <code>components</code> 里的每个 <code>Component</code> 的 <code>offset</code> 和 <code>endOffset</code> 值都正确</li>
</ol>
<p>下面来看看 <code>CompositeByteBuf</code> 对 <code>ByteBuf</code> 接口的实现代码，同样以 <code>getBytes</code> 方法为例：</p>
<p>​                        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, ByteBuf dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查索引是否越界</span></span><br><span class="line">    checkDstIndex(index, length, dstIndex, dst.capacity());</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用二分搜索查找index对应的Component在components中的索引</span></span><br><span class="line">    <span class="keyword">int</span> i = toComponentIndex(index);</span><br><span class="line">    <span class="comment">// 循环读直至length为0</span></span><br><span class="line">    <span class="keyword">while</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Component c = components.get(i);</span><br><span class="line">        ByteBuf s = c.buf;</span><br><span class="line">        <span class="keyword">int</span> adjustment = c.offset;</span><br><span class="line">        <span class="comment">// 取length和ByteBuf剩余字节数中的较小值</span></span><br><span class="line">        <span class="keyword">int</span> localLength = Math.min(length, s.capacity() - (index - adjustment));</span><br><span class="line">        <span class="comment">// 开始索引为index - c.offset，而不是0</span></span><br><span class="line">        s.getBytes(index - adjustment, dst, dstIndex, localLength);</span><br><span class="line">        index += localLength;</span><br><span class="line">        dstIndex += localLength;</span><br><span class="line">        length -= localLength;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the index for the given offset</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">toComponentIndex</span><span class="params">(<span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    checkIndex(offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> low = <span class="number">0</span>, high = components.size(); low &lt;= high;) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + high &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Component c = components.get(mid);</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= c.endOffset) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &lt; c.offset) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"should not reach here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>CompositeByteBuf</code> 在处理 <code>index</code> 时是先将其转换成对应 <code>Component</code> 在 <code>components</code> 中的索引，以及在 <code>Component</code> 中的偏移，然后从这个 <code>Component</code> 的这个偏移开始，往后循环取字节，直到读完。</p>
<p>NOTE：这里有个小trick，因为 <code>components</code> 是有序排列的，所以 <code>toComponentIndex</code> 做索引转换时没有直接遍历，而是用的二分查找。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://segmentfault.com/a/1190000011769315" target="_blank" rel="noopener">Netty 之 Zero-copy 的实现（上）</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/18/%E4%B8%BA%E5%95%A5HashMap%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%80%E5%AE%9A%E6%98%AF2%E7%9A%84n%E6%AC%A1%E6%96%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/18/%E4%B8%BA%E5%95%A5HashMap%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%80%E5%AE%9A%E6%98%AF2%E7%9A%84n%E6%AC%A1%E6%96%B9/" class="post-title-link" itemprop="url">为啥HashMap的长度一定是2的n次方</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-18 13:34:12 / 修改时间：21:36:52" itemprop="dateCreated datePublished" datetime="2020-07-18T13:34:12+08:00">2020-07-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先你应当记住的：<strong>不管你传不传参数，不管你传入的长度为多少，在你用HashMap的时候，他的长度都是2的n次方，且最大长度为2的30次方</strong></p>
<h1 id="最大长度"><a href="#最大长度" class="headerlink" title="最大长度"></a>最大长度</h1><p>在HashMap的源码中，最大长度这个常量值是这样定义的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="line">     * by either of the constructors with arguments.</span><br><span class="line">     * MUST be a power of two &lt;&#x3D; 1&lt;&lt;30.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这个值用在哪里呢？</p>
<ul>
<li>resize()函数，这个是用来扩容的</li>
<li>tableSizeFor()，这个也是用来扩容的</li>
<li>构造函数中</li>
<li>putEntries()，存放一组HashMap元素时，不是存放单个</li>
</ul>
<h1 id="为什么table长度一定是2的n次方"><a href="#为什么table长度一定是2的n次方" class="headerlink" title="为什么table长度一定是2的n次方"></a>为什么table长度一定是2的n次方</h1><p>注意，源码中他们采用了<strong>延迟初始化操作</strong>，也就是table只有在用到的时候才初始化，如果你不对他进行<code>put</code>等操作的话，table的长度永远为”零”</p>
<p>主要有两个函数保证了他的长度为2的n次方</p>
<ul>
<li>tableSizeFor()</li>
<li>resize()</li>
</ul>
<p>至于计算过程以及加载过程，请参考我的这篇文章：<em><a href="https://github.com/leosanqing/Java-Notes/blob/master/hashMap/table长度到底是多少.md" target="_blank" rel="noopener">table的长度到底是多少</a></em></p>
<p>这篇文章我从源码分析table的创建过程，包括上面提到的函数的调用，看了这个你一定明白为啥<code>table</code>的长度一定是2的n次方</p>
<p>当然我针对hashMap写的一部分源码的中文注释github上也有：<a href="https://github.com/leosanqing/StructAndAlgorithm/blob/master/Struct/hashMapDemo/src/MyHashMap.java" target="_blank" rel="noopener">HashMap源码中文注释</a></p>
<h1 id="2的n次有什么好处"><a href="#2的n次有什么好处" class="headerlink" title="2的n次有什么好处"></a>2的n次有什么好处</h1><ul>
<li>计算方便</li>
<li>hash分布更均匀</li>
</ul>
<h2 id="分布均匀"><a href="#分布均匀" class="headerlink" title="分布均匀"></a>分布均匀</h2><p><strong>如果不是2的n次方，那么有些位置上是永远不会被用到</strong>(我觉得比较牵强,前提是使用&amp;优化%)</p>
<p>具体可以参考这篇博文，他用例子讲述了为什么，<a href="https://blog.csdn.net/zjcjava/article/details/78495416" target="_blank" rel="noopener">为啥长度要是2的n次方</a></p>
<h2 id="计算方便"><a href="#计算方便" class="headerlink" title="计算方便"></a>计算方便</h2><ul>
<li>当容量一定是2^n时，h &amp; (length - 1) == h % length</li>
<li>扩容后计算新位置，非常方便，相比 JDK1.7</li>
</ul>
<h3 id="JDK-1-8改动"><a href="#JDK-1-8改动" class="headerlink" title="JDK 1.8改动"></a>JDK 1.8改动</h3><p>在 JDK1.8 中，HashMap有了挺大的改动，包括</p>
<ul>
<li>元素迁移算法(旧的到新的数组)</li>
<li>使用红黑树</li>
<li>链表为尾插法</li>
</ul>
<p>其中我重点讲下元素迁移算法，JDK1.8的时候</p>
<p>首先看下java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将原来数组中的所有元素都 copy进新的数组</span></span><br><span class="line"><span class="keyword">if</span>(oldTab != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; j++) &#123;</span><br><span class="line">        Entry e;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((e = oldTab[j]) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 说明还没有成链，数组上只有一个</span></span><br><span class="line">            <span class="keyword">if</span>(e.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 重新计算 数组索引 值</span></span><br><span class="line">                newTable[e.h &amp; (newCap-<span class="number">1</span>)] = e;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否为树结构</span></span><br><span class="line">            <span class="comment">//else if (e instanceof TreeNode)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不是树，只是链表,即长度还没有大于 8 进化成树</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 扩容后，如果元素的 index 还是原来的。就使用这个lo前缀的</span></span><br><span class="line">                Entry loHead=<span class="keyword">null</span>, loTail =<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 扩容后  元素index改变，那么就使用 hi前缀开头的</span></span><br><span class="line">                Entry hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                Entry next;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    <span class="comment">//这个非常重要，也比较难懂，</span></span><br><span class="line">                    <span class="comment">// 将它和原来的长度进行相与，就是判断他的原来的hash的上一个  bit 位是否为 1。</span></span><br><span class="line">                    <span class="comment">//以此来判断他是在相同的索引还是table长度加上原来的索引</span></span><br><span class="line">                    <span class="keyword">if</span>((e.h &amp; oldCap) == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// 如果 loTail == null ,说明这个 位置上是第一次添加，没有哈希冲突</span></span><br><span class="line">                        <span class="keyword">if</span>(loTail == <span class="keyword">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(hiTail == <span class="keyword">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e ;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(loTail != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTable[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 新的index 等于原来的 index+oldCap</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTable[j+oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们看到上面源码的最后一句，<code>newTable[j+oldCap] = hiHead;</code>意思就是哪怕我们的元素从旧的数组迁移到新的数组，我们也不需要重新计算他的hash和新数组长度相与的值，只需要直接将现在的<code>索引值+原来数组的长度</code>即可</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/6/169f2ac1fb1a2d06?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<blockquote>
<p>蓝色的表示不需要移动的，绿色的表示需要重新计算索引的，我们看到，他只是加了16(原来的数组table长度)</p>
</blockquote>
<h2 id="计算索引需要"><a href="#计算索引需要" class="headerlink" title="计算索引需要"></a>计算索引需要</h2><p>我们注意到上面的源代码中，判断扩容后元素位置需不需要改变的时候，我们使用到了这个判断</p>
<p><code>if((e.h &amp; oldCap) == 0)</code>，</p>
<blockquote>
<p>如果为0，那么就不需要改变，使用旧的索引即可；如果为1，那么就需要使用新的索引</p>
</blockquote>
<p>为啥会这样呢？</p>
<ul>
<li><strong>如果元素的索引要变那么   <code>hash&amp;(newTable.length-1)</code>一定是和 <code>hash&amp;(oldTable.length-1)+oldTable.length</code>相等</strong></li>
<li><strong>因为table的长度一定是2的n次方，也就是oldCap 一定是2的n次方，也就是说 oldCap有且只有一位是1，而且这个位置在最高位；</strong></li>
</ul>
<p>我们来举个例子：</p>
<p>我们假设元素的hash值的后12位是 110111010111，数组原来的长度为16，扩容后数组长度为32 </p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/6/169f2ac200f75065?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><strong>你可以试下下次扩容时，扩容到64时，索引变不变化。当然答案是不会变化，因为元素的hash值在那个位置为 0</strong></p>
<h3 id="对比1-7扩容"><a href="#对比1-7扩容" class="headerlink" title="对比1.7扩容"></a>对比1.7扩容</h3><p>我们来对比JDK1.7 的方式，他如果要扩容，并且扩容后计算元素的索引的话要使用 <code>indexFor函数</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Returns index for hash code h. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";  </span></span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>也就是要把元素的hash值重新再和新的数组长度-1 再相与一次，会比较麻烦而且不优雅，完全没有我看到1.8计算方式的那种惊艳感。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5ca89b1ee51d4560932c7705" target="_blank" rel="noopener">为啥HashMap的长度一定是2的n次方</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/18/%E4%B8%BA%E4%BB%80%E4%B9%88hashmap%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA8%E6%97%B6%E5%8F%98%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/18/%E4%B8%BA%E4%BB%80%E4%B9%88hashmap%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA8%E6%97%B6%E5%8F%98%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">为什么hashmap链表的长度为8时变成红黑树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-18 13:28:35 / 修改时间：21:32:52" itemprop="dateCreated datePublished" datetime="2020-07-18T13:28:35+08:00">2020-07-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为什么链表的长度为8是变成红黑树？为什么为6时又变成链表？</p>
<p>   因为，大部分的文章都是分析链表是怎么转换成红黑树的，但是并没有说明为什么当链表长度为8的时候才做转换动作。本人第一反应也是一样，只能初略的猜测是因为时间和空间的权衡</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">首先</span><br><span class="line">当链表长度为6时 查询的平均长度为 n&#x2F;2&#x3D;3</span><br><span class="line">红黑树为 log(6)&#x3D;2.6</span><br><span class="line">    </span><br><span class="line">为8时 ： 链表  8&#x2F;2&#x3D;4   </span><br><span class="line">         红黑树   log(8)&#x3D;3</span><br></pre></td></tr></table></figure>
<p>  根据两者的函数图也可以知道随着bin中的数量越多那么红黑树花的时间远远比链表少，所以我觉得这也是原因之一。为7的时候两者应该是 链表花的时间小于红黑树的，但是为什么不是在7的时候转成链表呢，我觉得可能是因为把7当做一个链表和红黑树的过渡点。</p>
<p>事实上真的是因为考虑到时间复杂度所以才把是在8的时候进行转成红黑树吗？其实这并不是真正的原因</p>
<p>至于为什么阈值是8，我想，去源码中找寻答案应该是最可靠的途径。</p>
<p>8这个阈值定义在HashMap中，如下所示，这段注释只说明了8是bin（bin就是bucket，即HashMap中hashCode值一样的元素保存的地方）从链表转成树的阈值，但是并没有说明为什么是8：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>我们继续往下看，在HashMap中有一段Implementation notes，笔者摘录了几段重要的描述，第一段如下所示，大概含义是当bin变得很大的时候，就会被转换成TreeNodes中的bin，其结构和TreeMap相似，也就是红黑树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This map usually acts as a binned (bucketed) hash table, but</span><br><span class="line">when bins get too large, they are transformed into bins of TreeNodes,</span><br><span class="line">each structured similarly to those in java.util.TreeMap</span><br></pre></td></tr></table></figure>
<p>继续往下看，TreeNodes占用空间是普通Nodes的两倍，所以只有当bin包含足够多的节点时才会转成TreeNodes，而是否足够多就是由TREEIFY_THRESHOLD的值决定的。当bin中节点数变少时，又会转成普通的bin。并且我们查看源码的时候发现，链表长度达到8就转成红黑树，当长度降到6就转成普通bin。</p>
<p>这样就解析了为什么不是一开始就将其转换为TreeNodes，而是需要一定节点数才转为TreeNodes，说白了就是trade-off，空间和时间的权衡：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="line">use them only when bins contain enough nodes to warrant use</span><br><span class="line">(see TREEIFY_THRESHOLD). And when they become too small (due to</span><br><span class="line">removal or resizing) they are converted back to plain bins.  In</span><br><span class="line">usages with well-distributed user hashCodes, tree bins are</span><br><span class="line">rarely used.  Ideally, under random hashCodes, the frequency of</span><br><span class="line">nodes in bins follows a Poisson distribution</span><br><span class="line">(http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Poisson_distribution) with a</span><br><span class="line">parameter of about 0.5 on average for the default resizing</span><br><span class="line">threshold of 0.75, although with a large variance because of</span><br><span class="line">resizing granularity. Ignoring variance, the expected</span><br><span class="line">occurrences of list size k are (exp(-0.5)*pow(0.5, k)&#x2F;factorial(k)). </span><br><span class="line">The first values are:</span><br><span class="line">0:    0.60653066</span><br><span class="line">1:    0.30326533</span><br><span class="line">2:    0.07581633</span><br><span class="line">3:    0.01263606</span><br><span class="line">4:    0.00157952</span><br><span class="line">5:    0.00015795</span><br><span class="line">6:    0.00001316</span><br><span class="line">7:    0.00000094</span><br><span class="line">8:    0.00000006</span><br><span class="line">more: less than 1 in ten million</span><br></pre></td></tr></table></figure>
<p>这段内容还说到：<strong>当hashCode离散性很好的时候，树型bin用到的概率非常小</strong>，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过<strong>理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布</strong>，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。</p>
<p>通俗点将就是put进去的key进行计算hashCode时 只要选择计算hash值的算法足够好(hash碰撞率极低)，从而遵循泊松分布，使得桶中挂载的bin的数量等于8的概率非常小，从而转换为红黑树的概率也小，反之则概率大。</p>
<p>所以，之所以选择8，不是拍脑袋决定的，而是根据概率统计决定的。由此可见，发展30年的Java每一项改动和优化都是非常严谨和科学的。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://blog.csdn.net/qq_27409289/article/details/92759730" target="_blank" rel="noopener">为什么hashmap链表的长度为8时变成红黑树</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/18/CopyOnWriteArrayList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/18/CopyOnWriteArrayList/" class="post-title-link" itemprop="url">CopyOnWriteArrayList</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-18 13:07:06 / 修改时间：21:12:58" itemprop="dateCreated datePublished" datetime="2020-07-18T13:07:06+08:00">2020-07-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Copy-On-Write-是什么？"><a href="#Copy-On-Write-是什么？" class="headerlink" title="Copy-On-Write 是什么？"></a>Copy-On-Write 是什么？</h2><p>首先我讲一下什么是<code>Copy-On-Write</code>，顾名思义，在计算机中就是当你想要对一块内存进行修改时，我们不在原有内存块中进行<code>写</code>操作，而是将内存拷贝一份，在新的内存中进行<code>写</code>操作，<code>写</code>完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉嘛！</p>
<p>网上兄弟们说了，这是一种用于程序设计中的<code>优化策略</code>，是一种<code>延时懒惰策略</code>。都说优化优化，那么到底优化了哪些问题呢？</p>
<p>先给大家一份代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		list.add(<span class="string">"1"</span>);</span><br><span class="line">		list.add(<span class="string">"2"</span>);</span><br><span class="line">		list.add(<span class="string">"3"</span>);</span><br><span class="line">		</span><br><span class="line">		Iterator&lt;String&gt; iter = list.iterator();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//我当前正在迭代集合（这里模拟并发中读取某一list的场景）</span></span><br><span class="line">		<span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">			</span><br><span class="line">			System.err.println(iter.next());</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.err.println(Arrays.toString(list.toArray()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序片段在单线程下执行时没什么毛病的，但到了多线程的环境中，可能就GG了！为什么呢？因为多线程环境中，你在迭代的时候是不允许有其他线程对这个集合list进行添加元素的，看下面这段代码，你会发现抛出<code>java.util.ConcurrentModificationException</code>的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		list.add(<span class="string">"1"</span>);</span><br><span class="line">		list.add(<span class="string">"2"</span>);</span><br><span class="line">		list.add(<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">		Iterator&lt;String&gt; iter = list.iterator();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 存放10个线程的线程池</span></span><br><span class="line">		ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 执行10个任务(我当前正在迭代集合（这里模拟并发中读取某一list的场景）)</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">						System.err.println(iter.next());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 执行10个任务</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					list.add(<span class="string">"121"</span>);<span class="comment">// 添加数据</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.err.println(Arrays.toString(list.toArray()));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>1、这里的<code>迭代</code>表示我当前正在读取某种<code>集合</code>中的数据,属于<code>读</code>操作；</li>
<li>2、线程则模拟当前程序处于多线程环境中，有其他线程正在修改该数据</li>
</ul>
<p>这里暴露的问题是什么呢？</p>
<ul>
<li>多线程会对迭代集合产生影响，影响读操作</li>
</ul>
<p>解决：</p>
<ul>
<li><code>CopyOnWriteArrayList</code> 避免了多线程操作List线程不安全的问题</li>
</ul>
<h2 id="CopyOnWriteArrayList介绍"><a href="#CopyOnWriteArrayList介绍" class="headerlink" title="CopyOnWriteArrayList介绍"></a>CopyOnWriteArrayList介绍</h2><p>从JDK1.5开始Java并发包里提供了两个使用<code>CopyOnWrite</code>机制实现的并发容器,它们是<code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>。<code>CopyOnWrite</code>容器非常有用，可以在非常多的并发场景中使用到。</p>
<p><code>CopyOnWriteArrayList</code>原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面已经讲了，就是在写的时候不对原集合进行修改，而是重新复制一份，修改完之后，再移动指针</span><br></pre></td></tr></table></figure>

<p>那么你可能会问？就算是对原集合进行复制，在多线程环境中不也是一样会导致写入冲突吗？没错，但是你可能还不知道<code>CopyOnWriteArrayList</code>中增加删除元素的实现细节，下面我就说说网上老是提到的<code>add()方法</code></p>
<h2 id="CopyOnWriteArrayList简单源码解读"><a href="#CopyOnWriteArrayList简单源码解读" class="headerlink" title="CopyOnWriteArrayList简单源码解读"></a>CopyOnWriteArrayList简单源码解读</h2><p><code>add()</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;<span class="comment">//重入锁</span></span><br><span class="line">        lock.lock();<span class="comment">//加锁啦</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//拷贝新数组</span></span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);<span class="comment">//将引用指向新数组  1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();<span class="comment">//解锁啦</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>恍然大悟，小样，原来<code>add()</code>在添加集合的时候加上了锁，保证了同步，避免了多线程写的时候会Copy出N个副本出来。(<code>想想，你在遍历一个10个元素的集合，每遍历一次有1人调用add方法，你说当你遍历10次，这add方法是不是得被调用10次呢？是不是得copy出10分新集合呢？万一这个集合非常大呢？</code>)</p>
<p>那么？你还要问？<code>CopyOnWriteArrayList</code>是怎么解决线程安全问题的？答案就是—-<code>写时复制，加锁</code> 还要问？那么有没有这么一种情况，当一个线程刚好调用完<code>add()</code>方法，也就是刚好执行到上面<code>1</code>处的代码，也就是刚好将引用指向心数组，而此时有线程正在遍历呢？会不会报错呢？（<code>答案是不会的，因为你正在遍历的集合是旧的，这就有点难受啦，哈哈~</code>）</p>
<p>当你把上面的代码的<code>ArrayList</code>改为<code>CopyOnWriteArrayList</code>，执行就不会报错啦！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		list.add(<span class="string">"1"</span>);</span><br><span class="line">		list.add(<span class="string">"2"</span>);</span><br><span class="line">		list.add(<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">		Iterator&lt;String&gt; iter = list.iterator();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 存放10个线程的线程池</span></span><br><span class="line">		ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 执行10个任务(我当前正在迭代集合（这里模拟并发中读取某一list的场景）)</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">						System.err.println(iter.next());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					list.add(<span class="string">"121"</span>);<span class="comment">// 添加数据</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 执行10个任务</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					list.add(<span class="string">"121"</span>);<span class="comment">// 添加数据</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">						System.err.println(iter.next());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.err.println(Arrays.toString(list.toArray()));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CopyOnWriteArrayList-优缺点"><a href="#CopyOnWriteArrayList-优缺点" class="headerlink" title="CopyOnWriteArrayList 优缺点"></a>CopyOnWriteArrayList 优缺点</h2><p>缺点：</p>
<ul>
<li>1、耗内存（集合复制）</li>
<li>2、实时性不高</li>
</ul>
<p>优点：</p>
<ul>
<li>1、数据一致性完整，为什么？因为加锁了，并发数据不会乱</li>
<li>2、解决了<code>像ArrayList</code>、<code>Vector</code>这种集合多线程遍历迭代问题，记住，<code>Vector</code>虽然线程安全，只不过是加了<code>synchronized</code>关键字，迭代问题完全没有解决！</li>
</ul>
<h2 id="CopyOnWriteArrayList-使用场景"><a href="#CopyOnWriteArrayList-使用场景" class="headerlink" title="CopyOnWriteArrayList 使用场景"></a>CopyOnWriteArrayList 使用场景</h2><ul>
<li>1、读多写少（白名单，黑名单，商品类目的访问和更新场景），为什么？因为写的时候会复制新集合</li>
<li>2、集合不大，为什么？因为写的时候会复制新集合</li>
<li>实时性要求不高，为什么，因为有可能会读取到旧的集合数据</li>
</ul>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5aaa2ba8f265da239530b69e" target="_blank" rel="noopener">CopyOnWriteArrayList</a><br><a href="https://www.cnblogs.com/wucao/p/5350461.html" target="_blank" rel="noopener">如何线程安全地遍历List：Vector、CopyOnWriteArrayList</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/16/Linux%20IO%E6%A8%A1%E5%BC%8F%E5%8F%8A%20select%E3%80%81poll%E3%80%81epoll%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/16/Linux%20IO%E6%A8%A1%E5%BC%8F%E5%8F%8A%20select%E3%80%81poll%E3%80%81epoll%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Linux IO模式及 select、poll、epoll详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-17 06:59:38 / 修改时间：15:38:15" itemprop="dateCreated datePublished" datetime="2020-07-17T06:59:38+08:00">2020-07-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文讨论的背景是Linux环境下的network IO。</span><br></pre></td></tr></table></figure>

<h1 id="一-概念说明"><a href="#一-概念说明" class="headerlink" title="一 概念说明"></a>一 概念说明</h1><p>在进行解释之前，首先要说明几个概念：<br> - 用户空间和内核空间<br> - 进程切换<br> - 进程的阻塞<br> - 文件描述符<br> - 缓存 I/O</p>
<h2 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h2><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：<br> \1. 保存处理机上下文，包括程序计数器和其他寄存器。<br> \2. 更新PCB信息。<br> \3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。<br> \4. 选择另一个进程执行，并更新其PCB。<br> \5. 更新内存管理的数据结构。<br> \6. 恢复处理机上下文。</p>
<p>注：<strong>总而言之就是很耗资源</strong>，具体的可以参考这篇文章：<a href="http://guojing.me/linux-kernel-architecture/posts/process-switch/" target="_blank" rel="noopener">进程切换</a></p>
<h2 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h2><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<code>当进程进入阻塞状态，是不占用CPU资源的</code>。</p>
<h2 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h2><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<h2 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I/O"></a>缓存 I/O</h2><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<p><strong>缓存 I/O 的缺点：</strong><br> 数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h1 id="二-IO模式"><a href="#二-IO模式" class="headerlink" title="二 IO模式"></a>二 IO模式</h1><p>刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：<br> \1. 等待数据准备 (Waiting for the data to be ready)<br> \2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</p>
<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。<br> - 阻塞 I/O（blocking IO）<br> - 非阻塞 I/O（nonblocking IO）<br> - I/O 多路复用（ IO multiplexing）<br> - 信号驱动 I/O（ signal driven IO）<br> - 异步 I/O（asynchronous IO）</p>
<p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p>
<h2 id="阻塞-I-O（blocking-IO）"><a href="#阻塞-I-O（blocking-IO）" class="headerlink" title="阻塞 I/O（blocking IO）"></a>阻塞 I/O（blocking IO）</h2><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：<br><img src="/img/bVm1c3" alt="clipboard.png"></p>
<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
<blockquote>
<p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
</blockquote>
<h2 id="非阻塞-I-O（nonblocking-IO）"><a href="#非阻塞-I-O（nonblocking-IO）" class="headerlink" title="非阻塞 I/O（nonblocking IO）"></a>非阻塞 I/O（nonblocking IO）</h2><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><img src="/img/bVm1c4" alt="clipboard.png"></p>
<p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<blockquote>
<p>所以，nonblocking IO的特点是用户进程需要<strong>不断的主动询问</strong>kernel数据好了没有。</p>
</blockquote>
<h2 id="I-O-多路复用（-IO-multiplexing）"><a href="#I-O-多路复用（-IO-multiplexing）" class="headerlink" title="I/O 多路复用（ IO multiplexing）"></a>I/O 多路复用（ IO multiplexing）</h2><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p><img src="/img/bVm1c5" alt="clipboard.png"></p>
<p><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<blockquote>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
</blockquote>
<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h2 id="异步-I-O（asynchronous-IO）"><a href="#异步-I-O（asynchronous-IO）" class="headerlink" title="异步 I/O（asynchronous IO）"></a>异步 I/O（asynchronous IO）</h2><p>inux下的asynchronous IO其实用得很少。先看一下它的流程：<br><img src="/img/bVm1c8" alt="clipboard.png"></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="blocking和non-blocking的区别"><a href="#blocking和non-blocking的区别" class="headerlink" title="blocking和non-blocking的区别"></a>blocking和non-blocking的区别</h3><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>
<h3 id="synchronous-IO和asynchronous-IO的区别"><a href="#synchronous-IO和asynchronous-IO的区别" class="headerlink" title="synchronous IO和asynchronous IO的区别"></a>synchronous IO和asynchronous IO的区别</h3><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：<br> -  A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br> -  An asynchronous I/O operation does not cause the requesting process to be blocked;</p>
<p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
<p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>
<p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<p><strong>各个IO Model的比较如图所示：</strong><br><img src="/img/bVm1c9" alt="clipboard.png"></p>
<p>通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<h1 id="三-I-O-多路复用之select、poll、epoll详解"><a href="#三-I-O-多路复用之select、poll、epoll详解" class="headerlink" title="三 I/O 多路复用之select、poll、epoll详解"></a>三 I/O 多路复用之select、poll、epoll详解</h1><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。（这里啰嗦下）</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p>
<p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>
<blockquote>
<p>在linux下网络通信中，经常用到select机制，这是一种异步通信的实现方式，select中提供一fd_set的数据结果，实际上是一个long类型的数组， 每一个数组元素都能与一打开的文件句柄建立联系，通常这个句柄并不局限于网络通信中的socket句柄，还包括其他文件、命名管道或设备句柄等。当程序中调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执select()的进程哪一Socket或文件可读或者可写。</p>
<p>　　select的本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p>
<p>　　1、单个进程可监视的fd数量受到了限制，在32位机器上，他所能管理的fd数量最大为1024。</p>
<p>　　2、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</p>
<p>　　3、对socket进行扫描时是线性扫描，当socket文件描述符数量变多时，大量的时间是被白白浪费掉的。</p>
</blockquote>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>不同于select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    short events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    short revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<blockquote>
<p>从上面看，select和poll都需要在返回后，<strong>通过遍历文件描述符来获取已经就绪的socket</strong>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
</blockquote>
<blockquote>
<p>　poll是Linux中的字符设备驱动中有一个函数，Linux 2.5.44版本后已经被epoll所取代。poll机制是用在某些Unix系统中，使用poll()函数用于执行与select()函数同等功能的函数。</p>
<p>　　poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<p>　　相比于select机制，poll机制采用链表来进行文件描述符的存储，因此它并没有最大连接数的限制，但同样存在一些缺点：</p>
<p>　　1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</p>
<p>　　2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p>
</blockquote>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<p>　epoll是Linux内核为处理大批量的句柄而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p>
<p>　　epoll会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。</p>
<p>　　相比于poll机制，epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次。在fd的数组在用户态和内核地址空间之间复制的问题上，epoll使用mmap减少复制开销。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p>
<h3 id="一-epoll操作过程"><a href="#一-epoll操作过程" class="headerlink" title="一 epoll操作过程"></a>一 epoll操作过程</h3><p>epoll操作过程需要三个接口，分别如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>1. int epoll_create(int size);</strong><br> 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<code>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议</code>。<br> 当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<p><strong>2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</strong><br> 函数是对指定描述符fd执行op操作。<br> - epfd：是epoll_create()的返回值。<br> - op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。<br> - fd：是需要监听的fd（文件描述符）<br> - epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//events可以是以下几个宏的集合：</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure>

<p><strong>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong><br> 等待epfd上的io事件，最多返回maxevents个事件。<br> 参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<h3 id="二-工作模式"><a href="#二-工作模式" class="headerlink" title="二 工作模式"></a>二 工作模式</h3><p>　epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和<strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：<br> 　<strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br> 　<strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<h4 id="1-LT模式"><a href="#1-LT模式" class="headerlink" title="1. LT模式"></a>1. LT模式</h4><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<h4 id="2-ET模式"><a href="#2-ET模式" class="headerlink" title="2. ET模式"></a>2. ET模式</h4><p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p><strong>假如有这样一个例子：</strong><br> \1. 我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符<br> \2. 这个时候从管道的另一端被写入了2KB的数据<br> \3. 调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作<br> \4. 然后我们读取了1KB的数据<br> \5. 调用epoll_wait(2)……</p>
<p><strong>LT模式：</strong><br> 如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。</p>
<p><strong>ET模式：</strong><br> 如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p>
<p>当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后，<br> 读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p>
<p>​                        </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs)&#123;</span><br><span class="line">  buflen = recv(activeevents[i].data.fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(buflen &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读</span></span><br><span class="line">    <span class="comment">// 在这里就当作是该次事件已处理处.</span></span><br><span class="line">    <span class="keyword">if</span>(errno == EAGAIN)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(buflen == <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">// 这里表示对端的socket已正常关闭.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(buflen == <span class="keyword">sizeof</span>(buf)&#123;</span><br><span class="line">      rs = <span class="number">1</span>;   <span class="comment">// 需要再次读取</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">      rs = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Linux中的EAGAIN含义</strong></p>
</blockquote>
<p>Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。<br>    从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</p>
<p>例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。<br>    又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</p>
<h3 id="三-代码演示"><a href="#三-代码演示" class="headerlink" title="三 代码演示"></a>三 代码演示</h3><p>下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。</p>
<p>​                        </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPADDRESS   <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT        8787</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE     1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ     5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FDSIZE      1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLEVENTS 100</span></span><br><span class="line"></span><br><span class="line">listenfd = socket_bind(IPADDRESS,PORT);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EPOLLEVENTS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个描述符</span></span><br><span class="line">epollfd = epoll_create(FDSIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加监听描述符事件</span></span><br><span class="line">add_event(epollfd,listenfd,EPOLLIN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环等待</span></span><br><span class="line"><span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">    <span class="comment">//该函数返回已经准备好的描述符事件数目</span></span><br><span class="line">    ret = epoll_wait(epollfd,events,EPOLLEVENTS,<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//处理接收到的连接</span></span><br><span class="line">    handle_events(epollfd,events,ret,listenfd,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> epollfd,struct epoll_event *events,<span class="keyword">int</span> num,<span class="keyword">int</span> listenfd,<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">int</span> fd;</span><br><span class="line">     <span class="comment">//进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。</span></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         fd = events[i].data.fd;</span><br><span class="line">        <span class="comment">//根据描述符的类型和事件类型进行处理</span></span><br><span class="line">         <span class="keyword">if</span> ((fd == listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))</span><br><span class="line">            handle_accpet(epollfd,listenfd);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">            do_read(epollfd,fd,buf);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">            do_write(epollfd,fd,buf);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理接收到的连接</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_accpet</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> listenfd)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> clifd;     </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span>     </span><br><span class="line">     <span class="keyword">socklen_t</span>  cliaddrlen;     </span><br><span class="line">     clifd = accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);     </span><br><span class="line">     <span class="keyword">if</span> (clifd == <span class="number">-1</span>)         </span><br><span class="line">     perror(<span class="string">"accpet error:"</span>);     </span><br><span class="line">     <span class="keyword">else</span> &#123;         </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"accept a new client: %s:%d\n"</span>,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);                       <span class="comment">//添加一个客户描述符和事件         </span></span><br><span class="line">         add_event(epollfd,clifd,EPOLLIN);     </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nread;</span><br><span class="line">    nread = <span class="built_in">read</span>(fd,buf,MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>)     &#123;         </span><br><span class="line">        perror(<span class="string">"read error:"</span>);         </span><br><span class="line">        <span class="built_in">close</span>(fd); <span class="comment">//记住close fd        </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN); <span class="comment">//删除监听 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)     &#123;         </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"client close.\n"</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd); <span class="comment">//记住close fd       </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN); <span class="comment">//删除监听 </span></span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">else</span> &#123;         </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read message is : %s"</span>,buf);        </span><br><span class="line">        <span class="comment">//修改描述符对应的事件，由读改为写         </span></span><br><span class="line">        modify_event(epollfd,fd,EPOLLOUT);     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">int</span> nwrite;     </span><br><span class="line">    nwrite = <span class="built_in">write</span>(fd,buf,<span class="built_in">strlen</span>(buf));     </span><br><span class="line">    <span class="keyword">if</span> (nwrite == <span class="number">-1</span>)&#123;         </span><br><span class="line">        perror(<span class="string">"write error:"</span>);        </span><br><span class="line">        <span class="built_in">close</span>(fd);   <span class="comment">//记住close fd       </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLOUT);  <span class="comment">//删除监听    </span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        modify_event(epollfd,fd,EPOLLIN); </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,MAXSIZE); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>&#123;     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注：另外一端我就省了</span></span><br></pre></td></tr></table></figure>

<h3 id="四-epoll总结"><a href="#四-epoll总结" class="headerlink" title="四 epoll总结"></a>四 epoll总结</h3><p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而<strong>epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知</strong>。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制</code>。这正是epoll的魅力所在。)</p>
<p><strong>epoll的优点主要是一下几个方面：</strong><br> \1. 监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</p>
<ol>
<li>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li>
</ol>
<p><strong>如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</strong></p>
<h2 id="select、poll与epoll的比较"><a href="#select、poll与epoll的比较" class="headerlink" title="select、poll与epoll的比较"></a>select、poll与epoll的比较</h2><h3 id="1、支持一个进程所能管理的最大连接数"><a href="#1、支持一个进程所能管理的最大连接数" class="headerlink" title="　　1、支持一个进程所能管理的最大连接数"></a>　　1、支持一个进程所能管理的最大连接数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</td>
</tr>
<tr>
<td>poll</td>
<td>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</td>
</tr>
<tr>
<td>epoll</td>
<td>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</td>
</tr>
</tbody></table>
<h3 id="2、文件描述符剧增后带来的IO效率问题"><a href="#2、文件描述符剧增后带来的IO效率问题" class="headerlink" title="　　2、文件描述符剧增后带来的IO效率问题"></a>　　2、文件描述符剧增后带来的IO效率问题</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</td>
</tr>
<tr>
<td>poll</td>
<td>同上</td>
</tr>
<tr>
<td>epoll</td>
<td>因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</td>
</tr>
</tbody></table>
<h3 id="3、消息传递的方式"><a href="#3、消息传递的方式" class="headerlink" title="　　3、消息传递的方式"></a>　　3、消息传递的方式</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>内核需要将消息传递到用户空间，都需要内核拷贝动作</td>
</tr>
<tr>
<td>poll</td>
<td>同上</td>
</tr>
<tr>
<td>epoll</td>
<td>epoll通过内核和用户空间共享一块内存来实现的。</td>
</tr>
</tbody></table>
<hr>
<p>本文整理自</p>
<p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></p>
<p><a href="http://guojing.me/linux-kernel-architecture/posts/process-switch/" target="_blank" rel="noopener">进程切换</a><br><a href="https://zh.wikipedia.org/wiki/文件描述符" target="_blank" rel="noopener">维基百科-文件描述符</a><br><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-directio/" target="_blank" rel="noopener">Linux 中直接 I/O 机制的介绍</a><br><a href="http://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a><br><a href="http://www.cnblogs.com/bigwangdi/p/3182958.html" target="_blank" rel="noopener">Linux中select poll和epoll的区别</a><br><a href="http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html" target="_blank" rel="noopener">IO多路复用之select总结</a><br><a href="http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html" target="_blank" rel="noopener">IO多路复用之poll总结</a><br><a href="http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html" target="_blank" rel="noopener">IO多路复用之epoll总结</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/16/%E7%94%A8shell%E5%88%86%E6%9E%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/16/%E7%94%A8shell%E5%88%86%E6%9E%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A5%E5%BF%97/" class="post-title-link" itemprop="url">用shell分析服务器日志</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-17 06:48:50 / 修改时间：14:54:02" itemprop="dateCreated datePublished" datetime="2020-07-17T06:48:50+08:00">2020-07-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1、查看有多少个IP访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;print $1&#125;&#39; log_file|sort|uniq|wc -l</span><br></pre></td></tr></table></figure>

<p>2、查看某一个页面被访问的次数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;&#x2F;index.php&quot; log_file | wc -l</span><br></pre></td></tr></table></figure>

<p>3、查看每一个IP访问了多少个页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;++S[$1]&#125; END &#123;for (a in S) print a,S[a]&#125;&#39; log_file &gt; log.txt</span><br></pre></td></tr></table></figure>

<p><code>sort -n -t &#39; &#39; -k 2 log.txt</code>   <strong>配合sort进一步排序</strong></p>
<p>4、将每个IP访问的页面数进行从小到大排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;++S[$1]&#125; END &#123;for (a in S) print S[a],a&#125;&#39; log_file | sort -n</span><br></pre></td></tr></table></figure>

<p>5、查看某一个IP访问了哪些页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep ^111.111.111.111 log_file| awk &#39;&#123;print $1,$7&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>6、去掉搜索引擎统计的页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;print $12,$1&#125;&#39; log_file | grep ^\&quot;Mozilla | awk &#39;&#123;print $2&#125;&#39; |sort | uniq | wc -l</span><br></pre></td></tr></table></figure>

<p>7、查看2015年8月16日14时这一个小时内有多少IP访问:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;print $4,$1&#125;&#39; log_file | grep 16&#x2F;Aug&#x2F;2015:14 | awk &#39;&#123;print $2&#125;&#39;| sort | uniq | wc -l</span><br></pre></td></tr></table></figure>

<p>8、查看访问前十个ip地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;print $1&#125;&#39; |sort|uniq -c|sort -nr |head -10 access_log</span><br></pre></td></tr></table></figure>

<p><strong>uniq -c 相当于分组统计并把统计数放在最前面</strong><br><code>cat access.log|awk &#39;{print $1}&#39;|sort|uniq -c|sort -nr|head -10</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log|awk &#39;&#123;counts[$(11)]+&#x3D;1&#125;; END &#123;for(url in counts) print counts[url], url&#125;</span><br></pre></td></tr></table></figure>

<p>9、访问次数最多的10个文件或页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat log_file|awk &#39;&#123;print $11&#125;&#39;|sort|uniq -c|sort -nr | head -10</span><br><span class="line">cat log_file|awk &#39;&#123;print $11&#125;&#39;|sort|uniq -c|sort -nr|head -20</span><br></pre></td></tr></table></figure>

<p><code>awk &#39;{print $1}&#39; log_file |sort -n -r |uniq -c | sort -n -r | head -20</code><br><strong>访问量最大的前20个ip</strong></p>
<p>10、通过子域名访问次数，依据referer来计算，稍有不准</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk &#39;&#123;print $11&#125;&#39; | sed -e &#39; s&#x2F;http:\&#x2F;\&#x2F;&#x2F;&#x2F;&#39; -e &#39; s&#x2F;\&#x2F;.*&#x2F;&#x2F;&#39; | sort | uniq -c | sort -rn | head -20</span><br></pre></td></tr></table></figure>

<p>11、列出传输大小最大的几个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat www.access.log |awk &#39;($7~&#x2F;\.php&#x2F;)&#123;print $10 &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7&#125;&#39;|sort -nr|head -100</span><br></pre></td></tr></table></figure>

<p>12、列出输出大于200000byte(约200kb)的页面以及对应页面发生次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat www.access.log |awk &#39;($10 &gt; 200000 &amp;&amp; $7~&#x2F;\.php&#x2F;)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -100</span><br></pre></td></tr></table></figure>

<p>13、如果日志最后一列记录的是页面文件传输时间，则有列出到客户端最耗时的页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat www.access.log |awk &#39;($7~&#x2F;\.php&#x2F;)&#123;print $NF &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7&#125;&#39;|sort -nr|head -100</span><br></pre></td></tr></table></figure>

<p>14、列出最最耗时的页面(超过60秒的)的以及对应页面发生次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat www.access.log |awk &#39;($NF &gt; 60 &amp;&amp; $7~&#x2F;\.php&#x2F;)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -100</span><br></pre></td></tr></table></figure>

<p>15、列出传输时间超过 30 秒的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat www.access.log |awk &#39;($NF &gt; 30)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -20</span><br></pre></td></tr></table></figure>

<p>16、列出当前服务器每一进程运行的数量，倒序排列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | awk -F &#39; &#39; &#39;&#123;print $8 &quot; &quot; $9&#125;&#39; |sort | uniq -c |sort -nr |head -20</span><br></pre></td></tr></table></figure>

<p>17、查看apache当前并发访问数</p>
<p><strong>对比httpd.conf中MaxClients的数字差距多少</strong><br><code>netstat -an | grep ESTABLISHED | wc -l</code></p>
<p>18、可以使用如下参数查看数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep httpd|wc -l</span><br><span class="line"></span><br><span class="line">1388</span><br></pre></td></tr></table></figure>
<p><strong>统计httpd进程数，连个请求会启动一个进程，使用于Apache服务器。</strong><br><strong>表示Apache能够处理1388个并发请求，这个值Apache可根据负载情况自动调整</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat|grep -i &quot;80&quot;|wc -l</span><br><span class="line"></span><br><span class="line">4341</span><br></pre></td></tr></table></figure>
<p><strong>netstat -an会打印系统当前网络链接状态，而grep -i “80”是用来提取与80端口有关的连接的，wc -l进行连接数统计。</strong><br><strong>最终返回的数字就是当前所有80端口的请求总数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -na|grep ESTABLISHED|wc -l</span><br><span class="line">376</span><br></pre></td></tr></table></figure>
<p><strong>netstat -an会打印系统当前网络链接状态，而grep ESTABLISHED 提取出已建立连接的信息。 然后wc -l统计</strong><br><strong>最终返回的数字就是当前所有80端口的已建立连接的总数。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat||grep ESTABLISHED|wc</span><br></pre></td></tr></table></figure>

<p><strong>可查看所有建立连接的详细记录</strong></p>
<p>19、输出每个ip的连接数，以及总的各个状态的连接数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;n&#x3D;split($(NF-1),array,&quot;:&quot;);if(n&lt;&#x3D;2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N&#125; END &#123;for(a in S)&#123;printf(&quot;%-20s %s\n&quot;, a, S[a]);++I&#125;printf(&quot;%-20s %s\n&quot;,&quot;TOTAL_IP&quot;,I);for(a in s) printf(&quot;%-20s %s\n&quot;,a, s[a]);printf(&quot;%-20s %s\n&quot;,&quot;TOTAL_LINK&quot;,N);&#125;</span><br></pre></td></tr></table></figure>

<p>20、其他的收集</p>
<p><strong>分析日志文件下 2012-05-04 访问页面最高 的前20个 URL  并排序</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log |grep &#39;04&#x2F;May&#x2F;2012&#39;| awk &#39;&#123;print $11&#125;&#39;|sort|uniq -c|sort -nr|head -20</span><br></pre></td></tr></table></figure>

<p><strong>查询受访问页面的URL地址中 含有 <a href="http://www.abc.com" target="_blank" rel="noopener">www.abc.com</a> 网址的 IP 地址</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access_log | awk &#39;($11~&#x2F;\www.abc.com&#x2F;)&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr</span><br></pre></td></tr></table></figure>

<p><strong>获取访问最高的10个IP地址  同时也可以按时间来查询</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat linewow-access.log|awk &#39;&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr|head -10</span><br></pre></td></tr></table></figure>

<p><strong><em>\</em>时间段查询日志时间段的情况**</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat log_file | egrep &#39;15&#x2F;Aug&#x2F;2015|16&#x2F;Aug&#x2F;2015&#39; |awk &#39;&#123;print $1&#125;&#39;|sort|uniq -c|sort -nr|head -10</span><br></pre></td></tr></table></figure>

<p><strong>分析2015/8/15 到 2015/8/16 访问”/index.php?g=Member&amp;m=Public&amp;a=sendValidCode”的IP倒序排列</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat log_file | egrep &#39;15&#x2F;Aug&#x2F;2015|16&#x2F;Aug&#x2F;2015&#39; | awk &#39;&#123;if($7 &#x3D;&#x3D; &quot;&#x2F;index.php?g&#x3D;Member&amp;m&#x3D;Public&amp;a&#x3D;sendValidCode&quot;) print $1,$7&#125;&#39;|sort|uniq -c|sort -nr</span><br></pre></td></tr></table></figure>

<p><strong>(7里面包含.php的就输出,本句的意思是最耗时的一百个PHP页面</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat log_file |awk &#39;($7~&#x2F;\.php&#x2F;)&#123;print $NF &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7&#125;&#39;|sort -nr|head -100</span><br></pre></td></tr></table></figure>

<p><strong>列出最最耗时的页面(超过60秒的)的以及对应页面发生次数</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log |awk &#39;($NF &gt; 60 &amp;&amp; $7~&#x2F;\.php&#x2F;)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -100</span><br></pre></td></tr></table></figure>

<p><strong>统计网站流量（G)</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log |awk &#39;&#123;sum+&#x3D;$10&#125; END &#123;print sum&#x2F;1024&#x2F;1024&#x2F;1024&#125;&#39;</span><br></pre></td></tr></table></figure>

<p><strong>统计404的连接</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;($9 ~&#x2F;404&#x2F;)&#39; access.log | awk &#39;&#123;print $9,$7&#125;&#39; | sort</span><br></pre></td></tr></table></figure>

<p><strong>统计http status</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat access.log |awk &#39;&#123;counts[$(9)]+&#x3D;1&#125;; END &#123;for(code in counts) print code, counts[code]&#125;&#39;&#96; </span><br><span class="line">&#96;cat access.log |awk &#39;&#123;print $9&#125;&#39;|sort|uniq -c|sort -rn</span><br></pre></td></tr></table></figure>

<p><strong>每秒并发</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch &quot;awk &#39;&#123;if($9~&#x2F;200|30|404&#x2F;)COUNT[$4]++&#125;END&#123;for( a in COUNT) print a,COUNT[a]&#125;&#39; log_file|sort -k 2 -nr|head -n10&quot;</span><br></pre></td></tr></table></figure>

<p><strong>带宽统计</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat apache.log |awk &#39;&#123;if($7~&#x2F;GET&#x2F;) count++&#125;END&#123;print &quot;client_request&#x3D;&quot;count&#125;&#39;&#96; </span><br><span class="line">&#96;cat apache.log |awk &#39;&#123;BYTE+&#x3D;$11&#125;END&#123;print &quot;client_kbyte_out&#x3D;&quot;BYTE&#x2F;1024&quot;KB&quot;&#125;&#39;</span><br></pre></td></tr></table></figure>

<p><strong>找出某天访问次数最多的10个IP</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;tmp&#x2F;access.log | grep &quot;20&#x2F;Mar&#x2F;2011&quot; |awk &#39;&#123;print $3&#125;&#39;|sort |uniq -c|sort -nr|head</span><br></pre></td></tr></table></figure>

<p><strong>当天ip连接数最高的ip都在干些什么</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | grep &quot;10.0.21.17&quot; | awk &#39;&#123;print $8&#125;&#39; | sort | uniq -c | sort -nr | head -n 10</span><br></pre></td></tr></table></figure>

<p><strong>小时单位里ip连接数最多的10个时段</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -vFS&#x3D;&quot;[:]&quot; &#39;&#123;gsub(&quot;-.*&quot;,&quot;&quot;,$1);num[$2&quot; &quot;$1]++&#125;END&#123;for(i in num)print i,num[i]&#125;&#39; log_file | sort -n -k 3 -r | head -10</span><br></pre></td></tr></table></figure>

<p><strong>找出访问次数最多的几个分钟</strong> </p>
<p><code>awk &#39;{print $1}&#39; access.log | grep &quot;20/Mar/2011&quot; |cut -c 14-18|sort|uniq -c|sort -nr|head</code><br><strong>取5分钟日志</strong><br><code>if [ $DATE_MINUTE != $DATE_END_MINUTE ] ;then</code> #则判断开始时间戳与结束时间戳是否相等<br><code>START_LINE=sed -n &quot;/$DATE_MINUTE/=&quot; $APACHE_LOG|head -n1</code> #如果不相等，则取出开始时间戳的行号，与结束时间戳的行号 </p>
<p><strong>查看tcp的链接状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat |awk &#39;&#123;print $6&#125;&#39;|sort|uniq -c|sort -rn </span><br><span class="line">    </span><br><span class="line">netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++S[$NF]&#125;;END &#123;for(a in S) print a, S[a]&#125;&#39; </span><br><span class="line"></span><br><span class="line">netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++state[$NF]&#125;; END &#123;for(key in state) print key,&quot;\t&quot;,state[key]&#125;&#39; </span><br><span class="line">    </span><br><span class="line">netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++arr[$NF]&#125;;END &#123;for(k in arr) print k,&quot;\t&quot;,arr[k]&#125;&#39; </span><br><span class="line">    </span><br><span class="line">netstat -n |awk &#39;&#x2F;^tcp&#x2F; &#123;print $NF&#125;&#39;|sort|uniq -c|sort -rn </span><br><span class="line">    </span><br><span class="line">netstat -ant | awk &#39;&#123;print $NF&#125;&#39; | grep -v &#39;[a-z]&#39; | sort | uniq -c</span><br><span class="line">netstat -ant|awk &#39;&#x2F;ip:80&#x2F;&#123;split($5,ip,&quot;:&quot;);++S[ip[1]]&#125;END&#123;for (a in S) print S[a],a&#125;&#39; |sort -n </span><br><span class="line">    </span><br><span class="line">netstat -ant|awk &#39;&#x2F;:80&#x2F;&#123;split($5,ip,&quot;:&quot;);++S[ip[1]]&#125;END&#123;for (a in S) print S[a],a&#125;&#39; |sort -rn|head -n 10 </span><br><span class="line">    </span><br><span class="line">awk &#39;BEGIN&#123;printf (&quot;http_code\tcount_num\n&quot;)&#125;&#123;COUNT[$10]++&#125;END&#123;for (a in COUNT) printf a&quot;\t\t&quot;COUNT[a]&quot;\n&quot;&#125;&#39;</span><br></pre></td></tr></table></figure>

<p><strong>查找请求数前20个IP（常用于查找攻来源）：</strong><br><code>netstat -anlp|grep 80|grep tcp|awk &#39;{print $5}&#39;|awk -F: &#39;{print $1}&#39;|sort|uniq -c|sort -nr|head -n20</code><br><code>netstat -ant |awk &#39;/:80/{split($5,ip,&quot;:&quot;);++A[ip[1]]}END{for(i in A) print A[i],i}&#39; |sort -rn|head -n20</code></p>
<p><strong>用tcpdump嗅探80端口的访问看看谁最高</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F&quot;.&quot; &#39;&#123;print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4&#125;&#39; | sort | uniq -c | sort -nr |head -20</span><br></pre></td></tr></table></figure>

<p><strong>查找较多time_wait连接</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n|grep TIME_WAIT|awk &#39;&#123;print $5&#125;&#39;|sort|uniq -c|sort -rn|head -n20</span><br></pre></td></tr></table></figure>

<p><strong>找查较多的SYN连接</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | grep SYN | awk &#39;&#123;print $5&#125;&#39; | awk -F: &#39;&#123;print $1&#125;&#39; | sort | uniq -c | sort -nr | more</span><br></pre></td></tr></table></figure>

<p><strong>根据端口列进程</strong><br><code>netstat -ntlp | grep 80 | awk &#39;{print $7}&#39; | cut -d/ -f1</code></p>
<p><strong>查看了连接数和当前的连接数</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -ant | grep $ip:80 | wc -l&#96; </span><br><span class="line">&#96;netstat -ant | grep $ip:80 | grep EST | wc -l</span><br></pre></td></tr></table></figure>

<p><strong>查看IP访问次数</strong><br><code>netstat -nat|grep &quot;:80&quot;|awk &#39;{print $5}&#39; |awk -F: &#39;{print $1}&#39; | sort| uniq -c|sort -n</code></p>
<p><strong>Linux命令分析当前的链接状况</strong><br><code>netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;</code></p>
<p><code>watch &quot;netstat -n | awk &#39;/^tcp/ {++S[\$NF]} END {for(a in S) print a, S[a]}&#39;&quot;</code>  # 通过watch可以一直监控</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LAST_ACK 5 #关闭一个TCP连接需要从两个方向上分别进行关闭，双方都是通过发送FIN来表示单方向数据的关闭，当通信双方发送了最后一个FIN的时候，发送方此时处于LAST_ACK状态，当发送方收到对方的确认（Fin的Ack确认）后才真正关闭整个TCP连接；</span><br><span class="line"></span><br><span class="line">SYN_RECV 30  # 表示正在等待处理的请求数；</span><br><span class="line"></span><br><span class="line">ESTABLISHED 1597 # 表示正常数据传输状态； </span><br><span class="line"></span><br><span class="line">FIN_WAIT1 51 # 表示server端主动要求关闭tcp连接； </span><br><span class="line"></span><br><span class="line">FIN_WAIT2 504 # 表示客户端中断连接； </span><br><span class="line"></span><br><span class="line">TIME_WAIT 1057  # 表示处理完毕，等待超时结束的请求数；</span><br></pre></td></tr></table></figure>

<hr>
<p>本文整理自</p>
<p><a href="https://segmentfault.com/a/1190000009745139" target="_blank" rel="noopener">shell在手分析服务器日志不用愁</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/16/%20kafka%E4%B8%AD%E7%9A%84topic%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%88%86%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/16/%20kafka%E4%B8%AD%E7%9A%84topic%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%88%86%E5%8C%BA/" class="post-title-link" itemprop="url">kafka中的topic为什么要进行分区</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-17 06:24:39 / 修改时间：14:33:38" itemprop="dateCreated datePublished" datetime="2020-07-17T06:24:39+08:00">2020-07-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kafka可以将主题划分为多个分区（Partition），会根据分区规则选择把消息存储到哪个分区中，只要如果分区规则设置的合理，那么所有的消息将会被均匀的分布到不同的分区中，这样就实现了负载均衡和水平扩展。另外，多个订阅者可以从一个或者多个分区中同时消费数据，以支撑海量数据处理能力：</p>
<p><img src="https://pic3.zhimg.com/50/v2-b30dec8282913a27d1978aae5a6e6431_hd.jpg?source=1940ef5c" alt="img">)<img src="https://pic3.zhimg.com/80/v2-b30dec8282913a27d1978aae5a6e6431_720w.jpg?source=1940ef5c" alt="img"></p>
<p>Kafka的设计也是源自生活，好比是为公路运输，不同的起始点和目的地需要修不同高速公路（主题），高速公路上可以提供多条车道（分区），流量大的公路多修几条车道保证畅通，流量小的公路少修几条车道避免浪费。收费站好比消费者，车多的时候多开几个一起收费避免堵在路上，车少的时候开几个让汽车并道就好了，嗯……</p>
<p>顺便说一句，由于消息是以追加到分区中的，多个分区顺序写磁盘的总效率要比随机写内存还要高（引用Apache Kafka – A High Throughput Distributed Messaging System的观点），是Kafka高吞吐率的重要保证之一。</p>
<p>为了保证数据的可靠性，Kafka会给每个分区找一个节点当带头大哥（Leader），以及若干个节点当随从（Follower）。消息写入分区时，带头大哥除了自己复制一份外还会复制到多个随从。如果随从挂了，Kafka会再找一个随从从带头大哥那里同步历史消息；如果带头大哥挂了，随从中会选举出新一任的带头大哥，继续笑傲江湖。</p>
<p><img src="https://pic3.zhimg.com/50/v2-59a85614d80d122c935bc03a065aba43_hd.jpg?source=1940ef5c" alt="img">)<img src="https://pic3.zhimg.com/80/v2-59a85614d80d122c935bc03a065aba43_720w.jpg?source=1940ef5c" alt="img"></p>
<h3 id="1-kafka为什么要在topic里加入分区的概念？"><a href="#1-kafka为什么要在topic里加入分区的概念？" class="headerlink" title="1.kafka为什么要在topic里加入分区的概念？"></a>1.kafka为什么要在topic里加入分区的概念？</h3><p>topic是逻辑的概念，partition是物理的概念，对用户来说是透明的。producer只需要关心消息发往哪个topic，而consumer只关心自己订阅哪个topic，并不关心每条消息存于整个集群的哪个broker。</p>
<p>为了性能考虑，如果topic内的消息只存于一个broker，那这个broker会成为瓶颈，无法做到水平扩展。所以把topic内的数据分布到整个集群就是一个自然而然的设计方式。Partition的引入就是解决水平扩展问题的一个方案。</p>
<p>每个partition可以被认为是一个无限长度的数组，新数据顺序追加进这个数组。物理上，每个partition对应于一个文件夹。一个broker上可以存放多个partition。这样，producer可以将数据发送给多个broker上的多个partition，consumer也可以并行从多个broker上的不同paritition上读数据，实现了水平扩展.</p>
<h3 id="2-如果没有分区-topic中的segment消息写满后-直接给订阅者不是也可以吗"><a href="#2-如果没有分区-topic中的segment消息写满后-直接给订阅者不是也可以吗" class="headerlink" title="2.如果没有分区,topic中的segment消息写满后,直接给订阅者不是也可以吗?"></a>2.如果没有分区,topic中的segment消息写满后,直接给订阅者不是也可以吗?</h3><p>“segment消息写满后”，consume消费数据并不需要等到segment写满，只要有一条数据被commit，就可以立马被消费.</p>
<p>segment对应一个文件（实现上对应2个文件，一个数据文件，一个索引文件），一个partition对应一个文件夹，一个partition里理论上可以包含任意多个segment。所以partition可以认为是在segment上做了一层包装。</p>
<p>这个问题换个角度问可能更好，“为什么有了partition还需要segment”。</p>
<p>如果不引入segment，一个partition直接对应一个文件（应该说两个文件，一个数据文件，一个索引文件），那这个文件会一直增大。同时，在做data purge时，需要把文件的前面部分给删除，不符合kafka对文件的顺序写优化设计方案。引入segment后，每次做data purge，只需要把旧的segment整个文件删除即可，保证了每个segment的顺序写，</p>
<hr>
<p>本文整理自</p>
<p><a href="https://www.zhihu.com/question/28925721/answer/139861200" target="_blank" rel="noopener">kafka中的topic为什么要进行分区</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EricMa"
      src="/images/eric.png">
  <p class="site-author-name" itemprop="name">EricMa</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">225</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Eric-Ma-C" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Eric-Ma-C" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chaoma@zju.edu.cn" title="E-Mail → mailto:chaoma@zju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EricMa</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">848k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
