<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Eric&#39;s Blogs">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Eric&#39;s Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="EricMa">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Eric's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Eric's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Better Code, Better Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/Java%E9%9B%86%E5%90%88%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/Java%E9%9B%86%E5%90%88%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Java集合简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-14 07:31:36 / 修改时间：20:33:25" itemprop="dateCreated datePublished" datetime="2020-06-14T07:31:36+08:00">2020-06-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h2><p>什么是集合（Collection）？集合就是“由若干个确定的元素所构成的整体”。</p>
<p>在数学中，我们经常遇到集合的概念。例如：</p>
<ul>
<li>有限集合：<ul>
<li>一个班所有的同学构成的集合；</li>
<li>一个网站所有的商品构成的集合；</li>
<li>…</li>
</ul>
</li>
<li>无限集合：<ul>
<li>全体自然数集合：1，2，3，……</li>
<li>有理数集合；</li>
<li>实数集合；</li>
<li>…</li>
</ul>
</li>
</ul>
<p>为什么要在计算机中引入集合呢？这是为了便于处理一组类似的数据，例如：</p>
<ul>
<li>计算所有同学的总成绩和平均成绩；</li>
<li>列举所有的商品名称和价格；</li>
<li>……</li>
</ul>
<p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] ss = <span class="keyword">new</span> String[<span class="number">10</span>]; <span class="comment">// 可以持有10个String对象</span></span><br><span class="line">ss[<span class="number">0</span>] = <span class="string">"Hello"</span>; <span class="comment">// 可以放入String对象</span></span><br><span class="line">String first = ss[<span class="number">0</span>]; <span class="comment">// 可以获取String对象</span></span><br></pre></td></tr></table></figure>

<p>既然Java提供了数组这种数据类型，可以充当集合，那么，我们为什么还需要其他集合类？这是因为数组有如下限制：</p>
<ul>
<li>数组初始化后大小不可变；</li>
<li>数组只能按索引顺序存取。</li>
</ul>
<p>因此，我们需要各种不同类型的集合类来处理不同的数据，例如：</p>
<ul>
<li>可变大小的顺序链表；</li>
<li>保证无重复元素的集合；</li>
<li>…</li>
</ul>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>Java标准库自带的<code>java.util</code>包提供了集合类：<code>Collection</code>，它是<strong>除<code>Map</code>外所有其他集合类的根接口</strong>。Java的<code>java.util</code>包主要提供了以下三种类型的集合：</p>
<ul>
<li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li>
<li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li>
<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li>
</ul>
<p>Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是<code>List</code>，具体的实现类有<code>ArrayList</code>，<code>LinkedList</code>等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 只能放入String类型</span></span><br></pre></td></tr></table></figure>

<p>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>
<p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<ul>
<li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li>
<li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li>
<li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li>
</ul>
<p>还有一小部分接口是遗留接口，也不应该继续使用：</p>
<ul>
<li><code>Enumeration</code>：已被<code>Iterator</code>取代。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Java的集合类定义在<code>java.util</code>包中，支持泛型，主要提供了3种集合类，包括<code>List</code>，<code>Set</code>和<code>Map</code>。Java集合使用统一的<code>Iterator</code>遍历，尽量不要使用遗留接口。</p>
<h2 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h2><p>Java的集合类都可以使用<code>for each</code>循环，<code>List</code>、<code>Set</code>和<code>Queue</code>会迭代每个元素，<code>Map</code>会迭代每个key。以<code>List</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; List.of(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;);</span><br><span class="line">for (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，Java编译器并不知道如何遍历<code>List</code>。上述代码能够编译通过，只是因为<strong>编译器把<code>for each</code>循环通过<code>Iterator</code>改写为了普通的<code>for</code>循环</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">     String s = it.next();</span><br><span class="line">     System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把这种通过<code>Iterator</code>对象遍历集合的模式称为迭代器。</p>
<p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。</p>
<p>例如，我们虽然知道<code>ArrayList</code>在内部是以数组形式存储元素，并且，它还提供了<code>get(int)</code>方法。虽然我们可以用<code>for</code>循环遍历：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i&#x3D;0; i&lt;list.size(); i++) &#123;</span><br><span class="line">    Object value &#x3D; list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样一来，调用方就必须知道集合的内部存储结构。并且，如果把<code>ArrayList</code>换成<code>LinkedList</code>，<code>get(int)</code>方法耗时会随着index的增加而增加。如果把<code>ArrayList</code>换成<code>Set</code>，上述代码就无法编译，因为<code>Set</code>内部没有索引。</p>
<p>用<code>Iterator</code>遍历就没有上述问题，因为<strong><code>Iterator</code>对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合</strong>，调用方则获得了统一的代码，编译器才能把标准的<code>for each</code>循环自动转换为<code>Iterator</code>遍历。</p>
<p>如果我们自己编写了一个集合类，想要使用<code>for each</code>循环，只需满足以下条件：</p>
<ul>
<li>集合类实现<code>Iterable</code>接口，该接口要求返回一个<code>Iterator</code>对象；</li>
<li>用<code>Iterator</code>对象迭代集合内部数据。</li>
</ul>
<p>这里的关键在于，集合类通过调用<code>iterator()</code>方法，返回一个<code>Iterator</code>对象，这个对象必须自己知道如何遍历该集合。</p>
<p>一个简单的<code>Iterator</code>示例如下，它总是以倒序遍历集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReverseList&lt;String&gt; rlist = <span class="keyword">new</span> ReverseList&lt;&gt;();</span><br><span class="line">        rlist.add(<span class="string">"Apple"</span>);</span><br><span class="line">        rlist.add(<span class="string">"Orange"</span>);</span><br><span class="line">        rlist.add(<span class="string">"Pear"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : rlist) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReverseIterator(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReverseIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        ReverseIterator(<span class="keyword">int</span> index) &#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">return</span> ReverseList.<span class="keyword">this</span>.list.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然<code>ReverseList</code>和<code>ReverseIterator</code>的实现类稍微比较复杂，但是，注意到这是底层集合库，只需编写一次。而调用方则完全按<code>for each</code>循环编写代码，根本不需要知道集合内部的存储逻辑和遍历逻辑。</p>
<p>在编写<code>Iterator</code>的时候，我们通常可以<strong>用一个内部类来实现<code>Iterator</code>接口</strong>，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，<strong>内部类<code>ReverseIterator</code>可以用<code>ReverseList.this</code>获得当前外部类的<code>this</code>引用</strong>，然后，通过这个<code>this</code>引用就可以访问<code>ReverseList</code>的所有字段和方法。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><code>Iterator</code>是一种抽象的数据访问模型。使用<code>Iterator</code>模式进行迭代的好处有：</p>
<ul>
<li>对任何集合都采用同一种访问模型；</li>
<li>调用者对集合内部结构一无所知；</li>
<li>集合类返回的<code>Iterator</code>对象知道如何迭代。</li>
</ul>
<p>Java提供了标准的迭代器模型，即集合类实现<code>java.util.Iterable</code>接口，返回<code>java.util.Iterator</code>实例。</p>
<h2 id="工具类Collections"><a href="#工具类Collections" class="headerlink" title="工具类Collections"></a>工具类Collections</h2><p><code>Collections</code>是JDK提供的工具类，同样位于<code>java.util</code>包中。它<strong>提供了一系列静态方法，能更方便地操作各种集合。</strong></p>
<blockquote>
<p> 注意Collections结尾多了一个s，不是Collection！</p>
</blockquote>
<p>我们一般看方法名和参数就可以确认<code>Collections</code>提供的该方法的功能。例如，对于以下静态方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static boolean addAll(Collection&lt;? super T&gt; c, T... elements) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><code>addAll()</code>方法可以给一个<code>Collection</code>类型的集合添加若干元素。因为方法签名是<code>Collection</code>，所以我们可以传入<code>List</code>，<code>Set</code>等各种集合类型。</p>
<h3 id="创建空集合"><a href="#创建空集合" class="headerlink" title="创建空集合"></a>创建空集合</h3><p><code>Collections</code>提供了一系列方法来创建空集合：</p>
<ul>
<li>创建空List：<code>List emptyList()</code></li>
<li>创建空Map：<code>Map emptyMap()</code></li>
<li>创建空Set：<code>Set emptySet()</code></li>
</ul>
<p>要注意到返回的空集合是<strong>不可变集合</strong>，无法向其中添加或删除元素。</p>
<p>此外，也可以用各个集合接口提供的<code>of(T...)</code>方法创建空集合。例如，以下创建空<code>List</code>的两个方法是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 &#x3D; List.of();</span><br><span class="line">List&lt;String&gt; list2 &#x3D; Collections.emptyList();</span><br></pre></td></tr></table></figure>

<h3 id="创建单元素集合"><a href="#创建单元素集合" class="headerlink" title="创建单元素集合"></a>创建单元素集合</h3><p><code>Collections</code>提供了一系列方法来创建一个单元素集合：</p>
<ul>
<li>创建一个元素的List：<code>List singletonList(T o)</code></li>
<li>创建一个元素的Map：<code>Map singletonMap(K key, V value)</code></li>
<li>创建一个元素的Set：<code>Set singleton(T o)</code></li>
</ul>
<p>要注意到返回的单元素集合也是<strong>不可变集合</strong>，无法向其中添加或删除元素。</p>
<p>此外，也可以用各个集合接口提供的<code>of(T...)</code>方法创建单元素集合。例如，以下创建单元素<code>List</code>的两个方法是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 &#x3D; List.of(&quot;apple&quot;);</span><br><span class="line">List&lt;String&gt; list2 &#x3D; Collections.singletonList(&quot;apple&quot;);</span><br></pre></td></tr></table></figure>

<p>实际上，使用<code>List.of(T...)</code>更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 &#x3D; List.of(); &#x2F;&#x2F; empty list</span><br><span class="line">List&lt;String&gt; list2 &#x3D; List.of(&quot;apple&quot;); &#x2F;&#x2F; 1 element</span><br><span class="line">List&lt;String&gt; list3 &#x3D; List.of(&quot;apple&quot;, &quot;pear&quot;); &#x2F;&#x2F; 2 elements</span><br><span class="line">List&lt;String&gt; list4 &#x3D; List.of(&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;); &#x2F;&#x2F; 3 elements</span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><code>Collections</code>可以对<code>List</code>进行排序。因为排序会直接修改<code>List</code>元素的位置，因此<strong>必须传入可变<code>List</code></strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"apple"</span>);</span><br><span class="line">        list.add(<span class="string">"pear"</span>);</span><br><span class="line">        list.add(<span class="string">"orange"</span>);</span><br><span class="line">        <span class="comment">// 排序前:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="comment">// 排序后:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="洗牌"><a href="#洗牌" class="headerlink" title="洗牌"></a>洗牌</h3><p><code>Collections</code>提供了洗牌算法，即传入一个有序的<code>List</code>，可以随机打乱<code>List</code>内部元素的顺序，效果相当于让计算机洗牌：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 洗牌前:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="comment">// 洗牌后:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p><code>Collections</code>还提供了一组方法把可变集合封装成不可变集合：</p>
<ul>
<li>封装成不可变List：<code>List unmodifiableList(List list)</code></li>
<li>封装成不可变Set：<code>Set unmodifiableSet(Set set)</code></li>
<li>封装成不可变Map：<code>Map unmodifiableMap(Map m)</code></li>
</ul>
<p>这种封装实际上是<strong>通过创建一个代理对象，拦截掉所有修改方法实现的</strong>。我们来看看效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; mutable = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        mutable.add(<span class="string">"apple"</span>);</span><br><span class="line">        mutable.add(<span class="string">"pear"</span>);</span><br><span class="line">        <span class="comment">// 变为不可变集合:</span></span><br><span class="line">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">        immutable.add(<span class="string">"orange"</span>); <span class="comment">// UnsupportedOperationException!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，继续对原始的可变<code>List</code>进行增删是可以的，并且，会直接影响到封装后的“不可变”<code>List</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; mutable = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        mutable.add(<span class="string">"apple"</span>);</span><br><span class="line">        mutable.add(<span class="string">"pear"</span>);</span><br><span class="line">        <span class="comment">// 变为不可变集合:</span></span><br><span class="line">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">        mutable.add(<span class="string">"orange"</span>);</span><br><span class="line">        System.out.println(immutable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[apple, pear, orange]</span><br></pre></td></tr></table></figure>

<p>因此，如果我们希望把一个可变<code>List</code>封装成不可变<code>List</code>，那么，返回不可变<code>List</code>后，<strong>最好立刻扔掉可变<code>List</code>的引用</strong>，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”<code>List</code>变化了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; mutable = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        mutable.add(<span class="string">"apple"</span>);</span><br><span class="line">        mutable.add(<span class="string">"pear"</span>);</span><br><span class="line">        <span class="comment">// 变为不可变集合:</span></span><br><span class="line">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">        <span class="comment">// 立刻扔掉mutable的引用:</span></span><br><span class="line">        mutable = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(immutable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h3><p><code>Collections</code>还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</p>
<ul>
<li>变为线程安全的List：<code>List synchronizedList(List list)</code></li>
<li>变为线程安全的Set：<code>Set synchronizedSet(Set s)</code></li>
<li>变为线程安全的Map：<code>Map synchronizedMap(Map m)</code></li>
</ul>
<p>多线程的概念我们会在后面讲。因为从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><code>Collections</code>类提供了一组工具方法来方便使用集合类：</p>
<ul>
<li>创建空集合；</li>
<li>创建单元素集合；</li>
<li>创建不可变集合；</li>
<li>排序／洗牌等操作。</li>
</ul>
<hr>
<p>本文整理自</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265109905179456" target="_blank" rel="noopener">Java集合简介</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/%E6%B5%85%E6%9E%90%20Netty%20%E5%AE%9E%E7%8E%B0%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/%E6%B5%85%E6%9E%90%20Netty%20%E5%AE%9E%E7%8E%B0%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E/" class="post-title-link" itemprop="url">浅析 Netty 实现心跳机制与断线重连</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-14 06:43:56 / 修改时间：14:47:22" itemprop="dateCreated datePublished" datetime="2020-06-14T06:43:56+08:00">2020-06-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="何为心跳"><a href="#何为心跳" class="headerlink" title="何为心跳"></a>何为心跳</h3><p>顾名思义, 所谓 <strong>心跳</strong>, 即在 TCP 长连接中, 客户端和服务器之间定期发送的一种特殊的数据包, 通知对方自己还在线, 以确保 TCP 连接的有效性.</p>
<h3 id="为什么需要心跳"><a href="#为什么需要心跳" class="headerlink" title="为什么需要心跳"></a>为什么需要心跳</h3><p>因为网络的不可靠性, 有可能在 TCP 保持长连接的过程中, 由于某些突发情况, 例如网线被拔出, 突然掉电等, 会造成服务器和客户端的连接中断. 在这些突发情况下, 如果恰好服务器和客户端之间没有交互的话, 那么它们是不能在短时间内发现对方已经掉线的. 为了解决这个问题, 我们就需要引入 <strong>心跳</strong> 机制. 心跳机制的工作原理是: 在服务器和客户端之间一定时间内没有数据交互时, 即处于 idle 状态时, 客户端或服务器会发送一个特殊的数据包给对方, 当接收方收到这个数据报文后, 也立即发送一个特殊的数据报文, 回应发送方, 此即一个 PING-PONG 交互. 自然地, 当某一端收到心跳消息后, 就知道了对方仍然在线, 这就确保 TCP 连接的有效性.</p>
<h3 id="如何实现心跳"><a href="#如何实现心跳" class="headerlink" title="如何实现心跳"></a>如何实现心跳</h3><p>我们可以通过两种方式实现心跳机制:</p>
<ul>
<li>使用 TCP 协议层面的 keepalive 机制.</li>
<li>在应用层上实现自定义的心跳机制.</li>
</ul>
<p>虽然在 TCP 协议层面上, 提供了 keepalive 保活机制, 但是使用它有几个缺点:</p>
<ol>
<li>它不是 TCP 的标准协议, 并且是默认关闭的.</li>
<li>TCP keepalive 机制依赖于操作系统的实现, 默认的 keepalive 心跳时间是 <strong>两个小时</strong>, 并且对 keepalive 的修改需要系统调用(或者修改系统配置), 灵活性不够.</li>
<li>TCP keepalive 与 TCP 协议绑定, 因此如果需要更换为 UDP 协议时, keepalive 机制就失效了.</li>
</ol>
<p>虽然使用 TCP 层面的 keepalive 机制比自定义的应用层心跳机制节省流量, 但是基于上面的几点缺点, 一般的实践中, 人们大多数都是选择在应用层上实现自定义的心跳.<br>既然如此, 那么我们就来大致看看在在 Netty 中是怎么实现心跳的吧. 在 Netty 中, 实现心跳机制的关键是 <strong>IdleStateHandler</strong>, 它可以对一个 Channel 的 读/写设置定时器, 当 Channel 在一定事件间隔内没有数据交互时(即处于 idle 状态), 就会触发指定的事件.</p>
<h2 id="使用-Netty-实现心跳"><a href="#使用-Netty-实现心跳" class="headerlink" title="使用 Netty 实现心跳"></a>使用 Netty 实现心跳</h2><p>上面我们提到了, 在 Netty 中, 实现心跳机制的关键是 <strong>IdleStateHandler</strong>, 那么这个 Handler 如何使用呢? 我们来看看它的构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">int</span> readerIdleTimeSeconds, <span class="keyword">int</span> writerIdleTimeSeconds, <span class="keyword">int</span> allIdleTimeSeconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>((<span class="keyword">long</span>)readerIdleTimeSeconds, (<span class="keyword">long</span>)writerIdleTimeSeconds, (<span class="keyword">long</span>)allIdleTimeSeconds, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化一个 IdleStateHandler 需要提供三个参数:</p>
<ul>
<li>readerIdleTimeSeconds, 读超时. 即当在指定的时间间隔内没有从 Channel 读取到数据时, 会触发一个 READER_IDLE 的 IdleStateEvent 事件.</li>
<li>writerIdleTimeSeconds, 写超时. 即当在指定的时间间隔内没有数据写入到 Channel 时, 会触发一个 WRITER_IDLE 的 IdleStateEvent 事件.</li>
<li>allIdleTimeSeconds, 读/写超时. 即当在指定的时间间隔内没有读或写操作时, 会触发一个 ALL_IDLE 的 IdleStateEvent 事件.</li>
</ul>
<p>为了展示具体的 IdleStateHandler 实现的心跳机制, 下面我们来构造一个具体的EchoServer 的例子, 这个例子的行为如下:</p>
<ol>
<li>在这个例子中, 客户端和服务器通过 TCP 长连接进行通信.</li>
<li>TCP 通信的报文格式是:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--------+-----+---------------+ </span><br><span class="line">| Length |Type |   Content     |</span><br><span class="line">|   17   |  1  |&quot;HELLO, WORLD&quot; |</span><br><span class="line">+--------+-----+---------------+</span><br></pre></td></tr></table></figure>

<ol>
<li>客户端每隔一个随机的时间后, 向服务器发送消息, 服务器收到消息后, 立即将收到的消息原封不动地回复给客户端.</li>
<li>若客户端在指定的时间间隔内没有读/写操作, 则客户端会自动向服务器发送一个 PING 心跳, 服务器收到 PING 心跳消息时, 需要回复一个 PONG 消息.</li>
</ol>
<p>下面所使用的代码例子可以在我的 <a href="https://github.com/yongshun/some_java_code" target="_blank" rel="noopener">Github</a> github.com/yongshun/some_java_code 上找到.</p>
<h3 id="通用部分"><a href="#通用部分" class="headerlink" title="通用部分"></a>通用部分</h3><p>根据上面定义的行为, 我们接下来实现心跳的通用部分 <strong>CustomHeartbeatHandler</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiongyongshun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> yongshun1228@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@created</span> 16/9/18 13:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomHeartbeatHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> PING_MSG = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> PONG_MSG = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CUSTOM_MSG = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeatCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomHeartbeatHandler</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext context, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (byteBuf.getByte(<span class="number">4</span>) == PING_MSG) &#123;</span><br><span class="line">            sendPongMsg(context);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (byteBuf.getByte(<span class="number">4</span>) == PONG_MSG)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">" get pong msg from "</span> + context.channel().remoteAddress());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handleData(context, byteBuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendPingMsg</span><span class="params">(ChannelHandlerContext context)</span> </span>&#123;</span><br><span class="line">        ByteBuf buf = context.alloc().buffer(<span class="number">5</span>);</span><br><span class="line">        buf.writeInt(<span class="number">5</span>);</span><br><span class="line">        buf.writeByte(PING_MSG);</span><br><span class="line">        context.writeAndFlush(buf);</span><br><span class="line">        heartbeatCount++;</span><br><span class="line">        System.out.println(name + <span class="string">" sent ping msg to "</span> + context.channel().remoteAddress() + <span class="string">", count: "</span> + heartbeatCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendPongMsg</span><span class="params">(ChannelHandlerContext context)</span> </span>&#123;</span><br><span class="line">        ByteBuf buf = context.alloc().buffer(<span class="number">5</span>);</span><br><span class="line">        buf.writeInt(<span class="number">5</span>);</span><br><span class="line">        buf.writeByte(PONG_MSG);</span><br><span class="line">        context.channel().writeAndFlush(buf);</span><br><span class="line">        heartbeatCount++;</span><br><span class="line">        System.out.println(name + <span class="string">" sent pong msg to "</span> + context.channel().remoteAddress() + <span class="string">", count: "</span> + heartbeatCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleData</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// IdleStateHandler 所产生的 IdleStateEvent 的处理逻辑.</span></span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleStateEvent e = (IdleStateEvent) evt;</span><br><span class="line">            <span class="keyword">switch</span> (e.state()) &#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    handleReaderIdle(ctx);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    handleWriterIdle(ctx);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    handleAllIdle(ctx);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"---"</span> + ctx.channel().remoteAddress() + <span class="string">" is active---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"---"</span> + ctx.channel().remoteAddress() + <span class="string">" is inactive---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleReaderIdle</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"---READER_IDLE---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleWriterIdle</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"---WRITER_IDLE---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleAllIdle</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"---ALL_IDLE---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 CustomHeartbeatHandler 负责心跳的发送和接收, 我们接下来详细地分析一下它的作用. 我们在前面提到, IdleStateHandler 是实现心跳的关键, 它会根据不同的 IO idle 类型来产生不同的 IdleStateEvent 事件, 而这个事件的捕获, 其实就是在 <strong>userEventTriggered</strong> 方法中实现的.<br>我们来看看 CustomHeartbeatHandler.userEventTriggered 的具体实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        IdleStateEvent e = (IdleStateEvent) evt;</span><br><span class="line">        <span class="keyword">switch</span> (e.state()) &#123;</span><br><span class="line">            <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                handleReaderIdle(ctx);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                handleWriterIdle(ctx);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                handleAllIdle(ctx);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 userEventTriggered 中, 根据 IdleStateEvent 的 state() 的不同, 而进行不同的处理. 例如如果是读取数据 idle, 则 e.state() == READER_IDLE, 因此就调用 <strong>handleReaderIdle</strong> 来处理它. CustomHeartbeatHandler 提供了三个 idle 处理方法: handleReaderIdle, handleWriterIdle, handleAllIdle, 这三个方法目前只有默认的实现, 它需要在子类中进行重写, 现在我们暂时略过它们, 在具体的客户端和服务器的实现部分时再来看它们.</p>
<p>知道了这一点后, 我们接下来看看数据处理部分:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext context, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (byteBuf.getByte(<span class="number">4</span>) == PING_MSG) &#123;</span><br><span class="line">        sendPongMsg(context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (byteBuf.getByte(<span class="number">4</span>) == PONG_MSG)&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" get pong msg from "</span> + context.channel().remoteAddress());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handleData(context, byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 CustomHeartbeatHandler.channelRead0 中, 我们首先根据报文协议:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--------+-----+---------------+ </span><br><span class="line">| Length |Type |   Content     |</span><br><span class="line">|   17   |  1  |&quot;HELLO, WORLD&quot; |</span><br><span class="line">+--------+-----+---------------+</span><br></pre></td></tr></table></figure>

<p>来判断当前的报文类型, 如果是 PING_MSG 则表示是服务器收到客户端的 PING 消息, 此时服务器需要回复一个 PONG 消息, 其消息类型是 PONG_MSG.<br>扔报文类型是 PONG_MSG, 则表示是客户端收到服务器发送的 PONG 消息, 此时打印一个 log 即可.</p>
<h3 id="客户端部分"><a href="#客户端部分" class="headerlink" title="客户端部分"></a>客户端部分</h3><h4 id="客户端初始化"><a href="#客户端初始化" class="headerlink" title="客户端初始化"></a>客户端初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">4</span>);</span><br><span class="line">        Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap</span><br><span class="line">                    .group(workGroup)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline p = socketChannel.pipeline();</span><br><span class="line">                            p.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                            p.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, -<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">                            p.addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            Channel ch = bootstrap.remoteAddress(<span class="string">"127.0.0.1"</span>, <span class="number">12345</span>).connect().sync().channel();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                String content = <span class="string">"client msg "</span> + i;</span><br><span class="line">                ByteBuf buf = ch.alloc().buffer();</span><br><span class="line">                buf.writeInt(<span class="number">5</span> + content.getBytes().length);</span><br><span class="line">                buf.writeByte(CustomHeartbeatHandler.CUSTOM_MSG);</span><br><span class="line">                buf.writeBytes(content.getBytes());</span><br><span class="line">                ch.writeAndFlush(buf);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">20000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是 Netty 的客户端端的初始化代码, 使用过 Netty 的朋友对这个代码应该不会陌生. 别的部分我们就不再赘述, 我们来看看 ChannelInitializer.initChannel 部分即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline p = socketChannel.pipeline();</span><br><span class="line">        p.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">        p.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, -<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">        p.addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们给 pipeline 添加了三个 Handler, <strong>IdleStateHandler</strong> 这个 handler 是心跳机制的核心, 我们为客户端端设置了读写 idle 超时, 时间间隔是5s, 即如果客户端在间隔 5s 后都没有收到服务器的消息或向服务器发送消息, 则产生 ALL_IDLE 事件.<br>接下来我们添加了 <strong>LengthFieldBasedFrameDecoder</strong>, 它是负责解析我们的 TCP 报文, 因为和本文的目的无关, 因此这里不详细展开.<br>最后一个 Handler 是 ClientHandler, 它继承于 CustomHeartbeatHandler, 是我们处理业务逻辑部分.</p>
<h4 id="客户端-Handler"><a href="#客户端-Handler" class="headerlink" title="客户端 Handler"></a>客户端 Handler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">CustomHeartbeatHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"client"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleData</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.readableBytes() - <span class="number">5</span>];</span><br><span class="line">        byteBuf.skipBytes(<span class="number">5</span>);</span><br><span class="line">        byteBuf.readBytes(data);</span><br><span class="line">        String content = <span class="keyword">new</span> String(data);</span><br><span class="line">        System.out.println(name + <span class="string">" get content: "</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleAllIdle</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleAllIdle(ctx);</span><br><span class="line">        sendPingMsg(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClientHandler 继承于 CustomHeartbeatHandler, 它重写了两个方法, 一个是 handleData, 在这里面实现 仅仅打印收到的消息.<br>第二个重写的方法是 <strong>handleAllIdle</strong>. 我们在前面提到, 客户端负责发送心跳的 PING 消息, 当客户端产生一个 <strong>ALL_IDLE</strong> 事件后, 会导致父类的 CustomHeartbeatHandler.userEventTriggered 调用, 而 userEventTriggered 中会根据 e.state() 来调用不同的方法, 因此最后调用的是 <strong>ClientHandler.handleAllIdle</strong>, 在这个方法中, 客户端调用 <strong>sendPingMsg</strong> 向服务器发送一个 PING 消息.</p>
<h3 id="服务器部分"><a href="#服务器部分" class="headerlink" title="服务器部分"></a>服务器部分</h3><h4 id="服务器初始化"><a href="#服务器初始化" class="headerlink" title="服务器初始化"></a>服务器初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap</span><br><span class="line">                    .group(bossGroup, workGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline p = socketChannel.pipeline();</span><br><span class="line">                            p.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">                            p.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, -<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">                            p.addLast(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            Channel ch = bootstrap.bind(<span class="number">12345</span>).sync().channel();</span><br><span class="line">            ch.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器的初始化部分也没有什么好说的, 它也和客户端的初始化一样, 为 pipeline 添加了三个 Handler.</p>
<h4 id="服务器-Handler"><a href="#服务器-Handler" class="headerlink" title="服务器 Handler"></a>服务器 Handler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">CustomHeartbeatHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"server"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleData</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf buf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes() - <span class="number">5</span>];</span><br><span class="line">        ByteBuf responseBuf = Unpooled.copiedBuffer(buf);</span><br><span class="line">        buf.skipBytes(<span class="number">5</span>);</span><br><span class="line">        buf.readBytes(data);</span><br><span class="line">        String content = <span class="keyword">new</span> String(data);</span><br><span class="line">        System.out.println(name + <span class="string">" get content: "</span> + content);</span><br><span class="line">        channelHandlerContext.write(responseBuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleReaderIdle</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleReaderIdle(ctx);</span><br><span class="line">        System.err.println(<span class="string">"---client "</span> + ctx.channel().remoteAddress().toString() + <span class="string">" reader timeout, close it---"</span>);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServerHandler 继承于 CustomHeartbeatHandler, 它重写了两个方法, 一个是 handleData, 在这里面实现 EchoServer 的功能: 即收到客户端的消息后, 立即原封不动地将消息回复给客户端.<br>第二个重写的方法是 <strong>handleReaderIdle</strong>, 因为服务器仅仅对客户端的读 idle 感兴趣, 因此只重新了这个方法. 若服务器在指定时间后没有收到客户端的消息, 则会触发 <strong>READER_IDLE</strong> 消息, 进而会调用 <strong>handleReaderIdle</strong> 这个方法. 我们在前面提到, 客户端负责发送心跳的 PING 消息, 并且服务器的 <strong>READER_IDLE</strong> 的超时时间是客户端发送 PING 消息的间隔的两倍, 因此当服务器 <strong>READER_IDLE</strong> 触发时, 就可以确定是客户端已经掉线了, 因此服务器直接关闭客户端连接即可.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>使用 Netty 实现心跳机制的关键就是利用 <strong>IdleStateHandler</strong> 来产生对应的 idle 事件.</li>
<li>一般是客户端负责发送心跳的 PING 消息, 因此客户端注意关注 <strong>ALL_IDLE</strong> 事件, 在这个事件触发后, 客户端需要向服务器发送 PING 消息, 告诉服务器”我还存活着”.</li>
<li>服务器是接收客户端的 PING 消息的, 因此服务器关注的是 <strong>READER_IDLE</strong> 事件, 并且服务器的 <strong>READER_IDLE</strong> 间隔需要比客户端的 <strong>ALL_IDLE</strong> 事件间隔大(例如客户端ALL_IDLE 是5s 没有读写时触发, 因此服务器的 READER_IDLE 可以设置为10s)</li>
<li>当服务器收到客户端的 PING 消息时, 会发送一个 PONG 消息作为回复. 一个 PING-PONG 消息对就是一个心跳交互.</li>
</ol>
<h2 id="实现客户端的断线重连"><a href="#实现客户端的断线重连" class="headerlink" title="实现客户端的断线重连"></a>实现客户端的断线重连</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NioEventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> Bootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        client.start();</span><br><span class="line">        client.sendData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                String content = <span class="string">"client msg "</span> + i;</span><br><span class="line">                ByteBuf buf = channel.alloc().buffer(<span class="number">5</span> + content.getBytes().length);</span><br><span class="line">                buf.writeInt(<span class="number">5</span> + content.getBytes().length);</span><br><span class="line">                buf.writeByte(CustomHeartbeatHandler.CUSTOM_MSG);</span><br><span class="line">                buf.writeBytes(content.getBytes());</span><br><span class="line">                channel.writeAndFlush(buf);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread.sleep(random.nextInt(<span class="number">20000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap</span><br><span class="line">                    .group(workGroup)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline p = socketChannel.pipeline();</span><br><span class="line">                            p.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                            p.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, -<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">                            p.addLast(<span class="keyword">new</span> ClientHandler(Client.<span class="keyword">this</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            doConnect();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChannelFuture future = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line">        future.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture futureListener)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (futureListener.isSuccess()) &#123;</span><br><span class="line">                    channel = futureListener.channel();</span><br><span class="line">                    System.out.println(<span class="string">"Connect to server successfully!"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Failed to connect to server, try connect after 10s"</span>);</span><br><span class="line"></span><br><span class="line">                    futureListener.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            doConnect();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中, 我们抽象出 doConnect 方法, 它负责客户端和服务器的 TCP 连接的建立, 并且当 TCP 连接失败时, doConnect 会 通过 “channel().eventLoop().schedule” 来延时10s 后尝试重新连接.</p>
<h3 id="客户端-Handler-1"><a href="#客户端-Handler-1" class="headerlink" title="客户端 Handler"></a>客户端 Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">CustomHeartbeatHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Client client;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"client"</span>);</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleData</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.readableBytes() - <span class="number">5</span>];</span><br><span class="line">        byteBuf.skipBytes(<span class="number">5</span>);</span><br><span class="line">        byteBuf.readBytes(data);</span><br><span class="line">        String content = <span class="keyword">new</span> String(data);</span><br><span class="line">        System.out.println(name + <span class="string">" get content: "</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleAllIdle</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleAllIdle(ctx);</span><br><span class="line">        sendPingMsg(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelInactive(ctx);</span><br><span class="line">        client.doConnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>断线重连的关键一点是检测连接是否已经断开. 因此我们改写了 ClientHandler, 重写了 <strong>channelInactive</strong> 方法. 当 TCP 连接断开时, 会回调 channelInactive 方法, 因此我们在这个方法中调用 client.doConnect() 来进行重连.</p>
<p>完整代码可以在我的 <a href="https://github.com/yongshun/some_java_code" target="_blank" rel="noopener">Github</a> github.com/yongshun/some_java_code 上找到.</p>
<hr>
<p>本文整理自</p>
<p>[<a href="https://segmentfault.com/a/1190000006931568" target="_blank" rel="noopener">浅析 Netty 实现心跳机制与断线重连</a>]</p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">HashMap的实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-13 10:00:35" itemprop="dateCreated datePublished" datetime="2020-06-13T10:00:35+08:00">2020-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-19 11:38:49" itemprop="dateModified" datetime="2020-06-19T11:38:49+08:00">2020-06-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。</p>
<p>本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析（JDK8会有所不同，需要了解的可自行阅读JDK8的HashMap源码）。</p>
<p>JDK7和JDK8中HashMap的大致变化是：</p>
<blockquote>
<p>1.7中采用数组+链表，1.8采用的是数组+链表/红黑树，即在1.7中链表长度超过一定长度后就改成红黑树存储。 </p>
<p>1.7扩容时需要重新计算哈希值和索引位置(rehash即开启自适应hash,只对String有效,<code>initHashSeedAsNeeded()</code>方法决定是否重新计算String类型的hash值)，1.8并不重新计算哈希值，巧妙地采用和扩容后容量进行&amp;操作来计算新的索引位置。 </p>
<p>1.7是采用表头插入法插入链表，1.8采用的是尾部插入法。 </p>
<p>在1.7中采用表头插入法，在扩容时会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题；在1.8中采用尾部插入法，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><em>什么是哈希表</em></li>
<li><em>HashMap实现原理</em></li>
<li><em>为何HashMap的数组长度一定是2的次幂？</em></li>
<li><em>重写equals方法需同时重写hashCode方法</em></li>
<li><em>总结</em></li>
</ul>
<h2 id="一、什么是哈希表"><a href="#一、什么是哈希表" class="headerlink" title="一、什么是哈希表"></a>一、什么是哈希表</h2><p>在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p>
<p><strong>数组：</strong>采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p>
<p><strong>线性链表：</strong>对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p>
<p><strong>二叉树：</strong>对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p>
<p><strong>哈希表：</strong>相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p>
<p>我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构和链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p>
<p>比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p>
<blockquote>
<p><strong>存储位置 = f(关键字)</strong></p>
</blockquote>
<p>其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBcL6KB4FdibQFHicRNs97cyF3cqmp3PuSibBIuX8mIAcTnqGwv8XpZYC30AAnjTREajFagZWKssZp6A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p>
<p><strong>哈希冲突</strong></p>
<p>然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。</p>
<p>前面我们提到过，哈希函数的设计至关重要，<strong>好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀</strong>,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。</p>
<p><strong>那么哈希冲突如何解决呢？</strong>哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式，</p>
<h2 id="二、HashMap实现原理"><a href="#二、HashMap实现原理" class="headerlink" title="二、HashMap实现原理"></a>二、HashMap实现原理</h2><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。</span><br><span class="line">transient Entry&lt;K,V&gt;[] table &#x3D; (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure>

<p>Entry是HashMap中的一个静态内部类。代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;&#x2F;&#x2F;存储指向下一个Entry的引用，单链表结构</span><br><span class="line">        int hash;&#x2F;&#x2F;对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Creates new entry.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value &#x3D; v;</span><br><span class="line">            next &#x3D; n;</span><br><span class="line">            key &#x3D; k;</span><br><span class="line">            hash &#x3D; h;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>所以，HashMap的整体结构如下</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBcL6KB4FdibQFHicRNs97cyFpSWqicibqmSGaZUaGdgiboT9CdpxgG96hSrXlIyKnbfrm8OGgRxPg9yFQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><strong>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</strong></p>
<p>其他几个重要字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;实际存储的key-value键值对的个数</span><br><span class="line">transient int size;</span><br><span class="line">&#x2F;&#x2F;阈值，当table &#x3D;&#x3D; &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到</span><br><span class="line">int threshold;</span><br><span class="line">&#x2F;&#x2F;负载因子，代表了table的填充度有多少，默认是0.75</span><br><span class="line">final float loadFactor;</span><br><span class="line">&#x2F;&#x2F;用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException</span><br><span class="line">transient int modCount;</span><br></pre></td></tr></table></figure>

<p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p>
<p>initialCapacity默认为16，loadFactory默认为0.75</p>
<p>我们看下其中一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">　　　　　<span class="comment">//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">　　　　　</span><br><span class="line">        init();<span class="comment">//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面这段代码我们可以看出，<strong>在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</strong></p>
<p>OK,接下来我们来看看put操作的实现吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//如果key为null，存储位置为table[0]或table[0]的冲突链上</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);<span class="comment">//对key的hashcode进一步计算，确保散列均匀</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//获取在table中的实际位置</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="comment">//如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span></span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;<span class="comment">//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span></span><br><span class="line">        addEntry(hash, key, value, i);<span class="comment">//新增一个entry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>先来看看inflateTable这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);<span class="comment">//capacity一定是2的次幂</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);<span class="comment">//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static int roundUpToPowerOf2(int number) &#123;</span><br><span class="line">        &#x2F;&#x2F; assert number &gt;&#x3D; 0 : &quot;number must be non-negative&quot;;</span><br><span class="line">        return number &gt;&#x3D; MAXIMUM_CAPACITY</span><br><span class="line">                ? MAXIMUM_CAPACITY</span><br><span class="line">                : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p>
<p>hash函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀</span><br><span class="line">final int hash(Object k) &#123;</span><br><span class="line">        int h &#x3D; hashSeed;</span><br><span class="line">        if (0 !&#x3D; h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">            return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^&#x3D; k.hashCode();</span><br><span class="line"></span><br><span class="line">        h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 返回数组下标</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static int indexFor(int h, int length) &#123;</span><br><span class="line">        return h &amp; (length-1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    1  0  0  1  0</span><br><span class="line">&amp;   0  1  1  1  1</span><br><span class="line">__________________</span><br><span class="line">    0  0  0  1  0    &#x3D; 2</span><br></pre></td></tr></table></figure>

<p>最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）</p>
<p>所以最终存储位置的确定流程是这样的：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBcL6KB4FdibQFHicRNs97cyFkfqOayTx95NbEoJicJNSHJcc6xABNiaesuibAWrFElIU4rqAjlpllpjqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>再来看看addEntry的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;</span><br><span class="line">            resize(2 * table.length);&#x2F;&#x2F;当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span><br><span class="line">            hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;</span><br><span class="line">            bucketIndex &#x3D; indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p>
<h2 id="三、为何HashMap的数组长度一定是2的次幂？"><a href="#三、为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="三、为何HashMap的数组长度一定是2的次幂？"></a>三、为何HashMap的数组长度一定是2的次幂？</h2><p>我们来继续看上面提到的resize方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        <span class="comment">//rehash即开启自适应hash,只对String有效,`initHashSeedAsNeeded()`方法决定是否重新计算String类型的hash值</span></span><br><span class="line">        transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">　　　　　<span class="comment">//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">　　　　　　　　　 <span class="comment">//将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p>
<p>hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。</p>
<p>从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBcL6KB4FdibQFHicRNs97cyFTA98jQT0IwX3pgvicOIzic1m2pQnFGnEZticIgjkNpRzlpWpm6Up8R0JQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBcL6KB4FdibQFHicRNs97cyFtIY11CAa3FBg8kBrHZz6trVdiba0IXWNSibJyiaVfMXLYQjj7ia7CC8fqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBcL6KB4FdibQFHicRNs97cyFkVLibyNBhJd3plIibRWZaeZ87KoKVpia9icllnlgiaXsSCU9wuvuqpX9nNg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p>
<p>get方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">　　　　 &#x2F;&#x2F;如果key为null,则直接去table[0]处去检索即可。</span><br><span class="line">        if (key &#x3D;&#x3D; null)</span><br><span class="line">            return getForNullKey();</span><br><span class="line">        Entry&lt;K,V&gt; entry &#x3D; getEntry(key);</span><br><span class="line">        return null &#x3D;&#x3D; entry ? null : entry.getValue();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过key的hashcode值计算hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="comment">//indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; </span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。</p>
<p>其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p>
<h2 id="四、重写equals方法需同时重写hashCode方法"><a href="#四、重写equals方法需同时重写hashCode方法" class="headerlink" title="四、重写equals方法需同时重写hashCode方法"></a>四、重写equals方法需同时重写hashCode方法</h2><p>关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chengxiao on 2016/11/15.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idCard;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> idCard, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.idCard = idCard;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Person person = (Person) o;</span><br><span class="line">            <span class="comment">//两个对象是否等值，通过idCard来确定</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.idCard == person.idCard;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        HashMap&lt;Person,String&gt; map = <span class="keyword">new</span> HashMap&lt;Person, String&gt;();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1234</span>,<span class="string">"乔峰"</span>);</span><br><span class="line">        <span class="comment">//put到hashmap中去</span></span><br><span class="line">        map.put(person,<span class="string">"天龙八部"</span>);</span><br><span class="line">        <span class="comment">//get取出，从逻辑上讲应该能输出“天龙八部”</span></span><br><span class="line">        System.out.println(<span class="string">"结果:"</span>+map.get(<span class="keyword">new</span> Person(<span class="number">1234</span>,<span class="string">"萧峰"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际输出结果：</p>
<blockquote>
<p>结果：null</p>
</blockquote>
<p>如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p>
<p>所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本文描述了HashMap的实现原理，并结合源码做了进一步的分析，也涉及到一些源码细节设计缘由，最后简单介绍了为什么重写equals的时候需要重写hashCode方法。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247484056&idx=1&sn=47cebe61a8902fd76e7bbf0929b97514&chksm=e80db4eedf7a3df8b357253fb6905dc423c47fcc7ddec89d5b81304c6f796f24a7dcf5b3cc10&scene=21#wechat_redirect" target="_blank" rel="noopener">HashMap的实现原理</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/12/Integer.highestOneBit(int%20i)%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/12/Integer.highestOneBit(int%20i)%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Integer.highestOneBit(int i)方法的作用与底层实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-13 06:02:56 / 修改时间：14:09:57" itemprop="dateCreated datePublished" datetime="2020-06-13T06:02:56+08:00">2020-06-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在Integer类中有这么一个方法，你可以给它传入一个数字，它将返回小于等于这个数字的一个2的幂次方数。这个方法就是<code>highestOneBit(int i)</code>。</p>
<p>比如下面的Demo，注意方法的输入与返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.highestOneBit(<span class="number">15</span>));  <span class="comment">// 输出8</span></span><br><span class="line">System.out.println(Integer.highestOneBit(<span class="number">16</span>));  <span class="comment">// 输出16</span></span><br><span class="line">System.out.println(Integer.highestOneBit(<span class="number">17</span>));  <span class="comment">// 输出16</span></span><br></pre></td></tr></table></figure>

<p>首先，对于这个方法的功能：<strong>给定一个数字，找到小于或等于这个数字的一个2的幂次方数。</strong></p>
<p>如果我们要自己来实现的话，我们需要知道：<strong>怎么判断一个数字是2的幂次方数。</strong></p>
<p>说真的，我一下想不到什么好方法来判断，唯一能想到的就是一个数字如果把它转换成二进制表示的话，它会有一个规律：<strong>如果一个数字是2的幂次方数，那么它对应的二进制表示仅有一个bit位上是1，其他bit位全为0。</strong> 比如： 十进制6，二进制表示为：0000 0110 十进制8，二进制表示为：0000 1000 十进制9，二进制表示为：0000 1001 所以，我们可以利用一个数字的二进制表示来判断这个数字是不是2的幂次方数。关键代码怎么实现呢？去遍历每个bit位？可以，但是不好，那怎么办？我们还是回头仔细看看Integer是如何实现的吧？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// HD, Figure 3-1</span></span><br><span class="line">	i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">	i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">	i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">	i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">	i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	<span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现这段代码中没有任何的遍历，只有位运算与一个减法，也就是说它的实现思路和我们自己的实现思路完全不一样，它的思路就是：<strong>给定一个数字，通过一系列的运算，得到一个小于或等于该数字的一个2的幂次方数。</strong></p>
<p>也就是：如果给定一个数字18，通过运算后，要得到16。</p>
<p>18用二进制表示为：      0001 0010</p>
<p>想要得到的结果(16)是：0001 0000</p>
<p>那么这个运算的过程无非就是<strong>将18对应的二进制数中除最高位的1之外的其他bit位都清零，则拿到了我们想要的结果。</strong></p>
<p>那怎么通过位运算来实现这个过程呢？</p>
<p>我们拿18对应的二进制数<code>0001 0010</code>来举个例子就行了： 先将<code>0001 0010</code>右移1位， 得到<code>0000 1001</code>，再与自身进行或运算： 得到<code>0001 1011</code>。</p>
<p>再将<code>0001 1011</code>右移2位， 得到<code>0000 0110</code>，再与自身进行或运算： 得到<code>0001 1111</code>。</p>
<p>再将<code>0001 1111</code>右移4位， 得到<code>0000 0001</code>，再与自身进行或运算： 得到<code>0001 1111</code>。</p>
<p>再将<code>0001 1111</code>右移8位， 得到<code>0000 0000</code>，再与自身进行或运算： 得到<code>0001 1111</code>。</p>
<p>再将<code>0001 1111</code>右移16位， 得到<code>0000 0000</code>，再与自身进行或运算： 得到<code>0001 1111</code>。</p>
<p>再将<code>0001 1111</code>无符号右移1位， 得到<code>0000 1111</code>。</p>
<p>最后用<code>0001 1111 - 0000 1111 = 0001 0000</code> 震惊！得到了我们想要的结果。</p>
<p>其实这个过程可以抽象成这样： 现在有一个二进制数据，<code>0001****</code>，我们不关心低位的取值情况，我们对其进行右移并且进行或运算。</p>
<p>先将<code>0001****</code>右移1位， 得到<code>00001***</code>，再与自身进行或运算： 得到<code>00011***</code>。</p>
<p>再将<code>00011***</code>右移2位， 得到<code>0000011*</code>，再与自身进行或运算： 得到<code>0001111*</code>。</p>
<p>再将<code>0001111*</code>右移4位， 得到<code>00000001</code>，再与自身进行或运算： 得到<code>00011111</code>。</p>
<p>后面不用再推算了，到这里我们其实可以发现一个规律： <strong>右移与或运算的目的就是想让某个数字的低位都变为1，再用该结果 减去 该结果右移一位后的结果，则相当于清零了原数字的低位。即得到了我们想要的结果。</strong></p>
<p>到此，只能感叹JDK作者对于位运算的使用已经达到了出神入化的境界了。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5d679f67f265da03d55e6ab5" target="_blank" rel="noopener">Integer.highestOneBit(int i)方法的作用与底层实现</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/12/%E7%AA%81%E7%A0%B4netty%E5%8D%95%E6%9C%BA%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/12/%E7%AA%81%E7%A0%B4netty%E5%8D%95%E6%9C%BA%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0/" class="post-title-link" itemprop="url">突破netty单机最大连接数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-12 11:35:19 / 修改时间：19:41:42" itemprop="dateCreated datePublished" datetime="2020-06-12T11:35:19+08:00">2020-06-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实现单机的百万连接，瓶颈有以下几点：<br> 1、如何模拟百万连接<br> 2、突破局部文件句柄的限制<br> 3、突破全局文件句柄的限制<br>在linux系统里面，单个进程打开的句柄数是非常有限的，一条TCP连接就对应一个文件句柄，而对于我们应用程序来说，一个服务端默认建立的连接数是有限制的。</p>
<p>如下图所示，通常一个客户端去除一些被占用的端口之后，可用的端口大于只有6w个左右，要想模拟百万连接要起比较多的客户端，而且比较麻烦，所以这种方案不合适。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/13624274-889b72884a359015.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/509/format/webp" alt="img"></p>
<p>在服务端启动800~8100，而客户端依旧使用1025-65535范围内可用的端口号，让同一个端口号，可以连接Server的不同端口。这样的话，6W的端口可以连接Server的100个端口，累加起来就能实现近600W左右的连接，TCP是以一个四元组概念，以原IP、原端口号、目的IP、目的端口号来确定的，当原IP  和原端口号相同，但目的端口号不同，最终系统会把他当成两条TCP 连接来处理，所以TCP连接可以如此设计。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/13624274-d9efff2f1d8d1e3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/443/format/webp" alt="img"></p>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>netty客户端和netty服务端,都是springboot项目。<br> 运行环境：linux<br> netty版本：4.1.6.Final</p>
<h2 id="netty服务端代码"><a href="#netty服务端代码" class="headerlink" title="netty服务端代码"></a>netty服务端代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">netty maven</span><br><span class="line"> &lt;properties&gt;</span><br><span class="line"> &lt;netty-all.version&gt;4.1.6.Final&lt;&#x2F;netty-all.version&gt;</span><br><span class="line"> &lt;&#x2F;properties&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;io.netty&lt;&#x2F;groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;netty-all&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;version&gt;$&#123;netty-all.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyserverApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BEGIN_PORT = <span class="number">8000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N_PORT = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(NettyserverApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">        <span class="keyword">new</span> Server().start(BEGIN_PORT, N_PORT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/----------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> beginPort, <span class="keyword">int</span> nPort)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server starting...."</span>);</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        bootstrap.group(bossGroup, workerGroup);</span><br><span class="line">        bootstrap.channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        bootstrap.childOption(ChannelOption.SO_REUSEADDR, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        bootstrap.childHandler(<span class="keyword">new</span> ConnectionCountHandler());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  绑定100个端口号</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nPort; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> port = beginPort + i;</span><br><span class="line">            bootstrap.bind(port).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">"bind success in port: "</span> + port);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"server started!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/-------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler.Sharable;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionCountHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="comment">//jdk1.5 并发包中的用于计数的类</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger nConnection = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionCountHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  每两秒统计一下连接数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"connections: "</span> + nConnection.get());</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  每次过来一个新连接就对连接数加一</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        nConnection.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  端口的时候减一</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        nConnection.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="keyword">if</span>(channel.isActive())&#123;</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="netty客户端代码"><a href="#netty客户端代码" class="headerlink" title="netty客户端代码"></a>netty客户端代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">netty maven</span><br><span class="line"> &lt;properties&gt;</span><br><span class="line"> &lt;netty-all.version&gt;4.1.6.Final&lt;&#x2F;netty-all.version&gt;</span><br><span class="line"> &lt;&#x2F;properties&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;io.netty&lt;&#x2F;groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;netty-all&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;version&gt;$&#123;netty-all.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyclientApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BEGIN_PORT = <span class="number">8000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N_PORT = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(NettyclientApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">        <span class="keyword">new</span> Client().start(BEGIN_PORT, N_PORT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">package</span> com.nettyclient.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> beginPort, <span class="keyword">int</span> nPort)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"client starting...."</span>);</span><br><span class="line">        EventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">final</span> Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(eventLoopGroup);</span><br><span class="line">        bootstrap.channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        bootstrap.option(ChannelOption.SO_REUSEADDR, <span class="keyword">true</span>);</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> port;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            port = beginPort + index;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ChannelFuture channelFuture = bootstrap.connect(SERVER_HOST, port);</span><br><span class="line">                channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"连接失败, 退出!"</span>);</span><br><span class="line">                        System.exit(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                channelFuture.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++index == nPort) &#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动服务端</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/13624274-728141279b26f1e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/610/format/webp" alt="img"></p>
<p>启动客户端</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/13624274-de84e3a575371495.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/734/format/webp" alt="img"></p>
<p>测试发现当连接数达到13136 的时候，此时达到了最大的连接数，这时候服务器将不再对新的连接进行处理，客户端赢长时间得不到服务端的响应而结束与服务端的连接。（不同的机器配置结果可能不同）<br> 下面通过优化要突破这个连接数。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/13624274-ceba004c115eddd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="1、局部文件句柄限制"><a href="#1、局部文件句柄限制" class="headerlink" title="1、局部文件句柄限制"></a>1、局部文件句柄限制</h3><p><img src="https:////upload-images.jianshu.io/upload_images/13624274-54921882dda8a164.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/419/format/webp" alt="img"></p>
<p>一个jvm进程最大能够打开的文件数</p>
<p>修改65535的这个限制<br><code>vi /etc/security/limits.conf</code><br> 在文件末尾添加两行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*hard nofile 1000000</span><br><span class="line">*soft nofile 1000000</span><br></pre></td></tr></table></figure>


<p> soft和hard为两种限制方式，其中soft表示警告的限制，hard表示真正限制，nofile表示打开的最大文件数。整体表示任何用户一个进程能够打开1000000个文件。注意语句签名有* 号 表示任何用户</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/13624274-9e7592bf4057ae73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/414/format/webp" alt="img"></p>
<p><code>shutdown -r now</code>  重启linux</p>
<p>再次查看</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/13624274-afe18b5b26290098.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/453/format/webp" alt="img"></p>
<p>已经修改生效了。</p>
<p>测试</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/13624274-07ee6077d068db86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/222/format/webp" alt="img"></p>
<p>最大连接数10万多</p>
<h3 id="2、突破全局文件句柄的限制"><a href="#2、突破全局文件句柄的限制" class="headerlink" title="2、突破全局文件句柄的限制"></a>2、突破全局文件句柄的限制</h3><p><code>cat /proc/sys/fs/file-max</code><br>file-max 表示在linux 中最终所有x线程能够打开的最大文件数</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/13624274-01d43ba5d34bf93a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/431/format/webp" alt="img"></p>
<p>image.png</p>
<p>修改这个最大值：<br> <code>sudo vi  /etc/sysctl.conf</code><br> 在文件的末尾添加 <code>fs.file-max=1000000</code><br> 然后让文件生效 <code>sudo sysctl -p</code><br> 这个时候再查看一下全局最大文件句柄的数已经变成1000000了</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/13624274-1f43043b3585da73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/473/format/webp" alt="img"></p>
<p>测试</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/13624274-d77cc04ce5934466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/420/format/webp" alt="img"></p>
<p>最大连接数36万多.png</p>
<p>注： 测试的服务器型号</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/13624274-9ea4b4b0c9ad094e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/751/format/webp" alt="img"></p>
<p>cpu 相关配置</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/13624274-7d9e344e96357abf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/532/format/webp" alt="img"></p>
<hr>
<p>本文整理自</p>
<p><a href="https://www.jianshu.com/p/490e2981545c" target="_blank" rel="noopener">突破netty单机最大连接数</a></p>
<p>遵循CC 4.0 BY-SA版权协议</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/12/%E5%8D%95%E6%9C%BA%E6%9C%80%E5%A4%A7%E5%B9%B6%E5%8F%91tcp%E8%BF%9E%E6%8E%A5%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/12/%E5%8D%95%E6%9C%BA%E6%9C%80%E5%A4%A7%E5%B9%B6%E5%8F%91tcp%E8%BF%9E%E6%8E%A5%E6%95%B0/" class="post-title-link" itemprop="url">单机最大并发tcp连接数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-12 11:18:21 / 修改时间：19:20:49" itemprop="dateCreated datePublished" datetime="2020-06-12T11:18:21+08:00">2020-06-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>做性能测试的同学，在问到到单台服务器最大连接数时，很多人多会回答是65535，因为最多有65535个端口，一个连接必须要占用一个端口号，所以得出答案是65535，真相到底是什么呢？</p>
<p>在tcp应用中，server事先在某个固定端口监听，client主动发起连接，经过三路握手后建立tcp连接。那么对单机，其最大并发tcp连接数是多少？</p>
<h3 id="如何标识一个TCP连接"><a href="#如何标识一个TCP连接" class="headerlink" title="如何标识一个TCP连接"></a>如何标识一个TCP连接</h3><p>在确定最大连接数之前，先来看看系统如何标识一个tcp连接。系统用一个4四元组来唯一标识一个TCP连接：{localip, localport,remoteip,remoteport}。</p>
<h3 id="client最大tcp连接数"><a href="#client最大tcp连接数" class="headerlink" title="client最大tcp连接数"></a>client最大tcp连接数</h3><p>client每次发起tcp连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他tcp连接共享。tcp端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，一个client最大tcp连接数为65535，这些连接可以连到不同的serverip。</p>
<h3 id="server最大tcp连接数"><a href="#server最大tcp连接数" class="headerlink" title="server最大tcp连接数"></a>server最大tcp连接数</h3><p>server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，因此server端tcp连接4元组中只有remoteip（也就是clientip）和remote port（客户端port）是可变的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。</p>
<h3 id="实际的tcp连接数"><a href="#实际的tcp连接数" class="headerlink" title="实际的tcp连接数"></a>实际的tcp连接数</h3><p>上面给出的是理论上的单机最大连接数，在实际环境中，受到机器资源、操作系统等的限制，特别是sever端，其最大并发tcp连接数远不能达到理论上限。在unix/linux下限制连接数的主要因素是内存和允许的文件描述符个数（每个tcp连接都要占用一定内存，每个socket就是一个文件描述符），另外1024以下的端口通常为保留端口。</p>
<p>对server端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发TCP连接数超过10万,甚至上百万是没问题的</p>
<hr>
<p>本文整理自</p>
<p><a href="https://www.sohu.com/a/221661481_216613" target="_blank" rel="noopener">单机最大并发tcp连接数是65535？原来我们都错了！</a></p>
<p>遵循CC 4.0 BY-SA版权协议</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/11/UML%E7%B1%BB%E5%9B%BE%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/11/UML%E7%B1%BB%E5%9B%BE%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">UML类图简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-12 03:20:13 / 修改时间：11:23:31" itemprop="dateCreated datePublished" datetime="2020-06-12T03:20:13+08:00">2020-06-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">程序设计</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这里不会将UML的各种元素都提到，我只想讲讲类图中各个类之间的关系； 能看懂类图中各个类之间的线条、箭头代表什么意思后，也就足够应对 日常的工作和交流； 同时，我们应该能将类图所表达的含义和最终的代码对应起来； 有了这些知识，看后面章节的设计模式结构图就没有什么问题了；</p>
<h2 id="从一个示例开始"><a href="#从一个示例开始" class="headerlink" title="从一个示例开始"></a>从一个示例开始</h2><p>请看以下这个类图，类之间的关系是我们需要关注的：</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_class_struct.jpg" alt="_images/uml_class_struct.jpg"></p>
<ul>
<li>车的类图结构为&lt;<abstract>&gt;，表示车是一个抽象类；</li>
<li>它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；</li>
<li>小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；</li>
<li>小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；</li>
<li>学生与班级之间是聚合关系，使用带空心箭头的实线表示；</li>
<li>学生与身份证之间为关联关系，使用一根实线表示；</li>
<li>学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；</li>
</ul>
<p>下面我们将介绍这六种关系；</p>
<hr>
<h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><h3 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h3><p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)：</p>
<p>继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)</p>
<p>eg：自行车是车、猫是动物</p>
<p>泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）；</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalization.jpg" alt="_images/uml_generalization.jpg"></p>
<p>eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalize.jpg" alt="_images/uml_generalize.jpg"></p>
<p>注：最终代码中，泛化关系表现为继承非抽象类；</p>
<h3 id="实现关系-realize"><a href="#实现关系-realize" class="headerlink" title="实现关系(realize)"></a>实现关系(realize)</h3><p>实现关系用一条带空心箭头的虚线表示；</p>
<p>eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解）</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_realize.jpg" alt="_images/uml_realize.jpg"></p>
<p>注：最终代码中，实现关系表现为继承抽象类；</p>
<h3 id="聚合关系-aggregation"><a href="#聚合关系-aggregation" class="headerlink" title="聚合关系(aggregation)"></a>聚合关系(aggregation)</h3><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_aggregation.jpg" alt="_images/uml_aggregation.jpg"></p>
<p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p>
<p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；</p>
<h3 id="组合关系-composition"><a href="#组合关系-composition" class="headerlink" title="组合关系(composition)"></a>组合关系(composition)</h3><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_composition.jpg" alt="_images/uml_composition.jpg"></p>
<p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p>
<p>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p>
<h3 id="关联关系-association"><a href="#关联关系-association" class="headerlink" title="关联关系(association)"></a>关联关系(association)</h3><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；</p>
<p>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；</p>
<p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_association.jpg" alt="_images/uml_association.jpg"></p>
<p>注：在最终代码中，关联对象通常是以成员变量的形式实现的；</p>
<h3 id="依赖关系-dependency"><a href="#依赖关系-dependency" class="headerlink" title="依赖关系(dependency)"></a>依赖关系(dependency)</h3><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_dependency.jpg" alt="_images/uml_dependency.jpg"></p>
<p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p>
<p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p>
<p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p>
<hr>
<p>本文整理自</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html" target="_blank" rel="noopener">看懂UML类图和时序图</a></p>
<p>遵循CC 4.0 BY-SA版权协议</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/11/equals()%E4%B8%8EhashCode()/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/11/equals()%E4%B8%8EhashCode()/" class="post-title-link" itemprop="url">equals()与hashCode()</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-12 02:56:30 / 修改时间：11:19:36" itemprop="dateCreated datePublished" datetime="2020-06-12T02:56:30+08:00">2020-06-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>equals和hashCode都是Object对象中的非final方法，它们设计的目的就是被用来覆盖(override)的，所以在程序设计中还是经常需要处理这两个方法的。而掌握这两个方法的覆盖准则以及它们的区别还是很必要的，相关问题也不少。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/27/16098428b73f5bd0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>下面我们继续以一次面试的问答，来考察对equals和hashCode的掌握情况。</p>
<h2 id="Java里面有-运算符了，为什么还需要equals"><a href="#Java里面有-运算符了，为什么还需要equals" class="headerlink" title="Java里面有==运算符了，为什么还需要equals"></a>Java里面有<code>==</code>运算符了，为什么还需要equals</h2><hr>
<p>equals()的作用是用来判断两个对象是否相等，在Object里面的定义是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这说明在我们实现自己的equals方法之前，equals等价于<code>==</code>,而<code>==</code>运算符是判断两个对象是不是同一个对象，即他们的<strong>地址是否相等</strong>。而覆写equals更多的是追求两个对象在<strong>逻辑上的相等</strong>，你可以说是<strong>值相等</strong>，也可说是<strong>内容相等</strong>。</p>
<p>在以下几种条件中，不覆写equals就能达到目的：</p>
<ul>
<li><strong>类的每个实例本质上是唯一的</strong>：强调活动实体的而不关心值得，比如Thread，我们在乎的是哪一个线程，这时候用equals就可以比较了。</li>
<li><strong>不关心类是否提供了逻辑相等的测试功能</strong>：有的类的使用者不会用到它的比较值得功能，比如Random类，基本没人会去比较两个随机值吧</li>
<li><strong>超类已经覆盖了equals，子类也只需要用到超类的行为</strong>：比如AbstractMap里已经覆写了equals，那么继承的子类行为上也就需要这个功能，那也不需要再实现了。</li>
<li><strong>类是私有的或者包级私有的，那也用不到equals方法</strong>：这时候需要覆写equals方法来禁用它：<code>@Override public boolean equals(Object obj) { throw new AssertionError();}</code></li>
</ul>
<h2 id="覆写equals时有哪些准则？"><a href="#覆写equals时有哪些准则？" class="headerlink" title="覆写equals时有哪些准则？"></a>覆写equals时有哪些准则？</h2><hr>
<p>这个我在Effective Java上看过，没记错的话应该是：</p>
<blockquote>
<p><strong>自反性</strong>：对于任何非空引用值 x，x.equals(x) 都应返回 true。</p>
</blockquote>
<blockquote>
<p><strong>对称性</strong>：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。</p>
</blockquote>
<blockquote>
<p><strong>传递性</strong>：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true， 并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。</p>
</blockquote>
<blockquote>
<p><strong>一致性</strong>：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false， 前提是对象上 equals 比较中所用的信息没有被修改。</p>
</blockquote>
<blockquote>
<p><strong>非空性</strong>：对于任何非空引用值 x，x.equals(null) 都应返回 false。</p>
</blockquote>
<h2 id="哪些情况下会违反对称性和传递性"><a href="#哪些情况下会违反对称性和传递性" class="headerlink" title="哪些情况下会违反对称性和传递性"></a>哪些情况下会违反对称性和传递性</h2><hr>
<h4 id="违反对称性"><a href="#违反对称性" class="headerlink" title="违反对称性"></a>违反对称性</h4><p>对称性就是x.equals(y)时，y也得equals x，很多时候，我们自己覆写equals时，让自己的类可以兼容等于一个已知类，比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CaseInsensitiveString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> CaseInsensiticeString)</span><br><span class="line">            <span class="keyword">return</span> s.equalsIgnoreCase(((CaseInsensitiveString)o).s);</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> String)</span><br><span class="line">            <span class="keyword">return</span> s.equalsIgnoreCase((String) o);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个想法很好，想创建一个无视大小写的String，并且还能够兼容String作为参数，假设我们创建一个CaseInsensitiveString:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CaseInsensitiveString cis = <span class="keyword">new</span> CaseInsensitiveString(<span class="string">"Case"</span>);</span><br></pre></td></tr></table></figure>

<p>那么肯定有<code>cis.equals(&quot;case&quot;)</code>,问题来了，<code>&quot;case&quot;.equals(cis)</code>吗？String并没有兼容CaseInsensiticeString，所以String的equals也不接受CaseInsensiticeString作为参数。</p>
<p>所以有个准则，一般在覆写equals<strong>只兼容同类型的变量</strong>。</p>
<h4 id="违反传递性"><a href="#违反传递性" class="headerlink" title="违反传递性"></a>违反传递性</h4><p>传递性就是A等于B，B等于C，那么A也应该等于C。</p>
<p>假设我们定义一个类Cat。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Cat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.height = h;</span><br><span class="line">        <span class="keyword">this</span>.weight = w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Cat))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Cat c = (Cat) o;</span><br><span class="line">        <span class="keyword">return</span> c.height == height &amp;&amp; c.weight == weight; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>名人有言，不管黑猫白猫抓住老鼠就是好猫，我们又定义一个类ColorCat:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class ColorCat <span class="title">extends</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorCat</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> w, String color)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(h, w);</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们在实现equals方法时，可以加上颜色比较，但是加上颜色就不兼容和普通猫作对比了，这里我们忘记上面要求只兼容同类型变量的建议，定义一个兼容普通猫的equals方法，在“混合比较”时忽略颜色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! (o <span class="keyword">instanceof</span> Cat))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//不是Cat或者ColorCat，直接false</span></span><br><span class="line">    <span class="keyword">if</span> (! (o <span class="keyword">instanceof</span> ColorCat))</span><br><span class="line">        <span class="keyword">return</span> o.equals(<span class="keyword">this</span>);<span class="comment">//不是彩猫，那一定是普通猫，忽略颜色对比</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(o)&amp;&amp;((ColorCat)o).color.equals(color); <span class="comment">//这时候才比较颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们定义了猫：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ColorCat whiteCat = <span class="keyword">new</span> ColorCat(<span class="number">1</span>,<span class="number">2</span>,<span class="string">"white"</span>);</span><br><span class="line">Cat cat = <span class="keyword">new</span> Cat(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">ColorCat blackCat = <span class="keyword">new</span> ColorCat(<span class="number">1</span>,<span class="number">2</span>,<span class="string">"black"</span>);</span><br></pre></td></tr></table></figure>

<p>此时有whiteCat等于cat，cat等于blackCat，但是whiteCat不等于blackCat，所以不满足传递性要求。</p>
<p>所以在覆写equals时，一定要遵守上述的5大军规，不然总是有麻烦事找上门来。</p>
<h2 id="有覆写equals方法的诀窍吗，比如写一下String里面的equals？"><a href="#有覆写equals方法的诀窍吗，比如写一下String里面的equals？" class="headerlink" title="有覆写equals方法的诀窍吗，比如写一下String里面的equals？"></a>有覆写equals方法的诀窍吗，比如写一下String里面的equals？</h2><hr>
<p>手写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">           String anotherString = (String)anObject;</span><br><span class="line">           <span class="keyword">int</span> n = value.length;</span><br><span class="line">           <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">               <span class="keyword">char</span> v1[] = value;</span><br><span class="line">               <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">               <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                   i++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上面的equals有以下几点诀窍：</p>
<ul>
<li><strong>使用==操作符检查“参数是否为这个对象的引用”</strong>：如果是对象本身，则直接返回，拦截了对本身调用的情况，算是一种性能优化。</li>
<li><strong>使用instanceof操作符检查“参数是否是正确的类型”</strong>：如果不是，就返回false，正如对称性和传递性举例子中说得，不要想着兼容别的类型，很容易出错。在实践中检查的类型多半是equals所在类的类型，或者是该类实现的接口的类型，比如Set、List、Map这些集合接口。</li>
<li><strong>把参数转化为正确的类型</strong>： 经历了上一步的检测，基本会成功。</li>
<li><strong>对于该类中的“关键域”，检查参数中的域是否与对象中的对应域相等</strong>：基本类型的域就用<code>==</code>比较，float域用Float.compare方法，double域用Double.compare方法，至于别的引用域，我们一般递归调用它们的equals方法比较，加上判空检查和对自身引用的检查，一般会写成这样：<code>(field == o.field || (field != null &amp;&amp; field.equals(o.field)))</code>,而上面的String里使用的是数组，所以只要把数组中的每一位拿出来比较就可以了。</li>
<li><strong>编写完成后思考是否满足上面提到的对称性，传递性，一致性等等</strong>。</li>
</ul>
<p>还有一些注意点。</p>
<p><strong>覆盖equals时一定要覆盖hashCode</strong></p>
<p><strong>equals函数里面一定要是Object类型作为参数</strong></p>
<p><strong>equals方法本身不要过于智能，只要判断一些值相等即可。</strong></p>
<h2 id="hashCode什么用"><a href="#hashCode什么用" class="headerlink" title="hashCode什么用"></a>hashCode什么用</h2><hr>
<p>hashCode用于返回对象的hash值，主要用于查找的快捷性，因为hashCode也是在Object对象中就有的，所以所有Java对象都有hashCode，在HashTable和HashMap这一类的散列结构中，都是通过hashCode来查找在散列表中的位置的。</p>
<p><strong>如果两个对象equals，那么它们的hashCode必然相等，</strong></p>
<p><strong>但是hashCode相等，equals不一定相等。(有哈希碰撞)</strong></p>
<p>以HashMap为例，使用的是链地址法来处理散列，假设有一个长度为8的散列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>那么，当往里面插数据时，是以hashCode作为key插入的，一般hashCode%8得到所在的索引，如果所在索引处有元素了，则使用一个链表，把多的元素不断链接到该位置，这边也就是大概提一下HashMap原理。所以hashCode的作用就是找到索引的位置，然后再用equals去比较元素是不是相等，形象一点就是先找到桶（bucket），然后再在里面找东西。</p>
<blockquote>
<p>hashCode 的常规协定是：<br> 在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</p>
<p>以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。</p>
<p>实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）</p>
<p>当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>
</blockquote>
<p>具体的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Stu s1 = <span class="keyword">new</span> Stu(<span class="string">"张三"</span>, <span class="number">18</span>);</span><br><span class="line">  Stu s2 = <span class="keyword">new</span> Stu(<span class="string">"张三"</span>, <span class="number">18</span>);</span><br><span class="line">  System.out.println(<span class="string">"stu:"</span> + s1.equals(s2));</span><br><span class="line"></span><br><span class="line">  Set&lt;Stu&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  set.add(s1);</span><br><span class="line">  System.out.println(<span class="string">"s1 hashCode:"</span> + s1.hashCode());</span><br><span class="line">  System.out.println(<span class="string">"add s1 size:"</span> + set.size());</span><br><span class="line">  set.add(s2);</span><br><span class="line">  System.out.println(<span class="string">"s2 hashCode:"</span> + s2.hashCode());</span><br><span class="line">  System.out.println(<span class="string">"add s2 size::"</span> + set.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">stu</span><span class="selector-pseudo">:false</span></span><br><span class="line"><span class="selector-tag">s1</span> <span class="selector-tag">hashCode</span><span class="selector-pseudo">:1317241155</span></span><br><span class="line"><span class="selector-tag">add</span> <span class="selector-tag">s1</span> <span class="selector-tag">size</span><span class="selector-pseudo">:1</span></span><br><span class="line"><span class="selector-tag">s2</span> <span class="selector-tag">hashCode</span><span class="selector-pseudo">:463175162</span></span><br><span class="line"><span class="selector-tag">add</span> <span class="selector-tag">s2</span> <span class="selector-tag">size</span><span class="selector-pseudo">::2</span></span><br></pre></td></tr></table></figure>

<p>Java中的Set是不允许有重复元素的，所以这里set的size由1变成了2，因为两个Stu都是new出来的，分配的地址不一样，那么Set是通过equals来定义重复的吗？</p>
<p>首先重写Stu的equals方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj.getClass() != getClass())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ((Stu)obj).getName().equals(getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">stu</span><span class="selector-pseudo">:true</span></span><br><span class="line"><span class="selector-tag">s1</span> <span class="selector-tag">hashCode</span><span class="selector-pseudo">:713679046</span></span><br><span class="line"><span class="selector-tag">add</span> <span class="selector-tag">s1</span> <span class="selector-tag">size</span><span class="selector-pseudo">:1</span></span><br><span class="line"><span class="selector-tag">s2</span> <span class="selector-tag">hashCode</span><span class="selector-pseudo">:1107557627</span></span><br><span class="line"><span class="selector-tag">add</span> <span class="selector-tag">s2</span> <span class="selector-tag">size</span><span class="selector-pseudo">::2</span></span><br></pre></td></tr></table></figure>

<p>重写equals方法，name相同就让equals返回true了，但是Set的size还是发生了改变，就说明不是有equals方法来定义重复的，现在仅仅重写hashCode方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getName().hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">stu</span><span class="selector-pseudo">:false</span></span><br><span class="line"><span class="selector-tag">s1</span> <span class="selector-tag">hashCode</span><span class="selector-pseudo">:774889</span></span><br><span class="line"><span class="selector-tag">add</span> <span class="selector-tag">s1</span> <span class="selector-tag">size</span><span class="selector-pseudo">:1</span></span><br><span class="line"><span class="selector-tag">s2</span> <span class="selector-tag">hashCode</span><span class="selector-pseudo">:774889</span></span><br><span class="line"><span class="selector-tag">add</span> <span class="selector-tag">s2</span> <span class="selector-tag">size</span><span class="selector-pseudo">::2</span></span><br></pre></td></tr></table></figure>

<p>仅重写了hashCode方法，所以equals返回false，然后hashCode由name属性的hashCode方法得到，所以hashCode相等，但是Set的size还是改变了，这说明Set也不是仅仅依据hashCode来定义重复。</p>
<p>那么现在将上述equals和hashCode两者同时重写，输出结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">stu</span><span class="selector-pseudo">:true</span></span><br><span class="line"><span class="selector-tag">s1</span> <span class="selector-tag">hashCode</span><span class="selector-pseudo">:774889</span></span><br><span class="line"><span class="selector-tag">add</span> <span class="selector-tag">s1</span> <span class="selector-tag">size</span><span class="selector-pseudo">:1</span></span><br><span class="line"><span class="selector-tag">s2</span> <span class="selector-tag">hashCode</span><span class="selector-pseudo">:774889</span></span><br><span class="line"><span class="selector-tag">add</span> <span class="selector-tag">s2</span> <span class="selector-tag">size</span><span class="selector-pseudo">::1</span></span><br></pre></td></tr></table></figure>

<p>结合上面引用的案例，可以类推，hash类存储结构（HashSet、HashMap等等）添加元素会有重复性校验，校验的方式就是<strong>先取hashCode判断是否相等</strong>（找到对应的位置，该位置可能存在多个元素），然后<strong>再取equals方法比较</strong>（极大缩小比较范围，高效判断），最终判定该存储结构中是否有重复元素。</p>
<h2 id="有哪些覆写hashCode的诀窍？"><a href="#有哪些覆写hashCode的诀窍？" class="headerlink" title="有哪些覆写hashCode的诀窍？"></a>有哪些覆写hashCode的诀窍？</h2><hr>
<p>一个好的hashCode的方法的目标：<strong>为不相等的对象产生不相等的散列码</strong>，同样的，相等的对象必须拥有相等的散列码。</p>
<p>好的散列函数要把实例均匀的分布到所有散列值上，结合前人的经验可以采取以下方法：</p>
<blockquote>
<p>引自Effective Java</p>
<ol>
<li><p>把某个非零的常数值，比如17，保存在一个int型的result中；</p>
</li>
<li><p>对于每个关键域f（equals方法中设计到的每个域），作以下操作：</p>
<p><strong>a</strong>. 为该域计算int类型的散列码；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i.如果该域是boolean类型，则计算(f?1:0),</span><br><span class="line">ii.如果该域是byte,char,short或者int类型,计算(int)f,</span><br><span class="line">iii.如果是long类型，计算(int)(f^(f&gt;&gt;&gt;32)).</span><br><span class="line">iv.如果是float类型，计算Float.floatToIntBits(f).</span><br><span class="line">v.如果是double类型，计算Double.doubleToLongBits(f),然后再计算long型的hash值</span><br><span class="line">vi.如果是对象引用，则递归的调用域的hashCode，如果是更复杂的比较，则需要为这个域计算一个范式，然后针对范式调用hashCode，如果为null，返回0</span><br><span class="line">vii. 如果是一个数组，则把每一个元素当成一个单独的域来处理。</span><br></pre></td></tr></table></figure>

<p><strong>b</strong>.result = 31 * result + c;</p>
</li>
<li><p>返回result</p>
</li>
<li><p>编写单元测试验证有没有实现所有相等的实例都有相等的散列码。</p>
</li>
</ol>
</blockquote>
<p>这里再说下2.b中为什么采用<code>31*result + c</code>,乘法使hash值依赖于域的顺序，如果没有乘法那么所有顺序不同的字符串String对象都会有一样的hash值，而31是一个奇素数，如果是偶数，并且乘法溢出的话，信息会丢失，31有个很好的特性是<code>31*i ==(i&lt;&lt;5)-i</code>,即2的5次方减1，虚拟机会优化乘法操作为移位操作的。</p>
<p>给个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">  result = <span class="number">31</span> * result + getName().hashCode();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5a4379d4f265da432003874c" target="_blank" rel="noopener">面试官爱问的equals与hashCode</a></p>
<p><a href="https://www.jianshu.com/p/5b7fe120bf94" target="_blank" rel="noopener">equals和hashCode的区别和联系</a></p>
<p>遵循CC 4.0 BY-SA版权协议</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARPC%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARPC%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">深入浅出RPC原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-11 12:28:49 / 修改时间：20:33:32" itemprop="dateCreated datePublished" datetime="2020-06-11T12:28:49+08:00">2020-06-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>远程过程调用(Remote Procedure Call，简称RPC)，在微服务大行其道的今天，得到了广泛的应用。因此，在分布式系统服务群中开发应用，了解RPC一些原理和实现架构，还是很有必要的。本文，将从大的框架层面来聊聊RPC原理和实现。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>远程过程调用RPC，就是客户端基于某种传输协议通过网络向服务提供端请求服务处理，然后获取返回数据(对于ONE WAY模式则不返还响应结果)；而这种调用对于客户端而言，和调用本地服务一样方便，开发人员不需要了解具体底层网络传输协议。简单讲，就是本地调用的逻辑处理的过程放在的远程的机器上，而不是本地服务代理来处理。</p>
<p>目前，Java界的RPC中间件百家争鸣，国内开源的就有阿里的Dubbo(当当二次开发的DubboX)，新浪Motan；国外跨语言的有Facebook的Thrift， Google的gRpc等。</p>
<h2 id="LPC-amp-IPC"><a href="#LPC-amp-IPC" class="headerlink" title="LPC &amp; IPC"></a>LPC &amp; IPC</h2><p>既然存在RPC这种远程过程调用，必然会有与之对应的本地过程调用了。本地过程调用在不同的操作系统中，叫法不同，使用方式也不太一样。在Windows编程中，称为LPC；在linux编程中，更习惯称之为IPC，即进程间通信。</p>
<p>但是，不管如何，其本质上就是本地机器上的不同进程之间通信协作的调用方式。</p>
<p>服务端开发，一般我们基于Linux，所以这里简单介绍下Linux环境下 IPC实现方式：</p>
<ul>
<li>管道</li>
<li>共享内存</li>
<li>信号量</li>
<li>Socket套接字</li>
</ul>
<p>除此之外，还有消息队列和信号两种实现进程间通信的方式。</p>
<p>信号很容易理解，比如我们在控制台输入的<code>CTRL + C</code>来向执行的进程发送kill信号来结束该进程。对于信号，一般我们再终端交互窗口中使用比较多，在服务端开发中很少涉及。</p>
<p>Linux提供的消息队列和各种分布式MQ不同，它是在内核中使用链表结构来保持消息的队列，然后其他进程从内核的消息队列中获取消息。目前，Linux官方不太推荐使用，将渐渐被淘汰。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道命令，在我们的<code>linux shell</code>中经常使用，一般，我们使用<code>|</code>操作符来保证两个命令之间的数据通信。比如，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java | xargs echo</span><br></pre></td></tr></table></figure>

<p>管道命令，其实内部实现就是使用的linux管道接口，每个命令其实是一个进程，各个进程的标准输出STDOUT，作为下一个进程的标准输入STDIN。</p>
<p>Linux管道包含：匿名管道和命名管道。</p>
<ul>
<li><p>匿名管道：只能父子进程间通信。使用pipe()方法来创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int pipe(int filedis[2]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数filedis返回两个文件描述符：filedes[0]为读而打开，filedes[1]为写而打开。filedes[1]的输出是filedes[0]的输入</p>
</blockquote>
</li>
<li><p>命名管道：可以在单台机器内的任何一组进程间进行通信。一般我们使用mkfifo()来创建命名管道：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname,<span class="keyword">mode_t</span> mode)</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>成功返回0，失败返回-1。成功返回之后，pathname其实就可以看着一个管道文件操作(当然并没有真实文件在磁盘存在)，对于文件操作的方法例如open,read,write都适用于fifo命名通道。</p>
</blockquote>
</li>
</ul>
<h3 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h3><p>Linux中的信号量和Java中的信号量一样，其主要用处是同步协作。</p>
<p>信号量其实就是一个比较特殊的变量，然后对它的操作都是原子进行的，并且一般只提供两种方法：P和V操作(在java中为wait()和notify())。</p>
<ul>
<li>P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行；</li>
<li>V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1。</li>
</ul>
<p>linux对外提供的API接口方法如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct sem &#123;</span><br><span class="line">  short sempid;&#x2F;* pid of last operaton *&#x2F;</span><br><span class="line">  ushort semval;&#x2F;* current value *&#x2F;</span><br><span class="line">  ushort semncnt;&#x2F;* num procs awaiting increase in semval *&#x2F;</span><br><span class="line">  ushort semzcnt;&#x2F;* num procs awaiting semval &#x3D; 0 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">　　 #include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">　　 #include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">　　 #include &lt;sys&#x2F;sem.h&gt;</span><br><span class="line">&#x2F;&#x2F;首先获取一个信号量,只有该方法可以才能直接使用key，其他方法必须先semget然后才能使用信号量</span><br><span class="line">　　 int semget(key_t key, int nsems, int flag);</span><br><span class="line">&#x2F;&#x2F;对信号量进行操作，直接控制信号量信息，比如删除信号量</span><br><span class="line">int semctl(int semid, int semnum, int cmd, union semun arg);</span><br><span class="line">&#x2F;&#x2F;改变信号量的值，P,V操作都是通过该方法</span><br><span class="line">int semop(int sem_id, struct sembuf *sem_opa, size_t num_sem_ops);</span><br></pre></td></tr></table></figure>

<p>信号量的主要作用就是同步，所以我们一般是使用共享内存方式完成进程间通信，而在此过程中通过信号量来完成多进程间的同步协调机制。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>由于同一台机器的硬件设备一般对于同一个系统来说，都是共享的。所以使用内存来完成进程间通信开发的思路，必然是很容易想到的，但是未必容易做到。</p>
<p>众所周知，进程和线程最大的区别就是一些资源是否隔离。也就是说，不同的进程，其内存资源使用是隔离独立的，每个进程有自己的一套内存地址映射逻辑，也即是系统是无法直接从不同进程的相同虚拟内存地址找到共同的物理内存地址的，这样，就无法像线程一样，简单把数据对象设置为<code>static</code>然后线程间就可以共享获取了。</p>
<p>因此，Linux对外提供了共享内存的方法来完成进程间通信。</p>
<p>共享内存是最有效的进程间通信方式。其对外提供的API如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">　   #include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">　　 #include &lt;sys&#x2F;shm.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建共享内存空间，大小为size</span><br><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line">&#x2F;&#x2F;所有需要使用共享内存通信的进程，映射到自身的内存地址空间中</span><br><span class="line">void *shmat(int shmid, void *addr, int flag);</span><br><span class="line">&#x2F;&#x2F;从当前进程地址空间中分离该共享内存</span><br><span class="line">int shmdt(const void *shmaddr);</span><br><span class="line">&#x2F;&#x2F;控制共享内存的，比如删除该共享内存空间等</span><br><span class="line">int shmctl(int shm_id, int command, struct shmid_ds *buf);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上面的方法可以很显然的看出，进程间的内存地址空间是独立隔离的(内核地址空间由于虚拟地址和物理地址是一致的，所以在进程间这块地址空间也是一致的，不过我们操作的都是用户空间的内存，所以不考虑这块)。当我们想要共享操作，必须要把物理内存分别绑定到对应进程的地址空间，才能共享操作。</p>
<p>使用的时候，很简单。<code>shmat</code>方法返回一个<code>void *</code>就可以强转某个指定的struct，然后直接操作该对象结构体即可。由于共享，所以需要考虑多线程同步安全问题。</p>
</blockquote>
<h3 id="Socket套接字"><a href="#Socket套接字" class="headerlink" title="Socket套接字"></a>Socket套接字</h3><p>从上面的几个API方法可以看到都是利用单机同用一套资源，然后各自进程的资源之间通过内核方式或者内存方式协作完成单机多进程间通信。</p>
<p>此外，还有一种方式来完成进程间通信，就是套接字socket。Socket一般情况下是用在不同的两台机器的不同进程之间通信的，当Socket创建时的类型为 <code>AF_LOCAL或AF_UNIX</code>时，则是本地进程通信了(当然你也可以直接使用网络套接字，如果你觉得走下网络更酷，或者以后便于服务分离)。</p>
<p>关于Socket的API介绍，这里就省略了。服务端/客户端模式的介绍和示例相对很常见，也很容易开发和理解。</p>
<p>从使用网络套接字Socket来实现进程间通信这个角度来说，其和RPC并没有什么不同了，所以有些文献分类时，说广义来讲RPC也应该包括LPC(IPC),因为从大的来讲，单机进程通信其实算是远程过程调用的一种特殊简化的方式而已。</p>
<p>当然，本文还是觉得还是区别开比较通用，也便于理解。</p>
<blockquote>
<p>如在Socket介绍的那样，本地过程调用很多情况下都是依赖操作系统对外提供的API来协调操作某个共享资源来完成进程间的数据交换。</p>
<p>如果不依赖单机共享资源，就只有Socket接口。因此，如果要扩展到分布式环境下的进程间通信，那就只能使用网络套接字来完成。</p>
</blockquote>
<p>说完单机的服务调用，在互联网时代，自然要讲web服务(Web Service)了。</p>
<h2 id="Web-Service技术"><a href="#Web-Service技术" class="headerlink" title="Web Service技术"></a>Web Service技术</h2><blockquote>
<p><code>Web Service</code>一般有两种定义：</p>
<ol>
<li>特指 W3C组织制定的<code>web service</code>规范技术。其包括SOAP(一个基于XML的可扩展消息信封格式，需同时绑定一个网络传输协议。这个协议通常是HTTP或HTTPS，但也可能是SMTP或XMPP)、WSDL(一个XML格式文档，用以描述服务端口访问方式和使用协议的细节。通常用来辅助生成服务器和客户端代码及配置信息)和UDDI(一个用来发布和搜索WEB服务的协议，应用程序可借由此协议在设计或运行时找到目标WEB服务)。从上面三个定义就可以看出，这种规范技术是一个重量级的协议。</li>
<li>泛指网络系统对外提供web服务所使用的技术。这里，我们主要是基于该定义来理解。</li>
</ol>
</blockquote>
<p>一般而言，技术体系，必然是服务于架构体系的。不同的架构，所约定的技术结构设计还是有些区别的。</p>
<p>因此，要了解web服务技术，必然要先了解其服务于哪个架构体系；也就是说，先去了解技术产生的架构背景。</p>
<h3 id="SOA-amp-微服务"><a href="#SOA-amp-微服务" class="headerlink" title="SOA &amp; 微服务"></a>SOA &amp; 微服务</h3><p>在分布式网络服务架构体系中，最火的莫过于 SOA(面向服务架构，Service-Oriented Architecture)和微服务。</p>
<p>嗯，一般将服务化架构，必然会扯到<code>全家桶</code>设计升级的故事。</p>
<p>简化版是这样子的：</p>
<ul>
<li>在很久很久以前，网络应用也是单机部署的，所有的业务代码全部都在一个大项目内，然后更改一个逻辑就需要重启部署应用，停止对外服务。</li>
<li>然后，这样子肯定不行的，就有了多机部署，通过Nginx或者其他代理/均衡软件来分发请求到相同服务的不同机器上，当其中一台机器停机部署时，请求全部打到其他机器上去。但是这个时候，所有机器上的代码还是一套。</li>
<li>后来，机器不断升级，但是业务不断变多，项目代码越来越大，更改一个地方编译打包部署时间非常长，于是，我们就把一些独立隔离开的业务代码分成多个项目。但是，实现业务逻辑的时候，必然有一些功能和数据是多个业务都会用到的，简单以前的代码copy过来，数据就直接操作数据库。但是，当有个公用的功能需要更改时，就发现所有相关业务都需要更改，并且数据库上的操作，还会带来其他同步兼容等等问题。</li>
<li>于是，就出现了SOA，也就是基于服务的架构设计理念。SOA的设计理念，就是把所有的服务都对外以HTTP或者其他协议方式对外暴露，绝对<code>不允许</code>相同的服务在不同的业务系统独立一套，然后共用底层数据库。服务化的设计系统，所有拆分的业务，彼此之间都通过暴露的服务接口通信，操作对方的数据。这样，各个业务系统之间开始独立自主的向着美好的方向发展了。</li>
<li>再后来，单个业务发展的越来越好，提供的功能也越来越多，这样一个业务系统的代码也变得很大了，开发人员也越来越多。于是乎，单个业务系统内部就存在问题了，当然，我们也可以拆分成不同的业务系统来开发发展。但是，单个业务系统，很多的公用逻辑都是一些业务细节，并不好独立成业务系统；此外，单个业务系统开发人员都很容易交流，因此，对于内部业务系统的架构设计，就出现了<code>微服务Micro-Service</code>了。我们把单个业务系统中一些功能细节的结构封装成服务，大的对外业务系统，组装各个微服务的接口数据，然后提供SOA服务。</li>
</ul>
<p>因此，SOA其实和微服务，从我的视角来看，其实就是 业务外部和内部服务的不同架构设计而已，其技术框架很大程度上都可以通用。其区别如下图：</p>
<p><img src="https://ketao1989.github.io/images/2016/12/soa_ms.jpg" alt="SOA和微服务"></p>
<p>从上面发展历程可以看到，SOA一般使用SOAP或者REST方式来提供服务，这样外部业务系统可以使用通用网络协议来处理请求和响应，而微服务，还可以有一些私有的协议方式来提供服务，例如基于自定义协议的RPC框架。RPC使得调用服务简单，但是需要一些其他耗时间的交流协调工作，这适合微服务的场景，但是不一定适合SOA场景了。</p>
<h3 id="web服务技术结构"><a href="#web服务技术结构" class="headerlink" title="web服务技术结构"></a>web服务技术结构</h3><p>先给出一个web服务的技术体系结构图：</p>
<p><img src="https://ketao1989.github.io/images/2016/12/web_service.png" alt="web服务技术体系"></p>
<p><code>web service</code>被W3C设立规范之初，SOAP方案就被提出来。但是，随着服务化技术和架构的发展，SOAP多少有点过于复杂，因此就出现了简化版的REST方案。此后，由于分布式服务应用越来越大，对性能和易用性上面要求越来越大，因此就出现了RPC框架(很多时候，RPC并不被当做一种web service方案。在绝大部分博客中，介绍web service 只会讨论 SOAP和REST，主要是其基本上都是基于SOA来介绍服务方案)。</p>
<h4 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h4><p>SOAP，全称为 Simple Object Access Protocol，也就是 简单对象访问协议。跟着<code>web service</code>一起出来的，说明历史悠久，不过感觉现在也慢慢要淘汰了。</p>
<p>SOAP，是基于XML数据格式来交换数据的；其内部定义了一套复杂完善的XML标签，标签中包含了调用的远程过程、参数、返回值和出错信息等等，通信双方根据这套标签来解析数据或者请求服务。与SOAP相关的配套协议是WSDL (Web Service Description Language)，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，类似我们现在聊服务治理中的服务发现功能。</p>
<p>因此，SOAP服务整体流程是：首先，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。</p>
<h4 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h4><p>REST，全称 REpresentational State Transfort，也就是 表示性状态转移。由于SOAP方案过于庞大复杂，在很多简单的web服务应用场景中，轻量级的REST就出现替代SOAP方案了。</p>
<p>和SOAP相比，REST只是对URI做了一些规范，数据才有JSON格式，底层传输使用HTTP/HTTPS来通信，因此，所有web服务器都可以快速支持该方案；开发人员也可以快速学习和使用。</p>
<h4 id="SOAP-amp-REST"><a href="#SOAP-amp-REST" class="headerlink" title="SOAP &amp; REST"></a>SOAP &amp; REST</h4><p>从命名来看，SOAP是一种协议，而REST只是一种方案。协议的设计很多时候，从上而下一整套都是新的，需要设计开发专门的工具支持；而方案相对就是基于目前以后的工具来做一些设计和约束，这就是为什么REST快速替换了SOAP的地位。</p>
<p>REST特点：</p>
<ul>
<li>由于数据返回格式是自定义的，绝大部分使用JSON，这种数据结构节省带宽，并且前端JavaScript能天生支持。</li>
<li>无状态，基于HTTP协议，所以只能适应无状态场景。</li>
</ul>
<p>SOAP特点：</p>
<ul>
<li>协议有安全性的一些规范。</li>
<li>基于xml的标签约束，而且也不要去底层是HTTP传输，所以支持有状态的场景。</li>
</ul>
<h3 id="RPC家族"><a href="#RPC家族" class="headerlink" title="RPC家族"></a>RPC家族</h3><p>RPC家族中，RMI是Java制定的远程通信协议。而后，基本上RPC框架都或多或少有RMI的影子(当然，其实主要是RPC本身的实现方式就是这样子了-_-)。RMI既然是Java的标准RPC组件，那必然其他编程语言就无法使用了；因此，Thrift这种基于IDL来跨语言的RPC组件就出现了。Thrift的使用者，只需要按照Thrift官方规定的方式来写API结构，然后生成对应语言的API接口，继而就可以跨语言完成远程过程调用了。但是，作为服务化的组件，如果没有服务治理来完成大规模应用集群中服务调用管理工作，则运维工作则是非常繁重的，因此类似dubbo这种包含服务治理的RPC组件出现了。</p>
<p>下面，就来介绍RPC组件。</p>
<h2 id="RPC介绍"><a href="#RPC介绍" class="headerlink" title="RPC介绍"></a>RPC介绍</h2><blockquote>
<p>RMI作为Java自带的官方RPC组件，单独介绍；然后我们来看看通用RPC实现结构。</p>
</blockquote>
<h3 id="RMI介绍"><a href="#RMI介绍" class="headerlink" title="RMI介绍"></a>RMI介绍</h3><p>RMI，全称是Remote Method Invocation，也就是远程方法调用。在JDK 1.2的时候，引入到Java体系的。当应用比较小，性能要求不高的情况下，使用RMI还是挺方便快捷的。</p>
<p>下面先看看RMI的调用流程。</p>
<p><img src="https://ketao1989.github.io/images/2016/12/rmi.png" alt="RMI服务调用流程"></p>
<p>其中，有些概念需要说明：</p>
<blockquote>
<p>stub(桩)：stub实际上就是远程过程在客户端上面的一个代理proxy。当我们的客户端代码调用API接口提供的方法的时候，RMI生成的stub代码块会将请求数据序列化，交给远程服务端处理，然后将结果反序列化之后返回给客户端的代码。这些处理过程，对于客户端来说，基本是透明无感知的。</p>
<p>remote：这层就是底层网络处理了，RMI对用户来说，屏蔽了这层细节。stub通过remote来和远程服务端进行通信。</p>
<p>skeleton(骨架)：和stub相似，skeleton则是服务端生成的一个代理proxy。当客户端通过stub发送请求到服务端，则交给skeleton来处理，其会根据指定的服务方法来反序列化请求，然后调用具体方法执行，最后将结果返回给客户端。</p>
<p>registry(服务发现)：rmi服务，在服务端实现之后需要注册到rmi server上，然后客户端从指定的rmi地址上lookup服务，调用该服务对应的方法即可完成远程方法调用。registry是个很重要的功能，当服务端开发完服务之后，要对外暴露，如果没有服务注册，则客户端是无从调用的，即使服务端的服务就在那里。</p>
</blockquote>
<p>下面给出一个简单的Java示例来show code下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口必须继承RMI的Remote</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RmiService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须有RemoteException，才是RMI方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UnicastRemoteObject会生成一个代理proxy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmiServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">RmiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RmiServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端server启动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmiServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RmiService service = <span class="keyword">new</span> RmiServiceImpl();</span><br><span class="line">            <span class="comment">//在本地创建和暴露一个注册服务实例，端口为9999</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">//注册service服务到上面创建的注册实例上</span></span><br><span class="line">            Naming.rebind(<span class="string">"rmi://127.0.0.1:9999/service1"</span>,service);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"------------server start-----------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端调用rmi服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmiClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据注册的服务地址来查找服务，然后就可以调用API对应的方法了</span></span><br><span class="line">            RmiService service = (RmiService)Naming.lookup(<span class="string">"rmi://localhost:9999/service1"</span>);</span><br><span class="line">            System.out.println(service.hello(<span class="string">"RMI"</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面一些核心的代码已经在注释中给了说明。</p>
</blockquote>
<h3 id="通用RPC架构"><a href="#通用RPC架构" class="headerlink" title="通用RPC架构"></a>通用RPC架构</h3><p>一般，远程过程调用RPC就是本地动态代理隐藏通信细节，通过组件序列化请求，走网络到服务端，执行真正的服务代码，然后将结果返回给客户端，反序列化数据给调用方法的过程。</p>
<p>RPC具体调用流程如下所示： <img src="https://ketao1989.github.io/images/2016/12/rpc.png" alt="RPC调用流程"></p>
<p>通用的RPC组件一般包括以下一些模块：</p>
<blockquote>
<ol>
<li>serviceClient：这个模块主要是封装服务端对外提供的API，让客户端像使用本地API接口一样调用远程服务。一般，我们使用动态代理机制，当客户端调用api的方法时，serviceClient会走代理逻辑，去远程服务器请求真正的执行方法，然后将响应结果作为本地的api方法执行结果返回给客户端应用。类似RMI的stub模块。</li>
<li>processor：在服务端存在很多方法，当客户端请求过来，服务端需要定位到具体对象的具体方法，然后执行该方法，这个功能就由processor模块来完成。一般这个操作需要使用反射机制来获取用来执行真实处理逻辑的方法，当然，有的RPC直接在server初始化的时候，将一定规则写进Map映射中，这样直接获取对象即可。类似RMI的skeleton模块。</li>
<li>protocol：协议层，这是每个RPC组件的核心技术所在。一般，协议层包括编码/解码，或者说序列化和反序列化工作；当然，有的时候编解码不仅仅是对象序列化的工作，还有一些通信相关的字节流的额外解析部分。序列化工具有：hessian，protobuf，avro,thrift，json系，xml系等等。在RMI中这块是直接使用JDK自身的序列化组件。</li>
<li>transport：传输层，主要是服务端和客户端网络通信相关的功能。这里和下面的IO层区分开，主要是因为传输层处理server/client的网络通信交互，而不涉及具体底层处理连接请求和响应相关的逻辑。</li>
<li>I/O：这个模块主要是为了提高性能可能采用不同的IO模型和线程模型，当然，一般我们可能和上面的transport层联系的比较紧密，统一称为remote模块。</li>
</ol>
</blockquote>
<p>此外，还有业务代码自己去实现的client和server层。client当需要远程调用服务时，会首先初始化一个API接口代理对象，然后调用某个代理方法。server在对外暴露服务时，需要首先实现对应API接口内部的方法，当请求过来时，通过反射找到对应的实例对象，执行对应的业务代码。</p>
<h3 id="简单RPC组件实现"><a href="#简单RPC组件实现" class="headerlink" title="简单RPC组件实现"></a>简单RPC组件实现</h3><p>介绍完RPC相关结构和概念之后，给一个简单的RPC组件示例来对各个模块进行code级别的说明。</p>
<blockquote>
<p>以下代码仅仅是了解RPC各个模块功能的示例，对性能和异常等情况未考虑全面，生产环境不适用。</p>
</blockquote>
<h4 id="protocol模块代码"><a href="#protocol模块代码" class="headerlink" title="protocol模块代码"></a>protocol模块代码</h4><blockquote>
<p>协议层主要包括编解码和序列化部分。编解码就是我们对传输通信的远程调用请求接口和方法参数等数据按照我们规定的格式进行组装编码，然后在接收的一方负责把数据解码成原始的对象，然后找到需要执行的接口和方法。序列化/反序列化，则是将数据对象，按照一定的映射关系转换成字节流，供网络传输，接收的一方首先将流映射为对象数据。</p>
<p>有的时候，序列化/反序列化组件会包含编解码部分。此外，编解码和序列化工作先后关系也不一定。一般高性能RPC，序列化工具十分强大和通用，所以编解码部分会放在序列化之后，主要是解码的时候，可以不完成反序列化就对流进行一些处理工作，比如映射、分发等。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 很明显，这里使用JSON来序列化和反序列化RPC调用传递的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ServiceProtocol protocol = <span class="keyword">new</span> ServiceProtocol();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将对象序列化为字符串字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encode(Object o) &#123;</span><br><span class="line">        <span class="keyword">return</span> JsonUtils.encode(o).getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化成字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">decode</span><span class="params">(<span class="keyword">byte</span>[] data, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JsonUtils.decode(<span class="keyword">new</span> String(data), clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编解码模型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolModel</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String clazz;</span><br><span class="line">        <span class="keyword">private</span> String method;</span><br><span class="line">        <span class="keyword">private</span> String[] argTypes;</span><br><span class="line">        <span class="keyword">private</span> Object[] args;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// setter getter方法省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例中的代码使用JSON来序列化/反序列化工作。由于JSON序列化组件比较弱，所以这边需要将执行调用方法相关的请求数据进行编码成<code>ProtocolModel</code>对象。</p>
<h4 id="remote模块代码"><a href="#remote模块代码" class="headerlink" title="remote模块代码"></a>remote模块代码</h4><blockquote>
<p>remote模块是提供服务端和客户端通信的功能。因此，在服务端需要起一个端口来监听外部的请求，在客户端则负责发送请求，接收响应数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端通信组件，客户端和外部服务端数据交互时使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientRemoter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ClientRemoter client = <span class="keyword">new</span> ClientRemoter();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">byte</span>[] getDataRemote(<span class="keyword">byte</span>[] requestData) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket()) &#123;</span><br><span class="line">             socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">9999</span>));</span><br><span class="line">             socket.getOutputStream().write(requestData);</span><br><span class="line">             socket.getOutputStream().flush();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10240</span>];</span><br><span class="line">             <span class="keyword">int</span> len = socket.getInputStream().read(data);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> Arrays.copyOfRange(data, <span class="number">0</span>, len);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端起一个端口监听服务，绑定到相关processor处理器上。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerRemoter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executor =</span><br><span class="line">        Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ServerSocket server = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        System.out.println(<span class="string">"-----------start server----------------"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> Socket socket = server.accept();</span><br><span class="line">                executor.execute(<span class="keyword">new</span> MyRunnable(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            server.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> (InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10240</span>];</span><br><span class="line">                <span class="keyword">int</span> len = is.read(data);</span><br><span class="line"></span><br><span class="line">                ServiceProtocol.ProtocolModel model = ServiceProtocol.protocol</span><br><span class="line">                    .decode(Arrays.copyOfRange(data, <span class="number">0</span>, len), ServiceProtocol.ProtocolModel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                Object object = ServiceProcessor.processor.process(model);</span><br><span class="line">                os.write(ServiceProtocol.protocol.encode(object));</span><br><span class="line">                os.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// close socket...</span></span><br><span class="line">           &#125;        &#125;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>简单处理，直接让网络一次获取所有的数据，假设一次请求和响应的数据大小小于10K。</p>
<p>在server端的remote中，启动服务之前是需要绑定对外提供的服务的，也就是服务server启动，其内部需要指定序列化、服务处理器等逻辑。</p>
</blockquote>
<p>通用RPC的通信层，是非常复杂的，其需要考虑各种网络环境导致的数据半包，分包和粘包情况，需要考虑高性能NIO组件，多线程处理超时，连接复用等等。</p>
<h4 id="processor模块代码"><a href="#processor模块代码" class="headerlink" title="processor模块代码"></a>processor模块代码</h4><blockquote>
<p>服务端接口方法定位处理器。作为一个组件，显然不应该在业务代码中嵌入一些非业务逻辑。processor会根据序列化完了之后的请求数据来定位具体的处理逻辑，然后调用对应的业务代码来处理获取返回结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class ServiceProcessor &#123;</span><br><span class="line"></span><br><span class="line">    public static final ServiceProcessor processor &#x3D; new ServiceProcessor();</span><br><span class="line"></span><br><span class="line">    private static final ConcurrentMap&lt;String, Object&gt; PROCESSOR_INSTANCE_MAP &#x3D; new ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public boolean publish(Class clazz, Object obj) &#123;</span><br><span class="line">        return PROCESSOR_INSTANCE_MAP.putIfAbsent(clazz.getName(), obj) !&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object process(ServiceProtocol.ProtocolModel model) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz &#x3D; Class.forName(model.getClazz());</span><br><span class="line"></span><br><span class="line">            Class[] types &#x3D; new Class[model.getArgTypes().length];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; types.length; i++) &#123;</span><br><span class="line">                types[i] &#x3D; Class.forName(model.getArgTypes()[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Method method &#x3D; clazz.getMethod(model.getMethod(), types);</span><br><span class="line"></span><br><span class="line">            Object obj &#x3D; PROCESSOR_INSTANCE_MAP.get(model.getClazz());</span><br><span class="line">            if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return method.invoke(obj, model.getArgs());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PROCESSOR_INSTANCE_MAP publish这个逻辑，在Spring环境中，一般通过xml配置自动注入进来，然后从context中获取对应的实例。但是，不管怎样，底层其实都是一个map来维护映射关系。</p>
</blockquote>
<p>如上文介绍的那样，经过解码获取到的调用对象，然后通过java反射机制，执行指定的方法获取结果。</p>
<h4 id="serviceClient模块代码"><a href="#serviceClient模块代码" class="headerlink" title="serviceClient模块代码"></a>serviceClient模块代码</h4><blockquote>
<p>其实，这块叫做serviceProxyClient比较直接点。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class ServiceProxyClient &#123;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T getInstance(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return (T) Proxy.newProxyInstance(clazz.getClassLoader(), new Class[] &#123;clazz&#125;, new ServiceProxy(clazz));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class ServiceProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">        private Class clazz;</span><br><span class="line"></span><br><span class="line">        public ServiceProxy(Class clazz) &#123;</span><br><span class="line">            this.clazz &#x3D; clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">            ServiceProtocol.ProtocolModel model &#x3D; new ServiceProtocol.ProtocolModel();</span><br><span class="line">            model.setClazz(clazz.getName());</span><br><span class="line">            model.setMethod(method.getName());</span><br><span class="line">            model.setArgs(args);</span><br><span class="line"></span><br><span class="line">            String[] argType &#x3D; new String[method.getParameterTypes().length];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; argType.length; i++) &#123;</span><br><span class="line">                argType[i] &#x3D; method.getParameterTypes()[i].getName();</span><br><span class="line">            &#125;</span><br><span class="line">            model.setArgTypes(argType);</span><br><span class="line"></span><br><span class="line">            byte[] req &#x3D; ServiceProtocol.protocol.encode(model);</span><br><span class="line">            byte[] rsp &#x3D; ClientRemoter.client.getDataRemote(req);</span><br><span class="line">            return ServiceProtocol.protocol.decode(rsp, method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ProxyClient</code>就是对客户端调用API时透明化底层序列化和网络操作相关细节。所以，在proxyClient内部，我们可以看到它封装代理了这块调用逻辑，业务代码直接使用<code>getInstance</code>方法就可以获取对象实例，然后按照正常使用api方法来执行调用逻辑，获取结果。</p>
<blockquote>
<p>如果使用spring框架的话，可以进一步封装成一个bean，然后客户端业务代码只需要在xml中配置一下，就可以通过注解annotation等方式注入进来。</p>
</blockquote>
<h4 id="server业务接口实现代码"><a href="#server业务接口实现代码" class="headerlink" title="server业务接口实现代码"></a>server业务接口实现代码</h4><blockquote>
<p>这里给出接口对外发布和测试</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface RpcService &#123;</span><br><span class="line">    String sayHi(String name);</span><br><span class="line">&#125;</span><br><span class="line">public class RpcServiceImpl implements RpcService &#123;</span><br><span class="line">    public String sayHi(String name) &#123;</span><br><span class="line">        return &quot;Hello,&quot; + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 服务端测试main执行代码</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ServerDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 发布接口</span><br><span class="line">        ServiceProcessor.processor.publish(RpcService.class,new RpcServiceImpl());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 启动server</span><br><span class="line">        ServerRemoter remoter &#x3D; new ServerRemoter();</span><br><span class="line">        remoter.startServer(9999);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上，我们构造了一个<code>RpcService</code>接口对外提供sayHi的服务。在main方法中，我们首先需要对外发布这个接口和对应的实现类对象。在一些框架中，这些对外暴露的接口，都是通过xml配置或者annotation来发布的。然后，我们就可以启动server服务，对外提供RPC服务。</p>
</blockquote>
<h4 id="6-client调用测试代码"><a href="#6-client调用测试代码" class="headerlink" title="6. client调用测试代码"></a>6. client调用测试代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ClientDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;----------start invoke----------------&quot;);</span><br><span class="line">        RpcService service &#x3D; ServiceProxyClient.getInstance(RpcService.class);</span><br><span class="line">        System.out.println(service.sayHi(&quot;RPC World&quot;));</span><br><span class="line">        System.out.println(&quot;----------end invoke----------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看我们的测试代码非常简单，当要远程调用某个接口方法时，只需要getInstance该接口类代理对象，然后就像调用本地方法一直执行方法执行和结果处理。</p>
</blockquote>
<h2 id="RPC技术深入"><a href="#RPC技术深入" class="headerlink" title="RPC技术深入"></a>RPC技术深入</h2><p>上文简单的介绍了RPC模块各个部分，并且实现了一个简单的RPC组件。这一部分，我们要介绍在生产环节下RPC需要使用的一些技术点。</p>
<h3 id="RPC序列化"><a href="#RPC序列化" class="headerlink" title="RPC序列化"></a>RPC序列化</h3><blockquote>
<p>将RPC序列化和编解码分开，是因为个人觉得，虽然在很多时候，编解码其实就是序列化操作，但是有的时候，我们会自定义一些数据结构来封装业务数据对象，然后再序列化成二进制流。此外，在协议层，我们可能也会对普通序列化完了之后，还会对传输头进行编码工作。因此，为了更好的说明，这里分开来。</p>
</blockquote>
<p>序列化，说的简单，就是将对象转换成二进制流，也就是<code>byte[]</code>，而反序列化就是讲二进制流转换成对象。使用序列化/反序列化，主要是我们想把内存对象数据，持久化到文件fd或者通过网络传输到其他地方，而这只能使用二进制流来呈现。此外，由于RPC是通过网络通信的，所以序列化工具的性能和二进制流的大小，都是直接影响整体处理能力的关键因素。</p>
<p>目前基于Java的序列化工具，主要有：</p>
<ul>
<li>JDK Serializable工具</li>
<li>Hessian工具</li>
<li>Kryo工具</li>
<li>JSON工具</li>
</ul>
<h4 id="JDK内置序列化工具"><a href="#JDK内置序列化工具" class="headerlink" title="JDK内置序列化工具"></a>JDK内置序列化工具</h4><p>JDK自带的序列化工作不需要引入任何第三方包就可以直接使用，我们仅仅只需要实现<code>java.io.Serializable</code>接口。然后，我们在需要序列化/反序列化的时候，直接使用<code>ObjectInputStream</code>/<code>ObjectOutStream</code>来readObject将流反序列化成对象或者writeObject将对象序列化成流。</p>
<p>很多时候，我们并不使用原生的JDK序列化工具进行序列化，主要原因是因为其序列化后的二进制流太大，并且序列化耗时也比较长。但是，其最大的优点就是原生支持，快速使用，引入成本低，此外，其支持java所有类型，所以在有些RPC组件中，其作为默认序列化工具。</p>
<blockquote>
<p>使用JDK自带的序列化工具，尤其需要注意<code>serialVersionUID</code>这个静态变量，在反序列化的时候，会根据这个变量来判断两个类是否一样，如果修改了该变量，那么将无法兼容来的二进制数据的反序列化操作。</p>
<p>此外，你可以通过在类中增加writeObject 和 readObject 方法可以实现自定义序列化。</p>
</blockquote>
<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class JdkSerialiable &#123;</span><br><span class="line">    public static void serial(Blog blog) throws Exception &#123;</span><br><span class="line">        ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream os &#x3D; new ObjectOutputStream(baos);</span><br><span class="line">        os.writeObject(blog);</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream is &#x3D; new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));</span><br><span class="line">        Blog blog1 &#x3D; (Blog) is.readObject();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(blog1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Hessian工具"><a href="#Hessian工具" class="headerlink" title="Hessian工具"></a>Hessian工具</h4><p>Hessian,其实是一个开源的轻量级RPC组件。从上面分析RPC通用结构，可以看到很多RPC为了性能会自己实现序列化/反序列化工具，比如Thrift，而hessian也是如此。hessian2的性能相对JDK来说，提高了很多，而且序列化完了之后的流也小了很多。由于hessian已经生产实践了很长时间，所以其还是很值得使用的。</p>
<p>hessian在处理序列化的时候，会根据对象的数据类型采用不同的序列化策略，比如有些直接使用JavaSerializer，有些事自己来实现对应类型的序列化方法，其实就是如上面所介绍的那样，实现对应类型的<code>writeObject</code>和<code>readObject</code>方法。</p>
<p>我们只是使用hessian工具来完成序列化和反序列化工作，如果你需要自己实现一个自定义序列化工具，那么可以参考hessian的实现方式。</p>
<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class HessianSerialibale &#123;</span><br><span class="line"></span><br><span class="line">    public static void serial(Blog blog) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        Hessian2Output os &#x3D; new Hessian2Output(baos);</span><br><span class="line">        os.writeObject(blog);</span><br><span class="line">        os.close();</span><br><span class="line">        Hessian2Input is &#x3D; new Hessian2Input(new ByteArrayInputStream(baos.toByteArray()));</span><br><span class="line">        Blog blog1 &#x3D; (Blog) is.readObject();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(blog1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>尤其需要说明，在上面的测试代码中，如果不将os close掉，则一直会报错，告诉<code>java.io.EOFException: readObject: unexpected end of file</code>.</p>
<p>此外，处理性能上的优势，hessian还可以在<code>serialVersionUID</code>被后期更改的时候，反序列化也没有问题。这是因为，hessian不依赖UID来匹配类型，而且hessian在序列化完了之后的二进制流里面，会保留每个field对应的一些属性信息，虽然这些信息会增加一点流大小，但是对反序列化工作很有帮助。</p>
</blockquote>
<h4 id="Kryo工具"><a href="#Kryo工具" class="headerlink" title="Kryo工具"></a>Kryo工具</h4><blockquote>
<p>关于Kryo的性能对比，可以参考<a href="http://developer.51cto.com/art/201506/480273.htm" target="_blank" rel="noopener">各种 Java 的序列化库的性能比较测试结果</a>。</p>
</blockquote>
<p>Kryo是一个快速高效的Java对象序列化框架，其在java的序列化上的性能指标甚至优于google著名的序列化框架protobuf，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。总之，Kryo性能非常霸道。</p>
<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class KryoSerializable &#123;</span><br><span class="line"></span><br><span class="line">    public static void serial(Blog blog)throws Exception&#123;</span><br><span class="line">        Kryo kryo &#x3D; new Kryo();</span><br><span class="line">        ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        Output output &#x3D; new Output(baos);</span><br><span class="line">        kryo.writeClassAndObject(output, blog);</span><br><span class="line">        output.close();</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bais &#x3D; new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        Input input &#x3D; new Input(bais);</span><br><span class="line">        Blog blog1 &#x3D; (Blog) kryo.readClassAndObject(input);</span><br><span class="line">        input.close();</span><br><span class="line">        System.out.println(blog1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于Kryo工具生成的字节码中是不包含field元数据信息的，这样的话，在兼容性上就很难处理了。比如我现在对一个对象增加一个字段属性，但是这样子的话，老的所有序列化二进制流就无法被正常反序列化成对象了。在很多场景下，这都是无法容忍的。</p>
</blockquote>
<h4 id="JSON工具"><a href="#JSON工具" class="headerlink" title="JSON工具"></a>JSON工具</h4><blockquote>
<p>JSON工具进行序列化和反序列化在上文已经进行了说明，并且RPC示例代码就是使用这种方式。其性能上跟hessian差不多，并且反序列化兼容会很，但是其有个比较大的缺点，就是很多类型，可能JSON工具无法支持，并且其是基于String然后再转成二进制流的，所以流的大小，可能并没有想象的那么好。</p>
</blockquote>
<h3 id="RPC协议编解码"><a href="#RPC协议编解码" class="headerlink" title="RPC协议编解码"></a>RPC协议编解码</h3><blockquote>
<p>除了序列化，在编码的上/下游还需要对二进制流或者对象做一些额外的处理，而这些处理本身和二进制流化没有太大关系。</p>
</blockquote>
<p>比如dubbo给出的处理流程，可以清晰的看出序列化和编码之间的区别(个人觉得广义的编码应该包括序列化那部分)如下：</p>
<p><img src="https://ketao1989.github.io/images/2016/12/dubbo_codec.png" alt="dubbo线程处理流程"></p>
<p>每个RPC组件，基本上都是直接基于Socket来开发通信层功能，但是在网络传输的数据由于网络链路和协议的问题，会出现半包，分包和粘包情况。这样就需要设计编解码协议头来解码网络流，如上dubbo视图。</p>
<p>下面我们来看下dubbo的协议编码格式(具体参考：<a href="http://dubbo.io/Developer+Guide-zh.htm#DeveloperGuide-zh-远程通讯细节" target="_blank" rel="noopener">远程通讯细节</a>)：</p>
<p><img src="https://ketao1989.github.io/images/2016/12/dubbo_protocol.png" alt="dubbo协议头"></p>
<p>Dubbo协议头分析：</p>
<blockquote>
<p>协议头固定长度<code>16</code>个字节，也就是128位。这样，当我们解码流的时候，会首先提取前16byte来解析。</p>
<p>先来看看MAGIC设计：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; magic header.</span><br><span class="line">protected static final short    MAGIC              &#x3D; (short) 0xdabb;</span><br><span class="line">protected static final byte     MAGIC_HIGH         &#x3D; Bytes.short2bytes(MAGIC)[0];</span><br><span class="line">protected static final byte     MAGIC_LOW          &#x3D; Bytes.short2bytes(MAGIC)[1];</span><br></pre></td></tr></table></figure>

<p><code>SerializationID</code>表示序列化类型ID，Dubbo支持多种序列化工具，比如hessian，jdk，fastjson等，所以需要在协议头里面指定序列化方式，这样在解码完了之后才能知道内容使用哪种工具反序列化。</p>
<p><code>event</code>表示事件，比如这个请求是<code>heartbeat</code>。<code>two way</code>表示请求是否是需要交互返回数据的请求。<code>req/res</code>表示该数据是请求还是响应。<code>status</code>表示状态位，当响应数据的时候，根据该字段判断是否成功。</p>
<p><code>id</code>表示请求id。这个ID真的真的很重要！！！这个id是请求客户端生成的唯一id，保证在服务运行期内id不会重复。此外，在阿里内部的RPC组件HSF最开始是将id放在data数据内，这样只有在反序列化的时候，才能拿到ReqId，但是有些时候ReqId对应的RPC请求可能由于超时或者已经被处理，导致客户端对于这种case直接丢弃就可以。因此，将id放在head里面，则直接解码的时候就可以拿到ReqId去check，而不需要额外反序列化工作。</p>
<p><code>data length</code>则表示正文内容的长度。解码是通过该字段来判断消息正文字节流的整个完整包，这样反序列化就可以进行正确的转换对象了。</p>
</blockquote>
<h3 id="RPC路由和负载均衡"><a href="#RPC路由和负载均衡" class="headerlink" title="RPC路由和负载均衡"></a>RPC路由和负载均衡</h3><blockquote>
<p>路由策略，是完成单个机器对于服务方调用链路的选择策略,然后把客户端的服务请求传输到具体的某台服务端的机器上。负载均衡是完成路由的一种实现方式，其将前端请求根据一定算法策略来分发到不同机器上，使得集群中机器资源得到充分均衡的利用，此外还可以将不可用机器剔出请求列表。但是，显然路由除了负载均衡之外，还有其他方式。</p>
<p>我们知道，现在的服务后台都是多台机器部署的服务集群，在这些集群在请求的入口，一般会有负责负载均衡的机器部署，来完成请求的合理分发。RPC的结构也是客户端和服务端模式，但是其结构中我们发现是没有中间代理server层的，所以对于客户端在集群中的远程服务调用，就需要客户端自己来完成负载均衡的逻辑了。</p>
<p>除负载均衡之外，我们还会存在其他路由加强方式。比如，我们有多个机房都部署服务的时候，我需要优先选择同机房内的服务调用。</p>
</blockquote>
<p>一般定义类似如下的接口，然后根据自己的需求实现自己的负载均衡/路由策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface ILoadBalanceStrategy &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从众多连接池子中选择其中一个池子.</span><br><span class="line">     *</span><br><span class="line">     * @param invokeConns 客户端维持的和各个服务端维持的连接池对象列表</span><br><span class="line">     * @param invocation 本次客户端调用服务端相关的信息</span><br><span class="line">     * @return 返回和其中一个服务端维持链接的连接池对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public InvokeConn select(List&lt;InvokeConn&gt; invokeConns, Invocation invocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般RPC组件中，会实现两个通用的负载均衡策略。随机和轮询。具体实现可以参考：<a href="https://github.com/ketao1989/ourea/tree/master/ourea-core/src/main/java/com/taocoder/ourea/core/loadbalance" target="_blank" rel="noopener">https://github.com/ketao1989/ourea/tree/master/ourea-core/src/main/java/com/taocoder/ourea/core/loadbalance</a></p>
</blockquote>
<p><em>再谈谈维护可用服务列表：</em></p>
<p>一般我们会在客户端和服务端之间维持长连接，然后通过心跳机制来确保服务端是否在线提供服务。此外，对一些没有维护长连接或者可选择不建立长连接的RPC组件来说，只能通过注册服务机制来监听服务端是否下线。</p>
<p>如果调用比较频繁的服务来说，客户端可以在服务连接未成功的情况下，将该机器从服务连接列表中剔除，放在<code>暂时不可用机器列表</code>，然后起一个定时任务，当机器暂存5s后，再放到可用列表尝试请求服务调用。</p>
<p>关于心跳请求的定时任务，可以参考使用Netty提供的<code>HashedWheelTimer</code><a href="https://zacard.net/2016/12/02/netty-hashedwheeltimer/" target="_blank" rel="noopener">netty源码解读之时间轮算法实现-HashedWheelTimer</a>，其提供了在不要求高精度触发定时任务的场景下，性能非常高。</p>
<p><em>最后，再聊聊服务调用路由：</em></p>
<p>服务路由，这里特指除负载均衡之外的一些服务寻址策略。和负载均衡不同的是，这里的路由策略是单个机器根据自身特点做出的服务方选择策略，而负载均衡策略则是基于整个集群中所有机器的普适策略。如上所言，我们的多机房部署，再拿到集群机器列表之后，我们还需要维持一个本机房的机器列表(一般，对服务集群列表进行按IP前缀规则来过滤)，这样当我们选择调用机器的时候，会优先从本机房获取连接，如果没有才会按照负载均衡来获取服务调用连接。</p>
<p>此外，对于一些完善的RPC框架，可能还会支持动态可配置路由规则。比如，我们可以按照机器ip来配置，某些客户端调用只能路由到某些服务端机器上。对于线上测试问题跟踪而言，可以很好的根据服务调用链路，来查看日志解决问题。</p>
<h3 id="RPC超时管理"><a href="#RPC超时管理" class="headerlink" title="RPC超时管理"></a>RPC超时管理</h3><p>作为一个健康的服务，一定需要超时机制。相当多的服务不可用问题，都是因为客户端没有超时机制，导致服务端抖动的一段时间内，客户端一直处于占用连接等待响应的阶段，耗尽服务端资源，最后导致服务端集群雪崩。所以在请求网络服务的时候，增加超时设置是多么重要(当然，连接使用现在最大连接数的连接池也非常重要)。</p>
<p>RPC的调用实现，一般会有一个IO线程池来处理RPC调用，也就是我们的业务线程会将调用请求交给RPC线程来处理，返回一个future对象。远程调用处理完成之后，RPC线程会将结果填充到<code>futrue</code>对象内部，然后告知调用方调用完成，可以使用<code>futrue.get</code>来获取返回数据。如下所示：</p>
<p><img src="https://ketao1989.github.io/images/2016/12/timeout.png" alt="RPC客户端调用处理"></p>
<p>从上图可以看出，<code>超时1</code>我们可以直接使用<code>futrue.get</code>特性来设置和处理超时问题。<code>超时2</code>指的是服务端执行的超时，比如我们客户端调用的时间是1s，但是服务端可能会超过1s，而这个时候客户端其实已经超时丢弃这次请求，但是服务端还一直执行直到完成返回，这个时候服务端需要序列化对象然后传输到客户端，但是这个流程其实可以简化的。</p>
<p>因此，服务端的超时管理，是当服务端业务逻辑执行完成之后(这期间实现超时中断比较难)，比较执行时间和客户端设置的超时时间，如果接近，则打包服务端超时错误信息返回给客户端即可。这样可以节省序列化数据时间(直接使用序列化好了的数据返回)，已经减少网络传输时间。</p>
<h3 id="RPC-服务发现"><a href="#RPC-服务发现" class="headerlink" title="RPC 服务发现"></a>RPC 服务发现</h3><p>在对外http服务里，我们有一个配套的支撑基础组件叫做DNS，其根据域名找到某几个外网ip地址。然后，请求打到网站内部，一般首先到nginx群，nginx也会根据url规则找到配置好的一组ip地址，此外，nginx根据healthcheck来检查http服务是否可用。但是，使用nginx时，我们通常需要把ip地址离线配置到nginx上。</p>
<p>我们提供的RPC服务都是集群部署，所以我们需要在客户端维持一个服务调用地址列表。所以，我们也需要类似DNS功能的服务。 但是，我们不想我们的RPC服务集群有机器迁移或者增加时，所需要离线给客户端配置，这就是说，我们还需要实时更新集群机器列表的功能。</p>
<p>这，就是RPC服务发现模块需要解决的问题。</p>
<p>一般，服务发现主要包括2部分：</p>
<ol>
<li>服务地址存储；</li>
<li>服务状态感知。</li>
</ol>
<h4 id="服务地址存储"><a href="#服务地址存储" class="headerlink" title="服务地址存储"></a>服务地址存储</h4><p>服务地址存储，首先需要一个组件来存放服务机器列表等RPC服务数据，提供存储服务的组件有很多，比如：zookeeper，redis，mysql等等。然后，在服务端正常启动可以提供服务之后，需要将自己的服务地址，比如ip，port，以及服务信息，比如接口，版本号等信息，提交到存储服务机器上。然后，客户端在启动的时候，从存储服务的机器上，根据接口，版本等服务信息来拿到提供对应服务的RPC地址列表，客户端根据这个列表就可以开始调用远程服务了。</p>
<p>此外，为了服务治理，比如我们需要知道哪些客户端调用了我们对外提供的服务，就需要客户端在启动的时候，把自己的地址数据和调用的服务信息提交到存储服务上去。</p>
<p>对于提供比较完善的服务治理功能，还可以提供后台操作界面，让某些服务端机器手动操作上/下线，这样让通过RPC调用的客户端不将流量打到下线的服务器上。</p>
<p>简单的服务发现，RPC方和存储组件之间的交互如下：</p>
<p><img src="https://ketao1989.github.io/images/2016/12/find.png" alt="RPC服务发现结果"></p>
<h4 id="服务状态感知"><a href="#服务状态感知" class="headerlink" title="服务状态感知"></a>服务状态感知</h4><p>这里的服务感知，包括客户端感知服务端状态，以及存储服务感知RPC参与方的状态。</p>
<p>正常情况下，我们从存储组件那里拿到服务端地址后，自己来处理路由策略，然后选择一个服务端建立连接，执行远程调用。在执行的过程中，如果有服务不可用，我们可以从我们的服务列表中，将它剔除。但是，如果服务增加机器或者服务机器迁移了呢？这就需要我们及时了解服务端集群的整体机器状态。两种方式：</p>
<ol>
<li>客户端其一个定时调度任务，周期去存储组件处拉取最新的服务集群地址列表，但是这个周期粒度比较难控制。</li>
<li>客户端和存储组件建立一个长连接，当存储组件发现有服务集群状态发生变更，推送给客户端。但是，这又要求存储组件具有推送功能。</li>
</ol>
<p>目前有这个功能的存储组件，主要有zookeeper和redis，此外，也可以自己实现一个简单可靠的服务发现中间件，对外提供推送存储服务。</p>
<p>我们在服务启动的时候，会告知存储组件我们对外提供服务的地址信息和客户端的地址信息；在服务已知操作的服务下线的时候，会将存储组件中存储的服务相关信息清除掉。但是，显然，在服务下线或者客户端下线的时候，都存在没有清除存储信息就宕机的情况，这个时候就需要存储组件需要有感知各个参与方的状态了。</p>
<p>一般，我们会让RPC两方都和存储组件保持连接，然后通过心跳等方式来探测对方是否下线。</p>
<p>目前提供这个功能的存储组件，主要有zookeeper和redis。当然，你也可以实现一个，可以和所有注册服务和查找服务的server保持长连接。由于，可能有大量的机器建立长连接，所以服务器性能一定要高。</p>
<blockquote>
<p>基于zookeeper实现服务发现功能的代码，可以参考：<a href="https://github.com/ketao1989/ourea" target="_blank" rel="noopener">https://github.com/ketao1989/ourea</a></p>
</blockquote>
<h3 id="RPC-多线程IO模型"><a href="#RPC-多线程IO模型" class="headerlink" title="RPC 多线程IO模型"></a>RPC 多线程IO模型</h3><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>RPC其实是一个说简单简单，说复杂复杂的组件。就如上文写的一个简单的RPC示例，其本身就是一个具备RPC功能的组件。但是，在深入篇中，可以看到每一个模块都可以深入优化，以及支持模块化插件话设计开发。</p>
<p>本文从单机到集群，从本地调用到远程调用的渐进过度。然后再从一个满足RPC结构图的简单示例开始，代码介绍每个模块，进而深入成熟RPC框架所需要考虑和优化的各个技术点。</p>
<p>本文的目的，旨在对RPC整体结构和各个模块进行介绍和深入，然后根据这些点，可以去分析开源的RPC框架或者自己写一个RPC组件。</p>
<p>在本文中，很多点都是一边学习，一边总结，所以知识有限，如有问题，欢迎交流。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><p><a href="https://yq.aliyun.com/articles/8931" target="_blank" rel="noopener">linux内存管理浅析</a></p>
</li>
<li><p><a href="http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1601_clark-trs/1601_clark.html" target="_blank" rel="noopener">微服务、SOA 和 API：是敌是友？</a></p>
</li>
<li><p><a href="http://tech.meituan.com/serialization_vs_deserialization.html" target="_blank" rel="noopener">序列化和反序列化</a></p>
</li>
</ol>
<hr>
<p>本文转载自</p>
<p><a href="https://ketao1989.github.io/2016/12/10/rpc-theory-in-action/" target="_blank" rel="noopener">深入浅出RPC原理</a></p>
<p>遵循CC 4.0 BY-SA版权协议</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/11/CAS%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/11/CAS%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">CAS存在的问题以及解决方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-11 10:57:09 / 修改时间：19:02:46" itemprop="dateCreated datePublished" datetime="2020-06-11T10:57:09+08:00">2020-06-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CAS的由来"><a href="#CAS的由来" class="headerlink" title="CAS的由来"></a>CAS的由来</h2><p>在JDK 5之前Java语言是靠synchronized关键字保证同步的，有锁机制存在以下问题：</p>
<p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p>
<p>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。</p>
<p>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p>
<p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p>
<p>独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。</p>
<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS,compare and swap的缩写，中文翻译成比较并交换。</p>
<p>我们都知道，在java语言之前，并发就已经广泛存在并在服务器领域得到了大量的应用。所以硬件厂商老早就在芯片中加入了大量直至并发操作的原语，从而在硬件层面提升效率。在intel的CPU中，使用cmpxchg指令。</p>
<p>在Java发展初期，java语言是不能够利用硬件提供的这些便利来提升系统的性能的。而随着java不断的发展,Java本地方法(JNI)的出现，使得java程序越过JVM直接调用本地方法提供了一种便捷的方式，因而java在并发的手段上也多了起来。而在Doug Lea提供的cucurenct包中，CAS理论是它实现整个java包的基石。</p>
<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”</p>
<p>通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。</p>
<p>类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。</p>
<h2 id="CAS的目的"><a href="#CAS的目的" class="headerlink" title="CAS的目的"></a>CAS的目的</h2><p>利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。</p>
<h2 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h2><blockquote>
<p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</p>
</blockquote>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</p>
<p>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>AtomicStampedReference 实例使用Demo示例代码:<br><a href="https://www.cnblogs.com/java20130722/p/3206742.html" target="_blank" rel="noopener">https://www.cnblogs.com/java20130722/p/3206742.html</a></p>
<h3 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h3><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p>
<p>转载自<a href="https://blog.csdn.net/hl_java/article/details/90520405" target="_blank" rel="noopener">CAS存在的问题以及解决方案</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EricMa"
      src="/images/eric.png">
  <p class="site-author-name" itemprop="name">EricMa</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">197</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Eric-Ma-C" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Eric-Ma-C" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chaoma@zju.edu.cn" title="E-Mail → mailto:chaoma@zju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EricMa</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">712k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
