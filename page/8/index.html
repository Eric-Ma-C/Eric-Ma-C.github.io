<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Eric&#39;s Blogs">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="Eric&#39;s Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="EricMa">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Eric's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Eric's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Better Code, Better Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/18/MySql%20MVCC%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/MySql%20MVCC%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">MySql MVCC机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-19 01:45:34 / 修改时间：09:59:50" itemprop="dateCreated datePublished" datetime="2020-06-19T01:45:34+08:00">2020-06-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Multiversion concurrency control 多版本并发控制</p>
<p>并发访问（读或者写）数据库时，对正在事务内处理的数据做多版本的管理，用来避免由于写操作的堵塞，而引发读操作失败的并发问题。</p>
</blockquote>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>先看一个案例：</p>
<p>1.查看数据的事务隔离级别</p>
<p>对事务隔离级别不熟悉的同学可以参考文章 <a href="https://mp.weixin.qq.com/s/WIqoR0-l7h9SObIzmGDatQ" target="_blank" rel="noopener">【MySQL （三） | 五分钟搞清楚MySQL事务隔离级别】</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure>



<p><img src="https://user-gold-cdn.xitu.io/2019/2/17/168f8c4a50c54d63?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="查看数据库的事务隔离级别"></p>
<p>可见 数据库隔离级别使用的是MySQL默认的RR级别。</p>
<p><strong>REPEATABLE READ</strong> 意味着：</p>
<ul>
<li>同一个事务中多次执行同一个select,读取到的数据没有发生改变；</li>
<li>此时：允许幻读，但不允许不可重复读和脏读，所以RR隔离级别要求解决不可重复读；</li>
</ul>
<p>2.在不同会话中执行以下SQL</p>
<p>补充一下建表语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`test_zq`</span> (</span><br><span class="line">	<span class="string">`id`</span> <span class="built_in">int</span> (<span class="number">11</span>),</span><br><span class="line">	<span class="string">`test_id`</span> <span class="built_in">int</span> (<span class="number">11</span>)</span><br><span class="line">); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`test_zq`</span> (<span class="string">`id`</span>, <span class="string">`test_id`</span>) <span class="keyword">values</span>(<span class="string">'1'</span>,<span class="string">'18'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`test_zq`</span> (<span class="string">`id`</span>, <span class="string">`test_id`</span>) <span class="keyword">values</span>(<span class="string">'4'</span>,<span class="string">'8'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`test_zq`</span> (<span class="string">`id`</span>, <span class="string">`test_id`</span>) <span class="keyword">values</span>(<span class="string">'7'</span>,<span class="string">'4'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`test_zq`</span> (<span class="string">`id`</span>, <span class="string">`test_id`</span>) <span class="keyword">values</span>(<span class="string">'10'</span>,<span class="string">'1234'</span>);</span><br></pre></td></tr></table></figure>

<p>用户1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="comment">-- 更新 id 为 1 的数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> test_zq <span class="keyword">SET</span> test_id = <span class="number">20</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>用户2:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="comment">--查询 id 为 1 的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test_zq <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>执行结果大致如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/17/168f8c50888174f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="执行结果"></p>
<p>根据事务隔离级别来看，我们理论上对获得 X 锁（关于锁的概念可以参考 <a href="http://mp.weixin.qq.com/s?__biz=MzI1Mzg4OTMxNQ==&mid=100000550&idx=1&sn=8a5cdff008fc1eed7b5c623c1bdf4ed1&chksm=69ccdd6a5ebb547c7b7baf6be78763fc5065e0a58de202f3e25d8d8ed56e6d1c1146332cfec1#rd" target="_blank" rel="noopener">【MySQL （四） | 五分钟搞清楚InnoDB锁机制】</a>）的数据行是不能再被获取读锁而访问的，但是事实上我们依然访问到了这个数据！</p>
<p><strong>通过结果说明</strong>：我们可以在一个事务未进行 commit/rollback操作之前，另一个事务仍然可以读取到数据库中的数据，只不过是读取到的是其他事务未改变之前的数据。此处是利用了MVCC多数据做了多版本处理，读取的数据来源于快照。</p>
<p>3.同理，在不同会话中执行以下SQL</p>
<p>用户1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">SELECT * FROM test_zq WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>用户2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update test_zq set test_id &#x3D; 22 where id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>执行完之后再回到用户1进行一次数据查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test_zq WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/17/168f8c6166f8fecf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="执行结果2"></p>
<p>执行结果和上一步的执行结果一样，只不过区别在于2步骤中是先 update 后 select , 3 步骤是先 select 后 update.</p>
<p>虽然两者执行结果是一致的，但是我们要思考两个问题：</p>
<ul>
<li>他们的底层实现是一样的吗？</li>
<li>他们的实现和MVCC有什么关系呢？</li>
</ul>
<p>接下来我们便开始了解一下 MVCC 机制</p>
<h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><blockquote>
<p>MVCC，Multi-Version Concurrency Control，多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；在编程语言中实现事务内存。</p>
</blockquote>
<p>如果有人从数据库中读数据的同时，有另外的人写入数据，有可能读数据的人会看到『半写』或者不一致的数据。有很多种方法来解决这个问题，叫做并发控制方法。最简单的方法，通过加锁，让所有的读者等待写者工作完成，但是这样效率会很差。MVCC 使用了一种不同的手段，每个连接到数据库的读者，<strong>在某个瞬间看到的是数据库的一个快照</strong>，写者写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于其他的读者来说是不可见的。</p>
<p>当一个 MVCC 数据库需要更一个一条数据记录的时候，它不会直接用新数据覆盖旧数据，而是将旧数据标记为过时（obsolete）并在别处增加新版本的数据。这样就会有存储多个版本的数据，但是只有一个是最新的。这种方式允许读者读取在他读之前已经存在的数据，即使这些在读的过程中半路被别人修改、删除了，也对先前正在读的用户没有影响。<strong>这种多版本的方式避免了填充删除操作在内存和磁盘存储结构造成的空洞的开销，但是需要系统周期性整理（sweep through）以真实删除老的、过时的数据。</strong>对于面向文档的数据库（Document-oriented database，也即半结构化数据库）来说，这种方式允许系统将整个文档写到磁盘的一块连续区域上，当需要更新的时候，直接重写一个版本，而不是对文档的某些比特位、分片切除，或者维护一个链式的、非连续的数据库结构。</p>
<p>MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用<strong>时间戳或者事务 ID</strong>去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。<strong>读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据。</strong></p>
<p>一句话总结就是：</p>
<blockquote>
<p>MVCC(<code>Multiversion concurrency control</code>) 就是 同一份数据临时保留多版本的一种方式，进而实现并发控制</p>
</blockquote>
<p>哪么此处需要注意的点就是：</p>
<ul>
<li>在读写并发的过程中如何实现多版本？</li>
<li>在读写并发之后，如何实现旧版本的删除（毕竟很多时候只需要一份最新版的数据就够了）？</li>
</ul>
<p>下面介绍一下MySQL中对于 MVCC 的逻辑实现</p>
<h3 id="MVCC逻辑流程-插入"><a href="#MVCC逻辑流程-插入" class="headerlink" title="MVCC逻辑流程-插入"></a>MVCC逻辑流程-插入</h3><p>在MySQL中建表时，每个表都会有三列隐藏记录，其中和MVCC有关系的有两列</p>
<ul>
<li>数据行的版本号 （DB_TRX_ID）</li>
<li>删除版本号 (DB_ROLL_PT)</li>
</ul>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">test_id</th>
<th align="center">DB_TRX_ID</th>
<th align="center">DB_ROLL_PT</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>在插入数据的时候，假设系统的全局事务ID从1开始，以下SQL语句执行分析参考注释信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin;-- 获取到全局事务ID</span><br><span class="line">insert into &#96;test_zq&#96; (&#96;id&#96;, &#96;test_id&#96;) values(&#39;5&#39;,&#39;68&#39;);</span><br><span class="line">insert into &#96;test_zq&#96; (&#96;id&#96;, &#96;test_id&#96;) values(&#39;6&#39;,&#39;78&#39;);</span><br><span class="line">commit;-- 提交事务</span><br></pre></td></tr></table></figure>

<p>当执行完以上SQL语句之后，表格中的内容会变成：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">test_id</th>
<th align="center">DB_TRX_ID</th>
<th align="center">DB_ROLL_PT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">5</td>
<td align="center">68</td>
<td align="center">1</td>
<td align="center">NULL</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">78</td>
<td align="center">1</td>
<td align="center">NULL</td>
</tr>
</tbody></table>
<p>可以看到，插入的过程中会把全局事务ID记录到列 DB_TRX_ID 中去</p>
<h3 id="MVCC逻辑流程-删除"><a href="#MVCC逻辑流程-删除" class="headerlink" title="MVCC逻辑流程-删除"></a>MVCC逻辑流程-删除</h3><p>对上述表格做删除逻辑，执行以下SQL语句（假设获取到的事务逻辑ID为 3）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin；--获得全局事务ID &#x3D; 3</span><br><span class="line">delete test_zq where id &#x3D; 6;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>执行完上述SQL之后数据并没有被真正删除，而是对删除版本号做改变，如下所示：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">test_id</th>
<th align="center">DB_TRX_ID</th>
<th align="center">DB_ROLL_PT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">5</td>
<td align="center">68</td>
<td align="center">1</td>
<td align="center">NULL</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">78</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
</tbody></table>
<h3 id="MVCC逻辑流程-修改"><a href="#MVCC逻辑流程-修改" class="headerlink" title="MVCC逻辑流程-修改"></a>MVCC逻辑流程-修改</h3><p>修改逻辑和删除逻辑有点相似，修改数据的时候 会先复制一条当前记录行数据，同事标记这条数据的数据行版本号为当前是事务版本号，最后把原来的数据行的删除版本号标记为当前是事务。</p>
<p>执行以下SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;-- 获取全局系统事务ID 假设为 10</span><br><span class="line">update test_zq set test_id &#x3D; 22 where id &#x3D; 5;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>执行后表格实际数据应该是：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">test_id</th>
<th align="center">DB_TRX_ID</th>
<th align="center">DB_ROLL_PT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">5</td>
<td align="center">68</td>
<td align="center">1</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">78</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">22</td>
<td align="center">10</td>
<td align="center">NULL</td>
</tr>
</tbody></table>
<h3 id="MVCC逻辑流程-查询"><a href="#MVCC逻辑流程-查询" class="headerlink" title="MVCC逻辑流程-查询"></a>MVCC逻辑流程-查询</h3><p>此时，数据查询规则如下：</p>
<ul>
<li><p>查找<strong>数据行版本号早于当前事务版本号</strong>的数据行记录</p>
<p>也就是说，数据行的版本号要小于或等于当前是事务的系统版本号，这样也就确保了读取到的数据是当前事务开始前已经存在的数据，或者是自身事务改变过的数据</p>
</li>
<li><p>查找<strong>删除版本号</strong>要么为NULL，要么<strong>大于当前事务版本号</strong>的记录</p>
<p>这样确保查询出来的数据行记录在事务开启之前没有被删除</p>
</li>
</ul>
<p>根据上述规则，我们继续以上张表格为例，对此做查询操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;-- 假设拿到的系统事务ID为 12</span><br><span class="line">select * from test_zq;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>执行结果应该是：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">test_id</th>
<th align="center">DB_TRX_ID</th>
<th align="center">DB_ROLL_PT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">6</td>
<td align="center">22</td>
<td align="center">10</td>
<td align="center">NULL</td>
</tr>
</tbody></table>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5c68a4056fb9a049e063e0ab" target="_blank" rel="noopener">【MySQL（5）| 五分钟搞清楚 MVCC 机制】</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/18/MySQL%20%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/MySQL%20%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">MySQL 运算符和函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-18 11:03:02 / 修改时间：19:04:56" itemprop="dateCreated datePublished" datetime="2020-06-18T11:03:02+08:00">2020-06-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h1><h4 id="CONCAT-字符连接"><a href="#CONCAT-字符连接" class="headerlink" title="CONCAT() 字符连接"></a><code>CONCAT()</code> 字符连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT(&#39;a&#39;,&#39;-&#39;,&#39;b&#39;);</span><br><span class="line">--结果为: a-b</span><br></pre></td></tr></table></figure>

<h4 id="CONCAT-WS-使用指定的分隔符进行字符连接"><a href="#CONCAT-WS-使用指定的分隔符进行字符连接" class="headerlink" title="CONCAT_WS() 使用指定的分隔符进行字符连接"></a><code>CONCAT_WS()</code> 使用指定的分隔符进行字符连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT_WS(&#39;|&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;); </span><br><span class="line">--结果为： A|B|C</span><br></pre></td></tr></table></figure>

<h4 id="FORMAT-数字格式化"><a href="#FORMAT-数字格式化" class="headerlink" title="FORMAT() 数字格式化"></a><code>FORMAT()</code> 数字格式化</h4><p>对数字四舍五入,返回字符串,包括逗号’,’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT FORMAT(12560.7,2); </span><br><span class="line">--结果：12,560.70</span><br><span class="line">SELECT FORMAT(12560.78,1); </span><br><span class="line">--结果：12,560.8</span><br></pre></td></tr></table></figure>

<h4 id="LOWER-转换成小写字母"><a href="#LOWER-转换成小写字母" class="headerlink" title="LOWER() 转换成小写字母"></a><code>LOWER()</code> 转换成小写字母</h4><h4 id="UPPER-转换成大写字母"><a href="#UPPER-转换成大写字母" class="headerlink" title="UPPER() 转换成大写字母"></a><code>UPPER()</code> 转换成大写字母</h4><h4 id="LEFT-截取左侧字符"><a href="#LEFT-截取左侧字符" class="headerlink" title="LEFT() 截取左侧字符"></a><code>LEFT()</code> 截取左侧字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT LEFT(&#39;mysql&#39;,2);  </span><br><span class="line">--结果：my</span><br></pre></td></tr></table></figure>

<h4 id="RIGHT-截取右侧字符"><a href="#RIGHT-截取右侧字符" class="headerlink" title="RIGHT() 截取右侧字符"></a><code>RIGHT()</code> 截取右侧字符</h4><h4 id="LENGTH-获取字符串长度"><a href="#LENGTH-获取字符串长度" class="headerlink" title="LENGTH() 获取字符串长度"></a><code>LENGTH()</code> 获取字符串长度</h4><p>长度包含空格</p>
<h4 id="LTRIM-删除前导空格"><a href="#LTRIM-删除前导空格" class="headerlink" title="LTRIM() 删除前导空格"></a><code>LTRIM()</code> 删除前导空格</h4><p>等同于<code>LEFT TRIM()</code></p>
<h4 id="RTRIM-删除后续空格"><a href="#RTRIM-删除后续空格" class="headerlink" title="RTRIM() 删除后续空格"></a><code>RTRIM()</code> 删除后续空格</h4><h4 id="TRIM-删除前后两边的指定字符-默认空格"><a href="#TRIM-删除前后两边的指定字符-默认空格" class="headerlink" title="TRIM() 删除前后两边的指定字符(默认空格)"></a><code>TRIM()</code> 删除前后两边的指定字符(默认空格)</h4><p>删除指定的前导和后续的字符,但不能删除中间的字符,如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT TRIM(LEADING&#39;?&#39;,&#39;??MYSQL????&#39;);  </span><br><span class="line">--leading前导,结果：MYSQL????</span><br><span class="line">SELECT TRIM(TRAILING&#39;?&#39;,&#39;??MYSQL????&#39;);  </span><br><span class="line">--trailing后序,结果：??MYSQL</span><br><span class="line">SELECT TRIM(BOTH&#39;?&#39;,&#39;??MYSQL???&#39;); </span><br><span class="line">--结果：MYSQL</span><br></pre></td></tr></table></figure>

<h4 id="REPLACE-替换字符"><a href="#REPLACE-替换字符" class="headerlink" title="REPLACE() 替换字符"></a><code>REPLACE()</code> 替换字符</h4><p>如将’?’替换为’-‘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT REPLACE(&#39;??MYSQL???&#39;,&#39;?&#39;,&#39;-&#39;);  </span><br><span class="line">--结果：--MYSQL---</span><br></pre></td></tr></table></figure>

<h4 id="SUBSTRING-string，offset，length-截取字符串"><a href="#SUBSTRING-string，offset，length-截取字符串" class="headerlink" title="SUBSTRING(string，offset，length) 截取字符串"></a><code>SUBSTRING(string，offset，length)</code> 截取字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUBSTRING(&#39;MYSQL&#39;,2,3);  </span><br><span class="line">--结果：SQL</span><br></pre></td></tr></table></figure>

<h4 id="NOT-LIKE-模糊匹配"><a href="#NOT-LIKE-模糊匹配" class="headerlink" title="[NOT] LIKE 模糊匹配"></a><code>[NOT] LIKE</code> 模糊匹配</h4><p><code>ESCAPE</code>可指定转义字符</p>
<ul>
<li><code>%</code> 代表任意个字符，0个或多个</li>
<li><code>_</code> 代表任意一个字符，只有一个</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM test WHERE name LIKE&#39;%o%&#39;; </span><br><span class="line">--结果：输入name 中带‘o’的name</span><br><span class="line">SELECT name FROM test WHERE name LIKE&#39;%1%%&#39; ESCAPE &#39;1&#39;;</span><br><span class="line">--找到中间带% 的匹配name</span><br></pre></td></tr></table></figure>

<h1 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h1><h4 id="CEIL-数值-向上取整"><a href="#CEIL-数值-向上取整" class="headerlink" title="CEIL(数值) 向上取整"></a><code>CEIL(数值)</code> 向上取整</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT CEIL(3.01);</span><br><span class="line">--结果是4</span><br></pre></td></tr></table></figure>

<h4 id="FLOOR-数值-向下取整"><a href="#FLOOR-数值-向下取整" class="headerlink" title="FLOOR(数值) 向下取整"></a><code>FLOOR(数值)</code> 向下取整</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT FLOOR(3.99);</span><br><span class="line">--结果是3;</span><br></pre></td></tr></table></figure>

<h4 id="DIV-除法-保留整数"><a href="#DIV-除法-保留整数" class="headerlink" title="DIV 除法,保留整数"></a><code>DIV</code> 除法,保留整数</h4><p>如果使用’’,如’3/4’结果为’0.75’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 3 DIV 4; </span><br><span class="line">--结果是0；因为3除以4，整数位为0</span><br></pre></td></tr></table></figure>

<h4 id="MOD-取模"><a href="#MOD-取模" class="headerlink" title="MOD 取模"></a><code>MOD</code> 取模</h4><p>相当于’%’取余运算符，可以用%号代替；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT 4 MOD 3; </span><br><span class="line">--结果为1；</span><br><span class="line">SELECT 5.3 MOD 3; </span><br><span class="line">--结果为2.3</span><br></pre></td></tr></table></figure>

<h4 id="POWER-数值-数值-幂运算"><a href="#POWER-数值-数值-幂运算" class="headerlink" title="POWER(数值,数值) 幂运算"></a><code>POWER(数值,数值)</code> 幂运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT POWER(3,3); </span><br><span class="line">--结果为27</span><br></pre></td></tr></table></figure>

<h4 id="ROUND-数值-小数的位数-四舍五入"><a href="#ROUND-数值-小数的位数-四舍五入" class="headerlink" title="ROUND(数值,小数的位数) 四舍五入"></a><code>ROUND(数值,小数的位数)</code> 四舍五入</h4><h4 id="TRUNCATE-数值-截取位数"><a href="#TRUNCATE-数值-截取位数" class="headerlink" title="TRUNCATE(数值,截取位数)"></a><code>TRUNCATE(数值,截取位数)</code></h4><p>和<code>ROUND()</code>类似,不四舍五入,直接截断,截取位数可以是负数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT TRUNCATE(125.68,-1); </span><br><span class="line">--结果为120</span><br></pre></td></tr></table></figure>

<h1 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h1><h4 id="NOT-BETWEEN-AND"><a href="#NOT-BETWEEN-AND" class="headerlink" title="[NOT] BETWEEN ... AND ..."></a><code>[NOT] BETWEEN ... AND ...</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT 15 BETWEEND 1 AND 20 </span><br><span class="line">-- 15在1到20之间 ,返回值是1</span><br><span class="line">SELECT 15 NOT BETWEEND 1 AND 20 </span><br><span class="line">--15在1到20之间,条件不成立 返回值是0</span><br></pre></td></tr></table></figure>

<h4 id="NOT-IN"><a href="#NOT-IN" class="headerlink" title="[NOT] IN()"></a><code>[NOT] IN()</code></h4><p>判断值是否在给定的集合中,如果在返回1,不在返回0,或者相反</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT 10 IN(5,10,15) </span><br><span class="line">-- 返回1 </span><br><span class="line">SELECT 10 NOT(5,10,15) </span><br><span class="line">-- 返回0</span><br></pre></td></tr></table></figure>

<h4 id="IS-NOT-NULL"><a href="#IS-NOT-NULL" class="headerlink" title="IS [NOT] NULL"></a><code>IS [NOT] NULL</code></h4><p>是否为<code>NULL</code>,成立返回1,不成立返回0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT NULL IS NULL </span><br><span class="line">-- 返回1 </span><br><span class="line">SELECT &#39;&#39; IS NULL</span><br><span class="line">-- 返回0 , 除了NULL其它都是非空 返回都是1</span><br></pre></td></tr></table></figure>

<h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><p>聚合函数只有一个返回值</p>
<h4 id="AVG-平均值"><a href="#AVG-平均值" class="headerlink" title="AVG()平均值"></a><code>AVG()</code>平均值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ROUND(AVG(goods_price),2) AS avg_price </span><br><span class="line">FROM tdb_goods;</span><br></pre></td></tr></table></figure>

<h4 id="COUNT-计数"><a href="#COUNT-计数" class="headerlink" title="COUNT()计数"></a><code>COUNT()</code>计数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(goods_id) AS counts </span><br><span class="line">FROM tdb_goods;</span><br></pre></td></tr></table></figure>

<h4 id="MAX-最大值"><a href="#MAX-最大值" class="headerlink" title="MAX()最大值"></a><code>MAX()</code>最大值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(goods_price) AS max </span><br><span class="line">FROM tdb_goods;</span><br></pre></td></tr></table></figure>

<h4 id="MIN-最小值"><a href="#MIN-最小值" class="headerlink" title="MIN()最小值"></a><code>MIN()</code>最小值</h4><h4 id="SUM-求和"><a href="#SUM-求和" class="headerlink" title="SUM()求和"></a><code>SUM()</code>求和</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(goods_price) AS sum </span><br><span class="line">FROM tdb_goods;</span><br></pre></td></tr></table></figure>

<h1 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h1><h4 id="MD5-摘要算法"><a href="#MD5-摘要算法" class="headerlink" title="MD5() 摘要算法"></a><code>MD5()</code> 摘要算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MD5(&#39;admin&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="PASSWORD-密码算法"><a href="#PASSWORD-密码算法" class="headerlink" title="PASSWORD() 密码算法"></a><code>PASSWORD()</code> 密码算法</h4><p>通过<code>PASSWORD()</code>修改MySQL当前用户和其他用户的密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 把密码修改成dimitar。</span><br><span class="line">SET PASSWORD&#x3D;PASSWORD(‘dimitar’);</span><br></pre></td></tr></table></figure>

<h1 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h1><h4 id="NOW-当前日期-时间"><a href="#NOW-当前日期-时间" class="headerlink" title="NOW() 当前日期,时间"></a><code>NOW()</code> 当前日期,时间</h4><h4 id="CURDATE-当前日期"><a href="#CURDATE-当前日期" class="headerlink" title="CURDATE() 当前日期"></a><code>CURDATE()</code> 当前日期</h4><h4 id="CURTIME-当前时间"><a href="#CURTIME-当前时间" class="headerlink" title="CURTIME() 当前时间"></a><code>CURTIME()</code> 当前时间</h4><h4 id="DATE-ADD-时间增减"><a href="#DATE-ADD-时间增减" class="headerlink" title="DATE_ADD() 时间增减"></a><code>DATE_ADD()</code> 时间增减</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INTERVAL&#96;可以为负值</span><br><span class="line">单位 &#96;YEAR, MONTH, WEEK, DAY</span><br><span class="line">SELECT DATE_ADD(&#39;2014-3-12&#39;,INTERVAL 365 DAY); </span><br><span class="line">-- 返回2015-3-12</span><br><span class="line">-- 在原有给定的时间上增加365天</span><br></pre></td></tr></table></figure>

<h4 id="DATEDIFF-日期差值"><a href="#DATEDIFF-日期差值" class="headerlink" title="DATEDIFF() 日期差值"></a><code>DATEDIFF()</code> 日期差值</h4><p>单位为日,前面时间减去后面时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATEDIFF(&#39;2014-1-1&#39;,&#39;2015-1-1&#39;) </span><br><span class="line">-- 返回365</span><br></pre></td></tr></table></figure>

<h4 id="DATEDIFF-日期格式化"><a href="#DATEDIFF-日期格式化" class="headerlink" title="DATEDIFF() 日期格式化"></a><code>DATEDIFF()</code> 日期格式化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE_FORMAT(&#39;2014-3-2&#39;,&#39;%m&#x2F;%d&#x2F;%Y&#39;);</span><br><span class="line">-- 返回03&#x2F;02&#x2F;2014</span><br></pre></td></tr></table></figure>

<h1 id="内置信息函数"><a href="#内置信息函数" class="headerlink" title="内置信息函数"></a>内置信息函数</h1><h4 id="VERSION-MySQL版本信息"><a href="#VERSION-MySQL版本信息" class="headerlink" title="VERSION() MySQL版本信息"></a><code>VERSION()</code> MySQL版本信息</h4><h4 id="SELECT-DATABASE-当前数据库"><a href="#SELECT-DATABASE-当前数据库" class="headerlink" title="SELECT DATABASE() 当前数据库"></a><code>SELECT DATABASE()</code> 当前数据库</h4><h4 id="USER-当前用户"><a href="#USER-当前用户" class="headerlink" title="USER() 当前用户"></a><code>USER()</code> 当前用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT USER();</span><br></pre></td></tr></table></figure>

<h4 id="CONNECTION-ID-当前用户的连接ID"><a href="#CONNECTION-ID-当前用户的连接ID" class="headerlink" title="CONNECTION_ID() 当前用户的连接ID"></a><code>CONNECTION_ID()</code> 当前用户的连接ID</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONNECTION_ID();</span><br></pre></td></tr></table></figure>

<h4 id="LAST-INSERT-ID-最后插入的记录的-ID-号"><a href="#LAST-INSERT-ID-最后插入的记录的-ID-号" class="headerlink" title="LAST_INSERT_ID() 最后插入的记录的 ID 号"></a><code>LAST_INSERT_ID()</code> 最后插入的记录的 ID 号</h4><p><code>ID</code>为主键,必须自动编号<code>AUTO_INCREMENT</code>,可以不叫’ID’.<br>如果一次<code>INSERT</code>插入的是多条记录，得到的是多条记录中的第一条（而不是最后一条！）</p>
<hr>
<p>本文遵循CC 4.0 BY-SA版权协议.</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/Innodb%20%E9%94%81%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/17/Innodb%20%E9%94%81%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">InnoDB 锁类型详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 07:04:20" itemprop="dateCreated datePublished" datetime="2020-06-18T07:04:20+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-06 11:20:06" itemprop="dateModified" datetime="2020-07-06T11:20:06+08:00">2020-07-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><blockquote>
<p>锁是用于管理不同事务对共享资源的并发访问</p>
</blockquote>
<p>表锁和行锁的区别：</p>
<p>在加锁效率、锁定粒度以及冲突概率上，表锁肯定是大于行锁的</p>
<p>但是在并发性能上，表锁远低于行锁。</p>
<p>表锁是锁定了整个表，在加锁期间，无论读写，这个表的数据都是锁定的，相反行锁只是锁定了这个表中的一条数据，其他数据仍然可以操作，这就可很好的提高了数据库的并发性能。</p>
<h2 id="Mysql-Innodb-锁类型"><a href="#Mysql-Innodb-锁类型" class="headerlink" title="Mysql Innodb 锁类型"></a>Mysql Innodb 锁类型</h2><ul>
<li>共享锁 Shared Locks  （简称 S 锁，属于行锁）</li>
<li>排他锁 Exclusive Locks（简称 X 锁，属于行锁）</li>
<li>意向共享锁 Intention Shared Locks （简称 IS 锁，属于表锁）</li>
<li>意向排他锁 Intention Exclusive Locks （简称 IX 锁，属于表锁）</li>
<li>自增锁 AUTO-INC Locks</li>
</ul>
<h3 id="共享锁（S）与排它锁-（X）"><a href="#共享锁（S）与排它锁-（X）" class="headerlink" title="共享锁（S）与排它锁 （X）"></a>共享锁（S）与排它锁 （X）</h3><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><blockquote>
<p>又称之为 读锁，简称 s 锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据库，但是只能读不能修改；</p>
</blockquote>
<p>加锁方式：</p>
<p>select * from users where id = 1 lock in share mode;</p>
<p>释放方式：</p>
<p>rollback/commit;</p>
<p>举例：</p>
<p>当手动为select语句加上共享锁之后，在右边的会话中我们对该条数据执行update 操作 ，会发现一直卡住，这就是说，加了共享锁的数据，只能被其他事务读取，但是不能被修改</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wiaHiab86pHEVsjczjHIlJCViandagPUgUSMPVblzsOic8pMzqSxEZG9NCceMqIfGbZoTqiavicgTtEEDFTfA6nN2gw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>当我们 commit/rollback结束掉左边会话框的事务时，会发现右边会话框的update操作可以正常进行了</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wiaHiab86pHEVsjczjHIlJCViandagPUgU03AHumpzGXmr1O5AgibNvrWfiaRM7bcugVRWBPEvmYdJ3yINaA8H3bvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>但是我们要注意一点，哪就是共享锁是不影响其他事物读取数据的，如下举例：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wiaHiab86pHEVsjczjHIlJCViandagPUgUnUUIibyicUY2y445Tlxtych9hXxvZjd3hcS2gz1jPj59ZUWOJx4eWqicg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h4><blockquote>
<p>又称为写锁，简称 X 锁，排它锁不能与其他锁并存，如一个事务获取了一个数据行的排它锁，其他事务就不能再获取改行的锁（包括共享锁和排它锁），只有当前获取了排它锁的事务可以对数据进行读取和修改（此时其他事务要读取数据可从快照获取）</p>
</blockquote>
<p>加锁方式：</p>
<p>delete update  insert 默认加排他锁</p>
<p>select * from users where id = 1 for update;</p>
<p>释放方式：</p>
<p>rollback/commit;</p>
<p>举例：</p>
<p>另一事务获取共享锁,排他锁,都会锁住</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wiaHiab86pHEVsjczjHIlJCViandagPUgUAMqY5LzLU8q4ia4owttZo5PvHaWiaMFvuGtsXDfZmsRK1zL6SbicKOeSA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wiaHiab86pHEVsjczjHIlJCViandagPUgUG3aMMGJmLcQD9F5UT9x5G7DuRicp32T7rQDbnib9XvYcHU0qRymOZQUg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="InnoDB-行锁到底锁的是什么？"><a href="#InnoDB-行锁到底锁的是什么？" class="headerlink" title="InnoDB 行锁到底锁的是什么？"></a>InnoDB 行锁到底锁的是什么？</h4><p>我们首先来看如下一个例子：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wiaHiab86pHEVsjczjHIlJCViandagPUgUriaCW7eXTC4wc9ATGKnbJTicjNzSyvgHMP0paA7jHxBVeC8Kp81eNksg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>发现在事务1中对id=1的数据行做了更新操作，但是事务未提交之前，事务2去再去更新这条数据会卡住，也就是被锁住了。</p>
<p>接下来我们在事务1 未做任何改变，保持事务未提交状态的情况下去更新id = 2 的数据行</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wiaHiab86pHEVsjczjHIlJCViandagPUgU7uzJrzSQiczd53rt0lFb3v8m4ibzyIfyuHW6WWiaBkq2vy47zKhIEAssg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>结果显而易见，更新数据成功了。</p>
<p>综上所述：</p>
<p>InnoDB的行锁是通过<strong>给索引上的索引项加锁</strong>来实现的，只有通过索引条件进行数据检索，Innodb才使用行级锁。否则，将使用表锁（锁住索引的所有记录）。</p>
<p>借此我们是不是能联想到，如果我们的删除/修改语句是没有命中索引的，哪么，则会锁住整个表，这在性能上的影响还是挺大的。</p>
<h3 id="意向共享锁-IS-和意向排他锁-IX"><a href="#意向共享锁-IS-和意向排他锁-IX" class="headerlink" title="意向共享锁(IS)和意向排他锁(IX)"></a>意向共享锁(IS)和意向排他锁(IX)</h3><h4 id="意向共享锁"><a href="#意向共享锁" class="headerlink" title="意向共享锁"></a>意向共享锁</h4><p>表示事务准备给数据行加入共享锁，也就是说一个数据行在加共享锁之前必须先取得该表的IS锁。</p>
<h4 id="意向排他锁"><a href="#意向排他锁" class="headerlink" title="意向排他锁"></a>意向排他锁</h4><p>表示事务准备给数据行加入排它锁，也就是说一个数据行加排它锁之前必须先取得该表的IX锁。</p>
<ul>
<li><p>意向锁是InnoDB数据操作之前自动加的，不需要用户干预</p>
</li>
<li><p>意向锁是表级锁</p>
</li>
</ul>
<p>关于这两个锁的实际演示例子本文鉴于篇幅便不再赘述，感兴趣的可以根据上边描述的共享锁和排他锁演示过程自己体验一遍.</p>
<p>这两个意向锁存在的意义是：</p>
<blockquote>
<p>当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速的返回，告知该表不能启用表锁（也就是会锁住对应会话），提高了加锁的效率。??</p>
</blockquote>
<h3 id="自增锁-（AUTO-INC-Locks）"><a href="#自增锁-（AUTO-INC-Locks）" class="headerlink" title="自增锁 （AUTO -INC Locks）"></a>自增锁 （AUTO -INC Locks）</h3><p>针对自增列自增长的一个特殊的表级别锁</p>
<p>可以使用如下语句查看 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 默认取值1 代表连续 事务未提交则id永久丢失</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'innodb_autoinc_lock_mode'</span>;</span><br></pre></td></tr></table></figure>

<p>实际演示效果如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wiaHiab86pHEVsjczjHIlJCViandagPUgUOGwehXDXLJzy76EsCnFS8XEuXgJERjQlI27qjuPLT1M5OaqicWtTGgg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>执行结果如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wiaHiab86pHEVsjczjHIlJCViandagPUgUgzrNtMRebpj9SeONiczVcM9ic3ROsuT5liaibQQG4CibhhMHu91OVMEAzPQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h2 id="行锁的算法"><a href="#行锁的算法" class="headerlink" title="行锁的算法"></a>行锁的算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>行锁锁的是索引上的索引项</p>
<p>只有通过索引条件进行数据检索，Innodb才使用行级锁。否则，将使用表锁（锁住索引的所有记录）</p>
<p>行锁的算法:</p>
<ul>
<li><p><strong>临键锁 Next-Key locks</strong></p>
<p>当sql执行按照索引进行数据的检索时，查询条件为<strong>范围查找</strong>（between and &lt; &gt; 等等）并<strong>有数据命中</strong>，则测试SQL语句加上的锁为Next-Key locks,锁住索引的记录区间加下一个记录区间，这个区间是<strong>左开右闭</strong>的</p>
</li>
<li><p><strong>间隙锁 Gap</strong> </p>
<p>查询条件为<strong>范围查找</strong>（between and &lt; &gt; 等等）且<strong>当记录不存在时</strong>，临键锁退化成Gap. 在上述检索条件下，如果没有命中记录，则退化成Gap锁，锁住数据不存在的区间（<strong>左开右开</strong>）</p>
</li>
<li><p><strong>记录锁 Record Lock</strong> </p>
<p>唯一性索引 条件为<strong>精准匹配</strong>，退化成Record锁. 当SQL执行按照唯一性（Primary Key,Unique Key）索引进行数据的检索时，查询条件等值匹配且<strong>查询的数据存在</strong>，这时SQL语句上加的锁即为记录锁Record locks,锁住具体的索引项。</p>
</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a><strong>临键锁</strong></h4><p>Next-Key locks 也是 InnoDB 引擎默认的行锁算法.</p>
<p>如图：我们假设一张表中的数据行的id 是 1 4 7 10</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wiaHiab86pHEVsjczjHIlJCViandagPUgU5iboxJuvrEH5zuDEFQU6pfm2w5SVAZqyACxib7U4D7CcW8fBDkN9kiaBw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>则innodb会把这个表的数据划分成如图五个区间(因为有四个记录)，然后我们执行图中的SQL语句之后，会发现有两个区间被锁住了，一个是（4,7] ， 一个是 (7,10]</p>
<p>为了验证这个结论，我做了如下实验：</p>
<p>验证区间是否左开右闭：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wiaHiab86pHEVsjczjHIlJCViandagPUgUA4IMQVFgaOPZjLGicSNKIAc7ramcBU9fVdL9Q5OKG1zicGE9u3Ria50AA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>验证当前记录行是否被锁定：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wiaHiab86pHEVsjczjHIlJCViandagPUgUkVLbVbsqrEa8V7iaaPB3aI7P3dwvFHZMTFCnwia4AdTjjkHYu1V3zPwQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>验证是否锁定下一区间：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wiaHiab86pHEVsjczjHIlJCViandagPUgUj5Skvok8TyKtqfh7LKqF1yVhKh3yVicWicLJpibQK4ZUjicDDkgEZeP9TA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>以下两种锁只给出结论，演示过程省略，感兴趣可自行验证哈！都是同样的方法，就不赘述了</p>
<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wiaHiab86pHEVsjczjHIlJCViandagPUgUH3k4pG23rtXq1fq06QMn6ib9hicIq9FVDN7z1ibnFTtcmzwxqwuWr2F8A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wiaHiab86pHEVsjczjHIlJCViandagPUgUWxia5c5BRVpKaegdcbicXic8Wus5BSayicF42tNNuokFzy7MWf0IdthOiaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MySQL 的 Innodb引擎正是通过上述不同类型的锁，完成了事务隔离：</p>
<ul>
<li>加 X 锁 避免了数据的脏读</li>
<li>加 S 锁 避免了数据的不可重复读</li>
<li>加上 Next Key 避免了数据的幻读</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><blockquote>
<p>Innodb中行级锁作用于索引之上，如果没有索引，则只能够锁表。</p>
</blockquote>
<h3 id="一次封锁法"><a href="#一次封锁法" class="headerlink" title="一次封锁法"></a>一次封锁法</h3><blockquote>
<p>为了预防死锁，一般应用中推荐一次封锁法。也就是在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行完成之后，再进行解锁。</p>
</blockquote>
<p>一次封锁法能够预防死锁，但从该方法的定义中可以看到，每次操作都锁住全部数据，如果这样数据的执行只能是串行化的，性能不高。</p>
<h3 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h3><blockquote>
<p>数据库遵循的是两段锁协议，将事务分解成加锁和解锁两个阶段</p>
</blockquote>
<h3 id="加锁阶段"><a href="#加锁阶段" class="headerlink" title="加锁阶段"></a>加锁阶段</h3><blockquote>
<p>该阶段可以进行加锁操作，在对任何数据进行读操作之前要申请并获得S锁(Shared Lock，其它事务可以继续加S锁，但不能加Exclusive Lock，即排他锁)；而在进行写操作之前，需要申请X锁(Exclusive Lock，其它事务不能再获得任何锁)。加锁不成功则进入等待状态，而不能再加其它锁。</p>
</blockquote>
<p>从这个定义可以看出，加锁阶段定义了事务之间的协调规则，能够有效提高多个事务之间的执行性能，但同时也带来了死锁的风险，之后会举例介绍死锁的成因。</p>
<h3 id="解锁阶段"><a href="#解锁阶段" class="headerlink" title="解锁阶段"></a>解锁阶段</h3><blockquote>
<p>事务进入解锁阶段将释放其持有的锁，该阶段只能进行解锁操作，而不能再加其它锁。</p>
</blockquote>
<h3 id="Innodb中的各种锁"><a href="#Innodb中的各种锁" class="headerlink" title="Innodb中的各种锁"></a>Innodb中的各种锁</h3><h3 id="Shared-Lock-And-Exclusive-Locks"><a href="#Shared-Lock-And-Exclusive-Locks" class="headerlink" title="Shared Lock And Exclusive Locks"></a>Shared Lock And Exclusive Locks</h3><p>这是两个行级锁，包括 <strong>Shared Lock(S 共享锁)</strong> 和 <strong>Exclusive Lock(X 排他锁):</strong></p>
<ol>
<li><strong>共享锁</strong> 允许持有锁的事务去读取一行数据，可以有多个事务同时持有共享锁，但当数据被加上共享锁时，不能再被加排他锁。</li>
<li><strong>排他锁</strong> 允许持有锁的事务去更新或则删除一行数据，同时只能有一个事务持有排他锁，当数据被加上排他锁时，不能再加共享锁。</li>
</ol>
<h3 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h3><p>记录锁是作用在索引上，比如这么一条语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT c1 FROM t WHERE c1&#x3D;10 FOR UPDATE</span><br></pre></td></tr></table></figure>

<p>这条语句将会在<code>c1</code>值为10这条记录的索引加锁，阻止其它事务的插入，更新和删除操作。 即使<code>c1</code>不存在索引，Innodb也会创建一个隐藏的<code>clustered index</code>，并用其作为锁的依据。</p>
<h3 id="Next-key-Locks"><a href="#Next-key-Locks" class="headerlink" title="Next-key Locks"></a>Next-key Locks</h3><p>Next-key锁是记录锁和Gap锁的结合，锁住了记录和记录之前的一段Gap区间。 比如索引包含了10，11，13和20，那么Next-key分出的区间如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure>

<h3 id="Intention-Locks"><a href="#Intention-Locks" class="headerlink" title="Intention Locks"></a>Intention Locks</h3><p>Intention Locks(意向锁)是MySQL为了支持不同粒度的锁而设计的一种 <strong>表级别锁(但不是通常认为的表锁)</strong> ，它表示了表之后将被加上哪种行级锁。意向锁的分类如下：</p>
<ol>
<li><strong>Intention Shared Lock，意向共享锁(IS)</strong> ，表示事务将要在表上加共享锁，规则是在表中申请某些行的共享锁之前，必须先申请<code>IS</code>锁。</li>
<li><strong>Intention Exclusive Lock，意向排他锁(IX)</strong> ，表示事务将要在标上加排他锁，规则是在表中申请某些行的排他锁之前，必须先申请<code>IX</code>锁。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE</span><br></pre></td></tr></table></figure>

<p>该语句将会在表上加<code>IS</code>锁，同时在对应的记录上加上<code>S</code>锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FOR UPDATE</span><br></pre></td></tr></table></figure>

<p>该语句将会在标上加上<code>IX</code>锁，同时在对应的记录上加上<code>X</code>锁。</p>
<p><strong>表级锁的兼容性矩阵：</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/5/9/fc76a4b5cf0aeeac6fe08ba3035a183f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Matrix"></p>
<p>总结:<strong>意向锁(IX,IS)之间不会产生冲突, 其他情况可将IX锁当做X锁, IS锁当做S锁</strong></p>
<p>事实上意向锁不会和行级的<code>S</code>和<code>X</code>锁产生冲突，只会和表级的<code>S</code>和<code>X</code>锁产生冲突.</p>
<h3 id="GAP-Locks"><a href="#GAP-Locks" class="headerlink" title="GAP Locks"></a>GAP Locks</h3><p>Gap锁是一种范围锁，Gap锁作用范围是Record锁之间，或者Record锁之前与Record锁之后的范围。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/5/9/1b13166b10c5b1662a636d5f1614488c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Gap"></p>
<p>如图所示，首先当前该记录存在索引，id为5和30的记录将整个分为了 <code>&lt;=5</code> ，<code>&gt;5&amp;&lt;=30</code> 和 <code>&gt;30</code> 三个区间，如果要更新30的数据，那么 <code>&gt;5</code> 的所有区间都会被锁住。</p>
<h3 id="Insert-Intention-Locks"><a href="#Insert-Intention-Locks" class="headerlink" title="Insert Intention Locks"></a>Insert Intention Locks</h3><p>Insert Intention Locks也就是插入意向锁，但它其实是一种GAP锁，在行数据被插入之前，设定的一种锁，如果两个事务要插入同一个GAP中的不同行记录，它们都会获取这个GAP的插入意向锁，但相互之间不会冲突。</p>
<h3 id="AUTO-INC-Locks"><a href="#AUTO-INC-Locks" class="headerlink" title="AUTO-INC Locks"></a>AUTO-INC Locks</h3><p>AUTO-INC锁是一种特殊的表级别锁，主要处理表中带有自增列的情况。实际上是为了保证自增的正确性，所以有了这种锁。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI1Mzg4OTMxNQ==&mid=100000550&idx=1&sn=8a5cdff008fc1eed7b5c623c1bdf4ed1&chksm=69ccdd6a5ebb547c7b7baf6be78763fc5065e0a58de202f3e25d8d8ed56e6d1c1146332cfec1#rd" target="_blank" rel="noopener">【MySQL （四） | 五分钟搞清楚InnoDB锁机制】</a></p>
<p><a href="https://juejin.im/entry/59104bdea0bb9f0058a2a1db" target="_blank" rel="noopener">Innodb 锁类型详解</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/mysql%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/17/mysql%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">mysql索引实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-18 06:34:07 / 修改时间：14:45:41" itemprop="dateCreated datePublished" datetime="2020-06-18T06:34:07+08:00">2020-06-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树是一种多路自平衡搜索树，它类似普通的二叉树，但是B书允许每个节点有更多的子节点。B树示意图如下：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7361383-b4226ba0e306bd27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p>
<p>B树的特点：<br> （1）所有键值分布在整个树中<br> （2）任何关键字出现且只出现在一个节点中<br> （3）搜索有可能在非叶子节点结束<br> （4）在关键字全集内做一次查找，性能逼近二分查找算法</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是B树的变体，也是一种多路平衡查找树，B+树的示意图为：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7361383-3e9ef22b51d553c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p>
<p>从图中也可以看到，B+树与B树的不同在于：<br> （1）所有关键字存储在叶子节点，非叶子节点不存储真正的data<br> （2）为所有叶子节点增加了一个链指针</p>
<h2 id="为什么用B-B-树来实现索引"><a href="#为什么用B-B-树来实现索引" class="headerlink" title="为什么用B/B+树来实现索引"></a>为什么用B/B+树来实现索引</h2><p>红黑树等结构也可以用来实现索引，但是文件系统及数据库系统普遍使用B/B+树结构来实现索引。mysql是基于磁盘的数据库，索引是以索引文件的形式存在于磁盘中的，索引的查找过程就会涉及到磁盘IO消耗，磁盘IO的消耗相比较于内存IO的消耗要高好几个数量级，所以索引的组织结构要设计得在<strong>查找关键字时要尽量减少磁盘IO的次数</strong>。为什么要使用B/B+树，跟磁盘的存储原理有关。</p>
<h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a><strong>局部性原理与磁盘预读</strong></h3><p> 为了提升效率，要尽量减少磁盘IO的次数。实际过程中，磁盘<strong>并不是每次严格按需读取，而是每次都会预读</strong>。磁盘读取完需要的数据后，会按顺序再多读一部分数据到内存中，这样做的理论依据是计算机科学中注明的局部性原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当一个数据被用到时，其附近的数据也通常会马上被使用</span><br><span class="line">程序运行期间所需要的数据通常比较集中</span><br></pre></td></tr></table></figure>

<p>（1）由于磁盘顺序读取的效率很高(不需要寻道时间，只需很少的旋转时间)，<br> 因此对于具有局部性的程序来说，预读可以提高I/O效率.预读的长度一般为页(page)的整倍数。<br> （2）MySQL(默认使用InnoDB引擎),将记录按照页的方式进行管理,每页大小默认为16K(这个值可以修改)。linux 默认页大小为4K。</p>
<h3 id="B-Tree利用了磁盘预读的机制"><a href="#B-Tree利用了磁盘预读的机制" class="headerlink" title="B-Tree利用了磁盘预读的机制"></a>B-Tree利用了磁盘预读的机制</h3><p> 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个结点只需一次I/O。<br> 假设 B-Tree 的高度为 h,B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，<strong>出度d</strong>是非常大的数字，通常超过100，因此h非常小（通常不超过3，也即索引的B+树层次一般不超过三层，所以查找效率很高）。<br> 而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，<strong>无法利用局部性</strong>，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<h3 id="B-树的优势"><a href="#B-树的优势" class="headerlink" title="B+树的优势"></a>B+树的优势</h3><p>为什么InnoDB的索引使用B+树而不是B树:<br> （1）B+树更适合外部存储(一般指磁盘存储),由于<strong>内节点(非叶子节点)不存储data</strong>，所以一个节点可以存储更多的内节点，<strong>每个节点能索引的范围更大更精确</strong>。也就是说使用B+树单次磁盘IO的信息量相比较B树更大，IO效率更高。<br> （2）mysql是关系型数据库，经常会<strong>按照区间来访问某个索引列</strong>，B+树的<strong>叶子节点间按顺序建立了链表指针</strong>，加强了区间访问性，所以B+树对索引列上的区间范围查询很友好。而B树每个节点的key和data在一起，无法进行区间查找。</p>
<h2 id="附-B树严格定义"><a href="#附-B树严格定义" class="headerlink" title="附:B树严格定义"></a>附:B树严格定义</h2><p><img src="https:////upload-images.jianshu.io/upload_images/7361383-8129bb0b3bf44e62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/624/format/webp" alt="img"></p>
<p>3：所有叶子节点都出现在同一层，且叶子节点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)<br> 4：每个非叶子节点包含有n个关键字信息(n，P0，K1，P1，K2，P2，……，Kn，Pn)，其中：<br> a)   Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。<br> b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。<br> c)   关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。</p>
<p>比如，我们通过上面那张btree结构来查找29这个元素，查找过程为：<br> （1）根据根节点找到文件目录的跟磁盘块1，将其中的信息装入到内存中【磁盘IO操作第1次】<br> （2）此时内存中有两个文件名17,35和三个存储其他磁盘页面地址的数据（指针），根据算法我们发现17 &lt; 29 &lt;35，因此我们找到指针p2<br> （3）根据指针p2我们找到磁盘块3，并将其中信息装入到内存中【磁盘IO操作第2次】<br> （4）此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据（指针），根据算法我们发现26 &lt;29&lt;30，因为我们找到指针p2<br> （5）根据指针p2我们定位到磁盘块8，并将其中信息装入内存【磁盘IO操作第3次】<br> （6）此时内存中有两个文件名28，29。根据算法我们查找到文件29，并定位了该文件内存的磁盘地址。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://www.jianshu.com/p/0371c9569736" target="_blank" rel="noopener">以B tree和B+ tree的区别来分析mysql索引实现</a><br><a href="https://link.jianshu.com?t=https://segmentfault.com/a/1190000004690721" target="_blank" rel="noopener">由 B-/B+树看 MySQL索引结构</a><br><a href="https://link.jianshu.com?t=http://m.blog.csdn.net/endlu/article/details/51720299" target="_blank" rel="noopener">BTree和B+Tree详解</a><br><a href="https://link.jianshu.com?t=http://www.cnblogs.com/heiming/p/5865101.html" target="_blank" rel="noopener">MySQL B+树索引和哈希索引的区别</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/MyISAM%20%E5%92%8C%20InnoDB%20%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/17/MyISAM%20%E5%92%8C%20InnoDB%20%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">MyISAM 和 InnoDB 的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-18 06:07:54 / 修改时间：14:18:08" itemprop="dateCreated datePublished" datetime="2020-06-18T06:07:54+08:00">2020-06-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>778</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>区别</p>
<ol>
<li><p>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p>
</li>
<li><p>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  </p>
</li>
<li><p>InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 </p>
</li>
<li><p>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    </p>
</li>
<li><p>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p>
<p><img src="https://blog.haohtml.com/wp-content/uploads/2017/01/timg.jpg" alt="img"></p>
</li>
</ol>
<p><strong>如何选择：</strong></p>
<ol>
<li><p>是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；</p>
</li>
<li><p>如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。</p>
</li>
<li><p>系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；</p>
</li>
<li><p>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的。如果你不知道用什么存储引擎，那就用InnoDB，至少不会差。</p>
</li>
</ol>
<hr>
<p>本文整理自</p>
<p><a href="https://www.zhihu.com/question/20596402" target="_blank" rel="noopener">Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/16/%E4%BA%92%E6%96%A5%E9%94%81mutex%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/16/%E4%BA%92%E6%96%A5%E9%94%81mutex%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">互斥锁mutex的简单实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-16 12:55:36 / 修改时间：20:57:18" itemprop="dateCreated datePublished" datetime="2020-06-16T12:55:36+08:00">2020-06-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>mutex一般用于为一段代码加锁，以保证这段代码的原子性（atomic）操作，即：要么不执行这段代码，要么将这段代码<strong>全部</strong>执行完毕。</p>
<p>例如，最简单的并发冲突问题就是一个变量自增1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">balance &#x3D; balance + 1;</span><br></pre></td></tr></table></figure>

<p>表面看这是一条语句，可是在背后的汇编中我们可以看到，指令集操作过程中会引入中间变量来保存右边的值，进而这个操作至少会被扩充为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp = balance + <span class="number">1</span>;</span><br><span class="line">balance = tmp;</span><br></pre></td></tr></table></figure>

<p>这就需要一把互斥锁（mutual exclusive, mutex）将这段代码给锁住，使其达到任何一个线程“要么全部执行上述代码，要么不执行这段代码”的效果。这个用法可以表示为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock_t</span> mutex;</span><br><span class="line">...</span><br><span class="line">lock(&amp;mutex)</span><br><span class="line">    balance = balance + <span class="number">1</span>;</span><br><span class="line">unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>

<p>那么，一个自然的问题便是，我如何实现上面的这个<code>lock()</code>函数呢？</p>
<p>乍一看这个问题是非常复杂的，特别是考虑到它能够被适用于各种代码的各种情况。但经过各种简化，这个<code>lock()</code>实现，可以通过几个test和set的组合得以实现。</p>
<p>例如，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span> <span class="keyword">int</span> flag; &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0: lock is available</span></span><br><span class="line">    <span class="comment">// 1: lock is held</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (mutex-&gt;flag == <span class="number">1</span>) &#123;  <span class="comment">// Test the flag.</span></span><br><span class="line">        ;    <span class="comment">// Wait the lock</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">1</span>;  <span class="comment">// Set the lock, i.e. start to hold lock</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我第一次看到这个算法的时候非常惊讶，一个本来极其复杂的问题就这么优雅地被解决了。它仅仅涉及到对条件的检验和变量的复制，然后整个问题就这么轻而易举地被攻破了。</p>
<p>当然，我并没能看到上述代码的“坑”，也即是必须依靠指令集级别的支持才能真正做到atomic。这同样说明了并发程序的困难，稍微不注意便会调入一个万劫不复的坑里，并且你还不知道哪里出错了。</p>
<p>上述极端优雅的代码，有一个隐藏的坑，那便是在<code>lock()</code>函数的实现里，<code>while</code>循环那一段其实是可以被乱入的。</p>
<p>假设thread A是第一个运行到此的线程，那么它得到的<code>mutex-&gt;flag</code>就肯定是0，于是它继续跳出循环往下运行，希望通过下面的<code>mutex-&gt;flag = 1</code>来持有锁，使得其它线程在检测<code>while</code>循环时为真，进而进入循环的等待状态。</p>
<p>可如果在A执行到这个赋值为1的语句之前，又有另外一个thread B运行到了这个<code>while</code>循环部分，由于<code>mutex-&gt;flag</code>还未被赋值为1，B同样可以跳出<code>while</code>，从而跟A一样拿到这把锁！这就出现了冲突。</p>
<p>那怎么办呢？仔细后可以发现，其实关键问题就在于：</p>
<ul>
<li>对<code>mutex-&gt;flag</code>的检测</li>
<li>对<code>mutex-&gt;flag</code>的赋值</li>
</ul>
<p>这两个操作必须是不被干扰的，也就是它必须是atomic的，要么这两段代码不被执行，要么这两段代码被不中断地完整执行。</p>
<p>这就需要借助CPU指令集的帮助，来保证上述两条语句的atomic操作，也即是著名的<code>TestAndSet()</code>操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *ptr;</span><br><span class="line">    *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CPU的指令集，并不需要支持繁复的各种atomic操作。仅仅支持上面这个函数，各种互斥加锁的情形，便都能够被涵盖。</p>
<p>此时，在回到我们最开始的那个优雅的<code>lock()</code>实现，就可以将其改造为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span> <span class="keyword">int</span> flag; &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0: lock is available</span></span><br><span class="line">    <span class="comment">// 1: lock is held</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;<span class="keyword">lock_t</span>-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码极其精巧。乍一看在<code>lock()</code>实现里不是还缺少一行<code>mutex-&gt;flag = 1;</code>么？可其实呢，它已经被整合到了<code>TestAndSet()</code>函数中。</p>
<p>这样的支持<code>TestAndSet()</code>的实现，便是最简单的spin lock，弹簧锁。之所以叫弹簧锁，那是因为在各类锁当中，弹簧锁就是最初的被投入工业使用的最简单的实现技术。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://segmentfault.com/a/1190000017102063" target="_blank" rel="noopener">互斥锁mutex的简单实现</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/16/ORM%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/16/ORM%E6%98%AF%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">ORM是什么</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-16 12:35:26 / 修改时间：20:40:32" itemprop="dateCreated datePublished" datetime="2020-06-16T12:35:26+08:00">2020-06-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="JDBC介绍"><a href="#JDBC介绍" class="headerlink" title="JDBC介绍"></a>JDBC介绍</h3><p>​    jdbc是java数据库连接(java DataBase Connectivity)技术的简称，由一组使用java语言编写的类与接口组成，可以为多种关系数据库提供统一访问</p>
<ul>
<li><strong>实现步骤</strong></li>
</ul>
<ol>
<li><ol>
<li>使用JDBC编程需要连接数据库，注册驱动和数据库信息</li>
<li>操作Connection，打开 Statement 对象 。</li>
<li>通过Statement执行SQL， 返回结果到ResultSet对象。</li>
<li>使用ResultSet读取数据，然后通过代码转化为具体的POJO对象。</li>
<li>关闭数据库的相关资源。</li>
</ol>
</li>
</ol>
<ul>
<li><strong>优点</strong></li>
</ul>
<p>​    直接底层操作，提供了很简单、便捷的访问数据库的方法，跨平台性比较强。灵活性比较强。可以写很复杂的SQL语句。</p>
<ul>
<li><strong>缺点</strong></li>
</ul>
<p>​    工作量相对较大。我们需要先连接，然后处理JDBC底层事务，处理数据类型。我们还需要操作Connection对象、Statement对象和ResultSet对象去拿到数据，并准确的关闭它们。</p>
<p>我们要对JDBC编程可能产生的异常进行捕捉处理并正确关闭资源。</p>
<h3 id="ORM介绍"><a href="#ORM介绍" class="headerlink" title="ORM介绍"></a>ORM介绍</h3><p>​    由于JDBC存在的缺陷，所以我们在实际工作中很少使用JDBC进行操作数据库的编程。于是我们就提出了<strong>对象关系映射</strong>（Object Relational Mapping）简称 ORM，或者O/RM，或者 O/R mapping。</p>
<ul>
<li><strong>介绍</strong></li>
</ul>
<ol>
<li>ORM模型就是数据库的表和简单Java对象（Plain Ordinary Java Object，简称POJO）的映射关系模型。 </li>
<li>它主要解决数据库数据和POJO对象的相互映射。我们通过这层映射就可以简单的把数据库表的数据转化为POJO。以便程序员更加容易的理解和应用Java程序.而且程序员一般只需要了解Java应用而无需对数据库进行深入的了解。此外，ORM模型提供了统一的规则使得数据库的数据通过配置便可轻易的映射到POJO上。</li>
</ol>
<ul>
<li>常用的ORM框架</li>
</ul>
<ol>
<li><strong>Java系列</strong>：</li>
</ol>
<p>​      Hibernate全自动需要写hql语句</p>
<p>​      Mybatis半自动自己写sql语句,可操作性强,小巧（前身iBatis）</p>
<p>​      Apache OJB</p>
<p>​      TopLink     是位居第一的Java对象关系可持续性体系结构 （待研究）</p>
<p>​      Jaxor  ：是一个简单但功能强大的创建到关系映像层对象的工具。它允许开发者轻松地 在表中插入、更新、删除行，但也可被扩展为创建一个可扩展的映像层，这个层可创建一 个完全的域模型，透明地映射到数据库表</p>
<ol start="2">
<li><strong>.Net系列</strong>：EF6与EFCore、Dapper</li>
</ol>
<ul>
<li><strong>优点</strong></li>
</ul>
<p>目前我们接触（用）到比较多的是Hibernate和MyBatis。 </p>
<p><strong>MyBatis优点：</strong></p>
<ol>
<li>易于上手和掌握。</li>
<li>sql写在xml里，便于统一管理和优化。</li>
<li>解除sql与程序代码的耦合。</li>
<li>提供映射标签，支持对象与数据库的orm字段关系映射</li>
<li>提供对象关系映射标签，支持对象关系组建维护</li>
<li>提供xml标签，支持编写动态sql。</li>
</ol>
<p><strong>Hibernate优点：</strong></p>
<ol>
<li>消除了代码的映射规则，它全部被分离到XML或者注解里面去配置。</li>
<li>无需再管理数据库连接，它也配置到XML里面。</li>
<li>一个会话中，不要操作多个对象，只要操作Sesison即可。</li>
<li>关闭资源只需要关闭一个Session即可。</li>
</ol>
<ul>
<li><strong>缺点</strong></li>
</ul>
<p><strong>MyBatis缺点：</strong></p>
<ol>
<li>sql工作量很大，尤其是字段多、关联表多时，更是如此。</li>
<li>sql依赖于数据库，导致数据库移植性差。</li>
<li>由于xml里标签id必须唯一，导致DAO中方法不支持方法重载。</li>
<li>字段映射标签和对象关系映射标签仅仅是对映射关系的描述，具体实现仍然依赖于sql。（比如配置了一对多Collection标签，如果sql里没有join子表或查询子表的话，查询后返回的对象是不具备对象关系的，即Collection的对象为null）</li>
<li>DAO层过于简单，对象组装的工作量较大。</li>
<li>不支持级联更新、级联删除。</li>
<li>编写动态sql时,不方便调试，尤其逻辑复杂时。</li>
<li>提供的写动态sql的xml标签功能简单（连struts都比不上），编写动态sql仍然受限，且可读性低。</li>
<li>若不查询主键字段，容易造成查询出的对象有“覆盖”现象。</li>
<li>参数的数据类型支持不完善。（如参数为Date类型时，容易报没有get、set方法，需在参数上加@param）</li>
<li>多参数时，使用不方便，功能不够强大。（目前支持的方法有map、对象、注解@param以及默认采用012索引位的方式）</li>
<li>缓存使用不当，容易产生脏数据。</li>
</ol>
<p><strong>Hibernate缺点：</strong></p>
<ol>
<li>全表映射带来的不便，比如更新时需要发送所有的字段。</li>
<li>无法根据不同的条件组装不同的SQL。　</li>
<li>对多表关联和复杂的SQL查询支持较差。需要自己写SQL，返回后，需要自己将数据组装到POJO中。</li>
<li>不能有效支持存储过程。</li>
<li>虽然有HQL，但是性能较差，大型互联网往往需要优化SQL，而Hibernate做不到。</li>
</ol>
<ul>
<li><strong>框架选择</strong></li>
</ul>
<p>​    Hibernate作为Java ORM框架，它确实编程简易，需要我们提供映射的规则，完全可以通过IDE生成。同时无需编写SQL确实开发效率优于MyBatis。而且，它也提供了缓存、日志、级联、等强大的功能，但是Hibernate的缺陷也是十分的明显的。就是在多表关联复杂的SQL时，数据系统权限限制时，根据条件变化的SQL时。存储过程等使用场景。Hibernate十分不便。而性能又难以通过SQL来优化。所以Hibernate一般只适用于场景不太复杂的、性能要求不太苛刻的时候使用。</p>
<p>​    MyBatis 是一个灵活的、可以动态生成映射关系的框架，它几物可以替代JDBC。拥有动态列、动态表名，存储过程都支持。同时提供了简易的缓存（如(默认)一级缓存，还有二级缓存）、日志、级联。但是它的缺陷是需要你提供映射规则和SQL，所以它的开发工作量一般要比Hibernate略大一些。</p>
<p>​    总结。你需要根据你的项目的实际情况去选择框架。MyBatis具有高度灵活、可优化、易维护等特点,所以目前还是myBatis比较合适我们。</p>
<h3 id="JDBC-Mybatis性能比较（无事务）"><a href="#JDBC-Mybatis性能比较（无事务）" class="headerlink" title="JDBC,Mybatis性能比较（无事务）"></a>JDBC,Mybatis性能比较（无事务）</h3><ul>
<li><strong>测试向本机的数据库插入数据</strong></li>
</ul>
<p><strong>JDBC：批量操作</strong></p>
<table>
<thead>
<tr>
<th>记录条数</th>
<th>耗时</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>210</td>
</tr>
<tr>
<td>1000</td>
<td>551</td>
</tr>
<tr>
<td>10000</td>
<td>1963</td>
</tr>
</tbody></table>
<p><strong>MyBatis：</strong></p>
<ol>
<li>批量处理（SQL拼接）代码如下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">     Map&lt;String,Object&gt; param &#x3D; Maps.newHashMap();</span><br><span class="line">        param.put(&quot;recordList&quot;, recordList);</span><br><span class="line">        recordDao.insertList(param);复制代码</span><br><span class="line">&lt;insert id&#x3D;&quot;insertList&quot; parameterType&#x3D;&quot;java.util.Map&quot;&gt;</span><br><span class="line">        insert into test</span><br><span class="line">        (aa,bb,cc,dd,ee,ff,gg,hh,ii)</span><br><span class="line">        values</span><br><span class="line">        &lt;foreach collection&#x3D;&quot;recordList&quot; item&#x3D;&quot;recordList&quot; open&#x3D;&quot;&quot; close&#x3D;&quot;&quot;</span><br><span class="line">                 separator&#x3D;&quot;,&quot;&gt;</span><br><span class="line">            (</span><br><span class="line">            null,</span><br><span class="line">            #&#123;recordList.aa,jdbcType&#x3D;VARCHAR&#125;,</span><br><span class="line">            #&#123;recordList.bb,jdbcType&#x3D;VARCHAR&#125;,</span><br><span class="line">            #&#123;recordList.cc,jdbcType&#x3D;VARCHAR&#125;,</span><br><span class="line">            #&#123;recordList.dd,jdbcType&#x3D;VARCHAR&#125;,</span><br><span class="line">            #&#123;recordList.ee,jdbcType&#x3D;VARCHAR&#125;,</span><br><span class="line">            #&#123;recordList.ff,jdbcType&#x3D;VARCHAR&#125;,</span><br><span class="line">            #&#123;recordList.gg,jdbcType&#x3D;VARCHAR&#125;,</span><br><span class="line">            #&#123;recordList.hh,jdbcType&#x3D;VARCHAR&#125;,</span><br><span class="line">            #&#123;recordList.ii,jdbcType&#x3D;VARCHAR&#125;,</span><br><span class="line">            )</span><br><span class="line">        &lt;&#x2F;foreach&gt;</span><br><span class="line">        ;</span><br><span class="line">    &lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>记录条数</th>
<th>耗时</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>414</td>
</tr>
<tr>
<td>1000</td>
<td>1035</td>
</tr>
<tr>
<td>10000</td>
<td>4899</td>
</tr>
</tbody></table>
<ol start="2">
<li>for 循环插入，一条条的执行插入</li>
</ol>
<table>
<thead>
<tr>
<th>记录条数</th>
<th>耗时</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>9624</td>
</tr>
<tr>
<td>1000</td>
<td>102275</td>
</tr>
<tr>
<td>10000</td>
<td>1183339</td>
</tr>
</tbody></table>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5d5cf777e51d45621320311b" target="_blank" rel="noopener">传统JDBC与ORM框架之间的性能比较</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/16/HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%A6%E8%A7%A3%E4%B8%8E%E9%80%89%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/16/HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%A6%E8%A7%A3%E4%B8%8E%E9%80%89%E7%94%A8/" class="post-title-link" itemprop="url">HTTP 状态码详解与选用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-16 11:15:58" itemprop="dateCreated datePublished" datetime="2020-06-16T11:15:58+08:00">2020-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-18 14:50:42" itemprop="dateModified" datetime="2020-06-18T14:50:42+08:00">2020-06-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类"></a>HTTP状态码分类</h2><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">分类描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1**</td>
<td align="left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td align="left">2**</td>
<td align="left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td align="left">3**</td>
<td align="left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td align="left">4**</td>
<td align="left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td align="left">5**</td>
<td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<p>HTTP状态码列表:</p>
<table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">状态码英文名称</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/" target="_blank" rel="noopener">客户端</a>应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">OK</td>
<td align="left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">Created</td>
<td align="left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">Accepted</td>
<td align="left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">Non-Authoritative Information</td>
<td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">No Content</td>
<td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">Reset Content</td>
<td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">Partial Content</td>
<td align="left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">Multiple Choices</td>
<td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="left">301</td>
<td align="left">Moved Permanently</td>
<td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="left">302</td>
<td align="left">Found</td>
<td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">See Other</td>
<td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="left"><strong>304</strong></td>
<td align="left">Not Modified</td>
<td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">Use Proxy</td>
<td align="left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="left">306</td>
<td align="left">Unused</td>
<td align="left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">Temporary Redirect</td>
<td align="left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>400</strong></td>
<td align="left">Bad Request</td>
<td align="left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="left"><strong>401</strong></td>
<td align="left">Unauthorized</td>
<td align="left">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">Payment Required</td>
<td align="left">保留，将来使用</td>
</tr>
<tr>
<td align="left"><strong>403</strong></td>
<td align="left">Forbidden</td>
<td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="left">404</td>
<td align="left">Not Found</td>
<td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td align="left"><strong>405</strong></td>
<td align="left">Method Not Allowed</td>
<td align="left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">Not Acceptable</td>
<td align="left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">Proxy Authentication Required</td>
<td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">Request Time-out</td>
<td align="left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">Conflict</td>
<td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">Gone</td>
<td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">Length Required</td>
<td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">Precondition Failed</td>
<td align="left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">Request Entity Too Large</td>
<td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">Request-URI Too Large</td>
<td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">Unsupported Media Type</td>
<td align="left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">Requested range not satisfiable</td>
<td align="left">客户端请求的范围无效</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">Expectation Failed</td>
<td align="left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>500</strong></td>
<td align="left">Internal Server Error</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">Not Implemented</td>
<td align="left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="left"><strong>502</strong></td>
<td align="left">Bad Gateway</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">Service Unavailable</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="left"><strong>504</strong></td>
<td align="left">Gateway Time-out</td>
<td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP Version not supported</td>
<td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><p>众所周知，每一个HTTP响应都会带有一个状态码，不过对于很多开发者来说，平时使用最多的几个状态码无外乎就是200、400、404、500等。</p>
<p>那其他众多状态码该应用在何种场景中，什么时候应该使用哪些状态码就成为一个值得我们深入思考的问题了。即便在Facebook这样的公司中，那些聪明的开发者所构建的API也可能只返回200。对于目前的绝大部分服务端接口层设计都会遵循REST规范，而REST规范中推荐选用标准的HTTP 状态码作为返回值。</p>
<p>在笔者的<a href="https://segmentfault.com/a/1190000006037478" target="_blank" rel="noopener">来自微软的接口设计指南</a>与<a href="https://segmentfault.com/a/1190000005924733" target="_blank" rel="noopener">来自于PayPal的RESTful API标准</a>这两篇来自于PayPal与Microsoft的REST设计规范中都建议了部分合适的返回值，而在本文这部分主要是对于通用的HTTP状态码选择进行一些讨论。</p>
<p>目前HTTP状态码主要分为如下几类:</p>
<blockquote>
<ul>
<li>1xx:信息响应类，表示接收到请求并且继续处理</li>
<li>2xx:处理<strong>成功</strong>响应类，表示动作被成功接收、理解和接受</li>
<li>﻿3xx:<strong>重定向</strong>响应类，为了完成指定的动作，必须接受进一步处理</li>
<li>4xx:<strong>客户端错误</strong>，客户<strong>请求</strong>包含语法错误或者是不能正确执行</li>
<li>5xx:<strong>服务端错误</strong>，服务器不能正确执行一个正确的请求</li>
</ul>
</blockquote>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Mzws9oBx0P5nbA2LgPKh9Hwzh1YJwgOTBub8kPpLve11Ijbzfn5ibADoBsDKY8j6ic8nPlHOZD29rhiaSLEkjy7uQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h3 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a><strong>1xx</strong></h3><table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td>
</tr>
<tr>
<td>101</td>
<td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td>
</tr>
<tr>
<td>102</td>
<td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td>
</tr>
</tbody></table>
<h3 id="2XX-3XX"><a href="#2XX-3XX" class="headerlink" title="2XX/3XX"></a><strong>2XX/3XX</strong></h3><p><img src="http://mmbiz.qpic.cn/mmbiz/Mzws9oBx0P5nbA2LgPKh9Hwzh1YJwgOTwqP7Hsm3OB0NVshpj9TfaD06cWcPO4h1hhh1mKWAl2iaXLhMnvAkNHA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td>
</tr>
<tr>
<td>201</td>
<td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td>
</tr>
<tr>
<td>202</td>
<td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。　　返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td>
</tr>
<tr>
<td>203</td>
<td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td>
</tr>
<tr>
<td>204</td>
<td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。　　如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。　　由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td>
</tr>
<tr>
<td>205</td>
<td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。　　与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td>
</tr>
<tr>
<td>206</td>
<td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。　　该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。　　响应必须包含如下的头部域：　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。　　Date　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td>
</tr>
<tr>
<td>207</td>
<td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td>
</tr>
<tr>
<td>300</td>
<td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。　　除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。　　如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td>
</tr>
<tr>
<td>301</td>
<td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。　　新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。　　如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。　　注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td>
</tr>
<tr>
<td>302</td>
<td>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。　　新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。　　如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。　　注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td>
</tr>
<tr>
<td>303</td>
<td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。　　新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。　　注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td>
</tr>
<tr>
<td>304</td>
<td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。　　该响应必须包含以下的头信息：　　Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。　　ETag 和/或 Content-Location，假如同样的请求本应返回200响应。　　Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。　　假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。　　假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。　　假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td>
</tr>
<tr>
<td>305</td>
<td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。　　注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td>
</tr>
<tr>
<td>306</td>
<td>在最新版的规范中，306状态码已经不再被使用。</td>
</tr>
<tr>
<td>307</td>
<td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。　　新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。　　如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td>
</tr>
</tbody></table>
<h3 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a><strong>4XX</strong></h3><p><img src="http://mmbiz.qpic.cn/mmbiz/Mzws9oBx0P5nbA2LgPKh9Hwzh1YJwgOTUlknicLIdLkSiauw1gfdf1xlq1fB132TN4BUzEog9yRib4ib8gJ3Mx6rkA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。　　2、请求参数有误。</td>
</tr>
<tr>
<td>401</td>
<td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td>
</tr>
<tr>
<td>402</td>
<td>该状态码是为了将来可能的需求而预留的。</td>
</tr>
<tr>
<td>403</td>
<td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td>
</tr>
<tr>
<td>404</td>
<td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td>
</tr>
<tr>
<td>405</td>
<td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td>
</tr>
<tr>
<td>406</td>
<td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。　　除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td>
</tr>
<tr>
<td>407</td>
<td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td>
</tr>
<tr>
<td>408</td>
<td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td>
</tr>
<tr>
<td>409</td>
<td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。　　冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td>
</tr>
<tr>
<td>410</td>
<td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。　　410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td>
</tr>
<tr>
<td>411</td>
<td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td>
</tr>
<tr>
<td>412</td>
<td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td>
</tr>
<tr>
<td>413</td>
<td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td>
</tr>
<tr>
<td>414</td>
<td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：　　本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。　　重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。　　客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td>
</tr>
<tr>
<td>415</td>
<td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td>
</tr>
<tr>
<td>416</td>
<td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。　　假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td>
</tr>
<tr>
<td>417</td>
<td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td>
</tr>
<tr>
<td>421</td>
<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>
</tr>
<tr>
<td>422</td>
<td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>
</tr>
<tr>
<td>422</td>
<td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked　　当前资源被锁定。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>424</td>
<td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>425</td>
<td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td>
</tr>
<tr>
<td>426</td>
<td>客户端应当切换到TLS/1.0。（RFC 2817）</td>
</tr>
<tr>
<td>449</td>
<td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td>
</tr>
</tbody></table>
<h3 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a><strong>5XX</strong></h3><p><img src="http://mmbiz.qpic.cn/mmbiz/Mzws9oBx0P5nbA2LgPKh9Hwzh1YJwgOTlx1gPUDNVqFFUNOEJp8m6dzbAQPNia7uT8MI5iaq26EV2bQzYvbQO0yg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>500</strong></td>
<td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td>
</tr>
<tr>
<td>501</td>
<td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td>
</tr>
<tr>
<td><strong>502</strong></td>
<td><strong>Bad Gateway</strong> 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td>
</tr>
<tr>
<td><strong>503</strong></td>
<td><strong>Service Unavailable</strong> 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td>
</tr>
<tr>
<td><strong>504</strong></td>
<td><strong>Gateway Time-out</strong> 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。　　注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td>
</tr>
<tr>
<td>505</td>
<td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td>
</tr>
<tr>
<td>506</td>
<td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td>
</tr>
<tr>
<td>507</td>
<td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td>
</tr>
<tr>
<td>509</td>
<td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td>
</tr>
<tr>
<td>510</td>
<td>获取资源所需要的策略并没有没满足。（RFC 2774）</td>
</tr>
</tbody></table>
<hr>
<p>本文整理自</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MjkxMzMyNg==&mid=2654068952&idx=1&sn=1bd63a71610d73fcd563888d6f93398d&scene=24&srcid=0804843QrwLCsKWGYxfPum2H#wechat_redirect" target="_blank" rel="noopener">HTTP 状态码详解与选用</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/16/JAVA%E9%94%81%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/16/JAVA%E9%94%81%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">JAVA锁优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-16 09:26:16 / 修改时间：18:52:22" itemprop="dateCreated datePublished" datetime="2020-06-16T09:26:16+08:00">2020-06-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="锁优化思路"><a href="#锁优化思路" class="headerlink" title="锁优化思路"></a>锁优化思路</h1><p>最好的方式不加锁，如果必须加锁，可以从如下几个方面入手进行锁优化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 减少锁持有时间</span><br><span class="line">2. 减小锁粒度</span><br><span class="line">3. 读写锁替代独占锁</span><br><span class="line">4. 锁分离</span><br><span class="line">5. 锁粗化</span><br></pre></td></tr></table></figure>

<h2 id="减少锁的持有时间"><a href="#减少锁的持有时间" class="headerlink" title="减少锁的持有时间"></a>减少锁的持有时间</h2><p>减少锁的持有时间，即减少锁内代码执行时间，可以通过减少锁内代码量实现，例如避免给整个方法加锁、将不需要加锁的代码移出去，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    needLockCode(); </span><br><span class="line">    System.out.println(<span class="string">"after"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改为：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123; </span><br><span class="line">        needLockCode(); </span><br><span class="line">    &#125; </span><br><span class="line">    System.out.println(<span class="string">"after"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123; </span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        needLockCode(); </span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改为：</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123; </span><br><span class="line">        needLockCode(); </span><br><span class="line">    &#125; </span><br><span class="line">    System.out.println(<span class="string">"after"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="减小锁的粒度"><a href="#减小锁的粒度" class="headerlink" title="减小锁的粒度"></a>减小锁的粒度</h2><p>减小锁的粒度，这个偏向于减小被锁住代码涉及的影响范围的减小，降低锁竞争的几率，例如jdk5的ConcurrentHashMap，ConcurrentHashMap不会为整个hash表加锁，而是将Hash表划分为多个分段，对每个段加锁，这样减小了锁粒度，提升了并发处理效果。</p>
<p>再如假设有对象object，如果加锁后，不允许对object操作，此时锁粒度相当于object对象，如果实际上object只有一个名为<code>needLock</code>字段可能会出现并发问题，此时将锁加在这个字段上即可。</p>
<h2 id="读写锁替代独占锁"><a href="#读写锁替代独占锁" class="headerlink" title="读写锁替代独占锁"></a>读写锁替代独占锁</h2><p>ReentrantLock和synchronized使用的是独占锁，无论是读或写都保证同时只有一个线程执行被锁代码。但是单纯的读实际上不会引起并发问题。尤其是对于读多写少的场景，可以将读和写的锁分离开来，可以有效提升系统的并发能力。</p>
<p>读写锁在同一时刻可以允许多个线程访问，但是在写线程访问时，所有的读线程和其他写线程都会被阻塞。读写锁维护了一对锁：读锁和写锁。一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。</p>
<p>当执行读操作的时候，需要获取读锁，在并发访问的时候，读锁不会被阻塞；在执行写操作时线程必须要获取写锁，当已经有线程持有写锁的情况下，所有的线程都会被阻塞。读锁和写锁关系：</p>
<ul>
<li>读锁与读锁可以共享</li>
<li>读锁与写锁互斥</li>
<li>写锁与写锁互斥</li>
</ul>
<p>ReentrantReadWriteLock是提供了读锁和写锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/** Inner class providing readlock */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inner class providing writelock */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h2><p>在读写锁的思想上做进一步的延伸，如果对两个上下文互相不依赖、互相不影响的操作使用了同一把锁，这时候可以把锁进行拆分，根据不同的功能拆分不同的锁, 进行有效的锁分离。</p>
<p>一个典型的示例便是<code>LinkedBlockingQueue</code>，在它内部，take()和put()分别实现了从队列中取得数据和往队列中增加数据的功能，虽然两个方法都对当前队列进行了修改操作，但由于当前队列为链表实现，两个操作分别作用于队列的前端和尾端，从理论上说，两者并不冲突。</p>
<p>如果使用独占锁，那么同一时间两个操作不能同时进行，会因为等待锁资源而阻塞。但是两个操作实际上是不冲突的，这时候可以使take()和put()各自使用一把锁，提高并发效率。LinkedBlockingQueue中为两个操作分别准备了takeLock和putLock：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>     <span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"> <span class="number">2</span>     <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span>     <span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"> <span class="number">5</span>     <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span>     <span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"> <span class="number">8</span>     <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> <span class="number">9</span> </span><br><span class="line"><span class="number">10</span>     <span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="number">11</span>     <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>

<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>必要的时候，将被锁住的代码量变多、锁持有时间更长也是锁优化的方式，但优化结果一定要使整体的执行效率变的更好，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        needLockCode();             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改为：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        needLockCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改造后，尽管每个线程每次持有锁的时间变长了，但减少了每个线程请求和释放锁的次数，而请求和释放锁也是要消耗资源的。</p>
<h1 id="虚拟机的锁优化"><a href="#虚拟机的锁优化" class="headerlink" title="虚拟机的锁优化"></a>虚拟机的锁优化</h1><h2 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h2><p>由于挂起线程和恢复线程都需要转入内核态完成，给系统带来很大压力，同时，共享数据的锁定状态只会持续很短的一段时间，因此去挂起和恢复线程很不值得。因此，可以使线程执行一个自我循环，因为对于执行时间短的代码这一会可能就会释放锁，而线程就不需要进行一次阻塞与唤醒。</p>
<p>自旋等待不能代替阻塞，自旋本身虽然避免了线程切换的开销，但是会占用处理器时间，如果锁被占用时间短，自旋等待效果好；反之，自旋的线程只会白白浪费处理器资源；因此，要限制自旋等待时间，自旋次数默认值是10次，超过次数仍然没有成功获取锁，就挂起线程，进入同步阻塞状态。</p>
<p>自适应自旋更智能一些，它根据前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定自旋次数，如果对于某个锁的自旋很少有成功获得过锁，就不自旋了，避免浪费CPU资源。如果自旋等待刚刚成功获得过锁，并且持有锁的线程在运行，则认为此次自旋很有可能成功，就允许自旋更多的次数。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指虚拟机<strong>即时编译器</strong>在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的目的主要是判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把他们当作栈数据对待，认为它们是线程私有的，同步加锁自然就无需进行。</p>
<p>有时候锁是开发者无意中涉及到的，例如对于下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String getStr(String s1, String s2) &#123;</span><br><span class="line">    return s1 + s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只进行了字符串的拼接，但其中的<code>s1 + s2</code>可能被虚拟机优化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(s1);</span><br><span class="line">sb.append(s2);</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br></pre></td></tr></table></figure>

<p>而append()涉及了synchronized:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>append()中的锁就是sb对象，如果该对象在方法中new的话，sb对象就不会逃逸到方法以外，jvm认为此时不必要加锁，此处的锁就被安全的消除了。</p>
<h2 id="锁粗化-1"><a href="#锁粗化-1" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p>
<p>但如果一系列操作频繁对同一个对象加锁解锁，或者加锁操作再循环体内，会耗费性能，这时虚拟机会扩大加锁范围来减少获取锁、释放锁的操作。具体可以看上文示例。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>轻量级锁是JDK6之中加入的新型锁机制，它名字中的“轻量级”是<strong>相对于使用操作系统互斥量来实现的传统锁而言的</strong>，因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是<strong>在没有多线程竞争的前提下减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>。</p>
<p>在代码进入同步块的时候，如果同步对象没有被锁定，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录( Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word的锁标志位(Mark Word的最后2bit)将转变为“00”，即表示此又对象处于轻量级锁定状态。</p>
<p>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了，如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，自旋失败后要膨胀为重量级锁，Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态。</p>
<p>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争”，这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</p>
<p>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如Locking、Unlocking及对Mark Word的Update等）。当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。</p>
<p>也就是说，偏向锁会偏向第一个获得它的线程，只有当其它线程尝试竞争偏向锁时，偏向模式才会失效。偏向锁是为了避免某个线程反复执行获取、释放同一把锁时的性能消耗，即如果仍是同个线程去获得这个锁，偏向锁模式会直接进入同步块，不需要再次获得锁。</p>
<h1 id="锁的作用效果"><a href="#锁的作用效果" class="headerlink" title="锁的作用效果"></a>锁的作用效果</h1><p>偏向锁是为了避免某个线程反复执行获取、释放同一把锁时的性能消耗，而轻量级锁和自旋锁是为了避免重量级锁，因为重量级锁属于操作系统层面的互斥操作，挂起和唤醒线程涉及到上下文切换,是非常消耗资源的操作。</p>
<h1 id="锁获取过程"><a href="#锁获取过程" class="headerlink" title="锁获取过程"></a>锁获取过程</h1><p>最终，锁的获取过程会是，首先会尝试轻量级锁，轻量级锁会使用CAS操作来获得锁，如果轻量级锁获得失败，说明存在多线程对锁资源的竞争。此时会会尝试自旋锁，如果自旋失败，最终只能膨胀为重量级锁。</p>
<p>除重量级锁外，以上锁均为乐观锁。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://yq.aliyun.com/articles/715740" target="_blank" rel="noopener">JAVA锁优化</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/16/Java%20%E4%B8%AD%E7%9A%84%20hashCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/16/Java%20%E4%B8%AD%E7%9A%84%20hashCode/" class="post-title-link" itemprop="url">Java 中的 hashCode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-16 08:42:06 / 修改时间：17:15:57" itemprop="dateCreated datePublished" datetime="2020-06-16T08:42:06+08:00">2020-06-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="hashCode简介"><a href="#hashCode简介" class="headerlink" title="hashCode简介"></a>hashCode简介</h2><p><code>hashCode</code>是 jdk 根据对象的值和状态算出来的一个 <strong>int</strong> 型数字，即对象的哈希码值，代表了该对象在内存中的存储位置。</p>
<p>顶级父类 <code>Object</code> 提供获取 hashcode 的方法，调用的是本地的方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native int hashCode();</span><br></pre></td></tr></table></figure>

<p>Java 中的 hash 值主要用来干什么的？</p>
<p>hash 值主要是用来在散列存储结构（HashMap、HashTable、HashSet 等等）中确定对象的存储地址的，提高对象的查询效率，</p>
<h2 id="常见类的hashcode"><a href="#常见类的hashcode" class="headerlink" title="常见类的hashcode"></a>常见类的hashcode</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>阅读 <code>String</code> 源码来分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash;<span class="comment">// 主要是 String 对象是不可变的，可以使用一个变量存储起来，方便以后使用。</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> val[] = value;</span><br><span class="line"><span class="comment">// 计算每个字符的 ascii 参与到 hashcode 计算中，将前面计算的结果乘以 31 。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>为什么要以 <em>31</em> 为权来计算 hashCode？</p>
<ol>
<li><p>因为 31 是素数，素数跟其他数相乘，更容易产生唯一性，所以 hash 冲突会小；</p>
</li>
<li><p>相乘的时候，数字越大，结果也越大，很容易超出 int 值上限，31是一个大小适中的素数.</p>
</li>
<li><p>为什么不是 17 ,23等等，参考StackOverflow上最高票的答案<a href="https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier" target="_blank" rel="noopener">参考答案</a></p>
<blockquote>
<p>The value 31 was chosen because it is an odd prime. If it were even and the multiplication overflowed, information would be lost, as multiplication by 2 is equivalent to shifting. The advantage of using a prime is less clear, but it is traditional. A nice property of 31 is that the multiplication can be replaced by a shift and a subtraction for better performance: <code>31 * i == (i &lt;&lt; 5) - i</code>. Modern VMs do this sort of optimization automatically.</p>
</blockquote>
<p>解释说，因为乘31可以方便地优化为<strong>移位和减法</strong>，实际计算的是<code>(i &lt;&lt; 5) - i</code>。</p>
</li>
</ol>
<h3 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h3><p>查看 <code>Long.java</code> 的 <code>hashCode()</code> 方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static int hashCode(long value) &#123;</span><br><span class="line">    return (int)(value ^ (value &gt;&gt;&gt; 32));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 Long 类型有 64 位，比 hash 的长度多了一倍，利用前 32 位 和后 32 位异或，尽可能的让更多的位置参与计算 hash 来保证唯一性。</p>
<h2 id="重写-hashcode-和-equals"><a href="#重写-hashcode-和-equals" class="headerlink" title="重写 hashcode 和 equals"></a>重写 hashcode 和 equals</h2><h3 id="为什么要同时重写"><a href="#为什么要同时重写" class="headerlink" title="为什么要同时重写"></a>为什么要同时重写</h3><p>首先了解默认情况下的 hashcode 和 equals 方法是什么样：</p>
<ul>
<li>hashcode 根据内存地址换算出来一个值(jdk5以前)；</li>
<li>equals 判断对象的内存地址是否一样；</li>
</ul>
<p>但是大多数情况下，我们是需要判断它们的值是否是相等的情况。</p>
<p><code>Object.hashCode</code>的通用约定（<em>摘自《Effective Java》第45页</em>）</p>
<blockquote>
<ol>
<li>在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，那么，对该对象调用hashCode方法多次，它必须始终如一地返回 同一个整数。在同一个应用程序的多次执行过程中，这个整数可以不同，即这个应用程序这次执行返回的整数与下一次执行返回的整数可以不一致。</li>
<li>如果两个对象根据equals(Object)方法是相等的，那么调用这两个对象中任一个对象的hashCode方法必须产生同样的整数结果。</li>
<li>如果两个对象根据equals(Object)方法是不相等的，那么调用这两个对象中任一个对象的hashCode方法，不要求必须产生不同的整数结果。然而，程序员应该意识到这样的事实，对于不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。</li>
</ol>
</blockquote>
<p><strong>如果只重写了equals方法而没有重写hashCode方法的话，则可能会违反第二条：相等的对象必须具有相等的散列码（hashCode）</strong>。</p>
<p>比如我们用一个可变的对象作为 hashMap 的键，并且重写了 hashcode 和 equals 方法，当我把一对键值（可变对象为键）装进 hashMap 后，又去改变了键对象的某个属性（这个属性参与了 hashcode 的计算），然后就不能再用这个可变对象去操作已经插入到 hashMap 中的键值对了。</p>
<h3 id="自定义hashCode"><a href="#自定义hashCode" class="headerlink" title="自定义hashCode"></a>自定义hashCode</h3><p>参考 <code>IDEA</code> 根据字段自动生成的 hashCode 和 equals 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value1;</span><br><span class="line">    <span class="keyword">private</span> String value2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        ObjectDemo that = (ObjectDemo) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value1 != <span class="keyword">null</span> ? !value1.equals(that.value1) : that.value1 != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">return</span> value2 != <span class="keyword">null</span> ? value2.equals(that.value2) : that.value2 == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = value1 != <span class="keyword">null</span> ? value1.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + (value2 != <span class="keyword">null</span> ? value2.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><hr>
<p>本文整理自</p>
<ul>
<li><a href="https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier" target="_blank" rel="noopener">Why does Java’s hashCode() in String use 31 as a multiplier?</a></li>
<li><a href="https://blog.csdn.net/zknxx/article/details/53862572" target="_blank" rel="noopener">java为什么要重写hashCode和equals方法</a></li>
</ul>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EricMa"
      src="/images/eric.png">
  <p class="site-author-name" itemprop="name">EricMa</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">229</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Eric-Ma-C" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Eric-Ma-C" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chaoma@zju.edu.cn" title="E-Mail → mailto:chaoma@zju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EricMa</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">864k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
