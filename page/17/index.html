<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Eric&#39;s Blogs">
<meta property="og:url" content="http://yoursite.com/page/17/index.html">
<meta property="og:site_name" content="Eric&#39;s Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="EricMa">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/17/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Eric's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Eric's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Better Code, Better Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/Python%20Web%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/19/Python%20Web%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Python Web开发入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-20 05:55:48 / 修改时间：13:57:36" itemprop="dateCreated datePublished" datetime="2020-05-20T05:55:48+08:00">2020-05-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文内容为慕课网Python全栈案例入门课程笔记,<a href="https://www.imooc.com/learn/864" target="_blank" rel="noopener">点击跳转课程页面</a></p>
<h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><h4 id="Python-web框架"><a href="#Python-web框架" class="headerlink" title="Python web框架"></a>Python web框架</h4><ul>
<li>flask    简单轻量,灵活性大,创建于2010</li>
<li>django 简单,比flask重,灵活性不如flask,创建于2006</li>
<li>web.py 简单轻量,不再维护,创建于2008</li>
</ul>
<h1 id="web应用开发流程"><a href="#web应用开发流程" class="headerlink" title="web应用开发流程"></a>web应用开发流程</h1><ol>
<li>产品分析: 用户需求,市场调研</li>
<li>技术选型: 前端,后端,数据库,业务框架(大数据,直播)</li>
<li>开发实现: 前后端开发,测试</li>
<li>生产上线: 部署,升级,峰值处理,成本优化,警报处理<h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><h4 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h4></li>
</ol>
<ul>
<li>字符串:<code>str,unicode</code><br>python3.x只有str</li>
<li>列表:<code>list 可变列表, tuple 不可变列表, set 唯一列表</code><br>tuple内的元素是不变的</li>
<li>字典:<code>dict</code><br>key —&gt; value映射,数据量大可用redis数据库</li>
</ul>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>generator</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一次性产生10个元素的数组,占内存</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">print</span> i</span><br><span class="line">	</span><br><span class="line"><span class="comment">#xrange() 函数用法与 range 完全相同，所不同的是生成的不是一个数组，而是一个生成器,依次产生1,2,3...节省内存</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>) <span class="comment">#</span></span><br><span class="line">	<span class="keyword">print</span> i</span><br></pre></td></tr></table></figure>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。<br>迭代器有两个基本的方法：<code>iter()</code>和 <code>next()</code>。<br>字符串<code>str</code>，列表<code>list</code>或元组<code>tuple</code>对象都可用于创建迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (next(it))   <span class="comment"># 输出迭代器的下一个元素</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (next(it))</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment"># 可以使用常规for语句进行遍历：</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="keyword">print</span> (x, end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure>

<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = range(<span class="number">10</span>)</span><br><span class="line">&gt;&gt;&gt;&gt; list</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list[<span class="number">5</span> : <span class="number">7</span>]    <span class="comment"># 切片,第5-6个位置</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list[<span class="number">-2</span> : ]    <span class="comment"># 倒数第二个位置到最后</span></span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul>
<li>def 自定义函数</li>
<li>lambda 匿名函数<figure class="highlight plain"><figcaption><span>[arg1 [,arg2,.....argn]]:expression```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;python</span><br><span class="line"> &gt;&gt;&gt; sum &#x3D; lambda arg1, arg2: arg1 + arg2</span><br><span class="line"> &gt;&gt;&gt; print (&quot;相加后的值为 : &quot;, sum( 10, 20 ))</span><br><span class="line">	相加后的值为 :  30</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>functools.partial 函数封装</li>
<li>functools.wraps 装饰器</li>
</ul>
<p>python中函数像变量一样,可作为参数传入另一个函数:<br><img src="https://img-blog.csdnimg.cn/20191210100759984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="列表-字典推导式"><a href="#列表-字典推导式" class="headerlink" title="列表 / 字典推导式"></a>列表 / 字典推导式</h4><ul>
<li><strong>列表推导式</strong>可以方便地由<code>a_list</code>生成新的列表<code>b_list</code></li>
<li><strong>字典推导式</strong>可以方便地由列表<code>a_list</code>和<code>string.letters</code>生成新的字典<code>b_dict</code><br><img src="https://img-blog.csdnimg.cn/20191210100255508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h4 id="列表-字典解析式"><a href="#列表-字典解析式" class="headerlink" title="列表 / 字典解析式"></a>列表 / 字典解析式</h4></li>
<li>使用<code>enumerate</code>可以在遍历时方便地获取<strong>列表</strong>下标<code>index</code></li>
<li>使用<code>iteritems()</code>迭代器可以方便地遍历<strong>字典</strong><code>(key,value)</code>,快速又省内存<br><img src="https://img-blog.csdnimg.cn/20191210100351382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h1 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h1><h3 id="最简单的web-app"><a href="#最简单的web-app" class="headerlink" title="最简单的web app"></a>最简单的web app</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__) <span class="comment">### 生成一个web app对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')  ### 注册一个url,当请求url+'/'这个网址时,执行hello_world函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, World!'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	app.run()     <span class="comment">### run(host=None, port=None, debug=None, **options)</span></span><br><span class="line">				  <span class="comment">### 默认host: 127.0.0.1</span></span><br><span class="line">				  <span class="comment">### 默认port: 5000</span></span><br></pre></td></tr></table></figure>
<h3 id="调试flask应用"><a href="#调试flask应用" class="headerlink" title="调试flask应用"></a>调试flask应用</h3></li>
<li>设置app.run(debug=True)</li>
<li>Python打印log,前端页面打印log(开发者模式)</li>
<li>本地开发可以使用断点调试<h3 id="图书馆管理系统"><a href="#图书馆管理系统" class="headerlink" title="图书馆管理系统"></a>图书馆管理系统</h3><img src="https://img-blog.csdnimg.cn/20191209194815498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191209195033835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h4 id="项目文件"><a href="#项目文件" class="headerlink" title="项目文件"></a>项目文件</h4></li>
</ul>
<p><strong>接口与逻辑分开设计</strong></p>
<ul>
<li>views.py: url接口逻辑<br><img src="https://img-blog.csdnimg.cn/20191209195357219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>logic.py: 逻辑处理<br><img src="https://img-blog.csdnimg.cn/20191209200108740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>run.py: 应用发布<br><img src="https://img-blog.csdnimg.cn/20191209200429598.png" alt="在这里插入图片描述"></li>
</ul>
<h1 id="实践-DashBoard可视化"><a href="#实践-DashBoard可视化" class="headerlink" title="实践:DashBoard可视化"></a>实践:DashBoard可视化</h1><p><a href="https://github.com/litaotao/IPython-Dashboard" target="_blank" rel="noopener">点击获取项目源码</a></p>
<h2 id="应用设计"><a href="#应用设计" class="headerlink" title="应用设计"></a>应用设计</h2><p><img src="https://img-blog.csdnimg.cn/20191209220402880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191209220500455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>项目文件结构:<br><img src="https://img-blog.csdnimg.cn/20191209222556417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="python应用发布工具"><a href="#python应用发布工具" class="headerlink" title="python应用发布工具"></a>python应用发布工具</h2><p>CI / CD  持续集成,持续部署</p>
<ol>
<li>setup.py打包至pip公共仓库, 通过pip安装 / 卸载</li>
<li>github hooks,  travis 轻量,适合中小型项目</li>
<li>jenkins 较重,适合中大型项目</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/Web%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/19/Web%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Web前端入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-20 05:52:00 / 修改时间：13:58:27" itemprop="dateCreated datePublished" datetime="2020-05-20T05:52:00+08:00">2020-05-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>前端开发三把瑞士军刀:</p>
<ul>
<li><strong>HTML 超文本标记语言</strong> <code>HyperText Markup Language</code><br>一种标记语言,用标记标签描述网页(静态网页)</li>
<li><strong>CSS 层叠样式表</strong> <code>Cascading Style Sheets</code><br>样式定义如何显示HTML元素,大小,形状等<br>样式表可内置于HTML文件中,但专业的做法是独立存放</li>
<li><strong>JS JavaScript</strong><br>一种轻量级的高级编程语言<br>服务于网页交互,生成动态网页<br>同CSS一样,JS可嵌入在HTML文件中,但专业的做法是单独存放</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20191209164927586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>补充</p>
<ul>
<li><strong>jQuery</strong><br>jQuery是一个轻量级的”写的少，做的多”的<strong>JavaScript库</strong>。是目前最流行的 JS 框架，而且提供了大量的扩展。jQuery <strong>极大地简化了 JavaScript 编程</strong>.</li>
<li><strong>bootstrap</strong><br>Bootstrap来自 Twitter,是基于HTML5和CSS3开发的<strong>CSS框架</strong>，它在jQuery的基础上进行了更为个性化的完善，形成一套自己独有的网站风格，并兼容大部分jQuery插件,可以<strong>方便地使用预定义的各种CSS元素和样式</strong>。</li>
</ul>
<br>

<ul>
<li><p><strong>JSP java服务器页面</strong> <code>Java Server Pages</code><br>JSP是为了简化Servlet的工作出现的替代品，Servlet输出HTML非常困难(需要一行一行print)，JSP就是替代Servlet输出HTML的。jsp更注重前端显示，servlet更注重模型和业务逻辑.简单地说,jsp就是在html里面写java代码，servlet就是在java里面写html代码,其实jsp经过容器解释之后就是servlet.<br>MVC模式在Web开发中的好处是非常明显，它规避了JSP与Servlet各自的短板，Servlet只负责业务逻辑而不会通过out.append()动态生成HTML代码；JSP中也不会充斥着大量的业务代码。这大大提高了代码的可读性和可维护性。</p>
</li>
<li><p><strong>Ajax  Asynchronous JavaScript + XML</strong><br>异步JavaScript和XML,Ajax是一种技术方案，但并不是一种新技术。它依赖现有的CSS/HTML/JavaScript，而其中最核心的依赖是浏览器提供的<strong>XMLHttpRequest对象</strong>，是这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。实现了<strong>在页面不刷新个情况下和服务器进行数据交互</strong>。</p>
</li>
<li><p><strong>Grunt</strong><br>是一个前端自动化工具,提高工作效率.Grunt可以帮助你处理需要重复执行的压缩，编译，单元测试，代码检查以及打包发布等任务.</p>
</li>
<li><p><strong>Node.js</strong><br>是一种通过JavaScript语言开发web服务端应用的框架,简单地说就是运行在服务端的 JavaScript。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。<br>如果你是一个前端程序员，你不懂得像PHP、Python或Ruby等动态编程语言，然后你想创建自己的服务，那么Node.js是一个非常好的选择。当然，如果你是后端程序员，想部署一些高性能的服务，那么学习Node.js也是一个非常好的选择。</p>
</li>
</ul>
<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>显示当前时间,刷新页面更新时间<br><img src="https://img-blog.csdnimg.cn/20191209201144526.png" alt="在这里插入图片描述"><br>对应的.html文件<br><img src="https://img-blog.csdnimg.cn/2019120920150448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&lt;head&gt;定义了当前网页在浏览器标签栏的标题,编码格式,当前页面css,js资源下载链接<br>&lt;body&gt;定义了网页中显示的元素<br>&lt;script&gt;js脚本,定义动态内容,这里每刷新一次更新一次显示时间</p>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>chrome –&gt; F12 –&gt; Console<br>输入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = document.getElementById(<span class="string">"time"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.textContent = <span class="string">" hello world "</span></span><br><span class="line"> <span class="string">" hello world "</span></span><br></pre></td></tr></table></figure>
<p>网页内容会跟着改变</p>
<h4 id="复杂一点的例子"><a href="#复杂一点的例子" class="headerlink" title="复杂一点的例子"></a>复杂一点的例子</h4><p>点击开始显示当前实时时间,点击停止时间暂停更新<br>颜色,布局:居中显示,设置字体颜色<br><img src="https://img-blog.csdnimg.cn/20191209212141134.png" alt="在这里插入图片描述"></p>
<ul>
<li>.html文件<br>&lt;head&gt;下新定义了.css和.js文件位置<br>&lt;button&gt;新定义了点击事件<br><img src="https://img-blog.csdnimg.cn/20191209213114526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyaWM0Nzg0NTEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>.css文件<br>id选择器:#id { 属性 }<br><img src="https://img-blog.csdnimg.cn/20191209213510444.png" alt="在这里插入图片描述"></li>
<li>.js文件<br>业务逻辑<br><img src="https://img-blog.csdnimg.cn/20191209213633443.png" alt="在这里插入图片描述"></li>
</ul>
<h1 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h1><p>职责分离,架构分离<br>前后端分开开发,各自持续集成,分离上线<br>前后端协作依靠配置文件<br>注意区别<strong>全栈工程师</strong>和<strong>前后端分离前的web工程师</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/LeetCode655/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/19/LeetCode655/" class="post-title-link" itemprop="url">LeetCode655</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-20 02:14:02 / 修改时间：10:18:27" itemprop="dateCreated datePublished" datetime="2020-05-20T02:14:02+08:00">2020-05-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：</p>
<ol>
<li><p>行数 m 应当等于给定二叉树的高度。</p>
</li>
<li><p>列数 n 应当总是奇数。</p>
</li>
<li><p>根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。</p>
</li>
<li><p>每个未使用的空间应包含一个空的字符串””。</p>
</li>
<li><p>使用相同的规则输出子树。</p>
</li>
</ol>
<p>   示例 1:</p>
<p>输入:<br>     1<br>    /<br>   2<br>输出:<br>[[“”, “1”, “”],<br> [“2”, “”, “”]]<br>示例 2:</p>
<p>输入:<br>     1<br>    / <br>   2   3<br>    <br>     4```<br>输出:<br>[[“”, “”, “”, “1”, “”, “”, “”],<br> [“”, “2”, “”, “”, “”, “3”, “”],<br> [“”, “”, “4”, “”, “”, “”, “”]]<br>示例 3:</p>
<p>输入:<br>      1<br>     / <br>    2   5<br>   /<br>  3<br> /<br>4<br>输出:<br>[[“”,  “”,  “”, “”,  “”, “”, “”, “1”, “”,  “”,  “”,  “”,  “”, “”, “”]<br> [“”,  “”,  “”, “2”, “”, “”, “”, “”,  “”,  “”,  “”,  “5”, “”, “”, “”]<br> [“”,  “3”, “”, “”,  “”, “”, “”, “”,  “”,  “”,  “”,  “”,  “”, “”, “”]<br> [“4”, “”,  “”, “”,  “”, “”, “”, “”,  “”,  “”,  “”,  “”,  “”, “”, “”]]<br>注意: 二叉树的高度在范围 [1, 10] 中。</p>
<p>先递归求出树的高度,生成矩阵框架,再递归填充节点值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; printTree(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> height = getHeight(root);</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, height) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** 生成矩阵 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                ans.get(i).add(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printNode(root, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> level, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = (begin + end) / <span class="number">2</span>;</span><br><span class="line">        ans.get(level).set(index, root.val + <span class="string">""</span>);</span><br><span class="line">        printNode(root.left, level + <span class="number">1</span>, begin, index - <span class="number">1</span>);</span><br><span class="line">        printNode(root.right, level + <span class="number">1</span>, index + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 树的高度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftH = getHeight(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightH = getHeight(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftH, rightH) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/18/%E4%B8%BA%E4%BB%80%E4%B9%88%20Redis%20%E5%BF%AB%E7%85%A7%E4%BD%BF%E7%94%A8%E5%AD%90%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/18/%E4%B8%BA%E4%BB%80%E4%B9%88%20Redis%20%E5%BF%AB%E7%85%A7%E4%BD%BF%E7%94%A8%E5%AD%90%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">为什么 Redis 快照使用子进程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-19 06:40:11 / 修改时间：14:41:52" itemprop="dateCreated datePublished" datetime="2020-05-19T06:40:11+08:00">2020-05-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://draveness.me/whys-the-design-redis-single-thread/" target="_blank" rel="noopener">原文链接</a> 作者:Draven</p>
<p>虽然我们经常将 Redis 看做一个纯内存的键值存储系统，但是我们也会用到它的持久化功能，RDB 和 AOF 就是 Redis 为我们提供的两种持久化工具，其中 RDB 就是 Redis 的数据快照，我们在这篇文章想要分析 Redis 为什么在对数据进行快照持久化时会需要使用子进程，而不是将内存中的数据结构直接导出到磁盘上进行存储。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在具体分析今天的问题之前，我们首先需要了解 Redis 的持久化存储机制 RDB 究竟是什么，RDB 会每隔一段时间中对 Redis 服务中当下的数据集进行快照，除了 Redis 的配置文件可以对快照的间隔进行设置之外，Redis 客户端还同时提供两个命令来生成 RDB 存储文件，也就是 <code>SAVE</code> 和 <code>BGSAVE</code>，通过命令的名字我们就能猜出这两个命令的区别。</p>
<p><img src="https://img.draveness.me/save-and-bgsave.png" alt="save-and-bgsave"></p>
<p>其中 <code>SAVE</code> 命令在执行时会直接阻塞当前的线程，由于 Redis 是 <a href="https://draveness.me/whys-the-design-redis-single-thread" target="_blank" rel="noopener">单线程</a> 的，所以 <code>SAVE</code> 命令会直接阻塞来自客户端的所有其他请求，这在很多时候对于需要提供较强可用性保证的 Redis 服务都是无法接受的。</p>
<p>我们往往需要 <code>BGSAVE</code> 命令在后台生成 Redis 全部数据对应的 RDB 文件，当我们使用 <code>BGSAVE</code> 命令时，Redis 会立刻 <code>fork</code> 出一个子进程，子进程会执行『将内存中的数据以 RDB 格式保存到磁盘中』这一过程，而 Redis 服务在 <code>BGSAVE</code> 工作期间仍然可以处理来自客户端的请求。</p>
<p><a href="https://github.com/antirez/redis/blob/e916058f0ba59e964f5de3dee17f46ae08f1d385/src/rdb.c#L1343-L1378" target="_blank" rel="noopener"><code>rdbSaveBackground</code></a> 就是用来处理在后台将数据保存到磁盘上的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasActiveChildProcess()) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((childpid = redisFork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        redisSetProcTitle(<span class="string">"redis-rdb-bgsave"</span>);</span><br><span class="line">        retval = rdbSave(filename,rsi);</span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK) &#123;</span><br><span class="line">            sendChildCOWInfo(CHILD_INFO_TYPE_RDB, <span class="string">"RDB"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exitFromChild((retval == C_OK) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis 服务器会在触发 <code>BGSAVE</code> 时调用 <code>redisFork</code> 函数来创建子进程并调用 <code>rdbSave</code> 在子进程中对数据进行持久化，我们在这里虽然省略了函数中的一些内容，但是整体的结构还是非常清晰的，感兴趣的读者可以在点击上面的链接了解整个函数的实现。</p>
<p>使用 <code>fork</code> 的目的最终一定是为了不阻塞主进程来提升 Redis 服务的可用性，但是到了这里我们其实能够发现两个问题：</p>
<ol>
<li>为什么 <code>fork</code> 之后的子进程能够获取父进程内存中的数据？</li>
<li><code>fork</code> 函数是否会带来额外的性能开销，这些开销我们怎么样才可以避免？</li>
</ol>
<p>既然 Redis 选择使用了 <code>fork</code> 的方式来解决快照持久化的问题，那就说明这两个问题已经有了答案，首先 <code>fork</code> 之后的子进程是可以获取父进程内存中的数据的，而 <code>fork</code> 带来的额外性能开销相比阻塞主线程也一定是可以接受的，只有同时具备这两点，Redis 最终才会选择这样的方案。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>为了分析上一节提出的两个问题，我们在这里需要了解以下的这些内容，这些内容是 Redis 服务器使用 <code>fork</code> 函数的前提条件，也是最终促使它选择这种实现方式的关键：</p>
<ol>
<li>通过 <code>fork</code> 生成的父子进程会共享包括内存空间在内的资源；</li>
<li><code>fork</code> 函数并不会带来明显的性能开销，尤其是对内存进行大量的拷贝，它能通过写时拷贝将拷贝内存这一工作推迟到真正需要的时候；</li>
</ol>
<h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h3><p>在计算机编程领域，尤其是 Unix 和类 Unix 系统中，<code>fork</code> 都是一个进程用于创建自己拷贝的操作，它往往都是被操作系统内核实现的系统调用，也是操作系统在 *nix 系统中创建新进程的主要方法。</p>
<p><img src="https://img.draveness.me/fork-and-processes.png" alt="fork-and-processes"></p>
<p>当程序调用了 <code>fork</code> 方法之后，我们就可以通过 <code>fork</code> 的返回值确定父子进程，以此来执行不同的操作：</p>
<ul>
<li><code>fork</code> 函数返回 0 时，意味着当前进程是子进程；</li>
<li><code>fork</code> 函数返回非 0 时，意味着当前进程是父进程，返回值是子进程的 <code>pid</code>；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child process</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent process</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>fork</code> 的 <a href="http://man7.org/linux/man-pages/man2/fork.2.html" target="_blank" rel="noopener">手册</a> 中，我们会发现调用 <code>fork</code> 后的父子进程会运行在不同的内存空间中，当 <code>fork</code> 发生时两者的内存空间有着完全相同的内容，对内存的写入和修改、文件的映射都是独立的，两个进程不会相互影响。</p>
<blockquote>
<p>The child process and the parent process run in separate memory spaces. At the time of fork() both memory spaces have the same content. Memory writes, file mappings (mmap(2)), and unmappings (munmap(2)) performed by one of the processes do not affect other.</p>
</blockquote>
<p>除此之外，子进程几乎是父进程的完整副本（Exact duplicate），然而这两个进程在以下的一些方面会有较小的区别：</p>
<ul>
<li>子进程用于独立且唯一的进程 ID；</li>
<li>子进程的父进程 ID 与父进程 ID 完全相同；</li>
<li>子进程不会继承父进程的内存锁；</li>
<li>子进程会重新设置进程资源利用率和 CPU 计时器；</li>
<li>…</li>
</ul>
<p>最关键的点在于父子进程的内存在 <code>fork</code> 时是完全相同的，在 <code>fork</code> 之后进行写入和修改也不会相互影响，这其实就完美的解决了快照这个场景的问题 —— 只需要某个时间点下内存中的数据，而父进程可以继续对自己的内存进行修改，这既不会被阻塞，也不会影响生成的快照。</p>
<h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><p>既然父进程和子进程拥有完全相同的内存空间并且两者对内存的写入都不会相互影响，那么是否意味着子进程在 <code>fork</code> 时需要对父进程的内存进行全量的拷贝呢？假设子进程需要对父进程的内存进行拷贝，这对于 Redis 服务来说基本都是灾难性的，尤其是在以下的两个场景中：</p>
<ol>
<li>内存中存储大量的数据，<code>fork</code> 时拷贝内存空间会消耗大量的时间和资源，会导致程序一段时间的不可用；</li>
<li>Redis 占用了 10G 的内存，而物理机或者虚拟机的资源上限只有 16G，在这时我们就无法对 Redis 中的数据进行持久化，也就是说 Redis 对机器上内存资源的最大利用率不能超过 50%；</li>
</ol>
<p>如果无法解决上面的两个问题，使用 <code>fork</code> 来生成内存镜像的方式也无法真正落地，不是一个工程中真正可以使用的方法。</p>
<blockquote>
<p>就算脱离了 Redis 的场景，<code>fork</code> 时全量拷贝内存也是难以接受的，假设我们需要在命令行中执行一个命令，我们需要先通过 <code>fork</code> 创建一个新的进程再通过 <code>exec</code> 来执行程序，<code>fork</code> 拷贝的大量内存空间对于子进程来说可能完全没有任何作用的，但是却引入了巨大的额外开销。</p>
</blockquote>
<p>写时拷贝（Copy-on-Write）的出现就是为了解决这一问题，就像我们在这一节开头介绍的，写时拷贝的主要作用就是<strong>将拷贝推迟到写操作真正发生时</strong>，这也就避免了大量无意义的拷贝操作。在一些早期的 *nix 系统上，系统调用 <code>fork</code> 确实会立刻对父进程的内存空间进行复制，但是在今天的多数系统中，<code>fork</code> 并不会立刻触发这一过程：</p>
<p><img src="https://img.draveness.me/process-shared-memory.png" alt="process-shared-memory"></p>
<p>在 <code>fork</code> 函数调用时，父进程和子进程会被 Kernel 分配到不同的虚拟内存空间中，所以在两个进程看来它们访问的是不同的内存：</p>
<ul>
<li>在真正访问虚拟内存空间时，Kernel 会将虚拟内存映射到物理内存上，所以父子进程共享了物理上的内存空间；</li>
<li>当父进程或者子进程对共享的内存进行修改时，共享的内存才会<strong>以页为单位进行拷贝</strong>，父进程会保留原有的物理空间，而子进程会使用拷贝后的新物理空间；</li>
</ul>
<p>在 Redis 服务中，子进程只会读取共享内存中的数据，它并不会执行任何写操作，只有父进程会在写入时才会触发这一机制，而对于大多数的 Redis 服务或者数据库，写请求往往都是远小于读请求的，所以使用 <code>fork</code> 加上写时拷贝这一机制能够带来非常好的性能，也让 <code>BGSAVE</code> 这一操作的实现变得非常简单。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis 实现后台快照的方式非常巧妙，通过操作系统提供的 <code>fork</code> 和写时拷贝的特性轻而易举的就实现了这个功能，从这里我们就能看出作者对于操作系统知识的掌握还是非常扎实的，大多人在面对类似的场景时，想到的方法可能就是手动实现类似『写时拷贝』的特性，然而这不仅增加了工作量，还增加了程序出现问题的可能性。</p>
<p>到这里，我们简单总结一下 Redis 为什么在使用 RDB 进行快照时会通过子进程的方式进行实现：</p>
<ol>
<li>通过 <code>fork</code> 创建的子进程能够获得和父进程完全相同的内存空间，父进程对内存的修改对于子进程是不可见的，两者不会相互影响；</li>
<li>通过 <code>fork</code> 创建子进程时不会立刻触发大量内存的拷贝，内存在被修改时会以页为单位进行拷贝，这也就避免了大量拷贝内存而带来的性能问题；</li>
</ol>
<p>上述两个原因中，一个为子进程访问父进程提供了支撑，另一个为减少额外开销做了支持，这两者缺一不可，共同成为了 Redis 使用子进程实现快照持久化的原因。到最后，我们还是来看一些比较开放的相关问题，有兴趣的读者可以仔细思考一下下面的问题：</p>
<ul>
<li>Nginx 的主进程会在运行时 <code>fork</code> 一组子进程，这些子进程可以分别处理请求，还有哪些服务会使用这一特性？</li>
<li>写时拷贝其实是一个比较常见的机制，在 Redis 之外还有哪里会用到它？</li>
</ul>
<blockquote>
<p>如果对文章中的内容有疑问或者想要了解更多软件工程上一些设计决策背后的原因，可以在博客下面留言，作者会及时回复本文相关的疑问并选择其中合适的主题作为后续的内容。</p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://redis.io/topics/persistence" target="_blank" rel="noopener">Redis Persistence</a></li>
<li><a href="https://jobs.zalando.com/tech/blog/understanding-redis-background-memory-usage/?gh_src=4n3gxh1" target="_blank" rel="noopener">Understanding Redis Background Memory Usage</a></li>
<li><a href="https://redis.io/topics/faq" target="_blank" rel="noopener">FAQ · Redis</a></li>
<li><a href="https://en.wikipedia.org/wiki/Copy-on-write" target="_blank" rel="noopener">Copy-on-write</a></li>
<li><a href="https://github.com/antirez/redis/blob/e916058f0ba59e964f5de3dee17f46ae08f1d385/src/rdb.c#L1343-L1378" target="_blank" rel="noopener">rdbSaveBackground · Redis</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fork_(system_call)" target="_blank" rel="noopener">Fork (system call)</a></li>
<li><a href="https://unix.stackexchange.com/questions/87551/which-file-in-kernel-specifies-fork-vfork-to-use-sys-clone-system-call" target="_blank" rel="noopener">Which file in kernel specifies fork(), vfork()… to use sys_clone() system call</a></li>
<li><a href="https://www.reddit.com/r/compsci/comments/31szui/trying_to_understand_fork_and_copyonwrite_cow/" target="_blank" rel="noopener">Trying to understand fork() and Copy-on-Write (COW)</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/18/Copy%20On%20Write%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/18/Copy%20On%20Write%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Copy On Write机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-19 06:35:22" itemprop="dateCreated datePublished" datetime="2020-05-19T06:35:22+08:00">2020-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-24 17:20:34" itemprop="dateModified" datetime="2020-05-24T17:20:34+08:00">2020-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://juejin.im/post/5bd96bcaf265da396b72f855" target="_blank" rel="noopener">原文链接</a> 作者:Java3y</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在读《Redis设计与实现》关于哈希表扩容的时候，发现这么一段话：</p>
<blockquote>
<p>执行BGSAVE命令或者BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用<strong>写时复制（copy-on-write）来优化子进程的使用效率</strong>，所以在子进程存在期间，服务器会提高负载因子的阈值，从而避免在子进程存在期间进行哈希表扩展操作，避免不必要的内存写入操作，最大限度地节约内存。</p>
</blockquote>
<p>触及到知识的盲区了，于是就去搜了一下copy-on-write写时复制这个技术究竟是怎么样的。发现涉及的东西蛮多的，也挺难读懂的。于是就写下这篇笔记来记录一下我学习copy-on-write的过程。</p>
<p>本文<strong>力求简单讲清copy-on-write这个知识点</strong>，希望大家看完能有所收获。</p>
<h1 id="一、Linux下的copy-on-write"><a href="#一、Linux下的copy-on-write" class="headerlink" title="一、Linux下的copy-on-write"></a>一、Linux下的copy-on-write</h1><p>在说明Linux下的copy-on-write机制前，我们首先要知道两个函数：<code>fork()</code>和<code>exec()</code>。需要注意的是<code>exec()</code>并不是一个特定的函数, 它是<strong>一组函数的统称</strong>, 它包括了<code>execl()</code>、<code>execlp()</code>、<code>execv()</code>、<code>execle()</code>、<code>execve()</code>、<code>execvp()</code>。</p>
<h2 id="1-1简单来用用fork"><a href="#1-1简单来用用fork" class="headerlink" title="1.1简单来用用fork"></a>1.1简单来用用fork</h2><p>首先我们来看一下<code>fork()</code>函数是什么鬼：</p>
<blockquote>
<p>fork is an operation whereby a process creates a copy of itself.</p>
</blockquote>
<p>fork是类Unix操作系统上<strong>创建进程</strong>的主要方法。fork用于<strong>创建子进程</strong>(等同于当前进程的副本)。</p>
<ul>
<li>新的进程要通过老的进程复制自身得到，这就是fork！</li>
</ul>
<p>如果接触过Linux，我们会知道Linux下<strong>init进程是所有进程的爹</strong>(相当于Java中的Object对象)</p>
<ul>
<li>Linux的进程都通过init进程或init的子进程fork(vfork)出来的。</li>
</ul>
<p>下面以例子说明一下fork吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">pid_t</span> fpid; <span class="comment">//fpid表示fork函数返回的值  </span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调用fork，创建出子进程  </span></span><br><span class="line">    fpid=fork();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所以下面的代码有两个进程执行！</span></span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建进程失败!/n"</span>);   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是子进程，由父进程fork出来/n"</span>);   </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是父进程/n"</span>);   </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"统计结果是: %d/n"</span>,count);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的结果输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我是子进程，由父进程fork出来</span><br><span class="line"></span><br><span class="line">统计结果是: 1</span><br><span class="line"></span><br><span class="line">我是父进程</span><br><span class="line"></span><br><span class="line">统计结果是: 1</span><br></pre></td></tr></table></figure>

<p>解释一下：</p>
<ul>
<li>fork作为一个函数被调用。这个函数会有<strong>两次返回</strong>，将<strong>子进程的PID返回给父进程，0返回给子进程</strong>。(如果小于0，则说明创建子进程失败)。</li>
<li>再次说明：当前进程调用<code>fork()</code>，会创建一个跟当前进程完全相同的子进程(除了pid)，所以子进程同样是会执行<code>fork()</code>之后的代码。</li>
</ul>
<p>所以说：</p>
<ul>
<li>父进程在执行if代码块的时候，<code>fpid变量</code>的值是子进程的pid</li>
<li>子进程在执行if代码块的时候，<code>fpid变量</code>的值是0</li>
</ul>
<h2 id="1-2再来看看exec-函数"><a href="#1-2再来看看exec-函数" class="headerlink" title="1.2再来看看exec()函数"></a>1.2再来看看exec()函数</h2><p>从上面我们已经知道了fork会创建一个子进程。<strong>子进程的是父进程的副本</strong>。</p>
<p>exec函数的作用就是：<strong>装载一个新的程序</strong>（可执行映像）覆盖<strong>当前进程</strong>内存空间中的映像，<strong>从而执行不同的任务</strong>。</p>
<ul>
<li>exec系列函数在执行时会<strong>直接替换掉当前进程的地址空间</strong>。</li>
</ul>
<p>我去画张图来理解一下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/31/166c94cfc1728f4e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="exec函数的作用"></p>
<p>参考资料：</p>
<ul>
<li>程序员必备知识——fork和exec函数详解<a href="https://blog.csdn.net/bad_good_man/article/details/49364947" target="_blank" rel="noopener">blog.csdn.net/bad_good_ma…</a></li>
<li>linux中fork（）函数详解（原创！！实例讲解）：<a href="https://blog.csdn.net/jason314/article/details/5640969" target="_blank" rel="noopener">blog.csdn.net/jason314/ar…</a></li>
<li>linux c语言 fork() 和 exec 函数的简介和用法：<a href="https://blog.csdn.net/nvd11/article/details/8856278" target="_blank" rel="noopener">blog.csdn.net/nvd11/artic…</a></li>
<li>Linux下Fork与Exec使用：<a href="https://www.cnblogs.com/hicjiajia/archive/2011/01/20/1940154.html" target="_blank" rel="noopener">www.cnblogs.com/hicjiajia/a…</a></li>
<li>Linux 系统调用 —— fork()内核源码剖析：<a href="https://blog.csdn.net/chen892704067/article/details/76596225" target="_blank" rel="noopener">blog.csdn.net/chen8927040…</a></li>
</ul>
<h2 id="1-3回头来看Linux下的COW是怎么一回事"><a href="#1-3回头来看Linux下的COW是怎么一回事" class="headerlink" title="1.3回头来看Linux下的COW是怎么一回事"></a>1.3回头来看Linux下的COW是怎么一回事</h2><blockquote>
<p>fork()会产生一个和父进程完全相同的子进程(除了pid)</p>
</blockquote>
<p>如果按<strong>传统</strong>的做法，会<strong>直接</strong>将父进程的数据拷贝到子进程中，拷贝完之后，父进程和子进程之间的数据段和堆栈是<strong>相互独立的</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/31/166c94cfc1818295?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="父进程的数据拷贝到子进程中"></p>
<p>但是，以我们的使用经验来说：往往子进程都会执行<code>exec()</code>来做自己想要实现的功能。</p>
<ul>
<li>所以，如果按照上面的做法的话，创建子进程时复制过去的数据是没用的(因为子进程执行<code>exec()</code>，原有的数据会被清空)</li>
</ul>
<p>既然很多时候复制给子进程的数据是无效的，于是就有了Copy On Write这项技术了，原理也很简单：</p>
<ul>
<li>fork创建出的子进程，<strong>与父进程共享内存空间</strong>。也就是说，如果子进程<strong>不对内存空间进行写入操作的话，内存空间中的数据并不会复制给子进程</strong>，这样创建子进程的速度就很快了！(不用复制，直接引用父进程的物理空间)。</li>
<li>并且如果在fork函数返回之后，子进程<strong>第一时间</strong>exec一个新的可执行映像，那么也不会浪费时间和内存空间了。</li>
</ul>
<p>另外的表达方式：</p>
<blockquote>
<p>在fork之后exec之前两个进程<strong>用的是相同的物理空间</strong>（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的<strong>物理空间是同一个</strong>。</p>
</blockquote>
<blockquote>
<p>当父子进程中<strong>有更改相应段的行为发生时</strong>，再<strong>为子进程相应的段分配物理空间</strong>。</p>
</blockquote>
<blockquote>
<p>如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。</p>
</blockquote>
<blockquote>
<p>而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。</p>
</blockquote>
<p>Copy On Write技术<strong>实现原理：</strong></p>
<blockquote>
<p>fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会<strong>把触发的异常的页复制一份</strong>，于是父子进程各自持有独立的一份。</p>
</blockquote>
<p>Copy On Write技术<strong>好处</strong>是什么？</p>
<ul>
<li>COW技术可<strong>减少</strong>分配和复制大量资源时带来的<strong>瞬间延时</strong>。</li>
<li>COW技术可减少<strong>不必要的资源分配</strong>。比如fork进程时，并不是所有的页面都需要复制，父进程的<strong>代码段和只读数据段都不被允许修改，所以无需复制</strong>。</li>
</ul>
<p>Copy On Write技术<strong>缺点</strong>是什么？</p>
<ul>
<li>如果在fork()之后，父子进程都还需要继续进行写操作，<strong>那么会产生大量的分页错误(页异常中断page-fault)</strong>，这样就得不偿失。</li>
</ul>
<p>几句话总结Linux的Copy On Write技术：</p>
<ul>
<li>fork出的子进程共享父进程的物理空间，当父子进程<strong>有内存写入操作时</strong>，read-only内存页发生中断，<strong>将触发的异常的内存页复制一份</strong>(其余的页还是共享父进程的)。</li>
<li>fork出的子进程功能实现和父进程是一样的。如果有需要，我们会用<code>exec()</code>把当前进程映像替换成新的进程文件，完成自己想要实现的功能。</li>
</ul>
<p>参考资料：</p>
<ul>
<li>Linux进程基础：<a href="http://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html" target="_blank" rel="noopener">www.cnblogs.com/vamei/archi…</a></li>
<li>Linux写时拷贝技术(copy-on-write)<a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html" target="_blank" rel="noopener">www.cnblogs.com/biyeymyhjob…</a></li>
<li>当你在 Linux 上启动一个进程时会发生什么？<a href="https://zhuanlan.zhihu.com/p/33159508" target="_blank" rel="noopener">zhuanlan.zhihu.com/p/33159508</a></li>
<li>Linux fork()所谓的写时复制(COW)到最后还是要先复制再写吗？<a href="https://www.zhihu.com/question/265400460" target="_blank" rel="noopener">www.zhihu.com/question/26…</a></li>
<li>写时拷贝（copy－on－write） COW技术<a href="https://blog.csdn.net/u012333003/article/details/25117457" target="_blank" rel="noopener">blog.csdn.net/u012333003/…</a></li>
<li>Copy-On-Write 写时复制原理<a href="https://blog.csdn.net/ppppppppp2009/article/details/22750939" target="_blank" rel="noopener">blog.csdn.net/ppppppppp20…</a></li>
</ul>
<h2 id="二、解释一下Redis的COW"><a href="#二、解释一下Redis的COW" class="headerlink" title="二、解释一下Redis的COW"></a>二、解释一下Redis的COW</h2><p>基于上面的基础，我们应该已经了解COW这么一项技术了。</p>
<p>下面我来说一下我对《Redis设计与实现》那段话的理解：</p>
<ul>
<li>Redis在持久化时，如果是采用BGSAVE命令或者BGREWRITEAOF的方式，那Redis会<strong>fork出一个子进程来读取数据，从而写到磁盘中</strong>。</li>
<li>总体来看，Redis还是读操作比较多。如果子进程存在期间，发生了大量的写操作，那可能就会出现<strong>很多的分页错误(页异常中断page-fault)</strong>，这样就得耗费不少性能在复制上。</li>
<li>而在<strong>rehash阶段上，写操作是无法避免</strong>的。所以Redis在fork出子进程之后，<strong>将负载因子阈值提高</strong>，尽量减少写操作，避免不必要的内存写入操作，最大限度地节约内存。</li>
</ul>
<p>参考资料：</p>
<ul>
<li>fork()后copy on write的一些特性：<a href="https://zhoujianshi.github.io/articles/2017/fork(" target="_blank" rel="noopener">zhoujianshi.github.io/articles/20…</a>后copy on write的一些特性/index.html)</li>
<li>写时复制：<a href="https://miao1007.github.io/gitbook/java/juc/cow/" target="_blank" rel="noopener">miao1007.github.io/gitbook/jav…</a></li>
</ul>
<h1 id="三、文件系统的COW"><a href="#三、文件系统的COW" class="headerlink" title="三、文件系统的COW"></a>三、文件系统的COW</h1><p>下面来看看文件系统中的COW是啥意思：</p>
<p>Copy-on-write在对数据进行修改的时候，<strong>不会直接在原来的数据位置上进行操作</strong>，而是重新找个位置修改，这样的好处是一旦系统突然断电，重启之后不需要做Fsck。好处就是能<strong>保证数据的完整性，掉电的话容易恢复</strong>。</p>
<ul>
<li>比如说：要修改数据块A的内容，先把A读出来，写到B块里面去。如果这时候断电了，原来A的内容还在！</li>
</ul>
<p>参考资料：</p>
<ul>
<li>文件系统中的 copy-on-write 模式有什么具体的好处？<a href="https://www.zhihu.com/question/19782224/answers/created" target="_blank" rel="noopener">www.zhihu.com/question/19…</a></li>
<li>新一代 Linux 文件系统 btrfs 简介:<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-btrfs/" target="_blank" rel="noopener">www.ibm.com/developerwo…</a></li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>最后我们再来看一下写时复制的思想(摘录自维基百科)：</p>
<blockquote>
<p>写入时复制（英语：Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被建立，因此多个调用者只是读取操作时可以共享同一份资源。</p>
</blockquote>
<p>至少从本文我们可以总结出：</p>
<ul>
<li>Linux通过Copy On Write技术极大地<strong>减少了Fork的开销</strong>。</li>
<li>文件系统通过Copy On Write技术一定程度上保证<strong>数据的完整性</strong>。</li>
</ul>
<p>其实在Java里边，也有Copy On Write技术，称为延迟拷贝。</p>
<p>Java中有三种类型的对象拷贝：浅拷贝(Shallow Copy)、深拷贝(Deep Copy)、延迟拷贝(Lazy Copy)。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/31/166c94cfc1b8a75f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Java中的COW"></p>
<p>这部分留到下一篇来说，敬请期待~</p>
<p>参考资料：</p>
<ul>
<li>写时复制，写时拷贝，写时分裂，Copy on write：<a href="https://my.oschina.net/dubenju/blog/815836" target="_blank" rel="noopener">my.oschina.net/dubenju/blo…</a></li>
<li>不会产奶的COW(Copy-On-Write)<a href="https://www.jianshu.com/p/b2fb2ee5e3a0" target="_blank" rel="noopener">www.jianshu.com/p/b2fb2ee5e…</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/18/%E4%B8%BA%E4%BB%80%E4%B9%88%20Redis%20%E9%80%89%E6%8B%A9%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/18/%E4%B8%BA%E4%BB%80%E4%B9%88%20Redis%20%E9%80%89%E6%8B%A9%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">为什么 Redis 选择单线程模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-19 06:06:21 / 修改时间：14:10:15" itemprop="dateCreated datePublished" datetime="2020-05-19T06:06:21+08:00">2020-05-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://draveness.me/whys-the-design-redis-single-thread/" target="_blank" rel="noopener">原文链接</a> 作者:Draven</p>
<p>Redis 作为广为人知的内存数据库，在玩具项目和复杂的工业级别项目中都看到它的身影，然而 Redis 却是使用单线程模型进行设计的，这与很多人固有的观念有所冲突，为什么单线程的程序能够抗住每秒几百万的请求量呢？这也是我们今天要讨论的问题之一。</p>
<p>除此之外，Redis 4.0 之后的版本却抛弃了单线程模型这一设计，原本使用单线程运行的 Redis 也开始选择性使用多线程模型，这一看似有些矛盾的设计决策是今天需要讨论的另一个问题。</p>
<blockquote>
<p>However with Redis 4.0 we started to make Redis more threaded. For now this is limited to deleting objects in the background, and to blocking commands implemented via Redis modules. For the next releases, the plan is to make Redis more and more threaded.</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>就像在介绍中说的，这一篇文章想要讨论的两个与 Redis 有关的问题就是：</p>
<ul>
<li>为什么 Redis 在最初的版本中选择单线程模型？</li>
<li>为什么 Redis 在 4.0 之后的版本中加入了多线程的支持？</li>
</ul>
<p>这两个看起来有些矛盾的问题实际上并不冲突，我们会分别阐述对这个看起来完全相反的设计决策作出分析和解释，不过在具体分析它们的设计之前，我们先来看一下不同版本 Redis 顶层的设计：</p>
<p><img src="https://img.draveness.me/redis-io-multiplexing.png" alt="redis-io-multiplexing"></p>
<p>Redis 作为一个内存服务器，它需要处理很多来自外部的网络请求，它使用 I/O 多路复用机制同时监听多个文件描述符的可读和可写状态，一旦收到网络请求就会在内存中快速处理，由于绝大多数的操作都是纯内存的，所以处理的速度会非常地快。</p>
<p>在 <a href="https://raw.githubusercontent.com/antirez/redis/4.0/00-RELEASENOTES" target="_blank" rel="noopener">Redis 4.0</a> 之后的版本，情况就有了一些变动，新版的 Redis 服务在执行一些命令时就会使用『主处理线程』之外的其他线程，例如 <code>UNLINK</code>、<code>FLUSHALL ASYNC</code>、<code>FLUSHDB ASYNC</code> 等非阻塞的删除操作。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>无论是使用单线程模型还是多线程模型，这两个设计上的决定都是为了更好地提升 Redis 的开发效率、运行性能，想要理解两个看起来矛盾的设计决策，我们首先需要重新梳理做出决定的上下文和大前提，从下面的角度来看，使用单线程模型和多线程模型其实也并不矛盾。</p>
<p>虽然 Redis 在较新的版本中引入了多线程，不过是在<strong>部分命令</strong>上引入的，其中包括非阻塞的删除操作，在整体的架构设计上，主处理程序还是单线程模型的；由此看来，我们今天想要分析的两个问题可以简化成：</p>
<ul>
<li>为什么 Redis 服务使用单线程模型处理绝大多数的网络请求？</li>
<li>为什么 Redis 服务增加了多个非阻塞的删除操作，例如：<code>UNLINK</code>、<code>FLUSHALL ASYNC</code> 和 <code>FLUSHDB ASYNC</code>？</li>
</ul>
<p>接下来的两个小节将从多个角度分析这两个问题。</p>
<h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><p>Redis 从一开始就选择使用单线程模型处理来自客户端的绝大多数网络请求，这种考虑其实是多方面的，作者分析了相关的资料，发现其中最重要的几个原因如下：</p>
<ol>
<li>使用单线程模型能带来更好的可维护性，方便开发和调试；</li>
<li>使用单线程模型也能并发的处理客户端的请求；</li>
<li>Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU；</li>
</ol>
<p>上述三个原因中的最后一个是最终使用单线程模型的决定性因素，其他的两个原因都是使用单线程模型额外带来的好处，在这里我们会按顺序介绍上述的几个原因。</p>
<h4 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h4><p>可维护性对于一个项目来说非常重要，如果代码难以调试和测试，问题也经常难以复现，这对于任何一个项目来说都会严重地影响项目的可维护性。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，代码的执行过程不再是串行的，多个线程同时访问的变量如果没有谨慎处理就会带来诡异的问题。</p>
<p><img src="https://img.draveness.me/multi-threading.png" alt="multi-threading"></p>
<p>在网络上有一个调侃多线程模型的段子，就很好地展示了多线程模型带来的潜在问题：<a href="https://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="noopener">竞争条件 (race condition)</a> —— 如果计算机中的两个进程（线程同理）同时尝试修改一个共享内存的内容，在没有并发控制的情况下，最终的结果依赖于两个进程的执行顺序和时机，如果发生了并发访问冲突，最后的结果就会是不正确的。</p>
<blockquote>
<p>Some people, when confronted with a problem, think, “I know, I’ll use threads,” and then two they hav erpoblesms.</p>
</blockquote>
<p>引入了多线程，我们就必须要同时引入并发控制来保证在多个线程同时访问数据时程序行为的正确性，这就需要工程师额外维护并发控制的相关代码，例如，我们会需要在可能被并发读写的变量上增加互斥锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu Mutex <span class="comment">// cost</span></span><br><span class="line">    data <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    data += <span class="number">1</span></span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread 2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    data -= <span class="number">1</span></span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在访问这些变量或者内存之前也需要先对获取互斥锁，一旦忘记获取锁或者忘记释放锁就可能会导致各种诡异的问题，管理相关的并发控制机制也需要付出额外的研发成本和负担。</p>
<h4 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h4><p>使用单线程模型也并不意味着程序不能并发的处理任务，Redis 虽然使用单线程模型处理用户的请求，但是它却使用 I/O 多路复用机制<strong>并发</strong>处理来自客户端的多个连接，同时等待多个连接发送的请求。</p>
<p>在 I/O 多路复用模型中，最重要的函数调用就是 <code>select</code> 以及类似函数，该方法的能够同时监控多个文件描述符（也就是客户端的连接）的可读可写情况，当其中的某些文件描述符可读或者可写时，<code>select</code> 方法就会返回可读以及可写的文件描述符个数。</p>
<p>使用 I/O 多路复用技术能够极大地减少系统的开销，系统不再需要额外创建和维护进程和线程来监听来自客户端的大量连接，减少了服务器的开发成本和维护成本。</p>
<h4 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h4><p>最后要介绍的其实就是 Redis 选择单线程模型的决定性原因 —— 多线程技术能够帮助我们充分利用 CPU 的计算资源来并发的执行不同的任务，但是 CPU 资源往往都不是 Redis 服务器的性能瓶颈。哪怕我们在一个普通的 Linux 服务器上启动 Redis 服务，它也能在 1s 的时间内处理 1,000,000 个用户请求。</p>
<blockquote>
<p>It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.</p>
</blockquote>
<p>如果这种吞吐量不能满足我们的需求，更推荐的做法是使用分片的方式将不同的请求交给不同的 Redis 服务器来处理，而不是在同一个 Redis 服务中引入大量的多线程操作。</p>
<p>简单总结一下，Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作都会在内存中完成不会涉及任何的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；整个服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。</p>
<blockquote>
<p>AOF 是 Redis 的一种持久化机制，它会在每次收到来自客户端的写请求时，将其记录到日志中，每次 Redis 服务器启动时都会重放 AOF 日志构建原始的数据集，保证数据的持久性。</p>
</blockquote>
<p>多线程虽然会帮助我们更充分地利用 CPU 资源，但是操作系统上线程的切换也不是免费的，线程切换其实会带来额外的开销，其中包括：</p>
<ol>
<li>保存线程 1 的执行上下文；</li>
<li>加载线程 2 的执行上下文；</li>
</ol>
<p>频繁的对线程的上下文进行切换可能还会导致性能地急剧下降，这可能会导致我们不仅没有提升请求处理的平均速度，反而进行了负优化，所以这也是为什么 Redis 对于使用多线程技术非常谨慎。</p>
<h3 id="引入多线程"><a href="#引入多线程" class="headerlink" title="引入多线程"></a>引入多线程</h3><p>Redis 在最新的几个版本中加入了一些可以被其他线程异步处理的删除操作，也就是我们在上面提到的 <code>UNLINK</code>、<code>FLUSHALL ASYNC</code> 和 <code>FLUSHDB ASYNC</code>，我们为什么会需要这些删除操作，而它们为什么需要通过多线程的方式异步处理？</p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>我们可以在 Redis 在中使用 <code>DEL</code> 命令来删除一个键对应的值，如果待删除的键值对占用了较小的内存空间，那么哪怕是<strong>同步地</strong>删除这些键值对也不会消耗太多的时间。</p>
<p>但是对于 Redis 中的一些超大键值对，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务，影响 Redis 服务处理请求的 PCT99 和可用性。</p>
<p><img src="https://img.draveness.me/redis-unlink.png" alt="redis-unlink"></p>
<p>然而释放内存空间的工作其实可以由后台线程异步进行处理，这也就是 <code>UNLINK</code> 命令的实现原理，它只会将键从元数据中删除，真正的删除操作会在后台异步执行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis 选择使用单线程模型处理客户端的请求主要还是因为 CPU 不是 Redis 服务器的瓶颈，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 I/O 操作上；而 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。</p>
<blockquote>
<p>如果对文章中的内容有疑问或者想要了解更多软件工程上一些设计决策背后的原因，可以在博客下面留言，作者会及时回复本文相关的疑问并选择其中合适的主题作为后续的内容。</p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://redis.io/topics/faq#redis-is-single-threaded-how-can-i-exploit-multiple-cpu--cores" target="_blank" rel="noopener">Redis is single threaded. How can I exploit multiple CPU / cores?</a></li>
<li><a href="https://stackoverflow.com/questions/10489298/redis-is-single-threaded-then-how-does-it-do-concurrent-i-o" target="_blank" rel="noopener">Redis is single-threaded, then how does it do concurrent I/O?</a></li>
<li><a href="https://www.quora.com/Why-isnt-Redis-designed-to-benefit-from-multi-threading" target="_blank" rel="noopener">Why isn’t Redis designed to benefit from multi-threading?</a></li>
<li><a href="https://blog.golang.org/concurrency-is-not-parallelism" target="_blank" rel="noopener">Concurrency is not parallelism</a></li>
<li><a href="http://www.odbms.org/2018/03/the-little-known-feature-of-redis-4-0-that-will-speed-up-your-applications/" target="_blank" rel="noopener">The little-known feature of Redis 4.0 that will speed up your applications</a></li>
<li><a href="https://draveness.me/redis-io-multiplexing" target="_blank" rel="noopener">Redis 和 I/O 多路复用</a></li>
<li><a href="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/6_CPU_Scheduling.html" target="_blank" rel="noopener">CPU Scheduling</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/17/LeetCode654/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/17/LeetCode654/" class="post-title-link" itemprop="url">LeetCode654</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-18 06:28:08 / 修改时间：14:31:38" itemprop="dateCreated datePublished" datetime="2020-05-18T06:28:08+08:00">2020-05-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<p>二叉树的根是数组中的最大元素。<br>左子树是通过数组中最大值左边部分构造出的最大二叉树。<br>右子树是通过数组中最大值右边部分构造出的最大二叉树。<br>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
<p>示例 ：</p>
<p>输入：[3,2,1,6,0,5]<br>输出：返回下面这棵树的根节点：</p>
<pre><code>   6
 /   \   
3     5
 \    / 
  2  0   
    \
      1</code></pre><p>提示：</p>
<p>给定的数组的大小在 [1, 1000] 之间。</p>
<p>递归建树.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxId = getMaxId(nums);</span><br><span class="line">        <span class="keyword">int</span> max = nums[maxId];</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(max);</span><br><span class="line">        <span class="keyword">if</span> (maxId - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, <span class="number">0</span>, maxId));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxId + <span class="number">1</span> &lt; nums.length) &#123;</span><br><span class="line">            node.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxId + <span class="number">1</span>, nums.length));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxId</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxId = <span class="number">0</span>, max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max) &#123;</span><br><span class="line">                maxId = i;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/17/LeetCode617/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/17/LeetCode617/" class="post-title-link" itemprop="url">LeetCode617</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-18 05:53:43 / 修改时间：13:56:31" itemprop="dateCreated datePublished" datetime="2020-05-18T05:53:43+08:00">2020-05-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>947</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<p>输入:<br>    Tree 1                  Tree 2<br>         1                         2<br>         / \                       / \<br>        3   2                  1   3<br>       /                           \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>        3<br>        / <br>      4   5<br>      / \     \<br>     5   4    7<br>注意: 合并必须从两个树的根节点开始。</p>
<p>递归遍历:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (t1==<span class="keyword">null</span>&amp;&amp;t2==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t1!=<span class="keyword">null</span>&amp;&amp;t2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                TreeNode node=<span class="keyword">new</span> TreeNode(t1.val+t2.val);</span><br><span class="line">                node.left=mergeTrees(t1.left,t2.left);</span><br><span class="line">                node.right=mergeTrees(t1.right,t2.right);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                TreeNode node=<span class="keyword">new</span> TreeNode(t1.val);</span><br><span class="line">                node.left=mergeTrees(t1.left,<span class="keyword">null</span>);</span><br><span class="line">                node.right=mergeTrees(t1.right,<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                if (t2!=null)</span></span><br><span class="line">                TreeNode node=<span class="keyword">new</span> TreeNode(t2.val);</span><br><span class="line">                node.left=mergeTrees(<span class="keyword">null</span>,t2.left);</span><br><span class="line">                node.right=mergeTrees(<span class="keyword">null</span>,t2.right);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/16/Java%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/16/Java%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" class="post-title-link" itemprop="url">Java中的静态代理与动态代理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-17 06:26:17" itemprop="dateCreated datePublished" datetime="2020-05-17T06:26:17+08:00">2020-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-27 10:47:50" itemprop="dateModified" datetime="2020-05-27T10:47:50+08:00">2020-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://chenjiayang.me/2018/10/05/dynamic-proxy/" target="_blank" rel="noopener">原文地址</a> 作者:<a href="https://www.yuque.com/chenjiayang" target="_blank" rel="noopener"><strong>YoungChen</strong></a></p>
<h2 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h2><p>人话来讲就是由代理对象来执行目标对象的方法，且还可以在代理对象中增强目标对象方法的一种设计模式。类比生活，像是房产中介。代理模式存在的意义和一个架构设计原则息息相关 —— 开闭原则（对扩展开放，对修改关闭），即一种好的设计模式，都是在不修改原有形态的基础上扩展出新的功能。</p>
<h2 id="为什么需要代理"><a href="#为什么需要代理" class="headerlink" title="为什么需要代理"></a>为什么需要代理</h2><p>代理模式的概念很容易理解，但是早期的我即使读懂了代理模式的概念，对为什么要使用代理模式，还是一头雾水。为什么我不直接调用目标对象的方法，非得要借助个代理对象呢？</p>
<h3 id="1-调用的目标对象在远程主机上，并不在你本地"><a href="#1-调用的目标对象在远程主机上，并不在你本地" class="headerlink" title="1. 调用的目标对象在远程主机上，并不在你本地"></a>1. 调用的目标对象在远程主机上，并不在你本地</h3><p>类似中介就是房东出国了，联系不上，你只能跟我沟通。对应到我们程序设计的时候就是：客户端无法直接操作实际目标对象。为什么无法直接操作？一种情况是你需要调用的对象在另外一台机器上，你需要跨越网络才能访问，如果让你直接编码实现远程调用，你需要处理网络连接、处理打包、解包等等非常复杂的步骤，所以为了简化客户端的处理，我们使用代理模式，在客户端建立一个远程目标对象的代理，客户端就象调用本地对象一样调用该代理，再由代理去跟实际对象联系，对于客户端来说背后这个通信过程是透明的。</p>
<h3 id="2-你不想理会目标类繁杂的功能，只希望增加一些自己的行为进去"><a href="#2-你不想理会目标类繁杂的功能，只希望增加一些自己的行为进去" class="headerlink" title="2. 你不想理会目标类繁杂的功能，只希望增加一些自己的行为进去"></a>2. 你不想理会目标类繁杂的功能，只希望增加一些自己的行为进去</h3><p>例如常见的例子就是 Spring AOP 实现日志功能，你不必关心目标类究竟如何繁杂，你只是想要在前后调用的时候打印一下日志，那么你就可以使用代理模式，通过 AOP 提供的切面进行编码实现，你通过代理模式达到了在目标对象的方法前后增加了一些自定义行为的目的。类似的例子还有权限校验。这样做的好处有很多，一方面你需要在意目标类的代码，二来你维护了目标类功能的单一性，而不是将日志或者权限校验的功能硬编码到目标类的方法中。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理非常简单，就是实现类和代理类均实现同样的接口，然后在代理类中通过构造器将接口或者实现类注入进来，然后就可以在代理类的方法实现中增加一些自己的逻辑。看个 <a href="https://www.cnblogs.com/daniels/p/8242592.html" target="_blank" rel="noopener">例子</a> 就懂了：</p>
<h3 id="静态代理的例子"><a href="#静态代理的例子" class="headerlink" title="静态代理的例子"></a>静态代理的例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BuyHouse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buyHosue</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyHouseImpl</span> <span class="keyword">implements</span> <span class="title">BuyHouse</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyHosue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HHHHH"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyHouseProxy</span> <span class="keyword">implements</span> <span class="title">BuyHouse</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> BuyHouse buyHouse;</span><br><span class="line">    <span class="comment">// 将接口引入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuyHouseProxy</span><span class="params">(<span class="keyword">final</span> BuyHouse buyHouse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buyHouse = buyHouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyHosue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 增加一些自己的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"HHHHH"</span>);</span><br><span class="line">        buyHouse.buyHosue();</span><br><span class="line">        System.out.println(<span class="string">"66666"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态代理的缺点"><a href="#静态代理的缺点" class="headerlink" title="静态代理的缺点"></a>静态代理的缺点</h3><p>很明显，静态代理中，一个代理类只能对一个业务接口的实现类进行包装，如果有多个业务接口的话就要定义很多实现类和代理类才行。而且，如果代理类对业务方法的预处理、调用后操作都是一样的（比如：调用前输出提示、调用后自动关闭连接），则多个代理类就会有很多重复代码。这时我们可以定义这样一个代理类，它能代理所有实现类的方法调用：根据传进来的业务实现类和方法名进行具体调用。即动态代理模式。Java 中常见的有 JDK 动态代理和 CGLib 动态代理，前者只能代理接口，后者可以代理实现类。</p>
<h2 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h2><p>JDK 的动态代理使用到 Java reflect 包下的 Proxy 类和 InvocationHandler 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HHHHH"</span>);</span><br><span class="line">        Object result = method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">"66666"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyHouse buyHouse = <span class="keyword">new</span> BuyHouseImpl();</span><br><span class="line">        BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(BuyHouse.class.getClassLoader(), new Class[]&#123;BuyHouse.class&#125;, new DynamicProxyHandler(buyHouse));</span><br><span class="line">        proxyBuyHouse.buyHosue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DynamicProxyHandler 实现了 InvocationHandler 接口，并复写其 invoke 方法，我们可以看到 invoke 方法的参数是实现类和方法参数列表。测试类中通过 newProxyInstance 这个静态工厂方法创建了代理对象，代理对象的每个执行方法都会替换执行InvocationHandler 中的 invoke 方法。这个方法总共有3个参数：</p>
<ol>
<li>ClassLoader loader用来指明生成代理对象使用哪个类装载器</li>
<li>Class&lt;?&gt;[] interfaces用来指明生成哪个对象的代理对象，通过接口指定，这就是为什么 JDK 动态代理必须要通过接口的方式</li>
<li>InvocationHandler 用来指明产生的这个代理对象要做什么事情。</li>
</ol>
<p>newProxyInstance 内部本质上是根据反射机制生成了一个新类。</p>
<h2 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a>CGLib 动态代理</h2><p>CGLib 是针对类来实现代理的，原理是对指定的实现类生成一个子类，并覆盖其中的方法实现代理。因为采用的是继承，所以不能对final 修饰的类进行代理。<a href="https://www.cnblogs.com/ygj0930/p/6542259.html" target="_blank" rel="noopener">例子</a> 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现类，有没有实现接口无所谓</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeImpl</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"新增图书..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeCglib</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 业务类对象，供代理方法中进行真正的业务方法调用</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 相当于JDK动态代理中的绑定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 给业务对象赋值</span></span><br><span class="line">        <span class="keyword">this</span>.target = target;  </span><br><span class="line">        <span class="comment">// 创建加强器，用来创建动态代理类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer(); </span><br><span class="line">        <span class="comment">// 为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）</span></span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());  </span><br><span class="line">        <span class="comment">// 设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>); </span><br><span class="line">       <span class="comment">// 创建动态代理类对象并返回 </span></span><br><span class="line">       <span class="keyword">return</span> enhancer.create(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现回调方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"预处理——————"</span>);</span><br><span class="line">        <span class="comment">//调用业务类（父类中）的方法</span></span><br><span class="line">        proxy.invokeSuper(obj, args); </span><br><span class="line">        System.out.println(<span class="string">"调用后操作——————"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      </span><br><span class="line">    BookFacadeImpl bookFacade = <span class="keyword">new</span> BookFacadeImpl()；</span><br><span class="line">    BookFacadeCglib cglib = <span class="keyword">new</span> BookFacadeCglib();  </span><br><span class="line">    BookFacadeImpl bookCglib = (BookFacadeImpl)cglib.getInstance(bookFacade);  </span><br><span class="line">    bookCglib.addBook(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.cnblogs.com/ygj0930/p/6542259.html" target="_blank" rel="noopener">Java动态代理之JDK实现和CGlib实现（简单易懂）</a></li>
<li><a href="https://www.cnblogs.com/xiaoluo501395377/p/3383130.html" target="_blank" rel="noopener">java的动态代理机制详解</a></li>
<li><a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html" target="_blank" rel="noopener">java动态代理实现与原理详细分析</a></li>
</ol>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><ul>
<li>本文遵守创作共享 <a href="https://link.zhihu.com/?target=https%3A//creativecommons.org/licenses/by-nc-sa/3.0/cn/">CC BY-NC-SA 3.0协议</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/16/UNIX%E4%B8%8B%E7%9A%84IO%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/16/UNIX%E4%B8%8B%E7%9A%84IO%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">UNIX下的I/O模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-17 03:44:34 / 修改时间：11:56:07" itemprop="dateCreated datePublished" datetime="2020-05-17T03:44:34+08:00">2020-05-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>RPC 中很重要的部分就是网络通信，因此这篇叙述一下 Unix 下为解决不同 I/O 问题所设计的 I/O 模型。首先要说明的是，I/O 是个很宽泛的概念，常见的有网络 I/O、磁盘 I/O、内存 I/O 等。</p>
<p>在 Unix 系统下，不论是标准输入还是借助套接字接受网络输入，其实都会有两个步骤，很多文章都提到：</p>
<ol>
<li>等待数据准备好（Waiting for the data to be ready）</li>
<li>从内核向进程复制数据（Copying the data from the kernel to the process）</li>
</ol>
<p><img src="https://pic4.zhimg.com/80/v2-89272a2047be6b90fff1893615a22a99_hd.jpg" alt="img"></p>
<p>这两个阶段涉及到用户空间和内核空间</p>
<h2 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h2><p>对 32 位 OS 而言，它的寻址空间（虚拟存储空间）为 4G。OS 的核心是内核，可以访问底层硬件设备，为了保证用户进程不能直接操作内核从而保证内核的安全，OS 将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</p>
<p>内核空间中存放的是内核代码和数据，例如 Linux 的 OS 和驱动便运行在内核空间，可以操作底层硬件，如果从磁盘读取数据，那么数据会被先载入内核空间的缓冲区中；而进程的用户空间中存放的是用户程序的代码和数据，通常来讲就是应用程序常驻的区域。</p>
<p>因此整个 Linux 内部结构可以分为三部分，从最底层到最上层依次是：硬件、内核空间、用户空间。如下图：</p>
<p><img src="https://pic4.zhimg.com/80/v2-0800f36d38f800111c76f362ea30daf2_hd.jpg" alt="img"></p>
<p>二者间无法直接通信，必须通过系统调用，一般来说系统调用的成本很高。</p>
<h2 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h2><ul>
<li>当一个进程经过系统调用而陷入内核代码中执行时，称进程处于内核运行态，简称内核态</li>
<li>当进程在执行用户自己的代码时，则称其处于用户运行态，简称用户态</li>
</ul>
<h2 id="高性能的Server有什么特点"><a href="#高性能的Server有什么特点" class="headerlink" title="高性能的Server有什么特点"></a>高性能的Server有什么特点</h2><p>说完上面的之后，你可能疑惑这和 RPC 的通信设计有什么关系呢？其实正是由于这种内存空间的划分，所以 I/O 一般会在两个地方阻塞，一个是等待数据报到达时，一个是从内核空间拷贝到用户空间时，而阻塞多数情况下我们是无法接受的，因为其损耗性能，而高性能的 server 到底在关注什么？一句话总结：用尽可能少的系统开销处理尽可能多的连接请求。因此诞生了不同的 I/O 模型，它们的不同点总结起来就是对这两个阻塞阶段的处理方式不同</p>
<h2 id="Unix-下的-I-O-模型"><a href="#Unix-下的-I-O-模型" class="headerlink" title="Unix 下的 I/O 模型"></a>Unix 下的 I/O 模型</h2><p>Unix 下存在五种 I/O 模型：</p>
<ol>
<li>阻塞 I/O</li>
<li>非阻塞 I/O</li>
<li>I/O 复用（select和poll）</li>
<li>信号驱动 I/O（SIGIO）</li>
<li>异步 I/O</li>
</ol>
<p>以下的例子，我们以 UDP 套接字中的 recvfrom 函数作为系统调用来说明I/O模型。recvfrom 函数类似于标准的 read 函数，它的作用是从指定的套接字中读取数据报。</p>
<h3 id="1-、阻塞-I-O"><a href="#1-、阻塞-I-O" class="headerlink" title="1 、阻塞 I/O"></a>1 、阻塞 I/O</h3><p><img src="https://pic4.zhimg.com/80/v2-a2576248ff4c0a7b6bfeb00cd34f6619_hd.jpg" alt="img"></p>
<p>可以看到阻塞 I/O 在两个步骤阶段都是阻塞的，等到数据报准备好和数据报从内核空间拷贝到用户空间之后，才会向用户侧的进程返回结果，此时用户侧的进程才能继续工作。</p>
<h3 id="2-、非阻塞-I-O"><a href="#2-、非阻塞-I-O" class="headerlink" title="2 、非阻塞 I/O"></a>2 、非阻塞 I/O</h3><p><img src="https://pic4.zhimg.com/80/v2-00e47334a74e9ad8eb66a5ca36181289_hd.jpg" alt="img"></p>
<p>非阻塞 I/O 的优化点在于第一阶段不是阻塞的，而是采取轮询的形式，如果数据报没有准备好，立刻返回一个错误 EWOULDBLOCK，此时用户侧进程不需要等待而是立刻得知此次询问的结果，然后进行重试直到数据报准备好再开始，但是再第二阶段拷贝数据报的时候依旧是阻塞的。</p>
<h3 id="3、-I-O-复用"><a href="#3、-I-O-复用" class="headerlink" title="3、 I/O 复用"></a>3、 I/O 复用</h3><p><img src="https://pic3.zhimg.com/80/v2-50bc7968407818f78ab3baab5b29b102_hd.jpg" alt="img"></p>
<p>本质上 I/O 复用的优化点在于让内核来负责非阻塞 I/O 时用户侧进程进行的反复重试操作，当内核发现某个套接字的数据报已经就绪时就通知进程。但是这里细心的你会发现，有两个系统调用，select 和 revfrom，但是由于 I/O 复用可以处理多个连接，性能还是有提升。</p>
<h2 id="4-、信号驱动-I-O"><a href="#4-、信号驱动-I-O" class="headerlink" title="4 、信号驱动 I/O"></a>4 、信号驱动 I/O</h2><p><img src="https://pic4.zhimg.com/80/v2-fd31b6ac102826ce9ac6cb6e629a24a0_hd.jpg" alt="img"></p>
<p>进程先创建一个信号处理 handler，然后内核立刻返回，进程可以去处理其他事情，等到数据报就绪，内核通过发送信号给之前的 handler 通知进程，然后进程在拷贝数据报期间阻塞。</p>
<h3 id="5-、异步-I-O"><a href="#5-、异步-I-O" class="headerlink" title="5 、异步 I/O"></a>5 、异步 I/O</h3><p><img src="https://pic1.zhimg.com/80/v2-1092eeaa0f367bb4bc0d4fd9c3b52e7a_hd.jpg" alt="img"></p>
<p>调用 aio_read 函数发起读取操作时其实是告诉内核 “当整个I/O操作完成后通知我们”。该系统调用会立即返回，进程不会被阻塞。当 I/O 阶段两个步骤完成后，内核会产生一个信号通知应用进程对数据报进行处理。</p>
<p>跟信号驱动 I/O 相比是告知进程何时进行数据拷贝操作，而异步 I/O 则是通知进程何时整个 I/O 操作完毕。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.tianshouzhi.com/api/tutorials/netty/221" target="_blank" rel="noopener">Unix五种IO模型</a></li>
<li><a href="http://www.rowkey.me/blog/2016/01/18/io-model/" target="_blank" rel="noopener">也谈IO模型</a></li>
<li><a href="https://blog.csdn.net/lihao21/article/details/51620374" target="_blank" rel="noopener">图解UNIX的I/O模型</a></li>
</ol>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><ul>
<li>本文遵守创作共享 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener"><strong>CC BY-NC-SA 3.0协议</strong></a></li>
</ul>
<p><a href="https://chenjiayang.me/2018/10/01/unix-io-model/" target="_blank" rel="noopener">原文链接</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EricMa"
      src="/images/eric.png">
  <p class="site-author-name" itemprop="name">EricMa</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">197</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Eric-Ma-C" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Eric-Ma-C" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chaoma@zju.edu.cn" title="E-Mail → mailto:chaoma@zju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EricMa</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">712k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
