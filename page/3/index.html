<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Eric&#39;s Blogs">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Eric&#39;s Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="EricMa">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Eric's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Eric's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Better Code, Better Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer(AQS)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer(AQS)/" class="post-title-link" itemprop="url">深入理解AbstractQueuedSynchronizer(AQS)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-30 11:00:41 / 修改时间：19:05:20" itemprop="dateCreated datePublished" datetime="2020-06-30T11:00:41+08:00">2020-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-AQS简介"><a href="#1-AQS简介" class="headerlink" title="1. AQS简介"></a>1. AQS简介</h1><p>在<a href="https://juejin.im/post/5aeb055b6fb9a07abf725c8c" target="_blank" rel="noopener">上一篇文章</a>中我们对lock和AbstractQueuedSynchronizer(AQS)有了初步的认识。在同步组件的实现中，AQS是核心部分，同步组件的实现者通过使用AQS提供的模板方法实现同步组件语义，AQS则实现了对<strong>同步状态的管理，以及对阻塞线程进行排队，等待通知</strong>等等一些底层的实现处理。AQS的核心也包括了这些方面:<strong>同步队列，独占式锁的获取和释放，共享锁的获取和释放以及可中断锁，超时等待锁获取这些特性的实现</strong>，而这些实际上则是AQS提供出来的模板方法，归纳整理如下：</p>
<p><strong>独占式锁：</strong></p>
<blockquote>
<p>void acquire(int arg)：独占式获取同步状态，如果获取失败则插入同步队列进行等待； void acquireInterruptibly(int arg)：与acquire方法相同，但在同步队列中进行等待的时候可以检测中断； boolean tryAcquireNanos(int arg, long nanosTimeout)：在acquireInterruptibly基础上增加了超时等待功能，在超时时间内没有获得同步状态返回false; boolean release(int arg)：释放同步状态，该方法会唤醒在同步队列中的下一个节点</p>
</blockquote>
<p><strong>共享式锁：</strong></p>
<blockquote>
<p>void acquireShared(int arg)：共享式获取同步状态，与独占式的区别在于同一时刻有多个线程获取同步状态； void acquireSharedInterruptibly(int arg)：在acquireShared方法基础上增加了能响应中断的功能； boolean tryAcquireSharedNanos(int arg, long nanosTimeout)：在acquireSharedInterruptibly基础上增加了超时等待的功能； boolean releaseShared(int arg)：共享式释放同步状态</p>
</blockquote>
<p>要想掌握AQS的底层实现，其实也就是对这些模板方法的逻辑进行学习。在学习这些模板方法之前，我们得首先了解下AQS中的同步队列是一种什么样的数据结构，因为同步队列是AQS对同步状态的管理的基石。</p>
<h1 id="2-同步队列"><a href="#2-同步队列" class="headerlink" title="2. 同步队列"></a>2. 同步队列</h1><p>当共享资源被某个线程占有，其他请求该资源的线程将会阻塞，从而进入同步队列。就数据结构而言，队列的实现方式无外乎两者一是通过数组的形式，另外一种则是链表的形式。AQS中的同步队列则是<strong>通过链式方式</strong>进行实现。接下来，很显然我们至少会抱有这样的疑问：<strong>1. 节点的数据结构是什么样的？2. 是单向还是双向？3. 是带头结点的还是不带头节点的？</strong>我们依旧先是通过看源码的方式。</p>
<p>在AQS有一个静态内部类Node，其中有这样一些属性：</p>
<blockquote>
<p>volatile int waitStatus //节点状态 volatile Node prev //当前节点/线程的前驱节点 volatile Node next; //当前节点/线程的后继节点 volatile Thread thread;//加入同步队列的线程引用 Node nextWaiter;//等待队列中的下一个节点</p>
</blockquote>
<p>节点的状态有以下这些：</p>
<blockquote>
<p>int CANCELLED =  1//节点从同步队列中取消 int SIGNAL    = -1//后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点的线程能够运行； int CONDITION = -2//当前节点进入等待队列中 int PROPAGATE = -3//表示下一次共享式同步状态获取将会无条件传播下去 int INITIAL = 0;//初始状态</p>
</blockquote>
<p>现在我们知道了节点的数据结构类型，并且每个节点拥有其前驱和后继节点，很显然这是<strong>一个双向队列</strong>。同样的我们可以用一段demo看一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例代码中开启了5个线程，先获取锁之后再睡眠10S中，实际上这里让线程睡眠是想模拟出当线程无法获取锁时进入同步队列的情况。通过debug，当Thread-4（在本例中最后一个线程）获取锁失败后进入同步时，AQS时现在的同步队列如图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/3/163261637bcef7e2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="LockDemo debug下 .png"></p>
<p>Thread-0先获得锁后进行睡眠，其他线程（Thread-1,Thread-2,Thread-3,Thread-4）获取锁失败进入同步队列，同时也可以很清楚的看出来每个节点有两个域：prev(前驱)和next(后继)，并且每个节点用来保存获取同步状态失败的线程引用以及等待状态等信息。另外AQS中有两个重要的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>

<p>也就是说AQS实际上通过头尾指针来管理同步队列，同时实现包括获取锁失败的线程进行入队，释放锁时对同步队列中的线程进行通知等核心方法。其示意图如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/3/163261637bb25796?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="队列示意图.png"></p>
<p>通过对源码的理解以及做实验的方式，现在我们可以清楚的知道这样几点：</p>
<ol>
<li><strong>节点的数据结构，即AQS的静态内部类Node,节点的等待状态等信息</strong>；</li>
<li><strong>同步队列是一个双向队列，AQS通过持有头尾指针管理同步队列</strong>；</li>
</ol>
<p>那么，节点如何进行入队和出队是怎样做的了？实际上这对应着锁的获取和释放两个操作：获取锁失败进行入队操作，获取锁成功进行出队操作。</p>
<h1 id="3-独占锁"><a href="#3-独占锁" class="headerlink" title="3. 独占锁"></a>3. 独占锁</h1><h2 id="3-1-独占锁的获取（acquire方法）"><a href="#3-1-独占锁的获取（acquire方法）" class="headerlink" title="3.1 独占锁的获取（acquire方法）"></a>3.1 独占锁的获取（acquire方法）</h2><p>我们继续通过看源码和debug的方式来看，还是以上面的demo为例，调用lock()方法是获取独占式锁，获取失败就将当前线程加入同步队列，成功则线程执行。而lock()方法实际上会调用AQS的<strong>acquire()</strong>方法，源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//先看同步状态是否获取成功，如果成功则方法结束返回</span></span><br><span class="line">		<span class="comment">//若失败则先调用addWaiter()方法再调用acquireQueued()方法</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键信息请看注释，acquire根据当前获得同步状态成功与否做了两件事情：1. 成功，则方法结束返回，2. 失败，则先调用addWaiter()然后在调用acquireQueued()方法。</p>
<blockquote>
<p><strong>获取同步状态失败，入队操作</strong></p>
</blockquote>
<p>当线程获取独占式锁失败后就会将当前线程加入同步队列，那么加入队列的方式是怎样的了？我们接下来就应该去研究一下addWaiter()和acquireQueued()。addWaiter()源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1. 将当前线程构建成Node类型</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// 2. 当前尾节点是否为null？</span></span><br><span class="line">		Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 2.2 将当前节点尾插入的方式插入同步队列中</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 2.1. 当前同步队列尾节点为null，说明当前线程是第一个加入同步队列进行等待的线程</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析可以看上面的注释。程序的逻辑主要分为两个部分：<strong>1. 当前同步队列的尾节点为null，调用方法enq()插入;2. 当前队列的尾节点不为null，则采用尾插入（compareAndSetTail（）方法）的方式入队。</strong>另外还会有另外一个问题：如果 <code>if (compareAndSetTail(pred, node))</code>为false怎么办？会继续执行到enq()方法，同时很明显compareAndSetTail是一个CAS操作，通常来说如果CAS操作失败会继续自旋（死循环）进行重试。因此，经过我们这样的分析，enq()方法可能承担两个任务：<strong>1. 处理当前同步队列尾节点为null时进行入队操作；2. 如果CAS尾插入节点失败后负责自旋进行尝试。</strong>那么是不是真的就像我们分析的一样了？只有源码会告诉我们答案:),enq()源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">			<span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">				<span class="comment">//1. 构造头结点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 2. 尾插入，CAS操作失败自旋尝试</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在上面的分析中我们可以看出在第1步中会先创建头结点，说明同步队列是<strong>带头结点的链式存储结构</strong>。带头结点与不带头结点相比，会在入队和出队的操作中获得更大的便捷性，因此同步队列选择了带头结点的链式存储结构。那么带头节点的队列初始化时机是什么？自然而然是在<strong>tail为null时，即当前线程是第一次插入同步队列</strong>。compareAndSetTail(t, node)方法会利用CAS操作设置尾节点，如果CAS操作失败会在<code>for (;;)</code>for死循环中不断尝试，直至成功return返回为止。因此，对enq()方法可以做这样的总结：</p>
<ol>
<li><strong>在当前线程是第一个加入同步队列时，调用compareAndSetHead(new Node())方法，完成链式队列的头结点的初始化</strong>；</li>
<li><strong>自旋不断尝试CAS尾插入节点直至成功为止</strong>。</li>
</ol>
<p>现在我们已经很清楚获取独占式锁失败的线程包装成Node然后插入同步队列的过程了？那么紧接着会有下一个问题？在同步队列中的节点（线程）会做什么事情了来保证自己能够有机会获得独占式锁了？带着这样的问题我们就来看看acquireQueued()方法，从方法名就可以很清楚，这个方法的作用就是排队获取锁的过程，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">				<span class="comment">// 1. 获得当前节点的先驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">				<span class="comment">// 2. 当前节点能否获取独占式锁					</span></span><br><span class="line">				<span class="comment">// 2.1 如果当前节点的先驱节点是头结点并且成功获取同步状态，即可以获得独占式锁</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">					<span class="comment">//队列头指针用指向当前节点</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">					<span class="comment">//释放前驱节点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// 2.2 获取锁失败，线程进入等待状态等待获取独占式锁</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序逻辑通过注释已经标出，整体来看这是一个这又是一个自旋的过程（for (;;)），代码首先获取当前节点的先驱节点，<strong>如果先驱节点是头结点的并且成功获得同步状态的时候（if (p == head &amp;&amp; tryAcquire(arg))），当前节点所指向的线程能够获取锁</strong>。反之，获取锁失败进入等待状态。整体示意图为下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/3/163261637c5fc765?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="自旋获取锁整体示意图.png"></p>
<blockquote>
<p><strong>获取锁成功，出队操作</strong></p>
</blockquote>
<p>获取锁的节点出队的逻辑是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列头结点引用指向当前节点</span></span><br><span class="line">setHead(node);</span><br><span class="line"><span class="comment">//释放前驱节点</span></span><br><span class="line">p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> interrupted;</span><br></pre></td></tr></table></figure>

<p>setHead()方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将当前节点通过setHead()方法设置为队列的头结点，然后将之前的头结点的next域设置为null并且pre域也为null，即与队列断开，无任何引用方便GC时能够将内存进行回收。示意图如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/3/163261637c63a47a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="当前节点引用线程获取锁，当前节点设置为队列头结点.png"></p>
<p>那么当获取锁失败的时候会调用shouldParkAfterFailedAcquire()方法和parkAndCheckInterrupt()方法，看看他们做了什么事情。shouldParkAfterFailedAcquire()方法源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shouldParkAfterFailedAcquire()方法主要逻辑是使用<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL)</code>使用CAS将节点状态由INITIAL设置成SIGNAL，表示当前线程阻塞。当compareAndSetWaitStatus设置失败则说明shouldParkAfterFailedAcquire方法返回false，然后会在acquireQueued()方法中for (;;)死循环中会继续重试，直至compareAndSetWaitStatus设置节点状态位为SIGNAL时shouldParkAfterFailedAcquire返回true时才会执行方法parkAndCheckInterrupt()方法，该方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使得该线程阻塞</span></span><br><span class="line">		LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的关键是会调用LookSupport.park()方法（关于LookSupport会在以后的文章进行讨论），该方法是用来阻塞当前线程的。因此到这里就应该清楚了，acquireQueued()在自旋过程中主要完成了两件事情：</p>
<ol>
<li><strong>如果当前节点的前驱节点是头节点，并且能够获得同步状态的话，当前线程能够获得锁该方法执行结束退出</strong>；</li>
<li><strong>获取锁失败的话，先将节点状态设置成SIGNAL，然后调用LookSupport.park方法使得当前线程阻塞</strong>。</li>
</ol>
<p>经过上面的分析，独占式锁的获取过程也就是acquire()方法的执行流程如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/3/163261637c891cc2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="独占式锁获取（acquire()方法）流程图.png"></p>
<h2 id="3-2-独占锁的释放（release-方法）"><a href="#3-2-独占锁的释放（release-方法）" class="headerlink" title="3.2 独占锁的释放（release()方法）"></a>3.2 独占锁的释放（release()方法）</h2><p>独占锁的释放就相对来说比较容易理解了，废话不多说先来看下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码逻辑就比较容易理解了，如果同步状态释放成功（tryRelease返回true）则会执行if块中的代码，当head指向的头结点不为null，并且该节点的状态值不为0的话才会执行unparkSuccessor()方法。unparkSuccessor方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//头节点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">		<span class="comment">//后继节点不为null时唤醒该线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码的关键信息请看注释，首先获取头节点的后继节点，当后继节点的时候会调用LookSupport.unpark()方法，该方法会唤醒该节点的后继节点所包装的线程。因此，<strong>每一次锁释放后就会唤醒队列中该节点的后继节点所引用的线程，从而进一步可以佐证获得锁的过程是一个FIFO（先进先出）的过程。</strong></p>
<p>到现在我们终于啃下了一块硬骨头了，通过学习源码的方式非常深刻的学习到了独占式锁的获取和释放的过程以及同步队列。可以做一下总结：</p>
<ol>
<li><strong>线程获取锁失败，线程被封装成Node进行入队操作，核心方法在于addWaiter()和enq()，同时enq()完成对同步队列的头结点初始化工作以及CAS操作失败的重试</strong>;</li>
<li><strong>线程获取锁是一个自旋的过程，当且仅当 当前节点的前驱节点是头结点并且成功获得同步状态时，节点出队即该节点引用的线程获得锁，否则，当不满足条件时就会调用LookSupport.park()方法使得线程阻塞</strong>；</li>
<li><strong>释放锁的时候会唤醒后继节点；</strong></li>
</ol>
<p>总体来说：<strong>在获取同步状态时，AQS维护一个同步队列，获取同步状态失败的线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是前驱节点是头结点并且成功获得了同步状态。在释放同步状态时，同步器会调用unparkSuccessor()方法唤醒后继节点。</strong></p>
<blockquote>
<p><strong>独占锁特性学习</strong></p>
</blockquote>
<h2 id="3-3-可中断式获取锁（acquireInterruptibly方法）"><a href="#3-3-可中断式获取锁（acquireInterruptibly方法）" class="headerlink" title="3.3 可中断式获取锁（acquireInterruptibly方法）"></a>3.3 可中断式获取锁（acquireInterruptibly方法）</h2><p>我们知道lock相较于synchronized有一些更方便的特性，比如能响应中断以及超时等待等特性，现在我们依旧采用通过学习源码的方式来看看能够响应中断是怎么实现的。可响应中断式锁可调用方法lock.lockInterruptibly();而该方法其底层会调用AQS的acquireInterruptibly方法，源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">		<span class="comment">//线程获取锁失败</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取同步状态失败后就会调用doAcquireInterruptibly方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="comment">//将节点插入到同步队列中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//获取锁出队</span></span><br><span class="line">			<span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">				<span class="comment">//线程中断抛异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键信息请看注释，现在看这段代码就很轻松了吧:),与acquire方法逻辑几乎一致，唯一的区别是当<strong>parkAndCheckInterrupt</strong>返回true时即线程阻塞时该线程被中断，代码抛出被中断异常。</p>
<h2 id="3-4-超时等待式获取锁（tryAcquireNanos-方法）"><a href="#3-4-超时等待式获取锁（tryAcquireNanos-方法）" class="headerlink" title="3.4 超时等待式获取锁（tryAcquireNanos()方法）"></a>3.4 超时等待式获取锁（tryAcquireNanos()方法）</h2><p>通过调用lock.tryLock(timeout,TimeUnit)方式达到超时等待获取锁的效果，该方法会在三种情况下才会返回：</p>
<ol>
<li>在超时时间内，当前线程成功获取了锁；</li>
<li>当前线程在超时时间内被中断；</li>
<li>超时时间结束，仍未获得锁返回false。</li>
</ol>
<p>我们仍然通过采取阅读源码的方式来学习底层具体是怎么实现的，该方法会调用AQS的方法tryAcquireNanos(),源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">		<span class="comment">//实现超时等待的效果</span></span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然这段源码最终是靠doAcquireNanos方法实现超时等待的效果，该方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//1. 根据超时时间和当前时间计算出截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">			<span class="comment">//2. 当前线程获得锁出队列</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 3.1 重新计算超时时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 3.2 已经超时返回false</span></span><br><span class="line">			<span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			<span class="comment">// 3.3 线程阻塞等待 </span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 3.4 线程被中断抛出被中断异常</span></span><br><span class="line">			<span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序逻辑如图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/3/163261637d087f5e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="超时等待式获取锁（doAcquireNanos()方法）"></p>
<p>程序逻辑同独占锁可响应中断式获取基本一致，唯一的不同在于获取锁失败后，对超时时间的处理上，在第1步会先计算出按照现在时间和超时时间计算出理论上的截止时间，比如当前时间是8h10min,超时时间是10min，那么根据<code>deadline = System.nanoTime() + nanosTimeout</code>计算出刚好达到超时时间时的系统时间就是8h 10min+10min = 8h 20min。然后根据<code>deadline - System.nanoTime()</code>就可以判断是否已经超时了，比如，当前系统时间是8h 30min很明显已经超过了理论上的系统时间8h 20min，<code>deadline - System.nanoTime()</code>计算出来就是一个负数，自然而然会在3.2步中的If判断之间返回false。如果还没有超时即3.2步中的if判断为true时就会继续执行3.3步通过<strong>LockSupport.parkNanos</strong>使得当前线程阻塞，同时在3.4步增加了对中断的检测，若检测出被中断直接抛出被中断异常。</p>
<h1 id="4-共享锁"><a href="#4-共享锁" class="headerlink" title="4. 共享锁"></a>4. 共享锁</h1><h2 id="4-1-共享锁的获取（acquireShared-方法）"><a href="#4-1-共享锁的获取（acquireShared-方法）" class="headerlink" title="4.1 共享锁的获取（acquireShared()方法）"></a>4.1 共享锁的获取（acquireShared()方法）</h2><p>在聊完AQS对独占锁的实现后，我们继续一鼓作气的来看看共享锁是怎样实现的？共享锁的获取方法为acquireShared，源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段源码的逻辑很容易理解，在该方法中会首先调用tryAcquireShared方法，tryAcquireShared返回值是一个int类型，当返回值为大于等于0的时候方法结束说明获得成功获取锁，否则，表明获取同步状态失败即所引用的线程获取锁失败，会执行doAcquireShared方法，该方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// 当该节点的前驱节点是头结点且成功获取同步状态</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在来看这段代码会不会很容易了？逻辑几乎和独占式锁的获取一模一样，这里的自旋过程中能够退出的条件<strong>是当前节点的前驱节点是头结点并且tryAcquireShared(arg)返回值大于等于0即能成功获得同步状态</strong>。</p>
<h2 id="4-2-共享锁的释放（releaseShared-方法）"><a href="#4-2-共享锁的释放（releaseShared-方法）" class="headerlink" title="4.2 共享锁的释放（releaseShared()方法）"></a>4.2 共享锁的释放（releaseShared()方法）</h2><p>共享锁的释放在AQS中会调用方法releaseShared：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当成功释放同步状态之后即tryReleaseShared会继续执行doReleaseShared方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段方法跟独占式锁释放过程有点点不同，在共享式锁的释放过程中，对于能够支持多个线程同时访问的并发组件，必须保证多个线程能够安全的释放同步状态，这里采用的CAS保证，当CAS操作失败continue，在下一次循环中进行重试。</p>
<h2 id="4-3-可中断（acquireSharedInterruptibly-方法），超时等待（tryAcquireSharedNanos-方法）"><a href="#4-3-可中断（acquireSharedInterruptibly-方法），超时等待（tryAcquireSharedNanos-方法）" class="headerlink" title="4.3 可中断（acquireSharedInterruptibly()方法），超时等待（tryAcquireSharedNanos()方法）"></a>4.3 可中断（acquireSharedInterruptibly()方法），超时等待（tryAcquireSharedNanos()方法）</h2><p>关于可中断锁以及超时等待的特性其实现和独占式锁可中断获取锁以及超时等待的实现几乎一致，具体的就不再说了，如果理解了上面的内容对这部分的理解也是水到渠成的。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5aeb07ab6fb9a07ac36350c8" target="_blank" rel="noopener">深入理解AbstractQueuedSynchronizer(AQS)</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/30/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/30/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">git基本操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-30 09:11:33 / 修改时间：17:14:58" itemprop="dateCreated datePublished" datetime="2020-06-30T09:11:33+08:00">2020-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">版本控制</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-git简介"><a href="#1-git简介" class="headerlink" title="1. git简介"></a>1. git简介</h1><p>在实际开发中，会使用git作为版本控制工具来完成团队协作。因此，对基本的git操作指令进行总结是十分有必要的，本文对一些术语或者理论基础，不重新码字，可以<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">参考廖雪峰老师的博文</a>，本文只对命令做归纳总结。</p>
<p>git的通用操作流程如下图（来源于网络）</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcc0987bf1c0a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="git操作通用流程"></p>
<p>主要涉及到四个关键点：</p>
<ol>
<li>工作区：本地电脑存放项目文件的地方，比如learnGitProject文件夹；</li>
<li>暂存区（Index/Stage）：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版本库。其中.git文件夹中包含了两个部分，一个是暂存区（Index或者Stage）,顾名思义就是暂时存放文件的地方，通常使用add命令将工作区的文件添加到暂存区里；</li>
<li>本地仓库：.git文件夹里还包括git自动创建的master分支，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中的文件添加到本地仓库中；</li>
<li>远程仓库：不是在本地仓库中，项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可；</li>
</ol>
<p>更细节的来看：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcc0e7e711dc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="git几个核心区域间的关系"></p>
<p>日常开发时代码实际上放置在工作区中，也就是本地的XXX.java这些文件，通过add等这些命令将代码文教提交给暂存区（Index/Stage），也就意味着代码全权交给了git进行管理，之后通过commit等命令将暂存区提交给master分支上，也就是意味打了一个版本，也可以说代码提交到了本地仓库中。另外，团队协作过程中自然而然还涉及到与远程仓库的交互。</p>
<p>因此，经过这样的分析，git命令可以分为这样的逻辑进行理解和记忆：</p>
<ol>
<li><p>git管理配置的命令；</p>
<p><strong>几个核心存储区的交互命令：</strong></p>
</li>
<li><p>工作区与暂存区的交互；</p>
</li>
<li><p>暂存区与本地仓库（分支）上的交互；</p>
</li>
<li><p>本地仓库与远程仓库的交互。</p>
</li>
</ol>
<h1 id="2-git配置命令"><a href="#2-git配置命令" class="headerlink" title="2. git配置命令"></a>2. git配置命令</h1><blockquote>
<p>查询配置信息</p>
</blockquote>
<ol>
<li>列出当前配置：<code>git config --list</code>;</li>
<li>列出repository配置：<code>git config --local --list</code>;</li>
<li>列出全局配置：<code>git config --global --list</code>;</li>
<li>列出系统配置：<code>git config --system --list</code>;</li>
</ol>
<blockquote>
<p>第一次使用git，配置用户信息</p>
</blockquote>
<ol>
<li>配置用户名：<code>git config --global user.name &quot;your name&quot;</code>;</li>
<li>配置用户邮箱：<code>git config --global user.email &quot;youremail@github.com&quot;</code>;</li>
</ol>
<blockquote>
<p>其他配置</p>
</blockquote>
<ol>
<li>配置解决冲突时使用哪种差异分析工具，比如要使用vimdiff：<code>git config --global merge.tool vimdiff</code>;</li>
<li>配置git命令输出为彩色的：<code>git config --global color.ui auto</code>;</li>
<li>配置git使用的文本编辑器：<code>git config --global core.editor vi</code>;</li>
</ol>
<h1 id="3-工作区上的操作命令"><a href="#3-工作区上的操作命令" class="headerlink" title="3. 工作区上的操作命令"></a>3. 工作区上的操作命令</h1><blockquote>
<p>新建仓库</p>
</blockquote>
<ol>
<li>将工作区中的项目文件使用git进行管理，即创建一个新的本地仓库：<code>git init</code>；</li>
<li>从远程git仓库复制项目：<code>git clone</code>，如：git clone git://github.com/wasd/example.git;克隆项目时如果想定义新的项目名，可以在clone命令后指定新的项目名：<code>git clone git://github.com/wasd/example.git mygit</code>；</li>
</ol>
<blockquote>
<p>提交</p>
</blockquote>
<ol>
<li>提交工作区所有文件到暂存区：<code>git add .</code></li>
<li>提交工作区中指定文件到暂存区：<code>git add   ...</code>;</li>
<li>提交工作区中某个文件夹中所有文件到暂存区：<code>git add [dir]</code>;</li>
</ol>
<blockquote>
<p>撤销</p>
</blockquote>
<ol>
<li>删除工作区文件，并且也从暂存区删除对应文件的记录：<code>git rm</code>;</li>
<li>从暂存区中删除文件，但是工作区依然还有该文件:<code>git rm --cached</code>;</li>
<li>取消暂存区已经暂存的文件：<code>git reset HEAD ...</code>;</li>
<li>撤销上一次对文件的操作：<code>git checkout --</code>。要确定上一次对文件的修改不再需要，如果想保留上一次的修改以备以后继续工作，可以使用stashing和分支来处理；</li>
<li>隐藏当前变更，以便能够切换分支：<code>git stash</code>；</li>
<li>查看当前所有的储藏：<code>git stash list</code>；</li>
<li>应用最新的储藏：<code>git stash apply</code>，如果想应用更早的储藏：<code>git stash apply stash@{2}</code>；重新应用被暂存的变更，需要加上<code>--index</code>参数：<code>git stash apply --index</code>;</li>
<li>使用apply命令只是应用储藏，而内容仍然还在栈上，需要移除指定的储藏：<code>git stash drop stash{0}</code>；如果使用pop命令不仅可以重新应用储藏，还可以立刻从堆栈中清除：<code>git stash pop</code>;</li>
<li>在某些情况下，你可能想应用储藏的修改，在进行了一些其他的修改后，又要取消之前所应用储藏的修改。Git没有提供类似于 stash unapply 的命令，但是可以通过取消该储藏的补丁达到同样的效果：<code>git stash show -p stash@{0} | git apply -R</code>；同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏：<code>git stash show -p | git apply -R</code>；</li>
</ol>
<blockquote>
<p>更新文件</p>
</blockquote>
<ol>
<li>重命名文件，并将已改名文件提交到暂存区：<code>git mv [file-original] [file-renamed]</code>;</li>
</ol>
<blockquote>
<p>查新信息</p>
</blockquote>
<ol>
<li>查询当前工作区所有文件的状态：<code>git status</code>;</li>
<li>比较工作区中当前文件和暂存区之间的差异，也就是修改之后还没有暂存的内容：git diff；指定文件在工作区和暂存区上差异比较：<code>git diff</code>;</li>
</ol>
<h1 id="4-暂存区上的操作命令"><a href="#4-暂存区上的操作命令" class="headerlink" title="4. 暂存区上的操作命令"></a>4. 暂存区上的操作命令</h1><blockquote>
<p>提交文件到版本库</p>
</blockquote>
<ol>
<li>将暂存区中的文件提交到本地仓库中，即打上新版本：<code>git commit -m &quot;commit_info&quot;</code>;</li>
<li>将所有已经使用git管理过的文件暂存后一并提交，跳过add到暂存区的过程：<code>git commit -a -m &quot;commit_info&quot;</code>;</li>
<li>提交文件时，发现漏掉几个文件，或者注释写错了，可以撤销上一次提交：<code>git commit --amend</code>;</li>
</ol>
<blockquote>
<p>查看信息</p>
</blockquote>
<ol>
<li>比较暂存区与上一版本的差异：<code>git diff --cached</code>;</li>
<li>指定文件在暂存区和本地仓库的不同：<code>git diff  --cached</code>;</li>
<li>查看提交历史：git log；参数<code>-p</code>展开每次提交的内容差异，用<code>-2</code>显示最近的两次更新，如<code>git log -p -2</code>;</li>
</ol>
<blockquote>
<p>打标签</p>
</blockquote>
<p>Git 使用的标签有两种类型：<strong>轻量级的（lightweight）和含附注的（annotated）</strong>。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</p>
<ol>
<li>列出现在所有的标签：<code>git tag</code>;</li>
<li>使用特定的搜索模式列出符合条件的标签，例如只对1.4.2系列的版本感兴趣：<code>git tag -l &quot;v1.4.2.*&quot;</code>;</li>
<li>创建一个含附注类型的标签，需要加<code>-a</code>参数，如<code>git tag -a v1.4 -m &quot;my version 1.4&quot;</code>;</li>
<li>使用git show命令查看相应标签的版本信息，并连同显示打标签时的提交对象：<code>git show v1.4</code>;</li>
<li>如果有自己的私钥，可以使用GPG来签署标签，只需要在命令中使用<code>-s</code>参数：<code>git tag -s v1.5 -m &quot;my signed 1.5 tag&quot;</code>;</li>
<li>验证已签署的标签：git tag -v ，如<code>git tag -v v1.5</code>;</li>
<li>创建一个轻量级标签的话，就直接使用git tag命令即可，连<code>-a</code>,<code>-s</code>以及<code>-m</code>选项都不需要，直接给出标签名字即可，如<code>git tag v1.5</code>;</li>
<li>将标签推送到远程仓库中：git push origin ，如<code>git push origin v1.5</code>；</li>
<li>将本地所有的标签全部推送到远程仓库中：<code>git push origin --tags</code>;</li>
</ol>
<blockquote>
<p>分支管理</p>
</blockquote>
<ol>
<li>创建分支：<code>git branch</code>，如<code>git branch testing</code>；</li>
<li>从当前所处的分支切换到其他分支：<code>git checkout</code>，如<code>git checkout testing</code>；</li>
<li>新建并切换到新建分支上：<code>git checkout -b</code>;</li>
<li>删除分支：<code>git branch -d</code>；</li>
<li>将当前分支与指定分支进行合并：<code>git merge</code>;</li>
<li>显示本地仓库的所有分支：<code>git branch</code>;</li>
<li>查看各个分支最后一个提交对象的信息：<code>git branch -v</code>;</li>
<li>查看哪些分支已经合并到当前分支：<code>git branch --merged</code>;</li>
<li>查看当前哪些分支还没有合并到当前分支：<code>git branch --no-merged</code>;</li>
<li>把远程分支合并到当前分支：<code>git merge /</code>，如<code>git merge origin/serverfix</code>；如果是单线的历史分支不存在任何需要解决的分歧，只是简单的将HEAD指针前移，所以这种合并过程可以称为快进（Fast forward），而如果是历史分支是分叉的，会以当前分叉的两个分支作为两个祖先，创建新的提交对象；如果在合并分支时，遇到合并冲突需要人工解决后，再才能提交；</li>
<li>在远程分支的基础上创建新的本地分支<code>：git checkout -b  /</code>，如<code>git checkout -b serverfix origin/serverfix</code>;</li>
<li>从远程分支checkout出来的本地分支，称之为跟踪分支。在跟踪分支上向远程分支上推送内容：<code>git push</code>。该命令会自动判断应该向远程仓库中的哪个分支推送数据；在跟踪分支上合并远程分支：<code>git pull</code>；</li>
<li>将一个分支里提交的改变移到基底分支上重放一遍：<code>git rebase</code>，如<code>git rebase master server</code>，将特性分支server提交的改变在基底分支master上重演一遍；使用rebase操作最大的好处是像在单个分支上操作的，提交的修改历史也是一根线；如果想把基于一个特性分支上的另一个特性分支变基到其他分支上，可以使用<code>--onto</code>操作：<code>git rebase --onto</code>，如<code>git rebase --onto master server client</code>；使用rebase操作应该遵循的原则是：<strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行rebase操作</strong>；</li>
</ol>
<h1 id="5-本地仓库上的操作"><a href="#5-本地仓库上的操作" class="headerlink" title="5.本地仓库上的操作"></a>5.本地仓库上的操作</h1><ol>
<li>查看本地仓库关联的远程仓库：<code>git remote</code>；在克隆完每个远程仓库后，远程仓库默认为<code>origin</code>;加上<code>-v</code>的参数后，会显示远程仓库的<code>url</code>地址；</li>
<li>添加远程仓库，一般会取一个简短的别名：<code>git remote add [remote-name] [url]</code>，比如：<code>git remote add example git://github.com/example/example.git</code>;</li>
<li>从远程仓库中抓取本地仓库中没有的更新：<code>git fetch [remote-name]</code>，如<code>git fetch origin</code>;使用fetch只是将远端数据拉到本地仓库，并不自动合并到当前工作分支，只能人工合并。如果设置了某个分支关联到远程仓库的某个分支的话，可以使用<code>git pull</code>来拉去远程分支的数据，然后将远端分支自动合并到本地仓库中的当前分支；</li>
<li>将本地仓库某分支推送到远程仓库上：<code>git push [remote-name] [branch-name]</code>，如<code>git push origin master</code>；如果想将本地分支推送到远程仓库的不同名分支：<code>git push  :</code>，如<code>git push origin serverfix:awesomebranch</code>;如果想删除远程分支：<code>git push [romote-name] :</code>，如<code>git push origin :serverfix</code>。这里省略了本地分支，也就相当于将空白内容推送给远程分支，就等于删掉了远程分支。</li>
<li>查看远程仓库的详细信息：<code>git remote show origin</code>；</li>
<li>修改某个远程仓库在本地的简称：<code>git remote rename [old-name] [new-name]</code>，如<code>git remote rename origin org</code>；</li>
<li>移除远程仓库：<code>git remote rm [remote-name]</code>；</li>
</ol>
<h1 id="6-忽略文件-gitignore"><a href="#6-忽略文件-gitignore" class="headerlink" title="6. 忽略文件.gitignore"></a>6. 忽略文件.gitignore</h1><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。如下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line"># 忽略所有 .a 结尾的文件</span><br><span class="line">*.a</span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!lib.a</span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir&#x2F;TODO</span><br><span class="line">&#x2F;TODO</span><br><span class="line"># 忽略 build&#x2F; 目录下的所有文件</span><br><span class="line">build&#x2F;</span><br><span class="line"># 会忽略 doc&#x2F;notes.txt 但不包括 doc&#x2F;server&#x2F;arch.txt</span><br><span class="line">doc&#x2F;*.txt</span><br><span class="line"># 忽略 doc&#x2F; 目录下所有扩展名为 txt 的文件</span><br><span class="line">doc&#x2F;**&#x2F;*.txt</span><br></pre></td></tr></table></figure>



<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5ae072906fb9a07a9e4ce596" target="_blank" rel="noopener">git基本操作</a></p>
<p><a href="https://git-scm.com/book/zh/v1/起步-关于版本控制" target="_blank" rel="noopener">非常详细准确的git学习资料</a>；</p>
<p><a href="https://github.com/flyhigher139/Git-Cheat-Sheet#配置" target="_blank" rel="noopener">git-cheat-sheet中文版</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">命令总结，资料一般，不够详细，作参考</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用命令很全</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/30/MySQL%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/30/MySQL%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">MySQL命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-30 09:04:35 / 修改时间：17:09:26" itemprop="dateCreated datePublished" datetime="2020-06-30T09:04:35+08:00">2020-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>MySQL的基本操作可以包括两个方面：MySQL常用语句如高频率使用的增删改查（CRUD）语句和MySQL高级功能，如存储过程，触发器，事务处理等。而这两个方面又可以细分如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/17/162d138e4ae68c7e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="MySQL基本操作总结.png"></p>
<ul>
<li>MySQL常用语句<ol>
<li>表（或者数据库）的CRUD</li>
<li>表数据的CRUD，其中表数据查询使用最多，也更复杂。查询可以按照单表还是多表可以分为：单表SELECT查询和多表的联结查询（INNER JOIN, LEFT JOIN, RIGHT JOIN和FULL JOIN）以及组合查询UNION和UNION ALL</li>
<li>SQL语句中各个关键字的执行顺序</li>
</ol>
</li>
<li>MySQL的高级功能<ol>
<li>存储过程</li>
<li>事务处理</li>
<li>触发器</li>
</ol>
</li>
</ul>
<h1 id="1-表-或数据库-操作语句"><a href="#1-表-或数据库-操作语句" class="headerlink" title="1. 表(或数据库)操作语句"></a>1. 表(或数据库)操作语句</h1><h2 id="1-1-查询表（或数据库）"><a href="#1-1-查询表（或数据库）" class="headerlink" title="1.1. 查询表（或数据库）"></a>1.1. 查询表（或数据库）</h2><ol>
<li><strong>获取所有可用的数据库</strong>：<code>SHOW DATABASES</code>；</li>
<li><strong>选择数据库</strong>：<code>USE customers</code>；</li>
<li>用于显示数据库服务器的状态信息：<code>SHOW STATUS</code>；</li>
<li>用来显示授权用户的安全权限：<code>SHOW GRANTS</code>；</li>
<li>用来显示数据库服务器或警告信息：<code>SHOW ERRORS</code> 或者 <code>SHOW WARNINGS</code>；</li>
<li><strong>用于显示创建数据库时的创建语句</strong>：<code>SHOW CREATE DATABASE customers</code>；</li>
<li><strong>用于显示创建表时的创建语句</strong>：<code>SHOW CREATE TABLE customers</code>；</li>
<li><strong>获取当前所选的数据库中所有可用的表</strong>：<code>SHOW TABLES</code>；</li>
<li><strong>获取表中所有列的信息</strong>：<code>SHOW COLUMNS FROM tableName</code>；同时DESCRIBE语句有相同的效果：<code>DESCRIBE tableName</code>；</li>
</ol>
<h2 id="1-2-新建表（或）数据库"><a href="#1-2-新建表（或）数据库" class="headerlink" title="1.2. 新建表（或）数据库"></a>1.2. 新建表（或）数据库</h2><ol>
<li><p><strong>新建数据库</strong>：<code>CREATE DATABASE customers</code>;</p>
</li>
<li><p><strong>创建表可以使用CREATE TABLE语句</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers(</span><br><span class="line">  cust_id <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  cust_name <span class="built_in">CHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  cust_age <span class="built_in">INT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(cust_id)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure>

<p>有这样一些细节：</p>
<ol>
<li>允许<strong>NULL</strong>值，则说明在插入行数据时允许不给出该列的值，而<strong>NOT NULL</strong>则表示在插入或者更新该列数据，必须明确给出该列的值；</li>
<li><strong>DEFAULT</strong>表示该列的默认值，在插入行数据时，若没有给出该列的值就会使用其指定的默认值；</li>
<li><strong>PRIMARY KEY</strong>用于指定主键，主键可以指定一列数据，而可以由多列数据组合构成，如<code>PRIMARY KEY(cust_id,cust_name)</code>；</li>
<li><strong>ENGINE</strong>用于指定引擎类型。常见的引擎类型有这些：（1）InnoDB是一个支持可靠的事务处理的引擎，但是不支持全文本搜索；（2）MyISAM是一个性能极高的引擎，它支持全文本搜索，但是不支持事务处理；（3）MEMORY在功能上等同于MyISAM，但由于数据存储在内存中，速度很快（特别适合于临时表）；</li>
</ol>
</li>
<li><p>在创建表的时候可以使用<strong>FOREIGN KEY</strong>来创建外键，即一个表中的FOREIGN KEY指向另一个表中PRIMARY KEY。外键FOREIGN KEY用于约束破坏表的联结动作，保证两个表的数据完整性。同时也能防止非法数据插入外键列，因为该列值必须指向另一个表的主键。实例为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">Id_O <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">OrderNo <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">Id_P <span class="built_in">int</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (Id_O),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Id_P) <span class="keyword">REFERENCES</span> Persons(Id_P)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="1-3-删除表（或数据库）"><a href="#1-3-删除表（或数据库）" class="headerlink" title="1.3 删除表（或数据库）"></a>1.3 删除表（或数据库）</h2><ol>
<li><strong>删除数据库</strong>：<code>DROP DATABASE customers</code>；</li>
<li><strong>删除表</strong>，使用DROP TABLE子句：<code>DROP TABLE customers</code>。</li>
</ol>
<h2 id="1-4-更新表"><a href="#1-4-更新表" class="headerlink" title="1.4 更新表"></a>1.4 更新表</h2><ol>
<li><p>更新表结构信息可以使用<strong>ALTER TABLE</strong>子句，如为表增加一列：<code>ALTER TABLE vendors ADD vend_name CHAR(20)</code>；另外经常用于定义外键，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customers </span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_custormer_orders</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(cust_id) <span class="keyword">REFERENCES</span> orders (order_cust)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重命名表，使用RENAME子句</strong>。<code>RENAME TABLE backup_customers TO customers, backup_vendors TO vendors</code>；更改多个表名，之间用逗号间隔</p>
</li>
</ol>
<h1 id="2-表数据操作语句"><a href="#2-表数据操作语句" class="headerlink" title="2 表数据操作语句"></a>2 表数据操作语句</h1><h2 id="2-1-查询表数据"><a href="#2-1-查询表数据" class="headerlink" title="2.1 查询表数据"></a>2.1 查询表数据</h2><blockquote>
<p><strong>基本查询语句</strong></p>
</blockquote>
<ol>
<li>根据过滤条件查询表中的单列或者多列或者全部列的信息<strong>SELECT FROM WEHERE</strong>：<code>SELECT cust_id,cust_name FROM customers WHERE cust_id=10086</code>；其中过滤条件操作符有：=，&lt;&gt;,!=,&lt;,&lt;=,&gt;,&gt;=,BETWEEN AND,IS NULL；</li>
<li>为查询出的某一列信息去重<strong>DISTINCT</strong>：<code>SELECT DISTINCT cust_name FROM customers</code>；</li>
<li>限制单列查询结果的行数：<code>SELECT cust_name FROM customers LIMIT 5</code>；LIMIT后跟一个数值，表示从第0行开始取，共取5行数据；如果LIMIT 5，5表示从第5行（数据库中实际第6行记录）开始取，共取5行数据。注意：数据是从第0行开始计数的；</li>
<li><strong>ORDER BY</strong>子句取一个或者多个列，据此对输出进行排序：<code>SELECT cust_id,cust_name FROM customers ORDER BY cust_id DESC, cust_name</code>;</li>
<li><strong>IN</strong>操作符用来指定条件范围，范围中的每个条件都可以进行匹配：<code>SELECT cust_id, cust_name FROM customers WHERE cust_id IN (1000,2000)</code>。另外，NOT操作符可以和IN操作符配合使用，用于表示检索出不符合条件的所有数据；</li>
<li><strong>LIKE</strong>操作符用来表明模糊查询，与之配合使用的通配符有<strong>%</strong>，%表示任何字符出现任何次数；<code>_</code>，<code>_</code>表示只能匹配一个字符：<code>SELECT cust_id,cust_name FROM customers WHERE cust_name LIKE &#39;%happy%&#39;</code>；</li>
<li>使用分组查询并可以满足一定的分组过滤条件<strong>GROUP BY HAVING</strong>。如检索总计订单金额大于等于50的订单号和订单总金额，并按总金额进行排序：<code>SELECT order_num,SUM(quantity*item_price) AS order_total FROM orderitems GROUP BY order_num HAVING SUM(quantity*item_price)&gt;=50 ORDER BY order_total</code></li>
<li><strong>WHERE和HAVING的比较</strong>。WHERE是行级过滤，而HAVING是组级过滤。被WHERE过滤掉的数据不会出现在分组中。WHERE中通配符以及多个WHERE子句的连接同样适用于HAVING子句；</li>
<li>GROUP BY的使用注意事项： （1）GROUP BY子句中可以嵌套分组（即通过多个列进行分组<code>GROUP BY cust_id, cust_name</code>），但是进行数据汇总时，是在最后规定的分组上进行；（2）GROUP BY子句中列出的每个列都必须是检索列或者是有效的表达式。（3）如果有NULL值，将值NULL作为一个分组进行返回，如果有多行NULL值，它们将分为一组</li>
<li>嵌套其他查询中的查询，称之为<strong>子查询</strong>。执行过程由里向外，里层查询结果作为外层查询的条件：<code>SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = &#39;happy&#39;)</code>。当然，多表的查询可以是用联结查询。</li>
</ol>
<blockquote>
<p><strong>联结查询</strong></p>
</blockquote>
<ol>
<li>内联结用又称之为内部联结，是基于两个表 之间的的相等测试。如果不加过滤条件，会造成“笛卡尔积”。<code>SELECT vend_name,prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id=products.vend_id</code>；同样可以使用WHERE进行多表联结查询，但是更推荐使用INNER JOIN等联结方式；</li>
<li>外部联结包括左外联结<strong>LEFT JOIN</strong>和右外联结<strong>RIGHT JOIN</strong>和全连接<strong>FULL JOIN</strong>。例如查询每个客户的订单数：<code>SELECT customers.cust_id,orders.orders_num FROM customers LEFT JOIN orders ON orders.cust_id =customers.cust_id</code>；LEFT JOIN 会全部返回左表数据，RIGHT JOIN会全部返回右表数据，FULL JOIN会将左右两个表的数据全部返回；</li>
<li>联结查询与聚集函数一起使用。如查询每个客户的订单数：<code>SELECT customers.cust_name,customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id=orders.cust_id GROUP BY customers.cust_id</code>；</li>
</ol>
<blockquote>
<p><strong>组合查询</strong></p>
</blockquote>
<ol>
<li>多个查询（SELECT）可以使用UNION将多个查询结果进行合并成一个结果集返回，<strong>UNIO</strong>N必须包含两个及两个以上的SELECT查询，并且每个传必须包含相同的列、表达式或聚集函数，数据类型不必完全相同，MySQL会进行隐式的类型转换。<code>SELECT vend_id,prod_id,prod_price FROM products WHERE prod_price&gt;5 UINON SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002)</code>;</li>
<li><strong>UNION</strong>返回的是去重后的结果，如果不需要去重则可以使用<strong>UNION ALL</strong>；</li>
<li>可以多组合查询使用ORDER BY进行排序，但是是针对的最终的结果集进行排序，而不是其中单个SELECT查询进行排序，因此对于组合查询来说ORDER BY子句只有一个。<code>SELECT vend_id,prod_id,prod_price FROM products WHERE prod_price&gt;5 UINON SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002) ORDER BY vend_id</code></li>
</ol>
<blockquote>
<p><strong>使用函数对数据进行处理</strong></p>
</blockquote>
<ol>
<li>拼接列名：<code>SELECT Concat (vendName,&#39;(&#39;,vendCountry,&#39;)&#39;) FROM vendors ORDER BY vendName</code>；</li>
<li>执行算术表达式计算：<code>SELECT prodId, quantity,price, quantity</code>*<code>price AS expandedPrice FROM orderItems</code>；</li>
<li>文本处理函数如Upper(),LTrim(),RTrim()等函数。比如使用Upper函数将文本转换成大写：<code>SELECT vendName, Upper(vendName) FROM vendors ORDER BY vendName</code>；</li>
<li>时间和日期处理函数，如Date(),Day()等。<code>SELECT custId, orderNum FROM orders WHERE Date(orderDate)=&#39;2015-09-01&#39;</code>；</li>
<li>数值处理函数，如Abs(),Cos()等；</li>
<li>常用的聚集函数。如AVG(),COUNT(),MAX(),MIN()以及SUM()。<code>SELECT COUNT(*) AS numbers, MIN(prod_price) AS price_min, MAX(prod_price) AS price_max,AVG(prod_price) AS price_avg FROM products</code>；</li>
</ol>
<h2 id="2-2-插入表数据"><a href="#2-2-插入表数据" class="headerlink" title="2.2 插入表数据"></a>2.2 插入表数据</h2><ol>
<li>向表中插入行数据可以使用INSERT INTO子句，更安全的方式是指定列名。<code>INSERT INTO customers (cust_name, cust_email) VALUES(&#39;happy&#39;,&#39;happy@gmail.com&#39;)</code>；在INSERT INTO子句中能够省略列名的前提条件是：该列可以允许定义为NULL值或者在定义该列时给出去了默认值；</li>
<li>如果插入多行数据可以将多组值用逗号进行分隔即可。<code>INSERT INTO customers (cust_name, cust_email) VALUES(&#39;happy&#39;,&#39;happy@gmail.com&#39;),(&#39;smart&#39;,&#39;smart@gmail.com&#39;)</code>；</li>
<li>将查询出来的数据插入表中，可以使用INSERT SELECT语句。<code>INSERT INTO customers(cust_id,cust_contact) SELECT cust_id, cust_contact FROM customers WHERE cust_id&gt;5</code>；其中SELECT中可以带WHERE过滤条件；INSERT SELECT通常被用于复制表数据</li>
</ol>
<h2 id="2-3-更新表数据"><a href="#2-3-更新表数据" class="headerlink" title="2.3 更新表数据"></a>2.3 更新表数据</h2><ol>
<li>如果要更新表数据的话，使用UPDATE子句：<code>UPDATE customers SET cust_name =&#39;happy&#39;,cust_email=&#39;happy@gmail.com&#39; WHERE cust_id = 1001</code>；</li>
<li><strong>注意：如果不加WHERE条件指定到某一行的话，会更新表中某一列全部的数据</strong>。</li>
</ol>
<h2 id="2-4-删除表数据"><a href="#2-4-删除表数据" class="headerlink" title="2.4 删除表数据"></a>2.4 删除表数据</h2><ol>
<li>如果从表中删除数据的话，可以使用DELETE子句。<code>DELETE FROM customers WHERE cust_id = 10086</code>；删除的数据必定是表中行数据，而不是某一列。因此，与UPDATE子句相比，DELETE子句并不需要指定是哪一列，而仅仅只需要指定具体的表名即可；</li>
<li><strong>注意：如果不添加WHERE指定条件的话，会将整个表中所有行数据全部删除。另外，DELETE只是删除表中的数据，而不会删除表结构信息；</strong></li>
<li>如果想删除表中全部的数据，可以使用<strong>TRUNCATE</strong>，比DELETE删除效率更高；</li>
</ol>
<h1 id="3-SQL中关键字执行顺序"><a href="#3-SQL中关键字执行顺序" class="headerlink" title="3. SQL中关键字执行顺序"></a>3. SQL中关键字执行顺序</h1><p>在SQL语句中每个关键字都会按照顺序往下执行，而每一步操作，会生成一个虚拟表，最后产生的虚拟表会作为执行的最终结果返回。下面的是常用的关键字的执行顺序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(8)<span class="keyword">SELECT</span> (<span class="number">9</span>)<span class="keyword">DISTINCT</span>&lt;select_list&gt;</span><br><span class="line">(<span class="number">1</span>)<span class="keyword">FROM</span> &lt;left_table&gt;</span><br><span class="line">(<span class="number">3</span>)&lt;join_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt;</span><br><span class="line">(<span class="number">2</span>)            <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line">(<span class="number">4</span>)<span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line">(<span class="number">5</span>)<span class="keyword">GROUP</span> <span class="keyword">BY</span>&lt;group_by_list&gt;</span><br><span class="line">(<span class="number">6</span>)<span class="keyword">WITH</span>&#123;<span class="keyword">CUBE</span>|<span class="keyword">ROLLUP</span>&#125;</span><br><span class="line">(<span class="number">7</span>)<span class="keyword">HAVING</span>&lt;having_condition&gt;</span><br><span class="line">(<span class="number">10</span>)<span class="keyword">ORDER</span> <span class="keyword">BY</span>&lt;order_by_list&gt;</span><br><span class="line">(<span class="number">11</span>)<span class="keyword">LIMIT</span>&lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>FROM</strong>：对FROM左边的表和右边的表计算笛卡尔积，产生虚表VT1；</li>
<li><strong>ON</strong>：对虚拟表VT1进行ON筛选，只有那些符合<join_condition>条件的行才会被记录在虚拟表VT2中；</li>
<li><strong>JOIN</strong>：如果是OUT JOIN，那么将保留表中（如左表或者右表）未匹配的行作为外部行添加到虚拟表VT2中，从而产生虚拟表VT3；</li>
<li><strong>WHERE</strong>:对虚拟表VT3进行WHERE条件过滤，只有符合<where_condition>的记录才会被放入到虚拟表VT4；</li>
<li><strong>GROUP BY</strong>：根据GROUP BY子句中的列，对虚拟表VT4进行分组操作，产生虚拟表VT5；</li>
<li><strong>CUBE|ROLLUP</strong>：对虚拟表VT5进行CUBE或者ROLLUP操作，产生虚拟表VT6；</li>
<li><strong>HAVING</strong>：对虚拟表VT6进行HAVING条件过滤，只有符合<having_condition>的记录才会被插入到虚拟表VT7中；</li>
<li><strong>SELECT</strong>：执行SELECT操作，选择指定的列，插入到虚拟表VT8中；</li>
<li><strong>DISTINCT</strong>：对虚拟表VT8中的记录进行去重，产生虚拟表VT9；</li>
<li><strong>ORDER BY</strong>：将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10；</li>
<li><strong>LIMIT</strong>：取出指定行的记录，产生虚拟表VT11，并将结果返回。</li>
</ol>
<h1 id="4-索引"><a href="#4-索引" class="headerlink" title="4. 索引"></a>4. 索引</h1><p>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，而组合索引，即一个索引包含多个列。</p>
<h2 id="4-1-创建索引"><a href="#4-1-创建索引" class="headerlink" title="4.1 创建索引"></a>4.1 创建索引</h2><p>创建索引有两种方式，一种是直接利用CREATE INDEX进行创建，另外一种则是通过修改表结构来进行添加，则是利用ALTER TABLE语句。</p>
<ol>
<li><p>使用CREATE INDEX</p>
<p>语法为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>|FULLTEXT|SPATIAL] <span class="keyword">INDEX</span> index_name</span><br><span class="line">[<span class="keyword">USING</span> index_type]</span><br><span class="line"><span class="keyword">ON</span> table_name (index_col_name,...)</span><br></pre></td></tr></table></figure>

<p>其中对应的语法变量信息如下：</p>
<blockquote>
<p><strong>[UNIQUE|FULLTEXT|SPATIAL]</strong></p>
</blockquote>
<p>其中括号中的这三个关键字表示创建的索引类型，它们分别表示<strong>唯一索引</strong>、<strong>全文索引</strong>、<strong>空间索引</strong>三种不同的索引类型。如果我们不指定任何关键字，则默认为普通索引。</p>
<blockquote>
<p><strong>index_name</strong></p>
</blockquote>
<p><code>index_name</code>表示索引的名称，由用户自行定义，以便于以后对该索引进行修改等管理操作。</p>
<blockquote>
<p><strong>index_type</strong></p>
</blockquote>
<p><code>index_type</code>表示索引的具体实现方式，在MySQL中，有两种不同形式的索引——BTREE索引和HASH索引。在存储引擎为MyISAM和InnoDB的表中只能使用BTREE，其默认值就是BTREE；在存储引擎为MEMORY或者HEAP的表中可以使用HASH和BTREE两种类型的索引，其默认值为HASH。</p>
<blockquote>
<p><strong>index_colname</strong></p>
</blockquote>
<p><code>index_col_name</code>表示需要创建索引的字段名称，我们还可以针对多个字段创建复合索引，只需要在多个字段名称之间以英文逗号隔开即可。此外，对于CHAR或VARCHAR类型的字段，我们还可以只使用字段内容前面的一部分来创建索引，只需要在对应的字段名称后面加上形如(length)的指令即可，表示只需要使用字段内容前面的length个字符来创建索引。在这里，我们以customers表的cust_name字段(类型为VARCHAR(50))为例，使用cust_name字段的6个字符前缀来创建索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_cust_name <span class="keyword">ON</span> <span class="keyword">user</span> (cust_name(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ALTER TABLE</p>
<p>语法为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>|FULLTEXT|SPATIAL] <span class="keyword">INDEX</span> index_name </span><br><span class="line">(index_col_name,...) [<span class="keyword">USING</span> index_type]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="4-2-删除索引"><a href="#4-2-删除索引" class="headerlink" title="4.2 删除索引"></a>4.2 删除索引</h2><p>删除指定表中指定名称的索引，语法为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name;</span><br></pre></td></tr></table></figure>

<p>例如删除名称为idx_cust_name的索引，其SQL语句为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customers</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> idx_cust_name;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-修改索引"><a href="#4-3-修改索引" class="headerlink" title="4.3 修改索引"></a>4.3 修改索引</h2><p>在MySQL中并没有提供修改索引的直接指令，一般情况下，我们需要先删除掉原索引，再根据需要创建一个同名的索引，从而变相地实现修改索引操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--先删除</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> idx_user_username;</span><br><span class="line"><span class="comment">--再以修改后的内容创建同名索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_cust_name <span class="keyword">ON</span> customers (cust_name(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>

<h2 id="4-4-查看索引"><a href="#4-4-查看索引" class="headerlink" title="4.4 查看索引"></a>4.4 查看索引</h2><p>在MySQL中，要查看某个数据库表中的索引也非常简单，只需要使用以下两个命令中的任意一种即可。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--如果查看索引前，没有使用user db_name等命令指定具体的数据库，则必须加上FROM db_name</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> table_name [<span class="keyword">FROM</span> db_name]</span><br><span class="line"><span class="comment">--如果查看索引前，没有使用user db_name等命令指定具体的数据库，则必须加上db_name.前缀</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> [db_name.]table_name</span><br></pre></td></tr></table></figure>

<h1 id="5-存储过程"><a href="#5-存储过程" class="headerlink" title="5. 存储过程"></a>5. 存储过程</h1><ol>
<li>什么是存储过程？存储过程简单来说，就是为了复用性或者实现复杂的业务功能，而保存的一条或多条MySQL语句的集合，可将其视为批文件；</li>
<li>为什么使用存储过程？（1）通过把处理封装在容易使用的单元中，简化复杂的操作；（2）由于不要求反复建立一系列处理步骤，这保证了数据的完整性，如果所有的开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的；（3）简化对变动的管理。如果表名、列名或业务逻辑有变化，只需要更改存储过程的代码，使用它的开发人员甚至不需要知道这些变化，也就是具备了安全性；（4）提高了性能，因为使用存储过程比单独使用SQL语句要快；（5）存储过程可用来编写功能更灵活的代码。因此，存储过程的具备三个特性:<strong>简单可复用、安全以及高性能</strong>；</li>
<li>存储过程的缺点？（1）存储过程编写比基本的SQL语句更加复杂，需要更高的技能；（2）可能没有创建存储过程的权限，数据库管理员可能会限制创建存储过程的权限，允许用户使用存储过程，而不允许用户自由创建存储过程；</li>
</ol>
<blockquote>
<p><strong>创建存储过程</strong></p>
</blockquote>
<ol>
<li><p>创建存储过程。如需要统计用户订单总金额，如果该用户需要交税的话，订单总金额则需要再加上税费</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal(</span><br><span class="line"><span class="keyword">IN</span> custid <span class="built_in">INT</span>,</span><br><span class="line"><span class="keyword">IN</span> taxable <span class="built_in">BOOLEAN</span>,</span><br><span class="line"><span class="keyword">OUT</span> ototal <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)<span class="keyword">COMMENT</span> <span class="string">'obtain total order price'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*declare variable for total*/</span></span><br><span class="line"><span class="keyword">DECLARE</span> total <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">DECLARE</span> taxrate <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*get the order total*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(item_price*item_quantity) <span class="keyword">INTO</span> total</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id = custid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*is this taxable?*/</span></span><br><span class="line"></span><br><span class="line">IF taxable THEN</span><br><span class="line">	<span class="keyword">SELECT</span> total+(total/<span class="number">100</span>*taxrate) <span class="keyword">INTO</span> total;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">SELECT</span> total <span class="keyword">INTO</span> ototal;</span><br><span class="line"><span class="keyword">END</span> //</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>有这样一些细节： 1. 使用<code>CREATE PROCEDURE</code>语句进行创建，（）圆括号中为存储过程的参数，其中参数类型有：1.  <strong>IN</strong>类型，表示传递给存储过程；2. <strong>OUT</strong> 类型，表示存储过程返回的结果，在调用存储过程时需要传入@开始的变量；3. <strong>INOUT</strong>类型，表示在存储过程中可以传入和传出； 2. <strong>DECLARE</strong>用来声明一个变量，如这里的total，taxrate。注意MySQL中定义变量时都是变量名在前，数据类型在后。 3. 存储过程具体逻辑写在<strong>BEGIN END</strong>之间； 4. 将值赋给变量使用<strong>INTO</strong>关键字； 5. 由于存储过程中每个SQL语句中用；作为分隔符，会和单个SQL造成冲突，因此可使用<strong>DELIMITER</strong>重新定义分类符，如该例子中定义//为分隔符，自然存储过程结尾就用END //结尾，而不再是END。同时，分隔符//成对出现后，恢复到默认的”;”作为分隔符；</p>
<blockquote>
<p><strong>执行存储过程</strong></p>
</blockquote>
<ol>
<li><p>使用CALL子句执行存储过程，CALL子句接受存储过程的名称以及需要传递的参数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> ordertotal(<span class="number">1</span>,<span class="literal">TRUE</span>,@total);</span><br><span class="line"><span class="keyword">SELECT</span> @total;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>如果存储过程中定义了OUT类型的输入参数，那么在执行存储过程时需要传入变量，如这里@total，并且变量都是用@开始的。如果存储过程中没有参数的话，就用空圆括号表示即可，<code>CALL ordertotal()</code>；</p>
<blockquote>
<p><strong>删除存储过程</strong></p>
</blockquote>
<ol>
<li>删除存储过程，可以使用DROP PROCEDURE子句。如<code>DROP PROCEDURE ordertotal</code>；</li>
</ol>
<blockquote>
<p><strong>查询存储过程</strong></p>
</blockquote>
<ol>
<li>显示创建一个存储过程的语句，可以使用SHOW CREATE PROCEDURE。如<code>SHOW CREATE PROCEDURE ordertotal</code>；</li>
<li>查询所有存储过程的状态，如果在定义存储过程中使用COMMENT添加注释，可以查看。同时可以LIKE进行过滤结果。如<code>SHOW PROCEDURE STATUS LIKE &#39;%order%&#39;</code>;</li>
</ol>
<h1 id="6-事务处理"><a href="#6-事务处理" class="headerlink" title="6. 事务处理"></a>6. 事务处理</h1><ol>
<li><p>什么是事务？</p>
<p>事务处理是用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。事务处理是一种机制，用来管理必须成批执行的MySQL操作，它们要么时作为整体执行或者完全不执行。</p>
</li>
<li><p>关键概念：</p>
<ol>
<li>事务：是指一组SQL语句；</li>
<li>回退：是指撤销指定的SQL语句的过程；</li>
<li>提交：指将未存储的SQL语句的结果写入数据库表中；</li>
<li>保留点：指事务处理中设置的临时占位符，可以对它发布回退；</li>
</ol>
</li>
<li><p>如何创建执行事务？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (cust_name,item_price,item_quantity) <span class="keyword">VALUES</span> (<span class="string">'1'</span>,<span class="number">5</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> customers;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> insertinto;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (cust_name,item_price,item_quantity) <span class="keyword">VALUES</span> (<span class="string">'2'</span>,<span class="number">5</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> insertinto;</span><br></pre></td></tr></table></figure>

<p>执行结果为：插入数据(‘1’,5,18)有效，因为，只会从保留点SAFEPOINT之后开始回退，也就是说保留点SAFEPOINT之前的SQL语句执行的结果仍然有效。</p>
<p>有这样一些细节：</p>
<ol>
<li><strong>STAET TRANSACTION</strong>用来表示下面的SQL语句集为一段事务；</li>
<li><strong>SAFEPOINT</strong> 用于指定保留点insertinto；</li>
<li><strong>ROLLBACK TO</strong>表示从指定保留点开始回退，也就是说保留点之前的SQL语句执行结果依然有效。如果仅仅使用<strong>ROLLBACK</strong>进行回退的话就表示从STAET TRANSACTION之后所有的SQL语句执行效果都会撤销；</li>
</ol>
</li>
<li><p>MySQL提交（写或保存）操作是自动进行的，这称之为隐含提交。但是在事务处理块中，提交不会隐含进行，要使用COMMIT子句进行提交。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (cust_name,item_price,item_quantity) <span class="keyword">VALUES</span> (<span class="string">'1'</span>,<span class="number">5</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (cust_name,item_price,item_quantity) <span class="keyword">VALUES</span> (<span class="string">'2'</span>,<span class="number">5</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>采用COMMIT提交事务，如果两条SQL语句都执行成功，才会将数据都写入表中。</p>
<h1 id="7-触发器"><a href="#7-触发器" class="headerlink" title="7. 触发器"></a>7. 触发器</h1><ol>
<li><p>什么是触发器？</p>
<p>当某条SQL语句发生时，自动执行某些其他的SQL语句的时候就需要使用到触发器。触发器只能响应：DELETE，INSERT,UPDATE这三个特定操作。</p>
</li>
<li><p>创建触发器？</p>
<p>创建触发器时需要给出最重要的四条信息：1.全局唯一的触发器名；2.触发器关联的表；3.触发器在何时执行（操作执行之前或者之后）4.触发器应该响应的活动（DELETE, INSERT或者UPDATE）；</p>
<p>由于触发器只能响应特定的三种类型的操作，因此可创建的触发器也就三种类型:INSERT触发器，DELETE触发器以及UPDATE触发器。</p>
<blockquote>
<p><strong>INSERT触发器</strong></p>
</blockquote>
<p>在执行INSERT触发器时，也这样几点需要注意：1.在INSERT触发器代码内，可以引用一个名为NEW的虚拟表，可以用NEW来访问刚插入的行数据；2.在BEFORE INSERT触发器中，NEW中的值可以被更新；3.对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自定生成值。</p>
<p>创建一个INSERT触发器，每次插入一行数据，每次会返回当前插入的行数据的id。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建触发器*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> insertcustomers <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> customers</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> NEW.cust_id <span class="keyword">INTO</span> @newinsertid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*执行触发器*/</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (cust_name,item_price,item_quantity) <span class="keyword">VALUES</span> (<span class="string">'2'</span>,<span class="number">5</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">SELECT</span> @newinsertid;</span><br></pre></td></tr></table></figure>

<p>有这样一些细节：</p>
<ol>
<li>使用CREATE TRIGGER来创建触发器；</li>
<li>AFTER INSERT表明在插入行数据之后，触发器才会执行特征操作；</li>
<li>FOR EACH ROW 表示对插入的每一行数据，触发器都起作用；</li>
<li>针对INSERT触发器，可以使用虚拟表NEW，来使用刚插入的行数据。比如例子中，<code>SELECT NEW.cust_id INTO @newinsertid</code>表示将新插入的行数据的id赋值给变量@newinsertid；</li>
</ol>
<blockquote>
<p><strong>DELETE触发器</strong></p>
</blockquote>
<p>DELETE触发器在DELETE语句执行之前或者之后，需要知道以下两点：</p>
<ol>
<li>在DELETE触发器代码内，可以引用一个名为OLD的虚拟表，来访问被删除的行；</li>
<li>OLD表中的数据只能读，不能被更新，而在INSERT触发器中，就可以通过NEW来更新被插入的行数据；</li>
</ol>
<p>例如，针对customers表，当删除一行数据时，返回被删除数据的<code>cust_id</code>以及<code>cust_name</code>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建DELETE触发器*/</span></span><br><span class="line"></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> insertcustomers <span class="keyword">AFTER</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> customers</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">  <span class="keyword">SELECT</span> OLD.cust_name <span class="keyword">INTO</span> @deletecustname;</span><br><span class="line">  <span class="keyword">SELECT</span> OLD.cust_id <span class="keyword">INTO</span> @deletecustid;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用DELETE触发器*/</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> cust_id = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @deletecustname;</span><br><span class="line"><span class="keyword">SELECT</span> @deletecustid;</span><br></pre></td></tr></table></figure>

<p>基本上与创建INSERT触发器一样，只不过在DELETE触发器中只能使用OLD来访问被删除的行数据。</p>
<blockquote>
<p><strong>UPDATE触发器</strong></p>
</blockquote>
<p>UPDATE触发器在UPDATE语句执行之前或者之后执行，需要知道一下几点：</p>
<ol>
<li>在BEFORE UPDATE触发器中可以使用NEW和OLD来访问数据，而在AFTER UPDATE触发器中使用NEW来访问数据会报错，只能使用OLD来访问数据；</li>
<li>在BEFORE UPDATE触发器中，NEW中的值可以被改变，即允许更改将用于UPDATE的数据；</li>
<li>OLD中的行数据只能读，不能被更新；</li>
</ol>
<p>一个UPDATE触发器示例如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建UPDATE触发器*/</span></span><br><span class="line"></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> insertcustomers <span class="keyword">BEFORE</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> customers</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> NEW.cust_name <span class="keyword">INTO</span> @beforeupdate;</span><br><span class="line"><span class="keyword">SET</span> NEW.cust_name = <span class="string">'reset_name'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> OLD.cust_name <span class="keyword">INTO</span> @afterupdate;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用UPDATE触发器*/</span></span><br><span class="line"><span class="keyword">UPDATE</span> customers <span class="keyword">SET</span> cust_name = <span class="string">'happy'</span> <span class="keyword">WHERE</span> cust_id = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @beforeupdate;</span><br><span class="line"><span class="keyword">SELECT</span> @afterupdate;</span><br></pre></td></tr></table></figure>

<p>输出为@beforeupdate为‘happay’，而@afterupdate为’reset_name’。有这样一些细节：</p>
<ol>
<li>NEW虚拟表中的数据可以更改，如这里采用        <code>SET NEW.cust_name = &#39;reset_name&#39;;</code>，将待更新的<code>cust_name由“happy”变成了“reset_name”</code>；</li>
<li>在BEFORE UPDATE触发器中可以使用NEW和OLD来访问数据，而在AFTER UPDATE触发器中使用NEW来访问数据会报错；</li>
</ol>
</li>
<li><p>删除触发器？</p>
<p>删除触发器，可以使用 DROP TRIGGER语句，比如<code>DROP TRIGGER insertcustomers;</code>。触发器不能更新或者覆盖，如果要修改触发器，必须删除这个触发器。</p>
</li>
</ol>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/5ae55861f265da0ba062ec71" target="_blank" rel="noopener">MySQL命令，一篇文章替你全部搞定</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/29/%E5%88%9D%E8%AF%86Lock%E4%B8%8EAbstractQueuedSynchronizer(AQS)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/29/%E5%88%9D%E8%AF%86Lock%E4%B8%8EAbstractQueuedSynchronizer(AQS)/" class="post-title-link" itemprop="url">初识Lock与AbstractQueuedSynchronizer(AQS)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-30 07:43:33 / 修改时间：19:10:38" itemprop="dateCreated datePublished" datetime="2020-06-30T07:43:33+08:00">2020-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="自己实现一个锁"><a href="#自己实现一个锁" class="headerlink" title="自己实现一个锁"></a>自己实现一个锁</h1><h2 id="自旋实现锁"><a href="#自旋实现锁" class="headerlink" title="自旋实现锁"></a>自旋实现锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mylock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t come in"</span>);</span><br><span class="line">        <span class="comment">// 自旋获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// CAS解锁</span></span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t invoked myunlock()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：耗费CPU资源，没有竞争到锁的线程会一直占用CPU资源进行CAS操作。</p>
<h2 id="park-自旋实现锁"><a href="#park-自旋实现锁" class="headerlink" title="park+自旋实现锁"></a>park+自旋实现锁</h2><p>Java提供了一个较为底层的并发工具类：LockSupport，可以让线程停止下来(阻塞)，还可以唤醒线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞线程</span></span><br><span class="line">LockSupport.park(Object blocker) </span><br><span class="line"><span class="comment">// 唤醒线程</span></span><br><span class="line">LockSupport.unpark(Thread thread)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    <span class="comment">// 阻塞线程队列</span></span><br><span class="line">    Queue&lt;Thread&gt; parkQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mylock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t come in"</span>);</span><br><span class="line">        <span class="comment">// 自旋获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line">            park();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// CAS解锁</span></span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t invoked myunlock()"</span>);</span><br><span class="line">        lock_notify();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        parkQueue.add(Thread.currentThread());</span><br><span class="line">        LockSupport.park(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = parkQueue.poll();</span><br><span class="line">        LockSupport.unpark(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="concurrent包的结构层次"><a href="#concurrent包的结构层次" class="headerlink" title="concurrent包的结构层次"></a>concurrent包的结构层次</h1><p>在针对并发编程中，Doug Lea大师为我们提供了大量实用，高性能的工具类，针对这些代码进行研究会让我们队并发编程的掌握更加透彻也会大大提升我们队并发编程技术的热爱。这些代码在java.util.concurrent包下。如下图，即为concurrent包的目录结构图。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/3/163260cff7a637f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="concurrent目录结构.png">concurrent目录结构.png</p>
<p>其中包含了两个子包：atomic以及lock，另外在concurrent下的阻塞队列以及executors,这些就是concurrent包中的精华，之后会一一进行学习。而这些类的实现主要是依赖于volatile以及CAS（关于volatile可以看<a href="https://juejin.im/post/5ae9b41b518825670b33e6c4" target="_blank" rel="noopener">这篇文章</a>，关于CAS可以看<a href="https://juejin.im/post/5ae6dc04f265da0ba351d3ff" target="_blank" rel="noopener">这篇文章的3.1节</a>），从整体上来看concurrent包的整体实现图如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/3/163260cff7cb847c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="concurrent包实现整体示意图.png">concurrent包实现整体示意图.png</p>
<h1 id="lock简介"><a href="#lock简介" class="headerlink" title="lock简介"></a>lock简介</h1><p>我们下来看concurent包下的lock子包。锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。在Lock接口出现之前，java程序主要是靠synchronized关键字实现锁功能的，而java SE5之后，并发包中增加了lock接口，它提供了与synchronized一样的锁功能。<strong>虽然它失去了像synchronize关键字隐式加锁解锁的便捷性，但是却拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</strong>通常使用显示使用lock的形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	.......</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是<strong>synchronized同步块执行完成或者遇到异常是锁会自动释放，而lock必须调用unlock()方法释放锁，因此在finally块中释放锁</strong>。</p>
<h2 id="Lock接口API"><a href="#Lock接口API" class="headerlink" title="Lock接口API"></a>Lock接口API</h2><p>我们现在就来看看lock接口定义了哪些方法：</p>
<blockquote>
<p>void lock(); //获取锁 void lockInterruptibly() throws InterruptedException；//获取锁的过程能够响应中断 boolean tryLock();//非阻塞式响应中断能立即返回，获取锁放回true反之返回fasle boolean tryLock(long time, TimeUnit unit) throws InterruptedException;//超时获取锁，在超时内或者未中断的情况下能够获取锁 Condition newCondition();//获取与lock绑定的等待通知组件，当前线程必须获得了锁才能进行等待，进行等待时会先释放锁，当再次获取锁时才能从等待中返回</p>
</blockquote>
<p>上面是lock接口下的五个方法，也只是从源码中英译中翻译了一遍，感兴趣的可以自己的去看看。那么在locks包下有哪些类实现了该接口了？先从最熟悉的ReentrantLock说起。</p>
<blockquote>
<p>public class ReentrantLock implements <strong>Lock</strong>, java.io.Serializable</p>
</blockquote>
<p>很显然ReentrantLock实现了lock接口，接下来我们来仔细研究一下它是怎样实现的。当你查看源码时你会惊讶的发现ReentrantLock并没有多少代码，另外有一个很明显的特点是：<strong>基本上所有的方法的实现实际上都是调用了其静态内存类<code>Sync</code>中的方法，而Sync类继承了<code>AbstractQueuedSynchronizer（AQS）</code></strong>。可以看出要想理解ReentrantLock关键核心在于对队列同步器AbstractQueuedSynchronizer（简称同步器）的理解。</p>
<h2 id="初识AQS"><a href="#初识AQS" class="headerlink" title="初识AQS"></a>初识AQS</h2><p>关于AQS在源码中有十分具体的解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> Provides a framework <span class="keyword">for</span> implementing blocking locks and related</span><br><span class="line"> synchronizers (semaphores, events, etc) that rely on</span><br><span class="line"> first-in-first-out (FIFO) wait queues.  This <span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">designed</span> <span class="title">to</span></span></span><br><span class="line"><span class="class"> <span class="title">be</span> <span class="title">a</span> <span class="title">useful</span> <span class="title">basis</span> <span class="title">for</span> <span class="title">most</span> <span class="title">kinds</span> <span class="title">of</span> <span class="title">synchronizers</span> <span class="title">that</span> <span class="title">rely</span> <span class="title">on</span> <span class="title">a</span></span></span><br><span class="line"><span class="class"> <span class="title">single</span> <span class="title">atomic</span> </span>&#123;<span class="meta">@code</span> <span class="keyword">int</span>&#125; value to represent state. Subclasses</span><br><span class="line"> must define the <span class="keyword">protected</span> methods that change <span class="keyword">this</span> state, and which</span><br><span class="line"> define what that state means in terms of <span class="keyword">this</span> object being acquired</span><br><span class="line"> or released.  Given these, the other methods in <span class="keyword">this</span> <span class="class"><span class="keyword">class</span> <span class="title">carry</span></span></span><br><span class="line"><span class="class"> <span class="title">out</span> <span class="title">all</span> <span class="title">queuing</span> <span class="title">and</span> <span class="title">blocking</span> <span class="title">mechanics</span>. <span class="title">Subclasses</span> <span class="title">can</span> <span class="title">maintain</span></span></span><br><span class="line"><span class="class"> <span class="title">other</span> <span class="title">state</span> <span class="title">fields</span>, <span class="title">but</span> <span class="title">only</span> <span class="title">the</span> <span class="title">atomically</span> <span class="title">updated</span> </span>&#123;<span class="meta">@code</span> <span class="keyword">int</span>&#125;</span><br><span class="line"> value manipulated using methods &#123;@link #getState&#125;, &#123;@link</span><br><span class="line"> #setState&#125; and &#123;@link #compareAndSetState&#125; is tracked with respect</span><br><span class="line"> to synchronization.</span><br><span class="line">&lt;p&gt;Subclasses should be defined as non-<span class="keyword">public</span> internal helper</span><br><span class="line">classes that are used to implement the synchronization properties</span><br><span class="line">of their enclosing <span class="class"><span class="keyword">class</span>.  <span class="title">Class</span></span></span><br><span class="line"><span class="class"></span>&#123;<span class="meta">@code</span> AbstractQueuedSynchronizer&#125; does not implement any</span><br><span class="line">synchronization <span class="class"><span class="keyword">interface</span>.  <span class="title">Instead</span> <span class="title">it</span> <span class="title">defines</span> <span class="title">methods</span> <span class="title">such</span> <span class="title">as</span></span></span><br><span class="line">&#123;@link #acquireInterruptibly&#125; that can be invoked as</span><br><span class="line">appropriate by concrete locks and related synchronizers to</span><br><span class="line">implement their <span class="keyword">public</span> methods.</span><br></pre></td></tr></table></figure>



<p>同步器是用来构建锁和其他同步组件的基础框架，它的实现主要依赖一个int成员变量来表示同步状态以及通过一个FIFO队列构成等待队列。它的<strong>子类必须重写AQS的几个protected修饰的用来改变同步状态的方法</strong>，其他方法主要是实现了排队和阻塞机制。<strong>状态的更新使用getState,setState以及compareAndSetState这三个方法</strong>。</p>
<p>子类被<strong>推荐定义为自定义同步组件的静态内部类</strong>，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用，同步器既支持独占式获取同步状态，也可以支持共享式获取同步状态，这样就可以方便的实现不同类型的同步组件。</p>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：<strong>锁是面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作</strong>。锁和同步器很好的隔离了使用者和实现者所需关注的领域。</p>
<h2 id="AQS的模板方法设计模式"><a href="#AQS的模板方法设计模式" class="headerlink" title="AQS的模板方法设计模式"></a>AQS的模板方法设计模式</h2><p>AQS的设计是使用模板方法设计模式，它将<strong>一些方法开放给子类进行重写，而同步器给同步组件所提供模板方法又会重新调用被子类所重写的方法</strong>。举个例子，AQS中需要重写的方法tryAcquire：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock中NonfairSync（继承AQS）会重写该方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而AQS中的模板方法acquire():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会调用tryAcquire方法，而此时当继承AQS的NonfairSync调用模板方法acquire时就会调用已经被NonfairSync重写的tryAcquire方法。这就是使用AQS的方式，在弄懂这点后会lock的实现理解有很大的提升。可以归纳总结为这么几点：</p>
<ol>
<li>同步组件（这里不仅仅值锁，还包括CountDownLatch等）的实现依赖于同步器AQS，在同步组件实现中，使用AQS的方式被推荐定义继承AQS的静态内存类；</li>
<li>AQS采用模板方法进行设计，AQS的protected修饰的方法需要由继承AQS的子类进行重写实现，当调用AQS的子类的方法时就会调用被重写的方法；</li>
<li>AQS负责同步状态的管理，线程的排队，等待和唤醒这些底层操作，而Lock等同步组件主要专注于实现同步语义；</li>
<li>在重写AQS的方式时，使用AQS提供的<code>getState(),setState(),compareAndSetState()</code>方法进行修改同步状态</li>
</ol>
<p>AQS可重写的方法如下图（摘自《java并发编程的艺术》一书）：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/3/163260cff7d16b38?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="AQS可重写的方法.png">AQS可重写的方法.png</p>
<p>在实现同步组件时AQS提供的模板方法如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/3/163260cff87fe8bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="AQS提供的模板方法.png">AQS提供的模板方法.png</p>
<p>AQS提供的模板方法可以分为3类：</p>
<ol>
<li>独占式获取与释放同步状态；</li>
<li>共享式获取与释放同步状态；</li>
<li>查询同步队列中等待线程情况；</li>
</ol>
<p>同步组件通过AQS提供的模板方法实现自己的同步语义。</p>
<h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>下面使用一个例子来进一步理解下AQS的使用。这个例子也是来源于AQS源码中的example。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;    <span class="comment">// Our internal helper class    // 继承AQS的静态内存类    // 重写方法    private static class Sync extends AbstractQueuedSynchronizer &#123;        // Reports whether in locked state        protected boolean isHeldExclusively() &#123;            return getState() == 1;        &#125;    // Acquires the lock if state is zero    public boolean tryAcquire(int acquires) &#123;        assert acquires == 1; // Otherwise unused        if (compareAndSetState(0, 1)) &#123;            setExclusiveOwnerThread(Thread.currentThread());            return true;        &#125;        return false;    &#125;     // Releases the lock by setting state to zero    protected boolean tryRelease(int releases) &#123;        assert releases == 1; // Otherwise unused        if (getState() == 0) throw new IllegalMonitorStateException();        setExclusiveOwnerThread(null);        setState(0);        return true;    &#125;     // Provides a Condition    Condition newCondition() &#123;        return new ConditionObject();    &#125;     // Deserializes properly    private void readObject(ObjectInputStream s)            throws IOException, ClassNotFoundException &#123;        s.defaultReadObject();        setState(0); // reset to unlocked state    &#125; &#125; // The sync object does all the hard work. We just forward to it. private final Sync sync = new Sync(); //使用同步器的模板方法实现自己的同步语义 public void lock() &#123;    sync.acquire(1); &#125; public boolean tryLock() &#123;    return sync.tryAcquire(1); &#125; public void unlock() &#123;    sync.release(1); &#125; public Condition newCondition() &#123;    return sync.newCondition(); &#125; public boolean isLocked() &#123;    return sync.isHeldExclusively(); &#125; public boolean hasQueuedThreads() &#123;    return sync.hasQueuedThreads(); &#125; public void lockInterruptibly() throws InterruptedException &#123;    sync.acquireInterruptibly(1); &#125; public boolean tryLock(long timeout, TimeUnit unit)        throws InterruptedException &#123;    return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125; 复制代码 复制代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>MutexDemo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutextDemo</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> Mutex mutex = <span class="keyword">new</span> Mutex(); <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;            mutex.lock();            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">3000</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125; <span class="keyword">finally</span> &#123;                mutex.unlock();            &#125;        &#125;);        thread.start();    &#125; &#125; 复制代码 复制代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行情况：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/3/163260cff934a80f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="mutex的执行情况.png">mutex的执行情况.png</p>
<p>上面的这个例子实现了独占锁的语义，在同一个时刻只允许一个线程占有锁。MutexDemo新建了10个线程，分别睡眠3s。从执行情况也可以看出来当前Thread-6正在执行占有锁而其他Thread-7,Thread-8等线程处于WAIT状态。按照推荐的方式，Mutex定义了一个<strong>继承AQS的静态内部类Sync</strong>,并且重写了AQS的tryAcquire等等方法，而对state的更新也是利用了setState(),getState()，compareAndSetState()这三个方法。在实现实现lock接口中的方法也只是调用了AQS提供的模板方法（因为Sync继承AQS）。从这个例子就可以很清楚的看出来，在同步组件的实现上主要是利用了AQS，而AQS“屏蔽”了同步状态的修改，线程排队等底层实现，通过AQS的模板方法可以很方便的给同步组件的实现者进行调用。而针对用户来说，只需要调用同步组件提供的方法来实现并发编程即可。同时在新建一个同步组件时需要把握的两个关键点是：</p>
<ol>
<li>实现同步组件时推荐定义继承AQS的静态内存类，并重写需要的protected修饰的方法；</li>
<li>同步组件语义的实现依赖于AQS的模板方法，而AQS模板方法又依赖于被AQS的子类所重写的方法。</li>
</ol>
<p>通俗点说，因为AQS整体设计思路采用模板方法设计模式，同步组件以及AQS的功能实际上别切分成各自的两部分：</p>
<p><strong>同步组件实现者的角度：</strong></p>
<p>通过可重写的方法：<strong>独占式</strong>： tryAcquire()(独占式获取同步状态），tryRelease()（独占式释放同步状态）；<strong>共享式</strong> ：tryAcquireShared()(共享式获取同步状态)，tryReleaseShared()(共享式释放同步状态)；<strong>告诉AQS怎样判断当前同步状态是否成功获取或者是否成功释放</strong>。同步组件专注于对当前同步状态的逻辑判断，从而实现自己的同步语义。这句话比较抽象，举例来说，上面的Mutex例子中通过tryAcquire方法实现自己的同步语义，在该方法中如果当前同步状态为0（即该同步组件没被任何线程获取），当前线程可以获取同时将状态更改为1返回true，否则，该组件已经被线程占用返回false。很显然，该同步组件只能在同一时刻被线程占用，Mutex专注于获取释放的逻辑来实现自己想要表达的同步语义。</p>
<p><strong>AQS的角度</strong></p>
<p>而对AQS来说，只需要同步组件返回的true和false即可，因为AQS会对true和false会有不同的操作，true会认为当前线程获取同步组件成功直接返回，而false的话就AQS也会将当前线程插入同步队列等一系列的方法。</p>
<p>总的来说，同步组件通过重写AQS的方法实现自己想要表达的同步语义，而AQS只需要同步组件表达的true和false即可，AQS会针对true和false不同的情况做不同的处理，至于底层实现，可以<a href="https://juejin.im/post/5aeb07ab6fb9a07ac36350c8" target="_blank" rel="noopener">看这篇文章</a>。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://blog.csdn.net/TJtulong/article/details/105345940" target="_blank" rel="noopener">Java中的锁及AQS实现原理</a></p>
<p><a href="https://juejin.im/post/5aeb055b6fb9a07abf725c8c" target="_blank" rel="noopener">初识Lock与AbstractQueuedSynchronizer(AQS)</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/29/Java%E4%B8%ADLock%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/29/Java%E4%B8%ADLock%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Java中Lock接口的原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-30 07:43:33 / 修改时间：16:46:53" itemprop="dateCreated datePublished" datetime="2020-06-30T07:43:33+08:00">2020-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p>锁是用来<strong>控制多个线程访问共享资源</strong>的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。</p>
<p>在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//定义需要保证线程安全的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//...method body</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用finally块来保证释放锁</span></span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>Reentrantlock</code>可以进行尝试锁定<code>tryLock()</code>，这样无法锁定，或者在指定时间内无法锁定，返回false；</p>
<p>使用<code>ReentrantLock</code>还可以调用<code>lockInterruptibly()</code>方法，可以对线程<code>interrupt()</code>方法做出响应，在一个线程等待锁的过程中，可以被打断，打断后会抛异常。</p>
<h2 id="自己实现一个锁"><a href="#自己实现一个锁" class="headerlink" title="自己实现一个锁"></a>自己实现一个锁</h2><h3 id="自旋实现锁"><a href="#自旋实现锁" class="headerlink" title="自旋实现锁"></a>自旋实现锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mylock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t come in"</span>);</span><br><span class="line">        <span class="comment">// 自旋获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// CAS解锁</span></span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t invoked myunlock()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：耗费CPU资源，没有竞争到锁的线程会一直占用CPU资源进行CAS操作。</p>
<h3 id="park-自旋实现锁"><a href="#park-自旋实现锁" class="headerlink" title="park+自旋实现锁"></a>park+自旋实现锁</h3><p>Java提供了一个较为底层的并发工具类：LockSupport，可以让线程停止下来(阻塞)，还可以唤醒线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞线程</span></span><br><span class="line">LockSupport.park(Object blocker) </span><br><span class="line"><span class="comment">// 唤醒线程</span></span><br><span class="line">LockSupport.unpark(Thread thread)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    <span class="comment">// 阻塞线程队列</span></span><br><span class="line">    Queue&lt;Thread&gt; parkQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mylock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t come in"</span>);</span><br><span class="line">        <span class="comment">// 自旋获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line">            park();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// CAS解锁</span></span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t invoked myunlock()"</span>);</span><br><span class="line">        lock_notify();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        parkQueue.add(Thread.currentThread());</span><br><span class="line">        LockSupport.park(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = parkQueue.poll();</span><br><span class="line">        LockSupport.unpark(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列同步器AQS"><a href="#队列同步器AQS" class="headerlink" title="队列同步器AQS"></a>队列同步器AQS</h2><p>队列同步器AbstractQueuedSynchronizer（AQS）是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。</p>
<h3 id="AQS的实现"><a href="#AQS的实现" class="headerlink" title="AQS的实现"></a>AQS的实现</h3><h4 id="FIFO队列"><a href="#FIFO队列" class="headerlink" title="FIFO队列"></a>FIFO队列</h4><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<p>AQS中的节点Node：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待状态，若值为-1，表示后继节点处于等待状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 节点绑定线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AQS的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待队列头结点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="comment">// 等待队列尾结点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="comment">// 状态</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    未完待续</p>
<hr>
<p>本文整理自</p>
<p><a href="https://blog.csdn.net/TJtulong/article/details/105345940" target="_blank" rel="noopener">Java中的锁及AQS实现原理</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/28/Java%20protected%20%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/28/Java%20protected%20%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Java protected 关键字详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-29 02:18:56 / 修改时间：10:27:47" itemprop="dateCreated datePublished" datetime="2020-06-29T02:18:56+08:00">2020-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>很多介绍Java语言的书籍(包括《Java编程思想》)都对protected介绍的比较的简单，基本都是一句话，就是:被protected修饰的成员对于本包和其子类可见。这种说法有点太过含糊，常常会对大家造成误解。实际上，protected的可见性在于两点：</p>
<ul>
<li><p>基类的protected成员是<strong>包内可见</strong>的，并且<strong>对子类可见</strong>；</p>
</li>
<li><p>若<strong>子类与基类不在同一包中</strong>，那么在子类中，子类实例<strong>可以访问其从基类继承而来的protected方法</strong>，而<strong>不能访问基类实例的protected方法</strong>。</p>
</li>
</ul>
<p>我们可以通过以下几个关于protected方法可见性的例子来进一步掌握protected关键字。在碰到涉及protected成员的调用时，首先要确定出该protected成员来自何方，其可见性范围是什么，然后就可以判断出当前用法是否可行了，看下面七个例子：</p>
<h2 id="1-、示例一"><a href="#1-、示例一" class="headerlink" title="(1)、示例一"></a>(1)、示例一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例一</span></span><br><span class="line"><span class="keyword">package</span> p1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;    <span class="comment">// 父类Father1中的protected方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son1</span> <span class="keyword">extends</span> <span class="title">Father1</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p11;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son11</span> <span class="keyword">extends</span> <span class="title">Father1</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son1 son1 = <span class="keyword">new</span> Son1();</span><br><span class="line">        son1.f(); <span class="comment">// Compile OK     ----（1）</span></span><br><span class="line">        son1.clone(); <span class="comment">// Compile Error     ----（2）</span></span><br><span class="line"></span><br><span class="line">        Son11 son = <span class="keyword">new</span> Son11();    </span><br><span class="line">        son11.f(); <span class="comment">// Compile OK     ----（3）</span></span><br><span class="line">        son11.clone(); <span class="comment">// Compile Error     ----（4）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于上面的示例，首先看(1)(3)，其中的f()方法从类Father1继承而来，其可见性是包p1及其子类Son1和Son11，而由于调用f()方法的类Test1所在的包也是p1，因此（1）(3)处编译通过。其次看(2)(4)，其中的clone()方法的可见性是java.lang包及其所有子类，对于语句“son1.clone();”和“son11.clone();”，二者的clone()在类Son1、Son11中是可见的，但对Test1是不可见的，因此（1）(3)处编译不通过。</p>
<h2 id="2-、示例二"><a href="#2-、示例二" class="headerlink" title="(2)、示例二"></a>(2)、示例二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例二</span></span><br><span class="line"><span class="keyword">package</span> p2;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p22;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">extends</span> <span class="title">MyObject2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       MyObject2 obj = <span class="keyword">new</span> MyObject2();</span><br><span class="line">       obj.clone(); <span class="comment">// Compile Error         ----（1）</span></span><br><span class="line"></span><br><span class="line">       Test2 tobj = <span class="keyword">new</span> Test2();</span><br><span class="line">       tobj.clone(); <span class="comment">// Complie OK         ----（2）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于(1)而言，clone()方法来自于类MyObject2本身，因此其可见性为包p2及MyObject2的子类，虽然Test2是MyObject2的子类，但在Test2中不能访问基类MyObject2的protected方法clone()，因此编译不通过;对于(2)而言，由于在Test2中访问的是其本身实例的从基类MyObject2继承来的的clone()，因此编译通过。</p>
<h2 id="3-、示例三"><a href="#3-、示例三" class="headerlink" title="(3)、示例三"></a>(3)、示例三</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例三</span></span><br><span class="line"><span class="keyword">package</span> p3;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject3</span> <span class="keyword">extends</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p33;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    MyObject3 obj = <span class="keyword">new</span> MyObject3();</span><br><span class="line">    obj.clone();   <span class="comment">// Compile OK     ------（1）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于(1)而言，clone()方法来自于类Test3，因此其可见性为包p33及其子类MyObject3，而（1）正是在p33的类Test3中调用，属于同一包，编译通过。</p>
<h2 id="4-、示例四"><a href="#4-、示例四" class="headerlink" title="(4)、示例四"></a>(4)、示例四</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例四</span></span><br><span class="line"><span class="keyword">package</span> p4;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject4</span> <span class="keyword">extends</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p44;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    MyObject4 obj = <span class="keyword">new</span> MyObject4();</span><br><span class="line">    obj.clone(); <span class="comment">// Compile Error      -----（1）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于(1)而言，clone()方法来自于类MyObject4，因此其可见性为包p4及其子类(此处没有子类)，而类Test4却在包p44中，因此不满足可见性，编译不通过。</p>
<h2 id="5-、示例五"><a href="#5-、示例五" class="headerlink" title="(5)、示例五"></a>(5)、示例五</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例五</span></span><br><span class="line"><span class="keyword">package</span> p5;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">       MyObject5 obj = <span class="keyword">new</span> MyObject5();</span><br><span class="line">       obj.clone(); <span class="comment">// Compile OK        ----(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于(1)而言，clone()方法来自于类MyObject5，因此其可见性为包p5及其子类(此处没有子类)，而类Test5也在包p5中，因此满足可见性，编译通过。</p>
<h2 id="6-、示例六"><a href="#6-、示例六" class="headerlink" title="(6)、示例六"></a>(6)、示例六</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例六</span></span><br><span class="line"><span class="keyword">package</span> p6;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject6</span> <span class="keyword">extends</span> <span class="title">Test6</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyObject6 obj = <span class="keyword">new</span> MyObject6();</span><br><span class="line">    obj.clone();        <span class="comment">// Compile OK   -------（1）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于(1)而言，clone()方法来自于类Test6，因此其可见性为包p6及其子类MyObject6，而类Test6也在包p6中，因此满足可见性，编译通过。</p>
<h2 id="7-、示例七"><a href="#7-、示例七" class="headerlink" title="(7)、示例七"></a>(7)、示例七</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例七</span></span><br><span class="line"><span class="keyword">package</span> p7;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject7</span> <span class="keyword">extends</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test7 test = <span class="keyword">new</span> Test7();</span><br><span class="line">        test.clone(); <span class="comment">// Compile Error   ----- (1)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于(1)而言，clone()方法来自于类Object，因此该clone()方法可见性为包java.lang及其子类Test7，由于类MyObject7不在此范围内，因此不满足可见性，编译不通过。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://blog.csdn.net/justloveyou_/article/details/61672133" target="_blank" rel="noopener">Java protected 关键字详解</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/28/%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2--%E5%AD%90%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%9B%BF%E6%8D%A2%E7%88%B6%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/28/%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2--%E5%AD%90%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%9B%BF%E6%8D%A2%E7%88%B6%E7%B1%BB/" class="post-title-link" itemprop="url">里氏代换 -- 子类可以替换父类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-29 01:50:13 / 修改时间：10:22:00" itemprop="dateCreated datePublished" datetime="2020-06-29T01:50:13+08:00">2020-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">程序设计</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>里氏代换原则由2008年图灵奖得主、美国第一位计算机科学女博士<strong>Barbara Liskov</strong>教授和卡内基·梅隆大学Jeannette Wing教授于1994年提出。其严格表述如下：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。这个定义比较拗口且难以理解，因此我们一般使用它的另一个通俗版定义：</p>
<p><strong>里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</strong></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>里氏代换原则告诉我们，在软件中<strong>将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，</strong>如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。</p>
<p>例如有两个类，一个类为BaseClass，另一个是SubClass类，并且SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个BaseClass类型的基类对象base的话，如：method1(base)，那么它必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能够正常运行。反过来的代换不成立，如一个方法method2接受BaseClass类型的子类对象sub为参数：method2(sub)，那么一般而言不可以有method2(base)，除非是重载方法。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>   里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此<strong>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象</strong>。</p>
<p>   在使用里氏代换原则时需要注意如下几个问题：</p>
<p>   (1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</p>
<p>   (2)  我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。</p>
<p>   (3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。</p>
<p>   <strong>里氏代换原则是实现开闭原则的重要方式之一。</strong>在传递参数时使用基类对象，除此以外，在定义成员变量、定义局部变量、确定方法返回类型时都可使用里氏代换原则。针对基类编程，在程序运行时再确定具体子类。</p>
<h2 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h2><ul>
<li>子类在重写(Override)父类方法时,<strong>子类方法的访问修饰符不能比父类更加严格.</strong></li>
</ul>
<p>比如父类方法是包访问权限，子类的重写方法是public访问权限</p>
<ul>
<li>子类在重写(Override)父类方法时,<strong>子类方法抛出的异常不能比父类更多.</strong></li>
</ul>
<p>子类重写方法可以不抛异常以及抛出更少的异常</p>
<p><strong><em>\</em>扩展**</strong></p>
<blockquote>
<p>里氏代换原则以Barbara Liskov（芭芭拉·利斯科夫）教授的姓氏命名。芭芭拉·利斯科夫：美国计算机科学家，2008年图灵奖得主，2004年约翰·冯诺依曼奖得主，美国工程院院士，美国艺术与科学院院士，美国计算机协会会士，麻省理工学院电子电气与计算机科学系教授，美国第一位计算机科学女博士。</p>
</blockquote>
<hr>
<p>本文整理自</p>
<p><a href="https://blog.csdn.net/zhiduoniu/article/details/18257661" target="_blank" rel="noopener">里氏代换 – 子类可以替换父类</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/28/Java%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/28/Java%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Java子类重写父类方法注意问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-28 13:46:19" itemprop="dateCreated datePublished" datetime="2020-06-28T13:46:19+08:00">2020-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-29 09:44:31" itemprop="dateModified" datetime="2020-06-29T09:44:31+08:00">2020-06-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>子类不能重写父类的静态方法，私有方法。即使你看到子类中存在貌似是重写的父类的静态方法或者私有方法，编译是没有问题的，但那其实是你重新又定义的方法，不是重写。具体有关重写父类方法的规则如下：</p>
<h2 id="重写规则之一："><a href="#重写规则之一：" class="headerlink" title="重写规则之一："></a><strong>重写规则之一：</strong></h2><p><strong>重写方法不能比被重写方法限制有更严格的访问级别。</strong></p>
<p>因为需要保证:<strong>任何父类出现的地方,替换成子类依然可以使用.</strong></p>
<p>访问权限可以更广泛，比如父类方法是包访问权限，子类的重写方法是public访问权限。有个人曾经这样说：父类为protected的，子类重写时一定要用public；我觉得这个观点不能是绝对的，只要满足子类的访问权限不比父类低就行了。</p>
<p>比如：Object类有个toString()方法，开始重写这个方法的时候我们总容易忘记public修饰符，编译器会报错。出错的原因就是：没有加任何访问修饰符的方法具有包访问权限，包访问权限比public当然要严格了，所以编译器会报错的。</p>
<h2 id="重写规则之二："><a href="#重写规则之二：" class="headerlink" title="重写规则之二："></a><strong>重写规则之二：</strong></h2><p><strong>参数列表必须与被重写方法的相同。</strong></p>
<p>重写有个孪生的弟弟叫重载，也就是后面要出场的。如果子类方法的参数与父类对应的方法不同，那么就是你认错人了，那是重载，不是重写。</p>
<h2 id="重写规则之三："><a href="#重写规则之三：" class="headerlink" title="重写规则之三："></a><strong>重写规则之三：</strong></h2><p>返回类型必须与被重写方法的<strong>返回类型相同。</strong></p>
<p>父类方法A：void eat(){} 子类方法B：int eat(){}两者虽然参数相同，可是返回类型不同，所以不是重写。</p>
<p>父类方法A：int eat(){} 子类方法B：long eat(){}返回类型虽然兼容父类，但是不同就是不同，所以不是重写。</p>
<h2 id="重写规则之四："><a href="#重写规则之四：" class="headerlink" title="重写规则之四："></a><strong>重写规则之四：</strong></h2><p><strong>重写方法不能抛出新的异常或者比被重写方法声明的检查异常更广的检查异常。</strong>但是可以抛出更少，更有限或者不抛出异常。</p>
<p>注意：这种限制只是针对检查异常，至于<strong>运行时异常RuntimeException及其子类不在这个限制之中</strong>。</p>
<h2 id="重写规则之五："><a href="#重写规则之五：" class="headerlink" title="重写规则之五："></a><strong>重写规则之五：</strong></h2><p>不能重写被标识为final的方法。</p>
<h2 id="重写规则之六："><a href="#重写规则之六：" class="headerlink" title="重写规则之六："></a><strong>重写规则之六：</strong></h2><p><strong>如果一个方法不能被继承，则不能重写它。如private方法</strong></p>
<p>比较典型的就是父类的private方法。下例会产生一个有趣的现象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">   <span class="comment">//Animal h = new Horse();  </span></span><br><span class="line">   Horse h = <span class="keyword">new</span> Horse();  </span><br><span class="line">    h.eat();  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    System.out.println (<span class="string">"Animal is eating."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;  </span><br><span class="line">     System.out.println (<span class="string">"Horse is eating."</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是能通过编译的。表面上看来违反了第六条规则，但实际上那是一点巧合。Animal类的eat()方法不能被继承，因此<strong>Horse类中的eat()方法是一个全新的方法</strong>，不是重写也不是重载，只是一个只属于Horse类的全新的方法！这点让很多人迷惑了，但是也不是那么难以理解。</p>
<p>main()方法如果是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal h = <span class="keyword">new</span> Horse();</span><br><span class="line"><span class="comment">//Horse h = new Horse();</span></span><br><span class="line">h.eat();</span><br></pre></td></tr></table></figure>

<p>编译器会报错，为什么呢？Horse类的eat()方法是public的啊！应该可以调用啊！请牢记，多态只看父类引用的方法，而不看子类对象的方法！</p>
<p><strong>重写规则之七：</strong></p>
<p>子类不能用 静态方法重写父类的非静态方法</p>
<p>编绎无法通过<code>this static method cannot hide the instance mehtod from A</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line"> <span class="function"><span class="keyword">protected</span>  <span class="keyword">int</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;  </span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">long</span> b)</span> </span>&#123;  </span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line"><span class="comment">//this static method cannot hide the instance mehtod from A  </span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;  </span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重写规则之八：</strong></p>
<p>子类不能用非静态方法重写父类的静态方法</p>
<p>编绎报错：<code>this instance method cannot override the static mehtod from A</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span>  <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">long</span> b)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line"><span class="comment">//this static method cannot hide the instance mehtod from A  </span></span><br><span class="line"> <span class="comment">//this instance method cannot override the static mehtod from A  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>本文整理自</p>
<p><a href="http://blog.csdn.net/heshuangyuan123/article/details/38896329" target="_blank" rel="noopener">Java子类重写父类方法注意问题</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/28/Java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B8%8E%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/28/Java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B8%8E%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">Java访问控制修饰符与继承</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-28 13:24:18" itemprop="dateCreated datePublished" datetime="2020-06-28T13:24:18+08:00">2020-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-29 09:45:19" itemprop="dateModified" datetime="2020-06-29T09:45:19+08:00">2020-06-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java的4种访问控制修饰符"><a href="#Java的4种访问控制修饰符" class="headerlink" title="Java的4种访问控制修饰符"></a>Java的4种访问控制修饰符</h2><p>Java使用访问控制修饰符（Access Modifiers）来保护对类、变量、方法和构造方法的访问。</p>
<ul>
<li>共有的，以public 修饰符指定，对所有类可见。</li>
<li>受保护的，以 protected 修饰符指定，对同一包内的类和所有子类可见。</li>
<li>默认的，也称为 default，在同一包内可见，不使用任何修饰符（No Keyword）。</li>
<li>私有的，以 private 修饰符指定，在同一类内可见。</li>
</ul>
<blockquote>
<p>Java provides a number of access modifiers to set access levels<br>for classes, variables, methods, and constructors. The four access<br>levels are</p>
<ul>
<li>Visible to the package, the default. No modifiers are needed.</li>
<li>Visible to the class only (private).</li>
<li>Visible to the world (public).</li>
<li>Visible to the package and all subclasses (protected).</li>
</ul>
</blockquote>
<p>可以采用以下表格形式描述方便大家记忆：</p>
<table>
<thead>
<tr>
<th>访问修饰符</th>
<th>类内部</th>
<th>当前包</th>
<th>子类</th>
<th>其他包</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h2 id="继承规则中的访问控制"><a href="#继承规则中的访问控制" class="headerlink" title="继承规则中的访问控制"></a>继承规则中的访问控制</h2><h3 id="方法的继承"><a href="#方法的继承" class="headerlink" title="方法的继承"></a>方法的继承</h3><p>java</p>
<p>Java中子类继承父类方法时，有如下规则：</p>
<ul>
<li>父类或超类中的public方法，在子类中也必须是public。</li>
<li>父类中的protected方法，在子类中必须是protected或public，不能为private。</li>
<li>父类中private的方法不能被继承。</li>
</ul>
<blockquote>
<p>Access Control and Inheritance</p>
<p>The following rules for inherited methods are enforced.</p>
<ul>
<li>Methods declared public in a superclass also must be public in all subclasses. </li>
<li>Methods declared protected in a superclass must either be protected or public in subclasses; they cannot be private.</li>
<li>Methods declared private are not inherited at all, so there is no rule for them.</li>
</ul>
</blockquote>
<h2 id="属性的继承"><a href="#属性的继承" class="headerlink" title="属性的继承"></a>属性的继承</h2><p>另外，对于子类继承父类属性（成员变量）需注意：</p>
<ul>
<li><p>从父类继承的成员变量，其访问控制符仍然相同。 </p>
</li>
<li><p>子类定义与父类同名的成员变量，并没有覆盖父类的成员变量，而是两个成员变量共存；默认情况下，父类的成员变量是被隐藏的，如果你非要调用父类的成员变量可使用super关键字。</p>
</li>
</ul>
<h2 id="静态属性方法的继承"><a href="#静态属性方法的继承" class="headerlink" title="静态属性方法的继承"></a>静态属性方法的继承</h2><p>而对于静态属性（成员变量）与静态方法：</p>
<ul>
<li><p>静态属性和静态方法可以被继承，但是不是被重写(override)而是被隐藏。这是因为静态方法和属性是属于类的，调用的时候直接通过类名.方法名完成对，不需要继承机制及可以调用。</p>
</li>
<li><p>静态属性、静态方法和非静态的属性都可以被继承和隐藏而不能被重写，因此不能实现多态，不能实现父类的引用可以指向不同子类的对象；非静态方法可以被继承和重写，因此可以实现多态。</p>
<h2 id="构造方法在继承关系下的调用"><a href="#构造方法在继承关系下的调用" class="headerlink" title="构造方法在继承关系下的调用"></a>构造方法在继承关系下的调用</h2><p>最后还有一点，请注意：</p>
</li>
<li><p>Java继承中对构造函数是不继承的，只是隐式或显式的调用（显而易见，构造函数命名与类同名，子类和父类不可能同名，也就谈不上继承覆盖）。<br>Java中创建类的对象时，如果该类存在父类，则先调用父类的构造方法，然后再调用子类的构造方法。</p>
</li>
<li><p>如果父类没有定义构造方法，则调用编译器自动创建的不带参数的默认构造方法。（如果没有任何构造方法，系统会默认有一个无参构造方法）</p>
</li>
<li><p>如果父类定义了public的无参的构造方法，则在调用子类的构造方法前会自动先调用该无参的构造方法。</p>
</li>
<li><p>如果父类只有有参的构造方法，没有无参的构造方法，则子类必须在构造方法中必须显式调用super(参数列表)来指定某个有参的构造方法。（因为创建有参构造方法后，系统就不再有默认无参构造方法了）</p>
</li>
<li><p>如果父类定义了无参的构造方法，也有有参的构造方法，则子类可以指定调用某个构造方法，如果没有指定，则调用无参构造方法。</p>
</li>
<li><p>如果父类定义有无参的构造方法，但无参的构造方法声明为private，则子类同样必须在构造方法中必须显式调用super(参数列表)来指定某个有参的构造方法。</p>
</li>
<li><p>如果父类定义有无参的构造方法，但无参的构造方法声明为private，而且没有其他的有参构造方法，则子类无法创建。</p>
</li>
</ul>
<hr>
<p>本文整理自</p>
<p><a href="https://blog.csdn.net/woaixiaoyu520/article/details/77451050" target="_blank" rel="noopener">Java访问控制修饰符与继承</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/28/clone()%E7%9A%84%E7%94%A8%E6%B3%95%E3%80%81%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E9%80%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/eric.png">
      <meta itemprop="name" content="EricMa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/28/clone()%E7%9A%84%E7%94%A8%E6%B3%95%E3%80%81%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E9%80%94/" class="post-title-link" itemprop="url">clone()的用法、原理和用途</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-28 09:38:12 / 修改时间：17:43:58" itemprop="dateCreated datePublished" datetime="2020-06-28T09:38:12+08:00">2020-06-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>object clone（对象克隆）网上资料很多，那我为什么还要写下这篇文章呢？主要是想汇聚多篇文章的优秀之处以及我对于对象克隆的理解来加深印象，也使读者能更全面的理解对象克隆的用法、原理和用途。</p>
<h3 id="何谓-“object-clone”"><a href="#何谓-“object-clone”" class="headerlink" title="何谓 “object clone”"></a>何谓 “object clone”</h3><blockquote>
<p>顾名思义clone就是一个相同东西的副本,是一个具体存在的复制体，是一个从生物科学开始变得熟悉的术语。在计算机行业，该术语被广泛用于指Compaq，戴尔等人对IBM PC的模仿。而在java语言中，clone方法被对象调用，所以会复制对象。</p>
</blockquote>
<h2 id="clone的用法"><a href="#clone的用法" class="headerlink" title="clone的用法"></a>clone的用法</h2><p>（1）方法摘要  </p>
<table>
<thead>
<tr>
<th align="left">作用域</th>
<th align="left">类型</th>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">protected</td>
<td align="left">Object</td>
<td align="left">clone()</td>
<td align="left">克隆实现了Cloneable接口的对象</td>
</tr>
</tbody></table>
<p>注意事项：clone方法是被native修饰的，简单的讲就是被Native修饰的方法在被调用时指向的是一个非java代码的具体实现，这个实现可能是其他语言或者操作系统。</p>
<p>（2）clone规则：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、 基本类型  </span><br><span class="line">    如果变量是基本类型，则拷贝其值，比如int、float等。</span><br><span class="line">2、 对象  </span><br><span class="line">    如果变量是一个实例对象，则拷贝其地址引用，也就是说新对象和原来对象是共用实例变量的。</span><br><span class="line">3、 String字符串  </span><br><span class="line">    若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有的对象保持不变。复制代码</span><br></pre></td></tr></table></figure>

<p>（2）示例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">实现clone方法的步骤：</span><br><span class="line"><span class="number">1</span>. 实现Cloneable接口 </span><br><span class="line"><span class="number">2</span>. 重载Object类中的clone()方法，重载时需定义为<span class="keyword">public</span> </span><br><span class="line"><span class="number">3</span>. 在重载方法中，调用<span class="keyword">super</span>.clone()复制代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Book)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Book book1 = <span class="keyword">new</span> Book();</span><br><span class="line">        book1.setName(<span class="string">"基础系列1"</span>);</span><br><span class="line">        Book book2 = (Book) book1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"图书1:"</span> + book1.getName());</span><br><span class="line">        System.out.println(<span class="string">"图书2:"</span> + book2.getName());</span><br><span class="line"></span><br><span class="line">        book2.setName(<span class="string">"基础系列2"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"图书1:"</span> + book1.getName());</span><br><span class="line">        System.out.println(<span class="string">"图书2:"</span> + book2.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">图书1:基础系列1</span><br><span class="line">图书2:基础系列1</span><br><span class="line">图书1:基础系列1</span><br><span class="line">图书2:基础系列2复制代码</span><br></pre></td></tr></table></figure>

<p>从运行结果看这应该是深克隆的，但为什么是浅克隆呢？从<em>string不可变</em>（原对象和克隆对象中的string属性引用的是同一地址）的角度出发结果应该是浅克隆，但从结果出发却又是深克隆，所以从这一角度来说clone对string是深克隆。</p>
<p>注意事项：<strong>如果没有implements Cloneable的类调用Object.clone()方法就会抛出CloneNotSupportedException</strong></p>
<p>（3）示例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在示例1的基础上增加bookBorrow的引用</span></span><br><span class="line">    <span class="keyword">private</span> BookBorrow bookBorrow;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> id, String name, BookBorrow bookBorrow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.bookBorrow = bookBorrow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BookBorrow <span class="title">getBookBorrow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookBorrow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookBorrow</span><span class="params">(BookBorrow bookBorrow)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.bookBorrow = bookBorrow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Book book = (Book)<span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">//这里注释掉就是浅克隆，否则就是深克隆</span></span><br><span class="line">        book.bookBorrow = (BookBorrow)bookBorrow.clone();</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BOOK[id="</span>+id+<span class="string">",name="</span>+name+<span class="string">",bookBorrow:"</span>+bookBorrow+<span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BookBorrow bookBorrow = <span class="keyword">new</span> BookBorrow(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        Book book1 = <span class="keyword">new</span> Book(<span class="number">1</span>,<span class="string">"基础系列1"</span>,bookBorrow);</span><br><span class="line">        Book book2 = (Book) book1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"图书1:"</span> + book1.toString());</span><br><span class="line">        System.out.println(<span class="string">"图书2:"</span> + book2.toString());</span><br><span class="line"></span><br><span class="line">        book2.setName(<span class="string">"基础系列2"</span>);</span><br><span class="line">        book2.setBookBorrow(<span class="keyword">new</span> BookBorrow(<span class="number">5</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"图书1:"</span> + book1.toString());</span><br><span class="line">        System.out.println(<span class="string">"图书2:"</span> + book2.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookBorrow</span>  <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> borstate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookBorrow</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> borstate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.borstate = borstate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBorstate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> borstate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBorstate</span><span class="params">(<span class="keyword">int</span> borstate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.borstate = borstate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (BookBorrow)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BookBorrow[id="</span>+id+<span class="string">",borstate="</span>+borstate+<span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">图书1:BOOK[id&#x3D;1,name&#x3D;基础系列1,bookBorrow:BookBorrow[id&#x3D;1,borstate&#x3D;1]]</span><br><span class="line">图书2:BOOK[id&#x3D;1,name&#x3D;基础系列1,bookBorrow:BookBorrow[id&#x3D;1,borstate&#x3D;1]]</span><br><span class="line">图书1:BOOK[id&#x3D;1,name&#x3D;基础系列1,bookBorrow:BookBorrow[id&#x3D;1,borstate&#x3D;1]]</span><br><span class="line">图书2:BOOK[id&#x3D;1,name&#x3D;基础系列2,bookBorrow:BookBorrow[id&#x3D;5,borstate&#x3D;5]]复制代码</span><br></pre></td></tr></table></figure>

<p>从结果看这里是一个标准的深克隆实现，深克隆实现的一个主要前提是当前对象引用的对象或对象的对象引用的对象都实现了<em>常规用法1</em>并且在重载clone方法中调用其引用对象的clone方法。</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">       Book book = (Book)<span class="keyword">super</span>.clone();</span><br><span class="line">       <span class="comment">//这里注释掉就是浅克隆，否则就是深克隆</span></span><br><span class="line">       book.bookBorrow = (BookBorrow)bookBorrow.clone();</span><br><span class="line">       <span class="keyword">return</span> book;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：示例2给出的例子是相对简单且常见的类，在实际开发中clone的对象可能依赖第三方的jar包或者引用层级过深不好修改的对象，如果是这种情况则建议采用示例3的做法，使用序列化clone。</p>
<p>（3）示例3： </p>
<p>序列化clone类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        T cloneObj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//写入字节流</span></span><br><span class="line">            ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream obs = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">            obs.writeObject(obj);</span><br><span class="line">            obs.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//分配内存，写入原始对象，生成新对象</span></span><br><span class="line">            ByteArrayInputStream ios = <span class="keyword">new</span> ByteArrayInputStream(out.toByteArray());</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(ios);</span><br><span class="line">            <span class="comment">//返回生成的新对象</span></span><br><span class="line">            cloneObj = (T) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cloneObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookBorrow</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//去掉clone方法，继承Serializable</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//去掉clone方法，继承Serializable</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BookBorrow bookBorrow = <span class="keyword">new</span> BookBorrow(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        Book book1 = <span class="keyword">new</span> Book(<span class="number">1</span>,<span class="string">"基础系列1"</span>,bookBorrow);</span><br><span class="line">        Book book2 = CloneUtils.clone(book1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"图书1:"</span> + book1.toString());</span><br><span class="line">        System.out.println(<span class="string">"图书2:"</span> + book2.toString());</span><br><span class="line"></span><br><span class="line">        book2.setName(<span class="string">"基础系列2"</span>);</span><br><span class="line">        book2.setBookBorrow(<span class="keyword">new</span> BookBorrow(<span class="number">5</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"图书1:"</span> + book1.toString());</span><br><span class="line">        System.out.println(<span class="string">"图书2:"</span> + book2.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">图书1:BOOK[id&#x3D;1,name&#x3D;基础系列1,bookBorrow:BookBorrow[id&#x3D;1,borstate&#x3D;1]]</span><br><span class="line">图书2:BOOK[id&#x3D;1,name&#x3D;基础系列1,bookBorrow:BookBorrow[id&#x3D;1,borstate&#x3D;1]]</span><br><span class="line">图书1:BOOK[id&#x3D;1,name&#x3D;基础系列1,bookBorrow:BookBorrow[id&#x3D;1,borstate&#x3D;1]]</span><br><span class="line">图书2:BOOK[id&#x3D;1,name&#x3D;基础系列2,bookBorrow:BookBorrow[id&#x3D;5,borstate&#x3D;5]]</span><br></pre></td></tr></table></figure>

<p>序列化克隆无需继承，通过序列化工具类可实现深克隆同等效果。然而<strong>序列化这种方式在效率上不如clone</strong>。</p>
<h2 id="clone原理"><a href="#clone原理" class="headerlink" title="clone原理"></a>clone原理</h2><p><em>本次讲解将基于示例1做出解释：</em></p>
<p>为了不丢失上下文而贴出的测试代码，将会以2部分讲解object clone的原理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="comment">//第一部分</span></span><br><span class="line">    Book book1 = <span class="keyword">new</span> Book();</span><br><span class="line">    book1.setName(<span class="string">"基础系列1"</span>);</span><br><span class="line">    Book book2 = (Book) book1.clone();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"图书1:"</span> + book1.getName());</span><br><span class="line">    System.out.println(<span class="string">"图书2:"</span> + book2.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二部分</span></span><br><span class="line">    book2.setName(<span class="string">"基础系列2"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"图书1:"</span> + book1.getName());</span><br><span class="line">    System.out.println(<span class="string">"图书2:"</span> + book2.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一部分执行结果</strong>： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">图书1:基础系列1</span><br><span class="line">图书2:基础系列1</span><br></pre></td></tr></table></figure>

<p>浅克隆原理图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/9/18/a931c7c00bdd438d8d012d6a718f83ce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>
<p>从图中可以看出clone的name引用的是同一个值，那为什么前面又说是深克隆呢？原因就是在这一步中并没有修改name所以他们是浅克隆，引用的是同一个name变量值。那接下来执行第二部分得出的结果和原理图如你所想对象完全隔离了。</p>
<p><strong>第二部分执行结果</strong>： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">图书1:基础系列1</span><br><span class="line">图书2:基础系列2</span><br></pre></td></tr></table></figure>

<p>深克隆原理图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/9/18/428f7259ad2da755de3d2854c025aeb9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>
<p>从图可以看出修改了name属性值，clone会从堆中重新生成一个对象被克隆对象引用，而原对象保持不变，从这一角度出发的确是深克隆。</p>
<h3 id="clone原理小结"><a href="#clone原理小结" class="headerlink" title="clone原理小结"></a>clone原理小结</h3><p>前面的原理介绍是以示例1做为蓝本介绍的，示例2 的原理和示例1类似，唯一区别是多了属性对象而属性对象在clone中也只会拷贝引用地址，要想实现深克隆就只能在引用的对象或引用对象的对象中中添加clone方法实现即可实现深克隆。</p>
<h2 id="clone的实际用途"><a href="#clone的实际用途" class="headerlink" title="clone的实际用途"></a>clone的实际用途</h2><p>1、精心设计一个浅克隆对象被程序缓存，作为功能模块模板；每次有用户调用这个模块则将可变部分替换成用户需要的信息即可。<br>示例：<br>功能：发邮件<br>描述：给同组的用户发送邮件，邮件内容相同（不可变）发送的用户不同（可变）  </p>
<p>2、精心设计一个深克隆对象本程序缓存，作为功能模块的初始对象，例如：“游客模式”每个游客进入系统访问的都是初始对象，基于初始对象发展出多条变化不一的游览路线。只要你想的到设计巧妙，很多功能都能应用object clone。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分3部分介绍了object clone，分别介绍了clone的用法、原理和用途； object clone归结就是可变和不可变两个特性，在实际的开发中我们可以基于这2个特性设计出性能良好的功能模块。</p>
<hr>
<p>本文整理自</p>
<p><a href="https://juejin.im/post/59bfc707f265da0646188bca" target="_blank" rel="noopener">（基础系列）object clone 的用法、原理和用途</a></p>
<p>仅做个人学习总结所用,遵循CC 4.0 BY-SA版权协议,如有侵权请联系删除!</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EricMa"
      src="/images/eric.png">
  <p class="site-author-name" itemprop="name">EricMa</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">201</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Eric-Ma-C" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Eric-Ma-C" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chaoma@zju.edu.cn" title="E-Mail → mailto:chaoma@zju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EricMa</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">731k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
